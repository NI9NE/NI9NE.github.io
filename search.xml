<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>CSS 基础-01</title>
    <url>/2017/10/15/CSS-01/</url>
    <content><![CDATA[
## 1. css文件导入方式

css的导入方式有四种： 

- **内联式** ：在head头标签中，通过style标签书写css

  > 使用场景：测试调试环境

  - 格式 :	

  ```代码
  <head>
  <style>
  	p{
          color:blue;
    		text-indent:2em;
  	}
  </style>
  </head>
  
  ```

- **外链式** ：在head头标签中，通过link标签引入css文件

  - 格式：

  > 使用场景：正式上线

  ```代码
  <head>
  <link rel="stylesheet" href="./demo.css">
  </head>
  
  ```

- **导入式** ：在head头标签中，通过style标签引入css文件

> 先加载html，再加载css，卡顿时会出现先出现原始内容的情况

```格式
<style>
	@import url('.demo.css')
</style>

```

**注意：@import 必须写在style标签里面的最前面**

​	    **@import 的本行最后必须加上分号；**

- **内嵌式** ：直接在开始标签中，通过style属性书写css

> 不推荐，优先级太高，可能打乱整体布局

```格式
<开始标签 style="属性名：属性值；属性名：属性值；"

```

## 2. css基础语法

**书写格式：**

```格式
选择器{
	属性名1：属性值；
	属性名2：属性值；
	属性名3：属性值；
	}

```

**注：css属性不区分大小写**

css注释：`/* 注释内容 */`

## 3. 颜色

**属性名**：color		字体颜色

**属性值**：

- 单词		       red  white   blue ...

- `#rgb`                      000~fff

  ​	                         r,g,b 的范围：0~9  a~f

- `#rrggbb`                000000~ffffff

- rgb(0~255,0~255,0~255)

- rgba(0~255,0~255,0~255,0~1)

  ```
  a:透明度，可小数
  
  
  ```

- hsla（h,s,l,a）       色轮值

  - h：色调            0~360
  - s：饱和度        %
  - l：亮度             %
  - a：透明度         0~1

**属性名**：opacity          透明度

**属性值**：0~1   可小数

## 4. 长度单位

### 1绝对长度

​	cm		  厘米

​	mm		毫米

​	in		    英寸

> 1 in=2.54 cm=25.4 mm

### 2相对长度

​	px		像素

​	em		倍数

​	%		  百分比

## 5. 基础选择器

### 1 html四大通用属性

style		样式

name	      命名

class		类，绰号

id		     身份码

### 2 基础选择器

#### - 标签选择器：

​	格式：标签名{...}

​	特性：匹配方位广，涉及整个body。适合做初始化

#### - 类选择器：

​	格式：.class名{...}

​	特性：一个标签可以有多个class名

​		    多个标签可以有相同的class名

#### - 身份选择器：

​	格式：#id名{...}

​	特性：一个标签只能有一个id名，多个标签原则上不能有重复id

> css可以重复id，但js检查到重复id会报错

## 6. 选择器详解

### 1.关联选择器

> 关联选择器：也叫关系选择器

​	设：s1,s2,s3,...为基础选择器

​	则：

```关系
s1 s1{ ... }  匹配s1下的所有后辈
s1>s2{ ... }  匹配s1下的所有儿子s2
s1+s2{ ... }  匹配s1后面的一个兄弟元素s2
s1~s2{ ... }  匹配s1后面的所有兄弟

```

### 2.组合选择器

**格式：**`s1，s2，s3，...，sn{ ... }`

分别给s1, s2 和 s3等元素赋予相同的css样式

s1, s2等元素之间没有关系

### 3.伪类选择器

**格式：**`s1:hover{ ... }`	

**效果：**当鼠标悬停在s1上时，触发css样式

​	**隔山打牛类：**	

- `s1:hover s2{}`

​	当鼠标悬停在s1上时，s1下所有后辈s2触发css样式

- `s1:hover>s2{}`

  当鼠标悬浮在s1上时，s1下的所有儿子s2触发css样式

- `s1:hover+s2`

  当鼠标悬浮在s1上时，s1后的一个兄弟元素s2触发css样式

- `s1:hover~s2`

  当鼠标悬停在s1上时，s1后的所有兄弟元素s2触发css样式

  

  **引申级**

  - `s1:first-child{...}`	

  找s1父级下的第一个标签，若是s1，应用css样式

  - `s1:first-of-type{...}`

  找到s1父级下的第一个标签，应用css样式

  - `s1:last-child{...}`

  找s1父级下的最后一个标签，若是s1，应用css样式

  - `s1:last-of-type{...}`

  找到s1父级下的最后一个标签，应用css样式

  - `s1:nth-child{...}`

  找s1父级下的指定顺序的标签，若是s1，应用css样式

  - `s1:nth-of-type{...}`

  找到s1父级下的指定顺序的标签，应用css样式

> nth属性值
>
> ​	单词：奇数（odd）   偶数（even）
>
> ​	公式：一元一次方程（2n）（2n+1）（3n+5）

4.伪对象选择器

- `s1::before{...}`在s1里面内容的最前面

- `s1::after{...}` 在s1里面内容的最后面

  content 配合before，代表内容

  before和after配合将来的浮动技术做布局使用

## 7. 优先级

**各标签权重值**：

​	标签名：1		class名：10			id名：100

**优先级规则**：

​	权重值越大，优先级越高

​	权重值相同，离标签越近的选择器，优先级越高

**权重值可以叠加**

**最高权重**：

​	没有具体值，只是一种象征

​	格式：属性值 !important

**继承性**：

​	许多标签都可以继承祖辈的大多数属性，会有小部分属性无法继承

​	例如：

​		a标签的颜色

​		h标签的大小

​		。。。

> 组合选择器前后权重不会叠加，互不影响

## 8. 边框

### 1 border

**属性名**：border

**属性值**：方向（top   bottom   left     right）

- **单边**： border-方向-color：	边框单边颜色

  ​	    border-方向-width：	边框单边宽度

  ​	    border-方向-style：	  边框单边线显示（solid）或关闭（none）

  简写：border-方向：[color|width]|style

- **四边**：border-color：                 边框四边颜色

  ​	    border-width：                边框四边宽度

  ​	    border-style：		  边框四边线显示/关闭

  简写：border：[color|width]|style

**注意**：单边和四边属性中，style属性必须设置，简写没有先后顺序要求



### 2 radius

**属性名**：border-radius		圆角

**属性值**：px，%

​	border-上下-左右-radius：		单边圆角

### 3 collapse

**属性名**：border-collapse		边框合并（一般用于表格）

**属性值**：collapse

### 4 outline

**属性名**：outline		外轮廓

**属性值**：与border相同，常用none，取消外轮廓

## 9. 字体

属性名：font

属性值：

- font-size：		字体大小

> 不同浏览器最小值不一样，竟可能不要触碰最小值

- font-family:		字体家族

> 必须本地存在该字体，浏览器才可以使用

- font-weight：		字体加粗

  属性值：加粗（bold）或 普通（normal）

- font-style：                字体倾斜

  属性值：斜体（italic）或 普通（naomal）

- line-height:                行高

> line-height 若设置为与当前元素的高度一致，怎显示垂直居中效果（仅限一行）

**简写**：font：size family
`font:[weight\style] size [/line-height] family;`

注意：font属性至少要写 size 和 family，且 font 属性中 size 必须在family的前面

> 手册常用公式写法：
>
> ​	| 选择左侧或者右侧或者两者都选，前后顺序无要求
>
> ​	[ ] 中括号内部的值可写可不写

]]></content>
      <categories>
        <category>学习笔记</category>
      </categories>
      <tags>
        <tag>CSS</tag>
        <tag>前端</tag>
      </tags>
  </entry>
  <entry>
    <title>CSS 基础-02</title>
    <url>/2017/10/22/CSS-02/</url>
    <content><![CDATA[
## 1.背景

属性名：**background** 

子属性名：

​	**background**-color：		背景颜色

​	**background**-image:		背景图片	属性值：url（' 链接地址 '）

​	**background**-**repeat**:		背景重复	属性值：no-repeat | repeat-x |repeat-y |repeat（默认）

​	position: X Y		若x和y的值为正数，向右或下移动；若x和y 的值为负数，向左或上移动

​	background-size：		背景大小

简写：`background:[color | image | repeat | position[/size]]`

**注意：定位position尺寸必须放在size尺寸前面**	`10px 10px/200px`

## 2.盒子阴影

属性名：**box-shadow**

属性值：s1，s2，s3，s4，s5（color），s6（insert）

1. s1 水平位移	可负值
2. s2 垂直位移	可负值
3. s3 模糊度            不能取负值，0为不模糊
4. s4 阴影面积        不能取负值，0为原大小，可以省略
5. s5 阴影颜色         
6. 内阴影             后加inset，可省略    `    		box-shadow: -104px -97px 0px 0px blue inset;`

**简写**：`box-shadow:s1 s2 s3 [s4] s5 [s6;]`

**拓展**：

> 移动当前元素到页面中间`margin:100px auto;`
>
> solid-实线	dashed-虚线	dotted-点状线	double-双实线

## 3.平滑过渡

属性名：**transition**

属性值：s1，s2，s3，s4

1. s1 过渡的标签名（transition-property）	

   ​	取值：all（所有可以过渡的属性）  none（不指定过渡的属性）   <标签名>

2. s2 过渡的持续时间（transition-duration）

   ​	取值：<持续时间>		1 s = 1000 ms

3. s3 过渡速率（transition-timing-function）

   ​	取值：linear（线性）	ease（平滑）	ease[-in|-out]（缓入、缓出、缓入缓出） 

4. s4 延迟时间（transition-delay）

**注意：transition能起作用的前提条件是该标签的属性值是可以进行 + / - 的值**

eg：`transition:a .5s ease`  /  `transition：all 1s ease ；`  /   `transition:p1,p2,p3 .5s ease`

## 4.变形

属性名：**transform**

属性值：

1. none		不变形
2. rotate		旋转		单位：deg
3. skew		扭曲		单位：deg
   1. skewX		指定水平方向扭曲
   2. skewY		指定垂直方向扭曲
4. scale		中心缩放		单位：倍数
   1. scaleX		水平缩放		单位：倍数
   2. scaleY		垂直缩放		单位：倍数
5. translate		位移                单位：px
   1. translateX		指定x轴方向的位移
   2. translateY		指定y轴方向的位移

**注意：skew扭曲为90*奇数倍时，都会被扭曲成一条线，导致看不见**

## 5.列表样式

属性名：**list-style**

属性值：

1. list-style-image		项目列表标记图像
   1. none		不指定图像
   2. <url(' ... ')>		使用指定图像作为项目列表标记
2. list-style-position		
   1. outside		标记放在文本外，且文本不依据标记对齐
   2. inside		标记放置在文本内部，依据标记对其文本
3. list-style-type		项目列表标记类型
   1. disc		实心圆（默认）
   2. circle		空心圆
   3. square		实心方块
   4. none		不适用项目符号

简写：`list-style[list-style-image]|[list-style-position]|[list-style-type]`

## 6.溢出

属性名：**overflow**

> 包括overflow-x，和overflow-y

属性值：

1. visible		不剪切（默认）
2. hidden		将超出对象尺寸的内容进行裁剪，将不出现滚动条。
3. auto		将超出部分内容剪切，并以滚动条方式显示超出对象

常见属性

​	width	height	

​	mingwidth	maxheight	

​	minheight	maxheight

## 7.文本

- text-indent:		首行缩进（也可控制图片）（单位：px ，%，em）

- text-align:		水平对齐方式（left    center    right）（对image标签也起作用）

- text-decoration		划线方式（underline   overline     line-through    none   blink）

- text-shadow		文本阴影

  格式：`text-shadow：h-shadow   v-shadow    blur   color;`

- text-overflow		溢出文本处理

  - 属性值：clip	修建文本
  - 属性值：ellipsis	使用省略号代替省略的文本ellipsis

  > 强制转为一行：`white-space:nowrap;`
  >
  > 将溢出内容隐藏：`overflow:hidden`

- vertical-align		垂直对齐（top   middle    bottom）

  ​					（默认情况情况下，是对外垂直对齐）

  ​					（若对内对齐，则需要配合display属性）

  > 将当前元素转为td单元`display:table cell`
  >
  > 垂直居中：`line-height:500px;`	`vertical-align:middle;`

## 8.鼠标样式

**属性名**：cursor（光标，指针）

**属性值**：

​		pointer			指向（手掌样式）

​		text			文本（大写的 i 字样式）

​		move			移动（十字箭头）

​		default			默认（鼠标指针）

​		none			隐藏箭头

**补充**：progress（正在进行）|wait（等待）|方向-size（双向箭头）|no-drop（无法拖动）|crosshair（十字准星）

## 9.字体图标

> 计算机中图片分为两类：位图、矢量图
>
> 位图：放大失真
>
> 矢量图：放大不失真

字体图标基本都是矢量图，可以使用字体的属性，但不能使用图片的属性

字体图标**下载**：阿里巴巴矢量图url（‘ https://www.iconfont.cn/ ’）

阿里字体图标**使用**：

​	1.下载图标文件

​	2.导入iconfont.css文件

​	3.给需要使用字体图标的标签赋予class="iconfont"

​	4.给需要使用字体图标的位置填写相应的图标符号（查询demo_unicode.html文件）

]]></content>
      <categories>
        <category>学习笔记</category>
      </categories>
      <tags>
        <tag>CSS</tag>
        <tag>前端</tag>
      </tags>
  </entry>
  <entry>
    <title>CSS 基础-03</title>
    <url>/2017/10/29/CSS-03/</url>
    <content><![CDATA[
## 1.盒子模型

> 盒子模型分为两类：（非IE）标准物理盒子 和 IE盒子

**标准物理盒子**：物理空间=内容+边框+内边距    	（以外都是外边距）

IE**盒子**：物理空间=内容		内容包括边框和内边距（内容固定，做减法）	（以外都是外边距）

## 2.行块级元素

> html中，标签分为两种： 块级 和 行级

块级元素（display：block）：

**特征**：    1.独占一行。

​		2.宽度若不设置，则默认与浏览器宽度一样；

​		3.高度若不设置，则默认随着内容增高而增高；

​		4.宽高，行高，内外边距的等属性均可以设置；

​		5.容纳性：可容纳任何元素；

**行级元素**（display：inline）：

**特征**：1.不独占一行；

​		2.宽度若不设置，则默认随着内容的增加而增加；

​		3.高度若不设置，则默认随着内容的增高而增高；

​		4.宽高，内外上下边距等无法控制，行高，内外左右边距等可以控制；

​		5.容纳性：行级元素

## 3.内外边距

**外边距**（margin）：定义元素与元素之间的距离

​	margin：10px；（四边）

​	margin：10px  20px；（上下10，左右20）

​	margin：10px  20px  30px；（上10，左右20，下30）

​	margin：10px  20px  30px  40px；（上10 ，右20，下30，左40）

**单边距**：

​	margin-方向 :__px；

**常用技巧**：基于父级宽度内，自动居中

​	margin-left：auto；

​	margin-right：auto；

**常见简写**：

​	marigin：__px  auto；



**内边距**（padding）：定义边框与内容之间的距离

​	padding：10px；（四边）

​	padding：10px  20px ；（上下10，左右20）

​	padding：10px  20px  30px；（上10，左右20，下30）

​	padding：10px  20px  30px  40px；（上10，右20，下30，下40）

**单边距**

​	padding-方向：__px;

## 4.定位(position)

使用场景：当元素（标签）发生重合时，就可以使用定位判定双方的位置属性。

属性名：`position`

属性值：

- `absolute`（绝对定位）

  > 定位后是否保留原位置：不保留原来的位置（网）
  >
  > 定位原点：基于网页第一页的四个角落

- `relative`（相对定位）

  > 定位后是否保留原有位置：保留原来的位置（柱子）
  >
  > 定位原点：基于原来位置的四个角落

- `fixed`（固定定位）

  > 定位后是否保留原有位置：不保留原来的位置（网）
  >
  > 定位原点：基于当前可视窗口的四个角落

------



**补充概念**：

**文档流**：在body体中，标签从上往下依次排列，形成一条奔流不止的河流。

**定位**：脱离文档流，原始位置就会被清除，下方元素上移补位，定位元素就会与文档流中的元素发生重叠

**定位优先级**(z-index)

​	当定位元素发生重叠时，可通过`z-index`来改变上层顺序；

​	格式：`z-index:数字；`

​	其中数字越大，优先级越高

> 仅限定位元素使用

## 5.浮动

属性名：`float`

属性值：`left | right | none`

作用：脱离文档流，将兄弟（同级）元素排成一排

位置：不保留原来的位置

<style>
    .box1{
        background:pink;
        float:left;
        /*float:right;*/
    }
</style>

<hr>	

有些场合不需要保留原来的位置，但有些也需要保留原来的位置

如何保留原来的位置：通过clear清除浮动

<hr/>

## 6.清除浮动

属性名：`clear`

属性值：`left | right | both`

- 方法一：条件（原理）

  在兄弟元素的最后面，加空标签（非浮动），通过空标签来清除前面的浮动元素

  ```示例
  原理	
  		<ul>
  			<li>小米手机</li>
  			<li>红米</li>
  			<li>电视</li>
  			<li>笔记本</li>
  			<li>家电</li>
  			<li>新品</li>
  			<li>路由器</li>
  			<li>智能硬件</li>
  			<div style="clear: left;"></div>
  		</ul> 
  ```

- 方法二

  ​	在浮动元素的父级，添加属性`overflow：hidden`，形成BFC区域，即可清除儿子项的浮动

  > BFC区域：内部元素不会影响任何外界的元素（统统保留位置）
  >
  > 形成BFC区域的方式：`overflow：hidden；`或者 `float：none；`
  >
  > 目前部分浏览器不支持BFC，故不推荐此种写法

  ```示例
  	<ul style="overflow:hidden">
      	<li>小米手机</li>
      	<li>红米</li>
      	<li>电视</li>
      	<li>笔记本</li>
      	<li>家电</li>
      	<li>新品</li>
      	<li>路由器</li>
      	<li>智能硬件</li>
      </ul> 
  ```

- 方法三

  在浮动元素的父级，通过伪对象的方式实现清除儿子项的浮动

  ```
  父级元素::after{
      content:' ';
      display:block;		/*将当前元素转为块级标签*/
      clear:both;
  }
  ```

  ```示例
  	<style>
  		/* 完美点的 方法3 */
  		ul::before, ul::after{
  			content:'';
  			display:block;
  		}
  		ul::after{
  			clear:both;
  		}
  	</style>
  		...
  	<ul>
      	<li>小米手机</li>
      	<li>红米</li>
      	<li>电视</li>
      	<li>笔记本</li>
      	<li>家电</li>
      	<li>新品</li>
      	<li>路由器</li>
      	<li>智能硬件</li>
      </ul> 
  ```

  ​	**友情提示：浮动若不需要后面的元素向上填充，记得及时清除浮动**

- 四.市场常用写法：

  ```
  	.clearfix::before, .clearfix::after{
          content:' ';
          display:block;
  	}
  	.clearfix::after{
          clear.both
  	}
  	之后儿子项需要使用清除浮动，只需给父级赋予class="cleanfix"
  ```

  

## 7.元素转换

标签名：**display**

标签名：

- **block**

  将当前元素转换为块级元素	（替换：独占一行，可应用宽高控制）

  `.i2{width: 400px; height: 100px; background: skyblue; display: block;}`

- **inline**

  将当前元素转换为行级元素	（替换：无法使用宽高控制，不独占一行）

  `.b1{width: 300px; height: 50px; background: pink; display: inline; }`

- **inline-block**

  将当前元素转换为内联-块元素（既不独占一行(block)，也可以应用宽高控制(inline)）

  `.b3{width: 300px; height: 50px; background: pink; display: inline-block;}`

- **table**

  将当前元素转换为块级表格

- **table-cell**

  将当前元素转换为`td`单元格

- **none**

  将当前元素隐藏（不占位）

  `.box1{width: 300px; height: 50px; background: lightgreen; display: none;`

- `visibility：hidden`	

  将当前元素隐藏（占位）

  `.box1{width: 300px; height: 50px; background:lightgreen; visibility: hidden;}`

## 8.初始化

​	**目的**：各个浏览器对css样式的默认设定值不一定一样，为了保证代码在各个浏览器上显示的效果一致，所以需要对浏览器的默认css值重新统一设定，（也称**初始化**）

​	主要初始化内容包括：默认内外边距（margin、padding），字体（font），项目符号（li），超链接（a下划线），表格等

## 9.网页布局

主要使用：Div+Css

在布局中主要使用定位和浮动，为方便维护修改，推荐尽量使用浮动

布局规则：

- 由宏观到微观
- 先看行，再看列
- 由上至下，从左到右

]]></content>
      <categories>
        <category>学习笔记</category>
      </categories>
      <tags>
        <tag>CSS</tag>
        <tag>前端</tag>
      </tags>
  </entry>
  <entry>
    <title>Git 版本控制</title>
    <url>/2018/08/20/Git%20%E7%89%88%E6%9C%AC%E6%8E%A7%E5%88%B6/</url>
    <content><![CDATA[
# Git 版本控制


### 1. 什么是 Git

> Git 是当今世界上最先进/最好用的分布式版本控制系统，没有之一

### 2. 什么是版本控制系统?

> #### 版本控制 --- 《维基百科》
>
> 版本控制是一种软件工程技巧，能在软件开发的过程中，确保由不同人所编辑的同一个代码文件都得到同步.
> 版本控制能使项目的设计者，将项目恢复到之前任意的状态，这种选择权在设计过程中特别重要.
> 理论上所有的信息记录都可以加上版本控制:利用版本控制来追踪、维护源码、文件以及配置文件等等的改动

------

### 3. 版本控制发展史

#### 3.1 文件名方式

早年的软件开发过程，代码管理以手动和邮件等形式，文件命名及保存存在问题

> 如图 : 文件命名方式
>
> ![文件命名](/images/imgs/%E6%96%87%E4%BB%B6%E5%91%BD%E5%90%8D.png)

> 如图 : 毕业论文版本
>
> ![文件名控制版本](/images/imgs/01.jpg)

#### 3.2 集中式

包括库和工作区两部分：在工作区编码，然后上传至库的方式，完成多人协作。
问题：工作机与库机，需要联网才能控制版本，传输速度较慢。

![集中式版本控制](/images/imgs/02.png)

#### 3.2 分布式

每台电脑都有，工作区和库，可以自己控制版本。数据更加安全，有逻辑上的中心。

![分布式版本控制](/images/imgs/03.png)

------

### 4. 常见版本控制系统

> 如图 : 版本管理器的发展史

![版本管理器的发展史](/images/imgs/04.png)

> 这张图上，分成了四个时期 :

> ● 史前时期：1982年的RCS。现在你可能还能在Unix的发布包中找到它。

> ● 古典时期：1990年的CVS自身缺陷已经过时；1985年的PVCS、1992年的clearcase（费用昂贵、功能复杂沿用至今）；微软VVS反人类；Perforace（广泛，谷歌内部最大代码管理器）

> ● 中世纪时期：SVN解决了CVS的问题，集中式领域王者。AccuRev（支持分支合并让很多公司拜托cvs和clearcase）。

> ● 文艺复兴：BitKeeper（SUN公司大量使用），2002年Linux内核使用BitKeeper，2005年闭源时有人试图破解BitKeeper，于是出现了Git。

#### Git 问世

Git的第一个版本是Linux之父Linus Torvalds亲手操刀设计和实现的（两周内 用C写完），Linus不仅仅给出一个原始设计，并在向世人介绍Git时强烈批评了CVS和SVN等，Git消除了分支和合并的恐惧。很多大型开源项目由SVN迁移至Git。

2008年[GitHub](https://github.com/)也成为世界最大的SCM系统(软件配置管理)，它使用的就是Git版本库的技术.从此Git成为版本控制系统的主流。

GitHub上的著名项目 :
Linux内核、安卓、jQuery、Bootstrap、Ruby ...

------

### 5. Git 的安装 和 基本配置

#### 5.1 安装

> Linux 安装
>
> > 二进制包（在线）
> > yum -y install git    // RedHat系列
> > apt-get git install   // Debian系列
> > 源码包（官网下载）

> Windows 安装
>
> > Git 在 Windows 使用模拟环境 msysgit
> > 下载地址：
> > [https://git-for-windows.github.io/](https://git-for-windows.github.io/)
> > 注意：如果想让 windows 作为 git 服务器则需要搭建ssh服务。

------

> 本教程使用 windows 版本来做演示 :
> 安装步骤:  (如果你不熟悉每个选项的意思，请保持默认的选项)

- 以`管理员方式`运行安装包,选择 `是` 安装

![安装00](/images/imgs/git00.png)

- 同意协议条款

![安装01](/images/imgs/git01.png)

- 选择安装选项: 安装Git Bash和Git GUI，创建图标(可选)

![安装02](/images/imgs/git02.png)

- 选择 Git 的默认编辑器 (默认为vim,可选取自己熟悉的编辑器)

![安装03](/images/imgs/git03.png)

- 选择: `git form the command line and also form 3rd-party software` (GIT命令行和第三方软件)

![安装04](/images/imgs/git04.png)

- 选择: 选择 OpenSSL 传输 HTTPS 的信息

![安装05](/images/imgs/git05.png)

- 选择 : 换行符默认为 windows 环境为主

![安装06](/images/imgs/git06.png)

- 选择 : MinTTY 默认终端

![安装07](/images/imgs/git07.png)

- 选择 : 系统文件缓存 和 git 的管理器(需要.net v4.5.1)

![安装07](/images/imgs/git08.png)

- 实验选项，暂不选择

![安装09](/images/imgs/git09.png)

- 点击 Install 安装，开始安装

![安装10](/images/imgs/git10.png)

- 安装完成，选择运行`git bash`工具

![安装11](/images/imgs/git11.png)

- Git 运行界面 (命令行提示的是 你电脑的用户名)

![安装12](/images/imgs/git12.png)

------

#### 5.2 配置

> 无论 Linux 还是 Windows，安装完成后都要初始化

```sh
# 查看 git 版本
git --version

# 查看配置
git config -l

# 设置用户名和邮箱
git config [--global] user.name "Your Name"
git config [--global] user.email "your@email.com"

# 中括号内的参数:
#     --local  本地
#     --system 系统
#     --global 全局
#     无参，则为当前库配置身份

# 如:
git config --global user.name "seeker"
git config --global user.email "3300696254@qq.com"
```

### 6. Git常用操作

#### 6.1 生成新的版本库

1. 新建空目录
2. 进入该目录---单击右键---选择 `Git Bash Here`
3. 弹出 git 的命令行工具
4. 初始化该目录为版本仓库，键入 `git init`
5. 显示 `Initialized empty Git repository in xxxxxx`
6. `ls -a` 查看该目录下出现`.git`的隐藏目录，即版本库
7. 初始化完成

#### 6.2 添加文件到版本库

1. 新建文件 `1.txt`
2. 查看当前版本状态

```sh
# 查看当前版本状态
git status
```

3. 红字提示有文件未跟踪（未加入版本控制）
4. 在命令行内输入以下，添加文件至版本库：

```sh
# 添加文件至缓存区
git add 1.txt

# 再次查看版本库状态
git status
# 提示有要提交的修改，有一个新增的文件

# 提交文件至版本库
    # 直接提交
    # 回车后，会打开指定的编辑器编写描述信息
    git commit
    # 填写完描述信息，保存关闭即可
    
    # 或者带参数 -m 直接写入提交的描述信息
    git commit -m "新增1.txt"

# 新建 2.txt / 3.txt
# 多文件添加
git add 2.txt 3.txt

# 将缓存区的多次添加一次提交
git commit -m "新增2.txt+3.txt"

# ps:
# 添加所有改动过的和新增的文件到缓存区 (不包括被删除的文件)
git add .
# 添加所有文件到缓存区
git add --all
git add -A
```

5. 执行完后，提示提交完成
6. 查看提交后的版本库状态：

```sh
$ git status
On branch master
nothing to commit, working tree clean
```

7. 至此，最简单的添加文件，到版本库的操作已完成

------

#### --- PS部分: Git 实现原理 ---

1. 工作区 : 就是程序员日常编写代码的文件夹
2. 版本库 : 负责代码版本控制，就是`.git`隐藏目录
3. 版本库原理图 :

![版本库原理](/images/imgs/05.png)

版本库包括：暂存区（index/stage），HEAD（指针），分支（默认为 master 主分支）等。

文件提交至版本库总共分两步：  

1. `git add filename` # 添加至 stage 缓存区
2. `git commit -m "描述"` # 将 stage 的内容提交至版本库的 master 分支

> 实验：
>
> 1. 修改文件 >>> 查看状态
> 2. 添加到缓存区 >>> 查看状态
> 3. 再次修改 >>> 提交 >>> 查看状态

实验过程如下，观察理解 Git 实现机制：

1. 修改文件 >>> 查看状态：
   - 修改`1.txt`文件的内容，添加一行`111`，查看状态：`git status`
   - 提示：`Changes not staged for commit:` (工作区的修改，还没有提交到缓存区)
   - 显示红字，`modified:   1.txt`
2. 添加到缓存区 >>> 查看状态：
   - 添加到缓存区`git add .`
   - 查看状态：`git status`
   - 提示：`Changes to be committed` (要提交的修改。表示已提交到缓存区，待提交到版本库)
   - 显示绿字：`modified:   1.txt`
3. 再次修改 >>> 提交 >>> 查看状态
   - 继续修改文件：`1.txt`文件的内容,添加一行`222`
   - 提交版本库：`git commit -m "第1次修改 1.txt"`
   - 再次查看状态：`git status`
   - 提示：`Changes not staged for commit`(表示工作区中，还有修改记录，没有被提交到版本库之中)
   - 显示红字：`modified:   1.txt`

说明：

- 第 3 步的提交，只是提交了缓存区内，已经缓存过的内容（即，第二步的`add .`操作)
- 第 3 步中的第二次修改文件内容的记录，并没有添加到缓存区，所以版本库与工作区文件不一致
- 此时需要将第二次的修改记录，添加到缓存区，再次提交即可

```sh
git add.
git commit -m '第2次修改 1.txt'
git status
```

------

#### 6.3 查看文件修改状态相关

```sh
# 查看当前版本状态（是否修改）
git status
```

修改文件，测试区别:

```sh
# 当 工作区/缓存区/版本库 都一致时，使用以下命令不会有任何提示
git diff            # 工作区 与 缓存区的区别
git diff --cached   # 缓存区 与 版本库的区别
git diff HEAD       # 工作区 与 版本库的区别

# 更改工作区的 1.txt，并将更改添加到缓存区
# 然后再次更改工作区的 1.txt，并保存文件的更改
# 再次测试以上三条命令
```

------

#### 6.4 Git 日志

```sh
# 查看提交历史
git log
# 以简短的方式查看提交日志
git log --oneline

# 行为日志，显示所有提交，回滚等..
git reflog
# 显示缓存区的所有文件
git ls-files
```

------

#### 6.5 版本回退

```sh
# 将当前版本重置为 HEAD（通常用于清空缓存区，或 merge 失败回退）
git reset --hard HEAD

git reset --hard HEAD^   # 回退上一个版本
git reset --hard HEAD^^  # 回退上两个版本
git reset --hard HEAD~n  # 回退上n个版本

# 回退到指定版本，commitid 可根据日志获取，'<>'内的id必填
git reset --hard <commitid>

```

------

#### 6.6 撤销

> 目的：将尚未提交至版本库的修改撤回

- 情况一 : 文件修改后，尚未添加至缓存区

```sh
# 修改 1.txt 的内容：添加一行
# 在工作区撤销文件的修改
git checkout -- filename
# 注意'--'不可缺少。没有'--'，就变成了“切换到另一个分支”的命令

```

- 情况二 : 文件修改后，已添加至缓存区

```sh
# 修改 1.txt 的内容：添加一行，并添加到缓存区
# 撤回添加至缓存区的修改
git checkout HEAD filename

```

------

#### 6.7 Git 删除

- 删除文件和版本库记录

```sh
# `rm`命令只会删除工作区的文件，不会删除记录
rm 2.txt
git status  # 提示2.txt 被删除，是否需要提交到版本库
# 如果删错文件，则可以撤回删除(因为此时的删除操作，还未写入到缓存区)
git checkout -- 2.txt

# 将 2.txt 的删除记录写入到缓存区，并删除文件
git rm 2.txt
# 如果还未提交，想要撤回，可使用 `git checkout HEAD 2.txt`
# 提交 2.txt 的删除记录到版本库中
git commit -m '删除2.txt'

```

- 删除缓存区的文件

```sh
# 新建 demo.html 文件，并加入到缓存区
git add demo.html
git status  # 提示有新文件等待提交
# 将 demo.html 文件移出缓存区，但不删除(文件还会保留在工作区)
git rm --cached demo.html
git status  # 提示工作区有文件等待 add

# 重新将 demo.html 加入到缓存区
# 将缓存区中的 demo.html 文件移出并删除(工作区不保留文件)
git rm -f demo.html

```

- 其他删除

```sh
# 新建 aaa/111.txt
# 新建 aaa/bbb/111.txt
# 将文件添加到版本库中
git add .
git commit -m '添加aaa目录及文件'
# 递归删除目录(删除的是，已被记录到版本库的目录)
git rm -r 目录名
git commit -m '删除aaa目录'

```

#### 6.8 Git 流程图

![Git流程图](/images/imgs/Git%E6%B5%81%E7%A8%8B%E5%9B%BE.png)

------

### 7. 远程仓库

#### 7.1 得到远程的版本库

> 可以使用两种方式来得到远程版本库:

- 在某个指定的文件夹下使用，即可得到远端版本库及代码

```sh
git clone <远端版本库url> <本地存放该库的文件夹名>

```

- 手动添加版本库,并拉取文件

```sh
# 初始化本地仓库
git init

# 添加远程版本库 <remote>可自行取名,默认origin
git remote add <remote> <url>

# 查看远程版本库信息
git remote -v
# 查看指定远程版本库信息
git remote show <remote>

# 删除远程remote链接
git remote remove <remote>

# 下载代码及快速合并
git pull <remote> <branch>

```

------

#### 7.2 推送分支代码

得到远端版本库后,可以在本地按正常的步骤编辑 :
新建或改动文件-->添加至缓存区-->提交到版本库

此时,要想将本地版本库发给远端,只有commit提交是不够的.
还需要下面的操作 :

```sh
git push <remote> <branch>
# 上传代码及快速合并

```

执行以上代码,会有报错 : 无法直接推送到远端的主分支
此时,可以曲线救国，推送自己的分支到远端即可 :

```sh
git push origin master:dev

```

此时,推送成功!

------

### 8. Git 分支管理

#### 8.1 查看版本库分支

```sh
# 显示本地分支
git branch
# 显示所有分支
git branch -a
# 切换到指定分支或标签
git checkout 分支名/标签名

```

#### 8.2 创建分支/删除分支

```sh
# 新建分支
git branch 分支名
# 创建并切换到dev分支
git checkout -b dev

# 删除本地分支 -D 强制删除
git branch -d 分支名

```

#### 8.3 合并分支

要将 B分支 合并到 A分支里
请切换到A分支内,合并B分支的操作在A分支内进行

```sh
# 合并分支到当前分支
git merge 分支名

```

#### 8.4 解决合并冲突

> 多分支修改同一文件，合并可能出现冲突。冲突部分用<<<===>>>表示

![合并冲突](/images/imgs/06.png)

解决方法：
先手动修改冲突部分，再次提交即可。

#### 8.5 分支管理策略

在实际开发中，我们应该按照几个基本原则进行分支管理：

首先，master分支应该是非常稳定的，也就是仅用来发布新版本，平时不能在上面干活；

那在哪干活呢？干活都在dev分支上，也就是说，dev分支是不稳定的，到某个时候，比如1.0版本发布时，再把dev分支合并到master上，在master分支发布1.0版本；

你和你的小伙伴们每个人都在dev分支上干活，每个人都有自己的分支，时不时地往dev分支上合并就可以了。

所以，团队合作的分支看起来就像这样：

![分支管理](/images/imgs/07.png)

#### 8.6 多人协作

多人协作的工作模式通常是这样：

首先，可以试图用`git push origin <branch-name>`推送自己的修改；
如果推送失败，则因为远程分支比你的本地更新，需要先用`git pull`试图合并；

如果合并有冲突，则解决冲突，并在本地提交；
没有冲突或者解决掉冲突后，再用`git push origin <branch-name>`推送就能成功！

如果`git pull`提示`no tracking information`，则说明本地分支和远程分支的链接关系没有创建，用命令`git branch --set-upstream-to <branch-name> origin/<branch-name>`
这就是多人协作的工作模式，一旦熟悉了，就非常简单。

------

### 9. 使用代码托管系统

市面上有名的Git托管系统 :

- [GitHub](https://github.com/)
- [码云](https://gitee.com/)
- [CODING](https://coding.net/)

#### 9.1 码云 生成SSH密钥及使用

1. 本地打开git bash ,`cd`切换到用户的家目录
2. 使用`pwd`来查看目录是否正确
3. 使用 `ssh-keygen.exe -t rsa` 来生成SHA256的SSH密钥(按回车确认即可)
4. `cd .ssh/` 切换至ssh目录
5. `ls` 查看目录下文件
6. `cat id_rsa.pub` 查看生成的密钥,并复制
7. 打开[码云](https://gitee.com/),登录自己的账户.点选个人资料
8. 选择SSH公钥
9. 在添加公钥界面,将刚刚复制好的密钥粘贴进来,再自己取一个该密钥的名字,以便于区分管理
10. 本地新建一个目录,用于拉取远端版本库
11. 使用 `git init`初始化该目录
12. 使用`git remote add origin <SSH地址>` 来添加远程版本库
13. 使用`git remote -v` 来查看远程版本库信息
14. 使用`git pull origin marster`来拉取版本库及代码

#### 9.2 GitHub 生成SSH密钥及使用

1. 运行 git Bash 客户端，输入如下代码：
   - `$ cd ~/.ssh`
   - `$ ls`
   - 这两个命令就是检查是否已经存在 id_rsa.pub 或 id_dsa.pub 文件，如果文件已经存在，那么你可以跳过步骤2，直接进入步骤3
2. 创建一个 SSH key
   - `$ ssh-keygen -t rsa -C "your_email@example.com"`
   - 代码参数含义：
   - `-t` 指定密钥类型，默认是 rsa ，可以省略。
   - `-C` 设置注释文字，比如邮箱。
   - `-f` 指定密钥文件存储文件名。
3. 添加你的 SSH key 到 github上面去
   - `$ cat ~/.ssh/id_rsa.pub`
4. 测试一下该SSH key   在git Bash 中输入以下代码
   - `$ ssh -T git@github.com`
   - 显示类似如下,表示成功:
   - `Hi username! You've successfully authenticated`
5. `git clone 远程git仓库地址`

------

### 10. 文件忽略

想要工作区的某些文件，不受版本的控制，可使用`.gitignore`文件进行忽略.
!(注意, .gitignore文件 是没有名字的文件.)

规则:

- 以斜杠 `/` 开头表示目录
- 以星号 `*` 通配多个字符
- 以问号 `?` 通配单个字符
- 以方括号 `[]` 包含单个字符的匹配列表
- 以叹号 `!` 表示不忽略(跟踪)匹配到的文件或目录

> 配置文件是按行 从上到下 进行规则匹配的，
> 这就意味着如果前面的规则匹配的范围更大，则后面的规则将不会生效.

### 11. 使用 TortoiseGit 操作 Git

> TortoiseGit 俗称 [ GIT小乌龟 ]

------

# Git 常用命令速查

- master 默认主分支
- dev 默认开发分支

> 创建版本库

```sh
# 初始化本地git版本库（创建新仓库）
git init

# 配置用户名
git config --global user.name "xxx"

# 配置邮件
git config --global user.email "xxx@xxx.com"

#查看当前配置列表
git config --list

# clone远程仓库
git clone <url>

```

> 修改、提交、删除

```sh
# 添加index.php文件到缓存区
git add index.php
# 添加所有改动过的文件到缓存区
git add .
# 添加所有文件到缓存区
git add --all

# 提交缓存区内的文件(回车后需要键入描述:wq保存退出)
git commit
# 提交缓存区内的文件,并提供描述
git commit -m "描述"

# 将add和commit合为一步
git commit -am '描述'
# 合并最后一次提交(用于反复修改)
git commit --amend -m 'xxx'

# 删除index.php文件
git rm index.php
# 将index.php文件移出缓存区,但不删除( -r * 递归目录)
git rm --cached index.php
# 将缓存区中的1.html文件移出并删除
git rm -f 1.html

```

> 查看

```sh
# 查看当前版本状态（是否修改）
git status

# 查看所有添加到缓存区的变更(工作区与版本库的区别)
git diff
# 查看工作区文件和库文件区别
git diff index.php
# 查看所有已添加到缓存区,但还未commit的变更(缓存区与版本库的区别)
git diff --cached

# 查看提交历史
git log
# 以简短的方式查看提交日志
git log --oneline

# 行为日志,显示所有提交,回滚等..
git reflog
# 显示缓存区的所有文件
git ls-files

```

> 回退 与 撤销

```sh
# 将当前版本重置为HEAD（通常用于merge失败回退）
git reset --hard HEAD

git reset --hard HEAD^   # 回退上一个版本
git reset --hard HEAD^^  # 回退上两个版本
git reset --hard HEAD~n  # 回退上n个版本

# 回退指定版本，commitid根据log获取
git reset --hard <commitid>

# 在工作区撤销文件的修改
git checkout --filename
# 撤回添加至缓存区的修改,不指定filename则撤回所有
git checkout HEAD [filename]

```

> 分支操作

```sh
# 获取远程分支master并merge到当前分支
git pull origin master

# 显示本地分支
git branch
# 显示所有分支
git branch -a
# 切换到指定分支或标签
git checkout 分支名/标签名

# 新建分支
git branch 分支名
# 删除本地分支 -D 强制删除
git branch -d 分支名

```

> 远程协作

```sh
# 添加远程版本库
git remote add <remote> <url>
# 查看远程版本库信息
git remote -v
# 查看指定远程版本库信息
git remote show <remote>
# 删除远程remote链接
git remote remove <remote>
# 重命名远程链接名
git remote rename <old> <new>

# 下载代码及快速合并
git pull <remote> <branch>

# 上传代码及快速合并
git push <remote> <branch>

# 将本地的远端库合并
git merge origin master

# 将远端库获取本地但不合并
git fetch origin

```

> > 黄超.Seeker
> > 更多信息，详见： [Pro Git（中文版）](https://gitee.com/progit/index.html)]]></content>
      <categories>
        <category>开发资料</category>
      </categories>
      <tags>
        <tag>Git</tag>
        <tag>版本控制</tag>
      </tags>
  </entry>
  <entry>
    <title>JavaScript Ajax</title>
    <url>/2018/06/28/JavaScript%20Ajax/</url>
    <content><![CDATA[


# 1. Ajax

> Asyn Javascript And Xml  "异步的 JS 和 xml"

请求: 客户端向服务器请求一个文件
响应: 服务端把文件内容 返回给客户端，一般服务端有输出才算真真的响应.

传统的请求: 通过地址栏 刷新页面请求
AJAX的请求: 通过技术 偷偷的请求

------

# 2. XMLHttpRequest对象 XHR

## 2.1 概念

XMLHttpRequest 对象提供了对 HTTP 协议的完全的访问，包括做出 POST 和 HEAD 请求以及普通的 GET 请求的能力。

XMLHttpRequest 可以同步或异步地返回 Web 服务器的响应，并且能够以文本或者一个 DOM 文档的形式返回内容。

------

## 2.2 常用属性

### 1. readyState   请求响应状态

| 状态 | 名称          | 描述                                                         |
| ---- | ------------- | ------------------------------------------------------------ |
| 0    | Uninitialized | 初始化状态。XMLHttpRequest 对象已创建或已被 abort() 方法重置。 |
| 1    | Open          | open() 方法已调用，但是 send()                               |
| 2    | Sent          | Send() 方法已调用，HTTP 请求已发送到 Web 服务器。未接收到响应。 |
| 3    | Receiving     | 所有响应头部都已经接收到。响应体开始接收但未完成。           |
| 4    | Loaded        | HTTP 响应已经完全接收。                                      |

### 2. status  返回服务器的响应状态码

- 200  成功响应
- 404  文件不存在
- 304  文件来自缓存
- 500  服务器未知错误
- 503  服务器宕机 服务暂时不可用

### 3. responseText 获取服务器的响应文本

------

## 2.3 常用方法

### 1. open()  初始化请求

- 参1 method 请求类型 GET/POST/HEAD
- 参2 url 请求主体
- 参3 是否同/异步: true(默认异步) / false(同步)
- 参4,5 认证的帐号和密码

### 2. send()  正式发送请求

- GET 方式 无参
- POST 方式 有可选参数

### 3. setRequestHeader()  设置POST请求头信息

- `xhr.setRequestHeader('Content-Type', 'application/x-www-form-urlencoded');`

------

## 2.4 事件句柄 onreadystatechange

`readyState` 的值一变化就触发

# 3. Ajax+php 请求流程

- 创建对象 xml请求对象
- 初始化请求
- 发送请求
- 接收 并 处理响应

```
    <h2 id="box"></h2>

    <script>
    // 创建 XHR 对象
    var xhr = new XMLHttpRequest();
    // console.dir(xhr);
    
    // 捕获响应结果,绑定事件
    xhr.onreadystatechange = function(){
        // console.log(xhr.readyState);
        if (xhr.readyState == 4) {
            if (xhr.status == 200) {
                // 处理结果
                // alert(xhr.responseText);
                box.innerHTML = xhr.responseText;
            }
        }
    }

    // 请求初始化
    // 参1 method 请求类型 GET/POST/HEAD
    // 参2 url 请求主体
    // 参3 是否同/异步: true(默认异步) / false(同步)
    // 参4,5 认证的帐号和密码
    xhr.open('get', './php/1.php', true);

    // 正式发送请求
    xhr.send();


    </script>
```



# 4. 处理json数据

- PHP:  json_encode()
- JS :  eval()  或 JSON.parse()

# 5. 同步和异步

open()方法的参3 决定了是否同异步
默认参数为true,表示请求是异步的,AJAX不会影响到其他程序代码的执行
参数为false时,表示请求是同步的,AJAX将会阻塞之后程序的运行,直到响应完全接收完毕为止.

```
    <h1>AJAX 同异步</h1>
    <button onclick="loadHtml(true)">异步</button>
    <button onclick="loadHtml(false)">同步</button>
    <hr>

    <script>

        function loadHtml(b){
            var msg = '我是来自于JS的值';

            var xhr = new XMLHttpRequest();
            xhr.onreadystatechange = function(){
                if (xhr.readyState == 4) {
                    if (xhr.status == 200) {
                        msg = xhr.responseText;
                        console.log(msg);
                        
                    }
                }
            }
            xhr.open('get', './php/6.php', b);
            xhr.send();

            alert(msg);
        }
    
    </script>
```



# 6. post 和 get

- POST方式
- GET方式

# 7. Ajax 无法跨域 与 jsonp

- Ajax 无法跨域

  为什么产生这个问题? (产生跨域的原因:)
  a. 发出的请求不是本域的,比如协议/域名/端口号,任何一个不一样都算是跨域.
  b. 浏览器的限制,不是服务器不让你跨域,是浏览器为了安全限制你不能随便跨域.
  c. XHR对象 不支持跨域. 如果你发送的不是XHR请求,就算是跨域,浏览器也不会报错

PS. 新建浏览器图标, [属性]--[目标] 新增以下: 关闭安全验证
 --disable-web-security --user-data-dir=d:\temp1

- JSONP
  - 不受同源策略的影响

```
PS. 九种跨域方式实现原理（完整版）
`https://segmentfault.com/a/1190000018017118`
```

```
    <h1>JSONP</h1>
    <button onclick="loadHtml()">加载</button>
    <hr>

    <div id="box"></div>

    <script>
        function makedata(obj){
            // alert(obj);
            box.innerHTML = '';
            // JSON.parse()  // NO
            for (var i in obj) {
                box.innerHTML += i  + ' : ' + obj[i] + '<br>';
            }
        }

        // JSONP 关键步骤
        function loadHtml(){
            // 创建JS对象
            var js = document.createElement('script');
            // 设置JS标签的src值
            js.src = 'http://127.0.0.1/s86/JS13/php/7.php';
            // 添加这个JS对象到页面之中
            document.body.appendChild(js);
        }



       /* function loadHtml(){
            var xhr = new XMLHttpRequest();
            xhr.onreadystatechange = function(){
                if (xhr.readyState == 4) {
                    if (xhr.status == 200) {
                        box.innerHTML = '';
                        var obj = JSON.parse(xhr.responseText);
                        for (var i in obj) {
                            box.innerHTML += i  + ' : ' + obj[i] + '<br>';
                        }
                    }
                }
            }
            xhr.open('get', 'http://127.0.0.1/s86/JS13/php/7.php', true);
            xhr.send();
        }*/
    </script>
   <!--  <script>
        // JS OBJ
        makedata({"id":"7","name":"\u5929\u4f7f","sex":"0","age":"30","province":"\u6c5f\u82cf"})
    </script> -->
</body>
```



# 8. 封装Ajax

```
    <h1>AJAX封装</h1>
    <hr>
    
    <button onclick="ajax('./php/8.php',fun1)">封装</button>
    <div id="box"></div>

    <script>
    	
    	function ajax(url,fun1){

    		var xhr = new XMLHttpRequest();
    		xhr.open('get',url,true);
    		xhr.send();
    		xhr.onreadystatechange = function(){
    			if (xhr.readyState==4) {
    				if (xhr.status==200) {
    					res = xhr.responseText;
    					fun1(res);
    				}
    			}
    		}
    	}

    	function fun1(y){
    		box.innerHTML=y;
    	}
    </script>
```



# PS:状态码

```
HTTP 状态
    1xx: 信息
        消息: 描述: 
        100 Continue 服务器仅接收到部分请求，但是一旦服务器并没有拒绝该请求，客户端应该继续发送其余的请求。 
        101 Switching Protocols 服务器转换协议：服务器将遵从客户的请求转换到另外一种协议。 
    2xx: 成功
    消息: 描述: 
        200 OK 请求成功（其后是对GET和POST请求的应答文档。） 
        201 Created 请求被创建完成，同时新的资源被创建。 
        202 Accepted 供处理的请求已被接受，但是处理未完成。 
        203 Non-authoritative Information 文档已经正常地返回，但一些应答头可能不正确，因为使用的是文档的拷贝。 
        204 No Content 没有新文档。浏览器应该继续显示原来的文档。如果用户定期地刷新页面，而Servlet可以确定用户文档足够新，这个状态代码是很有用的。 
        205 Reset Content 没有新文档。但浏览器应该重置它所显示的内容。用来强制浏览器清除表单输入内容。 
        206 Partial Content 客户发送了一个带有Range头的GET请求，服务器完成了它。 
    3xx: 重定向
    消息: 描述: 
        300 Multiple Choices 多重选择。链接列表。用户可以选择某链接到达目的地。最多允许五个地址。 
        301 Moved Permanently 所请求的页面已经转移至新的url。 
        302 Found 所请求的页面已经临时转移至新的url。 
        303 See Other 所请求的页面可在别的url下被找到。 
        304 Not Modified 未按预期修改文档。客户端有缓冲的文档并发出了一个条件性的请求（一般是提供If-Modified-Since头表示客户只想比指定日期更新的文档）。服务器告诉客户，原来缓冲的文档还可以继续使用。 
        305 Use Proxy 客户请求的文档应该通过Location头所指明的代理服务器提取。 
        306 Unused 此代码被用于前一版本。目前已不再使用，但是代码依然被保留。 
        307 Temporary Redirect 被请求的页面已经临时移至新的url。 
    4xx: 客户端错误
    消息: 描述: 
        400 Bad Request 服务器未能理解请求。 
        401 Unauthorized 被请求的页面需要用户名和密码。 
        402 Payment Required 此代码尚无法使用。 
        403 Forbidden 对被请求页面的访问被禁止。 
        404 Not Found 服务器无法找到被请求的页面。 
        405 Method Not Allowed 请求中指定的方法不被允许。 
        406 Not Acceptable 服务器生成的响应无法被客户端所接受。 
        407 Proxy Authentication Required 用户必须首先使用代理服务器进行验证，这样请求才会被处理。 
        408 Request Timeout 请求超出了服务器的等待时间。 
        409 Conflict 由于冲突，请求无法被完成。 
        410 Gone 被请求的页面不可用。 
        411 Length Required "Content-Length" 未被定义。如果无此内容，服务器不会接受请求。 
        412 Precondition Failed 请求中的前提条件被服务器评估为失败。 
        413 Request Entity Too Large 由于所请求的实体的太大，服务器不会接受请求。 
        414 Request-url Too Long 由于url太长，服务器不会接受请求。当post请求被转换为带有很长的查询信息的get请求时，就会发生这种情况。 
        415 Unsupported Media Type 由于媒介类型不被支持，服务器不会接受请求。 
        416  服务器不能满足客户在请求中指定的Range头。 
        417 Expectation Failed   
    5xx: 服务器错误
    消息: 描述: 
        500 Internal Server Error 请求未完成。服务器遇到不可预知的情况。 
        501 Not Implemented 请求未完成。服务器不支持所请求的功能。 
        502 Bad Gateway 请求未完成。服务器从上游服务器收到一个无效的响应。 
        503 Service Unavailable 请求未完成。服务器临时过载或当机。 宕机
        504 Gateway Timeout 网关超时。 
        505 HTTP Version Not Supported 服务器不支持请求中指明的HTTP协议版本。 

```

]]></content>
      <categories>
        <category>学习笔记</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
        <tag>Ajax</tag>
        <tag>Jsonp</tag>
      </tags>
  </entry>
  <entry>
    <title>JavaScript-Node.js</title>
    <url>/2018/07/10/JavaScript%20Node.js/</url>
    <content><![CDATA[
# Node.js

## 1.关于 Node.js

Node.js是一个让 JavaScript 运行在服务器端的开发平台.

### 1.1. 介绍

1). Node.js 不是一种独立的语言，与PHP、JSP、Python、Perl、Ruby的"既是语言，也是平台"不同，Node.js的使用JavaScript进行编程，运行在JavaScript引擎上（V8）。

2). 与PHP、JSP等相比，Node.js跳过了Apache、Naginx、IIS等HTTP服务器，它自己不用建设在任何服务器软件之上。Node.js的许多设计理念与经典架构（LAMP）有着很大的不同，可以提供强大的伸缩能力。

官网: https://nodejs.org/en/
中文网: http://nodejs.cn/

### 1.2. 特点

```
单线程 | 非阻塞I/O | 事件驱动
```

#### 1). 单线程

```
所有客户端请求的连接 都使用一个线程来处理.

Node.js 不是给每个连接去创建新的 线程,而是仅仅使用一个线程来处理.
单线程带来的好处,减少内存的损耗,提高并发量. 操作系统完全不再有线程创建和销毁的开销.
```

#### 2). 非阻塞I/O

```
I/O操作不会阻塞程序的运行
I: Input  输入
O: Output 输出

在阻塞模式下,一个线程只能处理一项任务,想要提高吞吐率,必须通过多线程
而非阻塞模式下,一个线程 永远在执行某种运算操作.这个线程的CPU 核心利用率永远是满载的
```

#### 3). 事件驱动

```
客户端 请求建立连接，提交数据等行为，就会触发 相应的事件.
在Node中，在一个时刻，只能执行 一个事件回调函数，但是在执行 一个事件回调函数的中途，（比如，又有新用户连接了）可以转而处理其他事件，然后返回继续执行原事件的回调函数，这种处理机制，称为“事件环”机制.
```

Node.js底层是C++(V8引擎也是C++写的).底层代码中，近半数都用于事件队列、回调函数队列的构建.用事件驱动 来完成服务器的 任务调度,是Node.js中 真正底层核心逻辑.

#### 4). 三特点说明

单线程
    是为了减少内存的开销,操作系统的内存换页(创建/销毁)
    但是,如果某一个请求 有I/O操作,单线程就会被阻塞了!
非阻塞I/O
    程序不会傻等I/O语句的执行结束,才继续后续代码的运行,而会直接运行后续代码.
    但是,非阻塞就能完美的解决问题吗, 比如 小A的业务执行I/O过程中,有小C要新的请求,此时则么办?
事件驱动(事件环)
    不管是新用户的请求,还是老用户的I/O操作,都将以事件的方式加入到事件环之中,等待调度.

Node.js 中所有的I/O都是异步的.回调函数 套 回调函数
泡茶 : 洗茶壶 4 / 洗茶杯 3 / 用茶壶烧开水 8 / 准备茶叶 2 / 泡茶水 5 / 倒茶水 1
4 + 8 + 5 + 1 = 18
 3 + 2 

### 1.3 Node.js 的优缺点,适合开发什么?

#### 1). 优点

​    善于I/O,不善于 大量计算
​    处理高并发
​    服务器推送

#### 2). 缺点

​    单线程的缺点: 单一线程 一旦奔溃则整个服务全奔溃
​    服务不是绝对可靠的.

#### 3). 适用场景

```
不能完全替代 传统的后端语言,但在某些方面优于传统.
当应用程序需要处理大量并发的I/O操作，而在发出响应之前，应用程序内部 并不需要进行非常复杂的计算处理的时候，Node.js非常适合。
Node.js也非常适合与web socket配合，开发长连接的实时交互应用程序。

- 聊天室
- 图文直播
- 考试系统
- 收集用户数据的表单
- 提供JSON的API
```

## 2.安装使用node

### 2.1 windows环境安装

`node -v `查看版本

`node 文件名`  运行文件

### 2.2 搭建Node.js服务器 

​	-- 首个nodejs页面页面

```
// 搭建nodejs WEB服务器

// 引入HTTP模版
var http = require('http');

var hostname = '127.0.0.1';
var port = 3000;

// 创建服务器
// req 表示请求(request) / res 表示响应(response)
var server = http.createServer(function(req, res){
    // 设置HTTP头信息. 状态码 200; 文件类型是html; 字符集 utf-8
    res.writeHead(200, {'Content-type':'text/html;charset=UTF-8'});
    // 服务器响应输出完成
    res.end('Hi~ o(*￣▽￣*)ブ, 首个nodejs页面,您的积分为: ' + (50 + 10) + '分'); 
});

// 运行服务器
server.listen(port, hostname, function(){
    console.log(`请访问: http://${hostname}:${port}`);
});
```

如果修改了程序代码,必须中断当前的node服务,重新在node一次

node.js是服务器的程序,写好的JS代码,都将运行在服务器上.返回给客户端的, 都是已经处理好的结果

node就是一个JS的运行环境

js文件是不能直接拖入浏览器取运行的,必须靠node去执行



### 2.3 根目录 与 web容器

```
1). Node.js没有根目录的概念，因为它根本没有任何的web容器！
```

​    

```
2). 静态页面的呈现

URL和真实的物理文件之间 是没有关系的。
URL是通过 Node 的路由设计之后，才呈现出 某一个静态文件的
```

```
3). HTTP运行原理
```

由此,我们可以看出,要是使用nodejs 搭建服务器,
是需要写 各种回调函数,定义 各种路由规则,来实现 页面的显示.
nodejs中就是 回调函数 套回调函数,每个回调函数 都是一个事件

由此就用到了 nodejs的三个特性:
    单线程 | 非阻塞I/O | 事件驱动(事件环)
    URL路由规则,与实际的物理文件,不一定有直接的联系. 

## 3.HTTP模块

   Node.js将各种功能，都划分为了一个个mudule(模块)
   需要用什么模块,就可以使用require('')来引入使用

## 4.URL模块

​	解析URL

```
   // GET 参数的处理
    var getParams = url.parse(req.url, true).query;
    var name = getParams.name;
    var age = getParams.age;
    var sex = getParams.sex;
    res.end('服务器接收到了以下信息: '+ name + ' | ' + age + ' | ' + sex);
```



​	路由设计

```

var http = require('http');
var url = require('url');

var hostname = '127.0.0.1';
var port = 3000;

// 创建服务器
var server = http.createServer(function(req, res){
    // 跳过了 chrome 的收藏夹图标的请求
    if (req.url == '/favicon.ico') return;
    res.writeHead(200, {'content-type': 'text/html;charset=utf-8'});

    // /stu/20190212007  查询学员
    // /tch/00128        查询老师
    
    //  获取URL中的path部分
    var user = url.parse(req.url).pathname;

    // substr
    if (user.substr(0, 5) == '/stu/') {
        var stuid = user.substr(5);
        // console.log(stuid);
        if (/^\d{11}$/.test(stuid)) {
            res.end('查询到的学号是: ' + stuid);
        } else {
            res.end('学员的学号有误!!!');
        }
    } else if (user.substr(0, 5) == '/tch/') {
        var tchid = user.substr(5);
        // console.log(tchid);
        if (/^\d{5}$/.test(tchid)) {
            res.end('查询到的工号是: ' + tchid);
        } else {
            res.end('工号有误!!!');
        }
    } else {
        res.end('URL有误,请检查重试!!!');
    }
});

// 运行服务器
server.listen(port, hostname);
```



## 5.文件系统

​	5.1. 新建文件夹 / 删除文件夹 / 文件状态信息 / 读取文件夹

​	5.2. 读取出 文件夹/文件

## 6.静态目录 文件加载 (web容器)



## 7.模块的概念

   在Node.js中,不可能用一个js文件去写全部的业务,肯定要有MVC.
   它以模块为单位 划分所有功能,并且提供了一个 完整的模块加载机制,我们可以将应用程序 划分为各个不同的部分.

   每一个JavaScript文件都是一个模块；
   而多个JavaScript文件可以使用require引入,使他们共同实现了一个功能模块.



### 7.1 输出变量/函数

​    Node.js中,JS文件中定义的变量、函数,都只在这个文件内部有效.
​    其他文件中需要引用变量、函数时,必须使用`exports对象`进行暴露(输出).
​    使用者要用`require()`命令,引用执行这个JS文件.

### 7.2 输出一个类(构造函数)

​    可以用`module.exports = 构造函数名;`的方式 向外输出一个类

### 7.3 模块关联关系

- 某一个js文件中,有函数或变量: exports.变量 = 变量;
- 某一个js文件中,有一个类: module.exports = 构造函数名;

### 7.4 模块封装

## 8.npm

 (node package management)

   这是一个工具名字.npm的主要职责是 安装开发包和管理依赖项.
   安装开发包:安装 `npm install`命令；更新 `npm update`命令.
   管理依赖项:借助 package.json 文件;最简单生成 package.json 的方法就是 `npm init`

   npm不需要单独安装,只要安装了 Node.js 环境,npm 就已经包含在里面了. 查看 npm 版本: `npm -v`

   **为什么要使用npm?**
   开发时,会使用到各种功能的组件,所有组件都由我们自己来写代码的话,开发效率就会很低.我们不要重复的去造轮子,要学会使用已有的工具,来完善我们的项目,站在巨人的肩膀上去工作.
   npm是js世界里的一个伟大的社区,能够让开发者更加轻松的共享代码和共用代码片段或模块组件.

   https://www.npmjs.com/   # npm官网
   https://npm.taobao.org/  # 淘宝npm镜像

   不要修改 [node_modules] + package-lock.json 这两个文件,因为它是使用npm去管理的

## 9.POST请求

   相比较GET请求，POST请求比较复杂。
   因为Node.js认为，使用POST请求时，数据量会比较多。
   为了追求极致的效率，它将数据拆分成为了众多小的数据块(chunk)，然后通过特定的事件，将这些小数据块有序传递给回调函数。

```

var http = require('http');
var fs = require('fs');
var querystring = require('querystring');

var hostname = '127.0.0.1';
var port = 3000;

var server = http.createServer(function(req,res){
    if (req.url == '/form') {
        // 读取表单加载页面
        fs.readFile('./form.html', function(err, data){
            res.writeHead(200, {'content-type': 'text/html;charset=UTF-8'});
            res.end(data);
        });
    } else if (req.url == '/dopost' && req.method.toLocaleLowerCase() == 'post') {
        // 如果访问/dopost,且请求类型是post
        // 进行POST数据处理
        var postData = '';
        // node为了实现极致的效率,所以把post分成多个小份去传递
        req.addListener('data', function (chunk){
            postData += chunk;
        });

        // 全部接收完毕
        req.addListener('end', function(){
            console.log(postData);

            // 将post字串转换为一个对象
            var dataObj = querystring.parse(postData);
            console.log(dataObj);
            console.log(dataObj.name);
            res.end('POST DATA Success!');
        });


    } else {
        res.end('404');
    }

});

server.listen(port, hostname);
```



## 10.文件上传处理

    原生写POST处理,比较复杂,要写两个监听.
    文件上传业务比较麻烦.所以,用第三方模块: `formidable`
```

var http = require('http');
var fs = require('fs');
var querystring = require('querystring');
var formidable = require('formidable'); // 处理表单数据
var timestamp = require('time-stamp'); // 时间
var path = require('path'); // 时间

var hostname = '127.0.0.1';
var port = 3000;

var server = http.createServer(function(req,res){
    if (req.url == '/form') {
        // 读取表单加载页面
        fs.readFile('./form_file.html', function(err, data){
            res.writeHead(200, {'content-type': 'text/html;charset=UTF-8'});
            res.end(data);
        });
    } else if (req.url == '/dopost' && req.method.toLocaleLowerCase() == 'post') {
        // 如果访问/dopost,且请求类型是post
        // formidable 处理 parse a file upload
        var form = new formidable.IncomingForm();

        // 设置上传目录
        form.uploadDir = "./uploads";
        // 该模块已经将 POST数据 和 文件数据 分离处理
        // 当代码执行到parse()方法的回调函数时,表单中的数据 就都已经处理好了
        form.parse(req, function(err, fields, files) {
            // console.log(fields);
            // console.log(files);
            // 处理上传文件的存储
            // 新文件名: 时间 + 随机数 + 后缀
            var t = timestamp('YYYYMMDDHHmmss');
            var ran = parseInt(Math.random()* 100000);
            var extname = path.extname(files.myfile.name);

            // 旧文件名
            var oldPath = './' + files.myfile.path;
            // 新文件名
            var newPath = './uploads/' + t + ran + extname;
            console.log(oldPath);
            console.log(newPath);

            // 实现改名
            fs.rename(oldPath, newPath, function (err){
                res.end('文件上传成功!!');
            });
        });
    } else {
        res.end('404');
    }

});

server.listen(port, hostname);
```



## 11.ejs模版

    https://ejs.co/        #官网
    https://www.npmjs.com/package/ejs #npm上的ejs包
    ejs是Embedded JavaScript templates的简称,意思是嵌入式JavaScript模板.node中的后台模版.

------

```

var http = require('http');
var ejs = require('ejs');
var fs = require('fs');
var hostname = '127.0.0.1';
var port = 3000;

var server = http.createServer(function (req, res) {
    if (req.url == '/') {
        fs.readFile('./views/index.ejs', function (err, data) {
            // 模版
            // console.log(data);
            var template = data.toString();
            // console.log(template);
            // 数据
            var dict = {
                title: 'EJS 模版的使用',
                content: '我是段落内容....',
                pic: './imgs/1.jpg',
                songci : {
                    title: '酒调歌头',
                    list : [
                        '12345',
                        '67890',
                        '09876',
                        '54321'
                    ]
                }
            }
            // 绑定数据
            var html = ejs.render(template, dict);

            // 显示输出页面
            res.writeHead(200, {'content-type':'text/html'});
            res.end(html);
        });
    } else if (req.url == '/imgs/1.jpg') {
        fs.readFile('./imgs/1.jpg', function (err, data) {
            res.writeHead(200, {'content-type':'image/jpg'});
            res.end(data);
        });
    }
});

server.listen(port, hostname);
```

```
<!--index.ejs-->
<!DOCTYPE html>
<html lang="cn">
<head>
    <meta charset="UTF-8">
    <title>Document</title>
    <style type="text/css"></style>
</head>
<body>
    <h1><%= title %>></h1>
    <hr>

    <p><%= content %>></p>
    <p><%= content %>></p>
    <p><%= content %>></p>
    <p><%= content %>></p>

    <hr>
    <br>
    <img src="<%= pic %>" width="300">

    <hr>
    <h2><%= songci.title %></h2>
    <ul>
        <% for (var i = 0; i < songci.list.length; i++) { %>
        <li><%= songci.list[i] %></li>
        <% } %>
    </ul>

</body>
</html>
```



## PS:V8引擎说明

​    V8 JavaScript引擎是 Google用于其Chrome浏览器的底层JavaScript引擎。
​    Google使用V8创建了一个用C++编写的超快解释器，该解释器拥有另一个独特特征：
​    您可以下载该引擎并将其嵌入任何应用程序。
​    V8 JavaScript引擎并不仅限于在一个浏览器中运行。
​    因此，Node.js实际上会使用Google编写的V8 JavaScript引擎，并将其重建为可在服务器上使用。]]></content>
      <categories>
        <category>学习笔记</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
        <tag>Node.js</tag>
        <tag>npm</tag>
        <tag>ejs</tag>
        <tag>express</tag>
      </tags>
  </entry>
  <entry>
    <title>JavaScript-Express</title>
    <url>/2018/07/15/JavaScript%20Express/</url>
    <content><![CDATA[
# Express

## 1.Express框架

基于 Node.js 平台，快速、开放、极简的 web 开发框架。
它是用于后台NodeJs的框架,与JQuery/Bootstrap/vue.js/AngularJs这类前端框架是不一样的!
Express 不对 Node.js 已有的特性进行二次抽象，我们只是在它之上扩展了 Web 应用所需的基本功能。
丰富的 HTTP 快捷方法和任意排列组合的 Connect 中间件，让你创建健壮、友好的 API 变得既快速又简单。

对比原生Node.js
    使用原生Node.js开发,会发现有很多问题:
    - 呈现静态页面很不方便,需要处理每个HTTP请求,还要考虑304缓存问题.
    - 路由处理代码不直观清晰,需要写很多正则表达式和字符串函数.
    - 开发者不能集中精力写业务,要考虑很多其他的东西.

官网：http://expressjs.com/
中文官网：http://www.expressjs.com.cn/

## 2.安装

npm install express --save  #即可安装最新版本的Express

- Express4.x与3.x版本的差别非常大，我们使用4.x

### 2.1. 基本使用

```
//  引入express 框架
var express = require('express');
// console.log(express);

// 创建 express 的 HTTP服务器
var app = express();
// 指定框架的模版引擎,无需导入
app.set('view engine', 'ejs');

// 指定静态化的目录
app.use('/static', express.static('./static'));


// 设置路由规则
app.get('/', function(req, res){
    // 响应输出
    res.send('Hello Express~~~');
});

app.get('/test', function(req, res){
    // 响应输出
    res.send('这是test页面');
});

app.get('/user', function(req, res){
    // 绑定并输入数据
    res.render('user', {
        'userlist' : [
            '钢铁侠 屎大颗',
            '绿巨人 浩克',
            '美队 史蒂文',
            '雷神 托尔',
            '邪神 洛基',
            '蜘蛛侠 彼得帕克'
        ]
    });

});

// 设置请求监听
app.listen(3000);
```

### 2.2. 路由处理

```
//  引入express 框架
var express = require('express');
// 创建 express 的 HTTP服务器
var app = express();

// 支持所有的请求方式, 实现中间件的功能
app.all('/t', function(req, res, next){
    console.log(new Date().toString());
    next();
});


// 设置路由规则
app.get('/', function(req, res){
    // 响应输出
    res.send('Hello Express~~~');
});
// GET
app.get('/t', function(req, res){
    // 响应输出
    res.send('GET 请求');
});
// POST
app.post('/t', function(req, res){
    // 响应输出
    res.send('POST 请求');
});

// DELETE
app.delete('/t', function(req, res){
    // 响应输出
    res.send('DELETE 请求');
});


// 路由方法默认匹配 pathnameb部分,忽略get参数
// 对大小写不敏感
app.get('/aaa', function(req,res){
    console.log(req.query);
    res.send('3A页面 ');
});

// 路由路径 默认express path-to-regexp 匹配路由路径

// 正则路由   /stu/1234567890/tom
app.get(/^\/stu\/(\d{10})\/(\w+)$/, function(req,res){
    console.log(req.params);
    res.send('学员的学号是: '+ req.params[0]);
});

// 路由参数
// :xx 表示参数占位,使用req.params读取参数
app.get('/tch/:tid', function(req,res){
    console.log(req.params);
    res.send('老师的工号是: '+req.params.tid);
});

// 多个路由参数
app.get('/goods/:name/:num', function(req,res){
    // 参数限制
    var name = req.params.name;
    var num = req.params.num;
    if (/\d+/.test(num)) {
        res.send('商品名: ' + name + ', 入库: ' + num + '件');
    } else {
        res.send('请填写正确的数量');
    }
});


// 设置请求监听
app.listen(3000);
```



2.3. 对模版引擎的支持

2.4. 静态文件/目录处理

## 3.路由

3.1. 路由的访问方式

3.2. 路由路径

3.3. 响应方法
    res.download()    提示下载文件。
    res.end()         终结响应处理流程。
    res.json()        发送一个JSON格式的响应。
    res.jsonp()       发送一个支持JSONP的JSON格式的响应
    res.redirect()    重定向请求。
    res.render()      渲染视图模板。
    res.send()        发送各种类型的响应。
    res.sendFile()    以八位字节流的形式发送文件。
    res.sendStatus()  设置响应状态代码，并将其以字符串形式作为响应体的一部分发送。

```

var express = require('express');
var app = express();

// 路由重名
// 路由中间件
app.get('/kk',function(req,res,next){
    console.log(1);
    next();
});

app.get('/kk',function(req,res){
    console.log(2);
    res.send('响应完成');
});


// 匹配冲突
app.get('/:goods/:num',function(req, res, next){
    // 做查询/匹配...
    if (false) {
        console.log(1);
        res.send('商品' + req.params.goods + '数量:'+req.params.num);
    } else {
        next();
    }
});

app.get('/admin/login',function(req,res){
    console.log(2);
    res.send('登录界面');
});

app.listen(3000);
```



## 4.中间件

4.1. 中间件概念

4.2. express路由 具有的中间件特性

4.3. app.use()的特性

app.use() 就是一个中间件,与get()/post()..方法不用的是,
它的URL不是精确匹配,而是模糊匹配

4.4. app.use()使用

```

var express = require('express');
var app = express();

// 全局中间件
app.use(function(req, res, next){
    console.log(new Date().toString());
    next();
});

// 中间件
app.use('/admin',function (req, res) {
    res.write(req.originalUrl + '\n'); // 完整的URL
    res.write(req.baseUrl + '\n');     // 基础URL
    res.write(req.path + '\n');        // 除去基础以外的URL
    res.end('后台...');
});

app.listen(3000);
```



4.5. 静态资源服务的说明

4.6. 404 页面的说明

------

## 5.模版引擎,渲染页面

5.1. 模版引擎 的设置和使用

5.2. 原生的 end() 与express的 send() 的区别

5.3. 设置响应头 和 状态码 和 MIME类型

```

var express = require('express');
var app = express();

// 指定框架的模版引擎,无需导入
app.set('view engine', 'ejs');

// 提供静态资源服务
// app.use(express.static('./static'));

// 默认使用 .ejs 为模版文件,目录views
// app.set('views', './pages');

app.get('/', function (req,res){
    // 绑定数据并渲染视图
    res.render('user', {
        'userlist' : [
            '钢铁侠 屎大颗',
            '绿巨人 浩克',
            '美队 史蒂文',
            '雷神 托尔',
            '邪神 洛基',
            '蜘蛛侠 彼得帕克'
        ]
    });
});

app.get('/hh', function (req,res){
    // node.js end()
    // express send()
    // 二进制
    // res.send(new Buffer('HOOH~'));

    // str
    // res.send('HOOH~');

    // JSON
    // res.send({name:"静静", sec:0});
    // ARRAY
    res.send([15,168,19681,9681,98,986884,true]);
    
});

app.listen(3000);
```



## 6.GET 与 POST

### 6.1 GET

GET请求的参数在URL中.
原生node中,要想得到get参数,需要借助于url模块来识别参数字符串.
在Express中，不需要使用url模块了.可以直接使用`req.query`对象得到GET参数

### 6.2 POST

GET请求的参数是隐蔽传参(在请求体中).
POST请求在Express中不能直接获得,必须使用`body-parser`模块.使用后,将可以用req.body得到参数.
但是如果表单中含有文件上传,那么还是需要使用`formidable`模块.

```

var express = require('express');
var bodyParser = require('body-parser');
var app = express();

// 指定框架的模版引擎,无需导入
app.set('view engine', 'ejs');


// parse application/x-www-form-urlencoded
//  解析 post数据
app.use(bodyParser.urlencoded({ extended: false }));

//GET参数
app.get('/', function (req,res){
    console.log(req.query);
    res.send('GET 完成');
});

app.get('/form', function (req,res){
    res.render('form');
});


// POST
app.post('/', function (req,res){
    console.log(req.body);
    res.send('POST 完成');
});


app.listen(3000);
```



## 7.Express对数据库的支持

7.1 数据库集成

7.2 连接mysql数据库

7.3 使用数据库 - 查/增/改/删

7.4 连接池

```

var express = require('express');
var mysql = require('mysql');
var app = express();

app.get('/', function(req,res){
    // 连接数据库
    var connection = mysql.createConnection({
        host     : '127.0.0.1',
        user     : 'root',
        password : '123456',
        database : 's86'
    });
    // 开启数据库
    connection.connect();

    // var sql = 'SELECT * FROM user';
    var sql = 'UPDATE user SET age="19" WHERE id="1"';
    connection.query(sql, function (err, result) {
        if (err) {
            console.log('执行出错: ' + err);
            return;
        }

        console.log(result);
        res.send(result);
    });

    connection.end();
});


app.listen(3000);
```





------

## 8.Web Socket和Socket.IO框架

### 8.1. HTTP的问题

HTTP无法轻松实现 实时应用：

- HTTP协议是无状态的，服务器只会响应来自客户端的请求，但是它与客户端之间不具备持续连接。(无法长时持续连接)
- 我们可以捕获浏览器上发生的事件（比如用户点击了button），这个事件可以产生与服务器的数据交互（比如Ajax）。
  但是，反过来却是不可能的：服务器端发生了一个事件，服务器无法将这个事件的信息实时主动通知它的客户端。只有在客户端查询服务器的当前状态的时候，所发生事件的信息才会从服务器传递到客户端。(无法主动输出信息)

但是,HTTP协议也能做聊天室这种'长连接'的东西,它是这么实现的:

- 长轮询：客户端每隔很短的时间，都会对服务器发出请求，查看是否有新的消息，只要轮询速度足够快，例如1秒，就能给人造成交互是实时进行的印象。这种做法是无奈之举，实际上对服务器、客户端双方都造成了大量的性能浪费。
- 长连接：客户端只请求一次，但是服务器会将连接保持，不会返回结果（想象一下我们没有写res.end()时，浏览器的小菊花会一直转）。服务器有了新数据，就将数据发回来，又有了新数据，就将数据发回来，而一直保持挂起状态。这种做法的也造成了大量的性能浪费。

### 8.2. WebSocket

WebSocket协议能够让浏览器和服务器全双工实时通信，互相的，服务器也能主动通知客户端了。

- WebSocket的原理非常的简单：利用HTTP请求产生握手，HTTP头部中含有WebSocket协议的请求，所以握手之后，二者转用TCP协议进行交流（QQ的协议）。现在的浏览器和服务器之间，就是QQ和QQ服务器的关系了。
  所以WebSocket协议，需要浏览器支持，更需要服务器支持。
- 支持WebSocket协议的浏览器有：Chrome 4、火狐4、IE10、Safari5
- 支持WebSocket协议的服务器有：Node、Apache Tomcat/7.0.27、Nginx1.3

### 8.3. Socket.IO

用原生Node搭建 WebSocket协议的服务 非常麻烦,我们使用写好的模块: Socket.IO
它屏蔽了所有底层细节，让顶层调用非常简单。
并且还为不支持WebSocket协议的浏览器(IE)，提供了长轮询的透明模拟机制。
Node的单线程、非阻塞I/O、事件驱动机制，使它非常适合Socket服务器。

官网：http://socket.io/

------

# chat_demo

## 初始化:

```
    npm init | 聊天室 | index.js
```

## 安装的组件:

```
    npm install express --save
    npm install ejs --save
    npm install socket.io --save
```

### 说明:

```
Express与Socket.IO
Express框架可以和Socket.IO搭配使用，但是不能像通常的Express程序那样，用app.listen进行监听了，而是采用一种固定的模式.
```

------

官方 画板 示例:
https://socket-io-whiteboard.now.sh/
官方 聊天室 示例:
https://socket-io-chat.now.sh/
官方socket.io 仓库:
https://github.com/socketio]]></content>
      <categories>
        <category>学习笔记</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
        <tag>Node.js</tag>
        <tag>express</tag>
      </tags>
  </entry>
  <entry>
    <title>JavaScript 基础01-基本语法</title>
    <url>/2018/05/13/JavaScript%20%E5%9F%BA%E7%A1%8001-%E5%9F%BA%E6%9C%AC%E8%AF%AD%E6%B3%95/</url>
    <content><![CDATA[


# web 开发

- 前端
  - HTML    数据展示,负责内容
  - CSS     页面美化, 负责样式
  - JS      页面特效,与用户的交互.负责行为
- 后端
  - PHP
  - JAVA
  - python
  - asp.net
  - node.js
  - Ruby
  - Go

------

# javascript 简介

## 什么是 javascript

> 概念： javascript是 基于对象 和 事件驱动 并具有相对安全性的 客户端 脚本语言

- 发展简史
  1. Nombas 公司 1992 年开发 嵌入式脚本语言 C-- 后改名 ScriptEase
  2. Netscape公司 1995 年发布 LiveScript 后改名 javascript1.0
  3. 三足鼎立  NetScape 推出 javascript 1.1后, Microsoft 推出 Jscript , 加上 ScriptEase
  4. 标准化 1997 javascript 1.1 作为草案 提交给 `ECMA`（欧洲计算机制造商协会） .
     由来自 Netscape、Sun、微软、Borland 和其他一些对脚本编程感兴趣的公司的程序员
     组成的 TC39 锤炼出了 ECMA-262,该标准定义了名为 ECMAScript 的全新脚本语言.
- 组成
  - 核心（ECMAScript）
  - 文档对象模型（DOM）
  - 浏览器对象模型（BOM）
- 客户端浏览器上执行的脚本 JavaScript  VBScript...
- ECMAScript核心: JavaScript  ActionScript  ScriptEase
- 扩展衍生：node.js / phonegap框架 / vue.js / angular.js / React ...
- 浏览器
  - IE    IE6 7 8  /  IE9+
  - 非IE  Chrome  firefox  opera  Safari ...

> 浏览器占比统计: http://tongji.baidu.com/data/browser

- javascript 的特点
  - javascript 是一种脚本编程语言,也是一种解释性语言
  - javascript 的语法结构与C++、java 十分类似
  - javascript 是一种基于对象的语言
  - javascript 具有跨平台性.
  - 安全性与简单性
  - 基于对象（真正的对象 封装 继承 多态）
- java 与 javascript 的关系: 雷锋 和 雷峰塔
- javascript 优点与局限
  - 优点
    - javascript 在客户端运行,节省服务器资源
    - 方便的操控页面中的各个对象,使网页更加友好可控
    - 使多种任务仅在客户端就可以完成而不需要网络和服务器的参与,从而支持分布式的运算和处理
  - 局限
    - 兼容性问题,所有浏览器没有统一的标准
    - javascript 不能打开/读写/保存计算机上的文件.

------

> javascript 以下简称 JS

# JS 基本语法

## 在 HTML 中使用 JS

1. 写在 header 中的`<script></script>`标签内
2. 外部文件导入`<script src="script.js"></script>`标签内不能写代码
3. 通过 JS 事件写在标签内`<tag onclick="JS code...."></tag>`

## 基本语法

- 区分大小写 : `JS 所有的一切全都区分大小写`
- 标示符 : `不能以数字开头，可以由：数字/字母/下划线/$组成`
- 注释
  - 单行注释：  `// 注释`
  - 多行注释：  `/* 注释 */`
- 语句（指令结束符）: `;`  或  `换行`
- 关键字和保留字

```
ECMAScript 关键字的完整列表:
break    case    catch   continue    default
delete   do      else    finally     for
function if      in      instanceof  new
return   switch  this    throw       try
typeof   var     void    while       with
(关键字是保留的,不能用作变量名或函数名)
```

## 变量

```javascript
var 变量名 = 值;
var 变量名 = 值,变量名 = 值,变量名 = 值;
var 变量名 = 变量名 = 变量名 = 值;
```

## 数据类型

以下，是以我们熟悉的角度去分类：

- 基本类型
  - String （字串）
  - Number （数值）
  - Boolean （布尔）
- 复合类型
  - Ojbect （对象）
  - array （数组）
- 特殊类型
  - Null （空）
  - undefined （未定义）
  - function （函数）

> `typeof(aa)   typeof aaa`  返回一个值或变量的数据类型

## 字符串类型

- 定义字符串： `""` 或 `''`
- 不论是单引号还是双引号，都可以解析转义字符，都不能解析变量
- 字符串连接符 `+`

## 数值类型

- 数值的声明方式： 10 进制/ 8 进制/ 16 进制/ 科学计数法
- 数值范围
  - `5e324` ~ `1.7976931348623157e+308`
  - 超过范围会自动转换成 `infinity`(正无穷) `-infinity`(负无穷)
  - 可以使用 `isFinity()` 验证是不是无穷，超出范围不能参与运算
- `NaN` 类型： 数值的特殊类型，表示 Not a Number
  - NaN 与任何数字操作，结果都是 NaN
  - NaN 与任何数都不相等，包括 NaN 自己
  - 函数 `isNaN()` 判断是否是 NaN
- `Number()` 类型转换
  1. true -> 1 / false -> 0
  2. null -> 0
  3. undefined -> NaN
  4. 字符串
     1. 空字串 -> 0
     2. '11' -> 11 / '011' -> 11 (非进制转换)
     3. '0b10' -> 2 (2进制转换) / '0xff' -> 255 (16进制转换)
     4. '1.1' -> 1.1
     5. '12e3' -> 12000 (科学计数法解析)
     6. 如果包含除上述格式之外的字符，则将其转换成NaN
- `parseInt()` 类型转换
  1. 数字开头的字符串，只转换数字整数部分，忽略字母部分
  2. 0x开头的字串会转换成十六进制，0不可以
  3. 空字串 -> NaN
  4. true / false / null / undefined 都会被转为 NaN
  5. 科学计数法(字串)不解析
- `parseFloat()` 类型转换
  1. 基本同上
  2. 第一个小数点有效，第二个无效
  3. 数字开头的字符串，忽略后面的字母
  4. 科学计数法(字串)会解析其值
  5. 16 进制转换为 0

## 自动数据类型转换

- 数字类型:
  - 在字符串环境下 隐身转换为字符串
  - 字符串类型 在数字环境下，可以隐式转换为字符串中的数字或 NaN
  - 在布尔环境下，可以隐式转换为 true
- 空字符串:
  - 在数字环境下可以隐式转换为 0
  - 在布尔环境下可以隐式转换为 false
- 字符串'true':
  - 在数字环境下可以隐式转换位1
  - 布尔为 true
- 字符串'false':
  - 数字环境为 0
  - 布尔位 false
- null:
  - 在字符串环境下，转换为'null'
  - 数字环境下，转换为 0
  - 布尔环境下，转为 false
- NaN:
  - 在字符串环境下可以隐式转换为'NaN'
  - 布尔环境下，转换为 false
- undefined: 
  - 字符串环境下，转换为“undefined”
  - 数字环境下，转为 NaN 
  - 布尔下，转为 false
- true:
  - 字符串转为'true'
  - 数字环境下转为 1
- false:
  - 字符串转为'false'
  - 数字环境下转为 0



JavaScript数据类型转换--数字

|   数据    | number( ) | parseInt( ) | parseFloat( ) |
| :-------: | :-------: | :---------: | :-----------: |
|    123    |    123    |     123     |      123      |
|   12.7    |   12.7    |     12      |     12.7      |
|   0b011   |     3     |      3      |       3       |
|  "0b011"  |     3     |      0      |       0       |
|   "123"   |    123    |     123     |      123      |
| "12.1we"  |    NaN    |     12      |     12.1      |
| "12.1e1w" |    NaN    |     12      |      121      |
|    " "    |     0     |     NaN     |      NaN      |
|   true    |     1     |     NaN     |      NaN      |
|   null    |     0     |     NaN     |      NaN      |
| undefined |    NaN    |     NaN     |      NaN      |



------

# 运算符

- 算术运算符
  1. 加法运算符        +
  2. 减法运算符        -
  3. 乘法运算符        *
  4. 除法运算符        /
  5. 模运算符          %
  6. 负号运算符        -
  7. 正号运算符        +
  8. 递增运算符        ++
  9. 递减运算符        --
- 关系运算符
  0. 赋值运算符        =
  1. 相等运算符        ==
  2. 等同运算符        ===
  3. 不等运算符        !=
  4. 不等同运算符      !==
  5. 小于运算符        <
  6. 大于运算符        >
  7. 小于或等于运算符  <=
  8. 大于或等于运算符  >=
  9. in 运算符  判断一个值是否属于某个数组或者一个属性是否属于一个对象
  10. instanceof  判断一个对象的实例是否属于某个对象
  11. 字符串运算符  + 连字符
- 逻辑运算符
  1. 逻辑与   &&
  2. 逻辑或   ||
  3. 逻辑非   !
- 其他运算符
  1. 条件运算符  ?:
  2. new 运算符  new 对象类型
  3. void 运算符  void 运算符可以让操作数进行运算，但是却舍弃运算之后的结果
  4. typeof 运算符 返回类型
- 对象属性存取运算符
  - 使用`.`来调用和设置对象的属性或者方法 : `obj.attr`| `obj.func()`
- `delete` 运算符
  - delete 运算符可以用来删除变量/对象的属性/数组中的元素
  - delete 运算符返回的是布尔值类型
    - delete 对象名  /  delete 变量名
    - delete 对象名.属性
    - delete 数组[索引]
- 逗号运算符
  - `var a = 1, b = 2;`
  - `c = a + b, d = a - b;`
- `this` 运算符
  - `this` 代表的是当前对象.

------

# 其他语句

1. 判断语句 `if()...else if()...else...`
2. 判断语句 `switch()...case...break`
3. 迭代语句 `while`
4. 迭代语句 `do-while`
5. 迭代语句 `for`
6. 迭代语句 `for-in`
7. 立即退出循环 `break`
8. 退出当前循环 `continue`



# 获取页面之中的元素对象

1. **获取页面中的一个元素**

document.getElementById()
一定要写写在元素生成之后
或者 写在函数中



2. **获取或设置元素的** css 属性

element.style.color;
element.style.color = '#f00';

3. **获取或设置元素标签的属性**

style
innerHTML
HTML元素标签 具有什么属性,当它变为 JS的element对象之后,该属性就会自动变为 该对象的属性了.
(img: src alt title width height id class)
(div:  alt title  id class)

4. **定时函数**

4.1 **单次定时**
    setTimeout('JS 代码', time)
    clearTimeout()
4.2 **多次定时**
    setInterval('JS 代码', time)
    clearInterval()



------

# 特效-全选/反选

```

	<ul id="list">
		<li><input type="checkbox" value="0">小翠翠</li>
		<li><input type="checkbox" value="1">小艳艳</li>
		<li><input type="checkbox" value="2">小莉莉</li>
		<li><input type="checkbox" value="3">小静静</li>
		<li><input type="checkbox" value="4">小萍萍</li>
		<li><input type="checkbox" value="5">小红红</li>
	</ul>
	<button onclick="selectAll(1)">全选</button>
	<button onclick="selectAll(2)">全不选</button>
	<button onclick="selectAll(3)">反选</button>
	<hr>
	
	<script>
		//声明函数
		function selectAll(m){
		    //获取所有的li
			//var ul = document.getElementById('list');
			var lis =document.getElementById('list').getElementsByTagName('input');
			//遍历 li
			for (var i = 0; i < lis.length; i ++) {
				switch (m) {
					case 1: lis[i].checked = true; break;
					case 2: lis[i].checked = false; break;
					case 3: lis[i].checked = !lis[i].checked; break;
				}
			   
			}
		}
		
	</script>
```





]]></content>
      <categories>
        <category>学习笔记</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title>JavaScript jQuery</title>
    <url>/2018/07/13/JavaScript%20jQuery/</url>
    <content><![CDATA[
# jQuery

# 1. jQuery 介绍

## 1.1 什么是 jQuery

jQuery 是 JavaScript 的类库

## 1.2 jQuery 特点

write less,do more (写得少 干得多)

## 1.3 jQuery 优势

- 开源
- 便捷的选择器
- 方便的 dom 操作
- 丰富的动画操作
- 简单的 ajax 操作
- 兼容性
- 方便的插件机制

## 1.4 jQuery 缺点

添加额外的 jQuery 文件，增加网络传输量

## 1.5 jQuery 版本

- jQuery 1.X   支持IE
- jQuery 2.X   IE9+  其他...
- jQuery 3.X   IE9+  支持最新的浏览器

# 2. jQuery的基本语法

`https://www.jquery.com/ [官网.手册]`
`http://www.jq22.com/chm/jquery/index.html`

## 2.1 jquery 入口标准的使用方式

```javascript
// 标准入口
$(document).ready(function (){
    JS code
});
// 简写入口
$(function (){
    JS CODE
});
```

## 2.2 onload 与 ready 的区别

- 触发点
  - ready  文档中的 DOM 加载完, 就触发
  - onload 文档中的 一切加载完, 才触发
- 绑定逻辑
  - ready 可以绑定多个事件(事件监听)
  - onload 后面的绑定会覆盖前的代码

```
    <script>
        // JS 
        window.onload = function(){
            console.log('onload1');
            // console.log(box);
        }
        window.onload = function(){
            console.log('onload2');
        }
        
        // JQ的标准入口
        $(document).ready(function(){
            console.log('ready1');
            // console.log(box);
        });
        $(document).ready(function(){
            console.log('ready2');
        });

    </script>
```



## 2.3 链式操作风格

JQDOM.css().attr().remove()....

## 2.4 jQueryDOM 与 JSDOM 的区别 以及相互转化

> 区别

- JQDOM 通过$()获取到一个数组对象
- JSDOM 通过各种方法获取到一个元素标签对象

> 转换

- JSDOM >>> JQDOM    $(JSDOM)
- JQDOM >>> JSDOM    JQDOM.get(index) 或 JQDOM[index]

```
    <h1>JQuery</h1>
    <hr>
    
    <div id="box">123456</div>

    <hr>
    <img src="./1.jpg" width="50" id="myimg" alt="">
    
    <script src="./jquery-3.3.1.min.js"></script>
    <script>
        $(function(){
            var box = document.getElementById('box'); // JS DOM
            var $box = $('#box'); // JQ DOM
            console.log(box);
            // console.log($box);
            
            box.style.backgroundColor = '#f00';
            // $box.style.backgroundColor = '#f90'; // NO
            $box.css('background-color', '#f90');
            // box.css('background-color', '#09f'); // NO

            myimg.width = 600;
            // $('#myimg').width = 4000; // NO
            $('#myimg').attr('width', '1000');

            // 互相转化
            // JSDOM ---> JQDOM
            $(box).css('background-color', '#09f');

            // JQDOM ---> JSDOM
            console.log($box[0]);
            console.log($box.get(0));
            $box.get(0).style.backgroundColor = '#feeeed';
        });

    </script>
```



## 2.5 jquery 命名冲突

$ 是 jQuery 的别名

------

# 3. jQuery 选择器

## 3.1 基本选择器

```javascript
*           通配符选择器
#id         ID选择器
.class      CLASS选择器
tagName     标签选择器
s1,s2,sN    组合/分组选择器
```

## 3.2 层级选择器

```javascript
selector selector    所有的后代元素
selector>selector    所有的子元素
selector+selector    紧邻着的下一个同辈元素
selector~selector    紧邻着的所有同辈元素
```

## 3.3 过滤选择器

```javascript
:first          首个
:last           最后一个
:eq(index)      指定第几个
:lt(index)      索引小于
:gt(index)      索引大于
:even           索引为偶数的 0索引也算为偶数
:odd            索引为奇数的
:header         所有的h标签
:not(selector)  排除指定选择器所选的元素
:root           根元素 html 1.9+
```

## 3.4 内容选择器

```javascript
:contains(text) 匹配包含指定文本的元素
:has(selector)  匹配含有选择器 所选择的元素的 元素
:parent         匹配含有子元素或文本的元素
:empty          匹配所有不含有子节点的元素
```

## 3.5 可见性选择器

```javascript
:visible        匹配所有可见元素
:hidden         匹配所有不可见元素
```

## 3.6 属性选择器

```javascript
selector[attribute]         选择有指定属性的元素
selector[attribute=value]   选择值等于value的元素
selector[attribute!=value]  选择值不等于value的元素
selector[attribute^=value]  选择值以value开头的元素
selector[attribute$=value]  选择值以value结尾的元素
selector[attribute*=value]  选择值包含value的元素
[][][][]...  属性选择器的进一步筛选
```

## 3.7 子元素选择器

```javascript
:first-child    选择首个子元素
:last-child     选择最后一个子元素
:only-child     选择唯一的子元素
:nth-child(n)   选择指定的第N个子元素
```

## 3.8 表单选择器

```javascript
:input          选择所有 input, textarea, select 和 button 元素. 
:text 
:password 
:radio 
:checkbox 
:submit 
:image 
:reset 
:button 
:file 
```

## 3.9 表单对象选择器

```javascript
:enabled     匹配所有的可用元素
:disabled    匹配所有的禁用元素
:checked     匹配所有的被选中的元素
:selected    匹配所有的被选中option元素
```

# 4. 筛选

## 4.1 过滤

```javascript
eq(index)           过滤出指定的某个
first()             过滤出首个
last()              过滤出最后一个
filter(selector)    满足指定选择器所选的元素
not(selector)       过滤排除
slice(start, end)   过滤出指定的一部分元素
has(selector)       过滤出 含有指定选择器所选的元素的元素

hasClass()          判断前面的集合中,是否包含有某个类
is()                判断前面的集合中,是否有某个元素符合指定的条件
map()               对JQdom的遍历,并且能取出一部分值出来
```

## 4.2 查找

> 都是具有破坏性,得到的对象,可能就不是前面集合的子集

```javascript
往里找:
    children()      只找子元素
    find()          找后代元素
往外找:
    parent()        父元素
    parents()       所有父级
    parentsUntil()  找到父级们,到指定位置为止
    offsetparent()  获取已定位的 父元素
    closest()       逐级向上找父级,返回找到的父级
往后找:
    next()          紧邻着的一个同级元素(后)
    nextAll()       紧邻着的所有同级元素(后)
    nextUntil()     紧邻着的所有同辈元素,直到某一个为止(后)
往前找:
    prev()          紧邻着的一个同级元素(前)
    prevAll()       紧邻着的所有同级元素(前)
    prevUntil()     紧邻着的所有同辈元素,直到某一个为止(前)
其他:
    siblings()      除了元素自己之外的所有同辈节点
```

## 4.3 串联

```javascript
add()               向集合内 追加元素
andSelf() / addBack() 把之前选中的集合加入到当前集合内
end()               返回最后一个 筛选操作之前的状态
contents()          获取所有的子节点(包括文本)
```

------

# 5. 文档处理

## 5.1 内部插入

```javascript
append()     内部最后
appendTo()   --
prepend()    内部最前
prependTo()  --
```

## 5.2 外部插入

```javascript
after()        外部之后
insertAfter()  --
before()       外部之前
insertBefore() --
```

## 5.3 包裹

```javascript
wrap()        将集合内的每一个元素 包裹在指定的元素内
wrapAll()     将整个集合元素 包裹在指定的元素内
unwrap()      去掉包裹
wrapInner()   将选中的元素里面的内容 包裹在一个标签内
```

## 5.4 替换

```javascript
replaceWith()  替换谁
replaceAll()   谁被替换
```

## 5.5 删除

```javascript
remove()      删除指定的元素
empty()       清空子节点
```

## 5.6 复制

```javascript
clone()  复制
```

------

# 6. 属性

## 6.1 属性操作

```javascript
attr()        读取/设置/修改 HTML属性 + 自定义属性
removeAttr()  移除 HTML属性 + 自定义属性

prop()        读取/设置/修改 HTML属性
removeProp()  移除 HTML属性
```

## 6.2 CSS 类

```javascript
addClass()     添加一个类属性
removeClass()  移除一个类属性
toggleClass()  以上俩 来回切换
```

## 6.3 HTML 代码/文本/值

```javascript
html()          相当于 innerHTML
text()          相当于 innerText
val()           相当于 .value  用于表单控件
```

------

# 7. CSS 操作

## 7.1 CSS

```javascript
// 设置样式
$('div').css('color', '#f00').css(.....);

// 多个样式,可用JSON作为参数传递多个样式
$('div').css({
    "color" : "#f00",
    "font-size" : "100px"
});

// 读取样式
$('div').css('color');
```

## 7.2 位置

```javascript
offset()     获取/设置  元素相对于整个文档的位置, left/top属性
position()   获取 已定位的父元素的位置

scrollTop()  获取/设置 滚动条距离上边的位置
scrollLeft() 获取/设置 滚动条距离左边的位置
```

## 7.3 尺寸

```javascript
(不加 内边距/边框)
width()  获取/设置  CSS设置的元素宽
height() 获取/设置  CSS设置的元素高

(不加边框)
innerWidth()  获取/设置  内容+内边距的宽
innerHeight() 获取/设置  内容+内边距的高

(标准元素大小: 内容+内边距+边框)
outerWidth()  获取/设置  实际的宽
outerHeight() 获取/设置  实际的高
```

------

# PS.

```javascript
$(window).height()   //浏览器时下窗口可视区域高度
$(document).height() //浏览器时下窗口文档的高度
$(document.body).height() //浏览器时下窗口文档body的高度
$(document.body).outerHeight(true) //浏览器时下窗口文档body的总高度 包括border padding margin
$(window).width()   //浏览器时下窗口可视区域宽度
$(document).width() //浏览器时下窗口文档对于象宽度
$(document.body).width() //浏览器时下窗口文档body的高度
$(document.body).outerWidth(true) //浏览器时下窗口文档body的总宽度 包括border padding margin

$(document).scrollTop()  //获取滚动条到顶部的垂直高度
$(document).scrollLeft() //获取滚动条到左边的垂直宽度
```

# 8. 事件

## 8.1 绑定事件 / 事件委派

1. 简写方式  `JQDOM.event(function(){})`
2. 标准绑定方式  `bind()` / `on()` [支持事件委托]
3. `one()`  绑定一次性 事件

## 8.2 解绑定

- `unbind()`
- `off()`  [支持 事件委派]

## 8.3 事件的自动触发

`trigger()`

## 8.4 阻止默认事件 和 事件冒泡

- 阻止默认事件: 在事件内使用 `return false`
- 使事件不冒泡: 在冒泡的事件内 `return false`

------

# 9. 动画效果

## 9.1 基本

```javascript
show()     显示
hide()     隐藏
toggle()   切换 显示/隐藏
```

## 9.2 滑动效果

```javascript
slideDown()   下滑动
slideUp()     上滑动
slideToggle() 切换 上/下滑动
```

## 9.3 淡入淡出

```javascript
fadeIn()      淡入
fadeOut()     淡出
fadeToggle()  切换  淡入/出
fadeTo()      指定透明度 0: 透明; 1: 不透明
```

## 9.4 自定义动画

```javascript
animate(JSON,time)  自定义动画
stop()       停止
delay()      延迟
```

# 10 ajax

## 10.1 ajax 请求

- JQDOM.load()  对象是 JQDOM
- $.get()       对象是 JQ本身
- $.post()
- $.ajax()

```
<body>
    <h1>JQ AJAX</h1>
    <button id="btn">加载</button>
    <hr>
    
    <div id="box"></div>

    
    <script src="./jquery-3.3.1.min.js"></script>
    <script>
    $(function (){
        $('#btn').click(function(){
            // load()
            // $('#box').load('./php/1.php');
            
            // get
            // $.get('./php/1.php', function(data){
            //     $('#box').html(data);
            // });
            
            // post
            // $.post('./php/1.php', function(data){
            //     $('#box').html(data);
            // });

            // ajax  
            $.ajax({
                // type : 'get',
                method : 'post',
                url    : './php/1.php',
                success: function (data){
                    $('#box').append(data +'<br>');
                },
                error  : function(){
                    alert('AJAX 执行失败');
                }
            });
        });
    });
    </script>
</body>
```

```
<body>
    <h1>JQ AJAX</h1>
    <button id="btn">加载</button>
    <hr>
    <hr>
    <div id="box"></div>

    
    <script src="./jquery-3.3.1.min.js"></script>
    <script>
    $(function (){
        $('#btn').click(function(){
            /*// get
            $.get('./php/4.php', function(data){
                // eval() / JSON.parse()
                console.log(data);
            }, 'json');*/

            // ajax  店长推荐
            $.ajax({
                // type : 'get',
                method : 'get',
                url    : './php/4.php',
                dataType : 'json',
                success: function (data){
                    console.log(data);
                    for (var i = 0; i < data.length; i++) {
                        $('<li>').html(data[i].name).appendTo('#box');
                    }
                },
                error  : function(){
                    alert('AJAX 执行失败');
                }
            });
        });
    });
    </script>
</body>
```



## 10.2 获取表单中数据

`serialize()`

## 10.3 jsonp 处理

`$.getScript()`

```
<body>
    <h1>JQ-JSONP</h1>
    <button onclick="loadHtml()">加载</button>
    <hr>

    <div id="box"></div>

    <script src="./jquery-3.3.1.min.js"></script>
    <script>
        function makedata(obj){
            // alert(obj);
            box.innerHTML = '';
            // JSON.parse()  // NO
            for (var i in obj) {
                box.innerHTML += i  + ' : ' + obj[i] + '<br>';
            }
        }

        // JSONP 关键步骤
        function loadHtml(){
            // // 创建JS对象
            // var js = document.createElement('script');
            // // 设置JS标签的src值
            // js.src = 'http://127.0.0.1/s86/JS16-JQ03/php/7.php';
            // // 添加这个JS对象到页面之中
            // document.body.appendChild(js);
            // 
            $.getScript('http://127.0.0.1/s86/JS16-JQ03/php/7.php');
        }

    </script>

</body>
```



# 11. jQuery 其他方法

```javascript
each()   遍历JQ DDM元素
get()    获取某个索引的元素
index()  当前元素的索引值
```

------

```
<body>
    <h1>JQ-其他</h1>
    <hr>

    <ul id="list">
        <li>赠汪伦 - 李先生</li>
        <li>李白乘舟将欲行，</li>
        <li>忽闻岸上踏歌声。</li>
        <li>桃花潭水深千尺，</li>
        <li>不及汪伦送我情。</li>
    </ul>


    <script src="./jquery-3.3.1.min.js"></script>
    <script>

        $('#list li').each(function (i, n){
            console.log(i, n, this, $(this).index());
        });

    </script>

</body>
```







# 特效-纵向导航条(手风琴)

```
<head>
    <meta charset="UTF-8">
    <title>Document</title>
    <style type="text/css">
        *{
            list-style: none;
            margin: 0;
            padding: 0;
        }
        #nav{
            margin: 40px;
        }
        #nav h3{
            width: 200px;
            line-height: 40px;
            padding: 0 20px;
            border: 1px solid #999;
            background-color: #abcdef;
            cursor: pointer;
        }
        #nav ul{
            width: 242px;
            display: none;
        }
        #nav li{
            width: 200px;
            height: 40px;
            line-height: 40px;
            padding: 0 20px;
            border: 1px solid #aaa;
            background-color: #f5f5f5;
            cursor: pointer;
        }
    </style>
</head>
<body>
    <h1>JQ 纵向导航条 手风琴效果</h1>
    <hr>

    <div id="nav">
        <h3>用户管理</h3>
        <ul>
            <li><a>用户列表</a></li>
            <li><a>添加用户</a></li>
            <li><a>用户黑名单</a></li>
            <li><a>用户权限</a></li>
        </ul>
        <h3>分类管理</h3>
        <ul>
            <li><a>分类列表</a></li>
            <li><a>添加分类</a></li>
            <li><a>分类权限</a></li>
        </ul>
        <h3>商品管理</h3>
        <ul>
            <li><a>商品列表</a></li>
            <li><a>添加商品</a></li>
            <li><a>商品黑名单</a></li>
            <li><a>商品权限</a></li>
        </ul>
        <h3>订单管理</h3>
        <ul>
            <li><a>订单列表</a></li>
            <li><a>添加订单</a></li>
            <li><a>订单权限</a></li>
        </ul>
        <h3>系统管理</h3>
        <ul>
            <li><a>系统列表</a></li>
            <li><a>添加系统</a></li>
            <li><a>系统黑名单</a></li>
            <li><a>系统权限</a></li>
        </ul>
    </div>


    <script src="./jquery-3.3.1.min.js"></script>
    <script>
    
        $(function(){
            $('#nav ul').eq(4).show();

            // 事件
            $('#nav h3').click(function(){
                // 展开
                /*$(this)
                .next('ul')
                .slideDown(1000)
                .siblings('ul')
                .slideUp(1000);*/
                $(this)
                .next('ul').slideDown(1000)
                .siblings('ul').slideUp(1000);
            });
        });
        
    </script>
```

# 特效-jq放大镜

```
<head>
	<meta http-equiv="Content-Type" content="text/html;charset=UTF-8">
	<title>放大镜</title>
	<script src='./jquery-1.8.3.min.js'></script>
	<script src='jquery.jqzoom-core.js'></script>
	<script>
		$(function(){
			//使用jqzoom
			$('.myclass').jqzoom({
				
			});
		})
	</script>
	<style>
			
	</style>
	<link rel="stylesheet" href="jquery.jqzoom.css">
</head>
<body>
    
		<a href="./images/big01.jpg" class='myclass' title='大图'>
			<img src="./images/small01.jpg" alt="">
		</a>

</body>
```

# PS:jQuyer常见插件总结

1. 五星级评价插件 jRating
    插件主页：http://www.myjqueryplugins.com/jquery-plugin/jrating
2. 流行的图片展示插件 unSlider
    插件主页： http://www.bootcss.com/p/unslider/
3. 相册插件    Galleriffic
    插件主页：http://www.twospy.com/galleriffic/index.html
4. 日期选取插件 Datepicker
    插件主页：http://jqueryui.com/datepicker/
5. 事件日历插件 xGCalendar
    主页 https://github.com/xuanye/xgcalendar
6. 表单插件 JQuery.form
    主页：http://plugins.jquery.com/form/
7. 表单验证插件 jQuery.validate
    主页 http://plugins.jquery.com/validate/
8. 表格插件 jqGrid 和 Flexigird
    主页： http://www.jqgrid.com/
    主页：http://flexigrid.info/
9. 树状列表插件 zTree
    主页：http://www.ztree.me/v3/main.php#_zTreeInfo
10. 对话框插件
    主页：http://www.fancybox.net/
11. 图片放大插件jQzoom
    主页： http://www.oschina.net/p/jqzoom
12. 图片上传插件 jQuery File Upload
13. 网站导航栏插件 jQuery.mmenu
    主页：http://mmenu.frebsite.nl/
14. 可拖放布局插件 gridster.js
    主页：http://gridster.net/
15  页面便条插件 jStickyNode
    主页 http://tympanus.net/codrops/2009/10/30/jstickynote-a-jquery-plugin-for-creating-sticky-notes/]]></content>
      <categories>
        <category>学习笔记</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
        <tag>jQuery</tag>
      </tags>
  </entry>
  <entry>
    <title>JavaScript 基础02-js函数</title>
    <url>/2018/05/22/JavaScript%20%E5%9F%BA%E7%A1%8002-js%E5%87%BD%E6%95%B0/</url>
    <content><![CDATA[
# JS 函数

## 1. 函数的声明

1. function 关键字方式
   function 函数名([形参]) {
       JS 代码
   }
2. 表达式方式
   var 函数名 = function([形参]) {
       JS 代码
   }
3. Function 构造函数方式
   var 函数名 = new Function('参数1', 'JS 代码');

## 2. 调用函数

- 加括号才是调用
- 不加括号 是引用 该函数

## 3. JS 函数特点

- 函数没有返回值 默认返回undefined
- 函数可以重复定义的

## 4. JS 函数中的参数

- 形参与实参
  - 实参个数 > 形参个数 多余的实参会被忽略
  - 实参个数 < 形参个数 未赋值的参数 会被自动赋值为 undefined
- 参数的默认值
  - 在函数内部判断 是否是undefined. 做赋值
- 可变参数个数
  - arguments 获取所有传递的是参数,是一个数组对象

## 5. JS 中的变量作用域  全局和局部变量

- 在函数内 使用 var 定义的是 局部变量
- 在函数外 使用 var 定义的是 全局变量
- 在函数内/外 不使用 var 定义的是 全局变量

## 6. JS 的作用域链

函数的执行 依赖于变量的作用域

这个作用域是在 函数定义声明时决定的，而不是 函数调用时决定的！

- 如果当前作用域里 没有声明变量，则向上一层作用域里面找.
- 如果直到找到全局里 还都未找到，则在执行函数时 会报错.



## 7. 自执行函数 与 闭包

### 7.1 自执行

```javascript
( function(){console.log(1)} )()
( function(){console.log(2)} () )
```

这种写法的含义是将函数声明转换成函数表达式，消除了 JS 引擎识别函数表达式和函数声明的歧义.

它告诉 JS 引擎这是一个函数表达式，不是函数声明。并且可以在后面加括号，立即执行函数的内的代码.



### 7.2 闭包

简单说，闭包就是 能够读取 其他函数内部变量的 函数。

由于在 JS 中，只有函数内部的 子函数 才能读取 局部变量，
因此可以把闭包 简单理解成 “定义在一个 函数内部的 函数”。

所以，在本质上，闭包就是将 函数内部 和 函数外部 连接起来的一座桥梁。

闭包的最大用处有两个

1. 一个是可以读取 函数内部的变量，
2. 另一个就是 让这些变量的值 始终保持在内存中。



## 特效-倒计时同意

```
<h3>10s倒计时生效按钮</h3>
<button id="btn" disabled onclick="alert('已同意!')">同意(10)</button>

<script>
    m = 10;
    function showbtn() {
        var  btn = document.getElementById('btn');
        if (m <= 0) {
            btn.disabled = false;
            btn.innerHTML = '同意';
            return;
        }
        btn.innerHTML = '同意('+m+')';
        m--;
        setTimeout("showbtn()", 1000);
    }

    showbtn();

</script>

```





]]></content>
      <categories>
        <category>学习笔记</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title>JavaScript 基础03-对象数组事件</title>
    <url>/2018/05/27/JavaScript%20%E5%9F%BA%E7%A1%8003-%E5%AF%B9%E8%B1%A1%E6%95%B0%E7%BB%84%E4%BA%8B%E4%BB%B6/</url>
    <content><![CDATA[
# 1.JS 数组

## 声明数组

- 1 使用 Array() 构造函数方式
  - var list = new Array(); // 空数组
  - var list = new Array(length); // 定义数组 初始长度
  - var list = new Array(v1,v2,v3); // 指定初始值
- 2 JSON 方式 
  - var list = []; // 空数组
  - var list = [v1,v2,v3]; // 指定初始值

## 数组特点

- 不能使用 `[]` 的形式去追加数组元素,想要追加的请使用 push()
- JS数组的下标是连续的, 跳跃着赋值数组元素的话,中间的元素会自动赋值为undefined
- JS 只有索引数组,没有关联数组

## 遍历

- for 适合遍历从页面中获取到的元素集合对象
- for-in  适合遍历对象

## 数组 属性

见手册

## 数组 方法

- 不改变原数组的方法:
  - concat()
  - join()
  - slice()
- 改变原数组的方法:
  - reverse()
  - push()
  - pop()
  - unshift()
  - shift()
  - sort()

------

# 2.JavaScript 的内置对象

## Boolean

Boolean 对象的声明

- 直接赋值
- 转换函数
- 构造函数

------

## Number

Number 对象的声明

- 直接赋值
- 转换函数
- 构造函数

Number的属性

Number的方法

------

## String

String 对象的声明

- 直接赋值
- 转换函数
- 构造函数

String 的属性

String 的方法

------

## RegExp

RegExp 对象的声明

- 直接赋值
- RegExp 构造函数

RegExp的方法

RegExp 示例

------

## Date

获取 date 对象

获取 date 中的信息

设置 date

------

## Math

Math 的属性

Math 的方法

------

## Array

已学习



# 3.JavaScript 事件

### 1. 事件的绑定

- 事件作为 元素的属性

```javascript
<tagName event="JS code..."></tagName>
```

- 事件作为 元素对象的属性

```javascript
element.onclick = function(){}
element.onclick = funName;
```

- 事件监听(标准)

```javascript
非IE: element.addEventListener('event', funName, false);
IE:   element.attachEvent('onevent', funName);
```

### 2. 解除绑定

- 第1种和第2种的绑定方式

```javascript
element.event = function(){}
element.event = null;
```

- 监听方式

```javascript
非IE: element.removeEventListener('event', funName, false);
IE:   element.detachEvent('onevent', funName);
```

### 3. 给一组元素绑定事件和this的使用

- 循环绑定事件,获取触发事件的元素对象时,需要使用 this
- 元素内部绑定事件时 传入this, 表示该元素对象自己

### 4. 闭包 closure

- 在循环绑定事件时,将循环变量保留下来时,就需要使用闭包
- 用一组元素 去控制另一组元素时,建议使用闭包
- 语法:

```javascript
for( ... ) {
    (function (i,x,y){
        element.event = function(){
            // 使用 i,x,y
        }
    })(i,x,y);
}
```

### 5. 常用事件

#### 5.1 鼠标事件

- onclick       单击触发
- ondblclick    双击触发
- oncontextmenu 右击触发/return false阻止系统菜单
- onmouseover   鼠标指向触发
- onmouseout    鼠标移开触发
- onmousedown   鼠标按下触发
- onmouseup     鼠标松开触发
- onmousemove   鼠标移动触发

#### 5.2 键盘事件

- onkeydown     按下按键触发
- onkeyup       松开按键触发
- onkeypress    按下并松开触发(JS高级事件)
      不是所有的按键都能触发,无输出的按键 就不能触发
      (方向键/shift/alt/ctrl/tab/大小写)

#### 5.3 表单事件

- onsubmit   表单被提交时触发
- onreset    表单被重置时触发
- onfocus    获取焦点时触发
- onblur     失去焦点时触发
- onchange   改变表单控件的内容或状态时就触发
      `用于input元素时,value值变化且失焦才触发`
- oninput           非IE: 输入时输入时(input/textarea)
- onpropertychange  IE: 输入时输入时(input/textarea)
- onselect   选中时触发

#### 5.4 框架/对象事件

- onload    文档加载完触发/图片加载完触发
- onunload  文档关闭时触发 IE
- onbeforeunload  文档关闭时触发 非IE
  `浏览器阻止了关闭前的弹框 需要return "string..."`
- onabort   图片加载过程中中断触发
- onerror   图片加载错误触发
- onresize  窗口/框架大小变化时触发
- onscroll  元素滚动条在滚动时触发

#### 5.5 其他事件

- oncopy   拷贝内容时触发
- oncut    剪切内容时触发
- onpaste  粘贴内容时触发
- onplay   音/视频开始播放时触发(audio/video)
- onpause  音/视频暂停时触发(audio/video)
- onended  音/视频播放结束时触发(audio/video)

// Chrome 73+  自动处理 play 状态
// https://www.tuicool.com/articles/J363M3v

### 6. Event 事件对象

#### 6.1 获取

事件内部 传入 en 获取使用
`var en = en || window.event;`

#### 6.2 属性

```javascript
en.x/en.clientX 鼠标的x坐标
en.y/en.clientY 鼠标的y坐标
en.button       鼠标的按键码: 0左键/1中键/2右键/3后退键/4前进键
en.offsetX      鼠标相对于触发事件元素的 x 坐标
en.offsetY      鼠标相对于触发事件元素的 y 坐标
```

### 7. 常用HTML元素属性

```javascript
    innerHTML   双标签之间的文本

    当前元素 相对与body 或已定位的父元素的 偏移量
    offsetTop
    offsetLeft

    当前元素 左边缘或顶边缘 滚过的像素值
    scrollTop
    scrollLeft

    className   当前元素的class属性值
    tagName     当前元素的标签名
```



------

# PS.补充

> JS 中的随机数的产生.
>
> > Math.random() 函数 返回 0 和 1 之间的伪随机数
> > 可能为 0, 但总是小于 1

```javascript
// 生成 min-max,包含 min 但不包含 max 的整数:
parseInt(Math.random() * (max-min) + min, 10);

// 生成min-max,不包含 min 但包含 max 的整数:
Math.floor(Math.random() * (max-min) + min) + 1;

// 生成 min-max,不包含 min 和 max 的整数:
Math.round(Math.random() * (max-min) + min + 1);

// 生成min-max ,包含 min 和 max 的随机数:
Math.round(Math.random() * (max-min)+min);
Math.floor(Math.random() * ((max-min)+1) + min);
```



# 特效-下载进度条

```
<body>
    <h1>下载进度条</h1>
    <hr>
    <button onclick="start()" id="but">开始下载</button>
    <div id="container">
    	<div id="color">
    		<span id="tip"></span>
    	</div>
    </div>
    
    <script>
		//获取color的宽度
		var container=document.getElementById('container');
		var color=document.getElementById('color');
        var tip=document.getElementById('tip');
		var but=document.getElementById('but');
                console.log(but.onclick);
        // 设置每次调用设置color宽度
        var w=0;
        function download(){
                color.style.width=w+'%';
                w++;
                tip.innerHTML=(w-1)+'%';
                but.onclick=stop;
                but.innerHTML='暂停下载';
                console.log(but.onclick);
    			if (w>100) {
    				clearInterval(c1);
					// alert('下载完成');
					tip.innerHTML='下载完成';
                    but.innerHTML='下载完毕';
                    but.onclick=start;
    			}
    	}

    	// 点击start开启定时器
    	function start(){
    		if (w<100) {
    			c1 = setInterval('download()',50)	
    		}
    	}
        function stop(){
            clearInterval(c1);
            but.onclick=start;
            but.innerHTML='继续下载';
            console.log(but.onclick);
        }
    </script>

```

# 特效-图层拖拽

```
<head>
    <meta charset="UTF-8">
    <title>图层拖拽</title>
    <style>
    	#box{
    		width: 100px;
    		height: 100px;
    		border: 1px solid #000;
    		position: absolute;
    	}
    </style>
</head>
<body>
    <h1>图层拖拽</h1>
    <hr>
    
    
	<div id="box">
		
	</div>

	<script>	
		var box = document.getElementById('box');
		box.onmousedown = function(en){
			var en = en || window.event;
			box.style.background='#00eef3';
			box.innerHTML='按住';
    		console.log(box.style);
			document.onmousemove = function(env){
				var env = env || window.event;
				box.style.top=env.y-en.offsetY+'px';
				box.style.left=env.x-en.offsetX+'px';
	    		console.log(box.style.top);
	    		console.log(box.style.left);
			}
		}

		document.onmouseup = function(){
			box.style.background = '#fff';
			box.innerHTML='松开';
			document.onmousemove = null;
		}

	</script>

</body>
```

# 特效-地址联动

```
    <h1>JS onchange 地址联动实例</h1>
    <hr>

    <select name="con" id="con"></select>
    <select name="city" id="city"></select>

    <script>
    // 声明数组
    // 国家的信息
    var conList = ['中国', '美国', '英国', '日本', '德国'];

    // 城市的信息 二维数组
    var cityList = new Array();
    cityList[0] = ['北京', '上海', '天津', '重庆', '南京'];
    cityList[1] = ['纽约', '洛杉矶', '芝加哥', '旧金山', '华盛顿'];
    cityList[2] = ['伦敦', '伯明翰', '曼彻斯特', '剑桥', '爱丁堡'];
    cityList[3] = ['东京', '北海道', '福冈县', '广岛', '大阪'];
    cityList[4] = ['柏林', '汉堡', '慕尼黑', '科隆', '法兰克福'];

    // 获取下拉框 填充国家或城市
    
    var con = document.getElementById('con');
    var city = document.getElementById('city');
    // console.log(con, city);
    
    // 填充国家下拉框选项
    for (var i = 0; i < conList.length; i++) {
        // con.innerHTML += '<option value="'+i+'">'+conList[i]+'</option>';
        con.add(new Option(conList[i], i));
    }

    // 绑定onchange事件到第一个下拉框之上
    con.onchange = function () {
        // 清空之前的选项
        // city.innerHTML = '';
        city.options.length = 0;

        // 根据value值 获取被选中的option信息
        var index = con.value;
        // console.log(index);
        // 根据索引值,去取出对应的城市信息
        var citys = cityList[index];
        // console.log(citys);

        // 填充城市信息
        for (var i = 0; i < citys.length; i++) {
            city.add(new Option(citys[i], i));
        }
    }

    // 手动触发onchange一次
    con.onchange();
    </script>
```

# 特效-resize事件

```
   <h1>JS onresize  事件</h1>
    <hr>

    <div id="box"></div>

    <script>
        window.onresize = function(){
            box.innerHTML = Math.random();
            // 随机背景颜色
            // // rgb(0,0,0)  ~ rgb(255,255,255)
            // var r = Math.floor(Math.random() * 100000 % 256);
            // var g = Math.floor(Math.random() * 100000 % 256);
            // var b = Math.floor(Math.random() * 100000 % 256);
            // console.log(r,g,b);
            // document.body.style.backgroundColor = 'rgb('+r+','+g+','+b+')';

            // 0~9a~f >>> [0,1,2,3,4,....e,f]
            // #000000 ~ #ffffff
            var color = '#' + Math.floor(Math.random() * 16777215).toString(16);
            document.body.style.backgroundColor = color;

            // 2147483647   int
            // 10485760   =>  10M
            // 1048576   =>  1M
        }
    
    </script>
```



]]></content>
      <categories>
        <category>学习笔记</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title>JavaScript 基础04-JS BOM</title>
    <url>/2018/06/10/JavaScript%20%E5%9F%BA%E7%A1%8004-BOM/</url>
    <content><![CDATA[
# BOM

### 1. 什么是BOM

Browser Object Model  浏览器对象模型

### 2. JavaScript 对象层次

#### 2.1 对象种类

- 自定义对象 Obejct
- 内置对象 A/S/N/B/M/D/R/G
- BOM 浏览器对象模型
- DOM 文档对象模型

#### 2.2 对象树 (倒树状结构)

```
                    window
                       |
history   location  document  screen   navigator
                        |
                doc       html
                           |
                    head         body
                      |           |
                mate  link      div p li  span ...
```

### 3. BOM 对象

#### 3.1 window

- 描述整个浏览器窗口的
- 它是JS中 所有对象的根对象
- 使用window的属性和方法时,可以省略window的调用
- 自定义对象/变量/函数
- 属性: 见手册
- 方法:
  - setInterval() 按照指定的周期（以毫秒计）来调用函数或计算表达式。 
  - setTimeout() 在指定的毫秒数后调用函数或计算表达式。 
  - clearInterval() 取消由 setInterval() 设置的 timeout。 
  - clearTimeout() 取消由 setTimeout() 方法设置的 timeout。 
  - alert()    警告框
  - confirm()  确认框
  - prompt()   输入框
  - open()     打开新窗口
  - close()    关闭窗口,只能关闭自己打开过的窗口
  - print()    打印
  - srcollTo() 滚到哪去
  - srcollBy() 滚多少

#### 3.2 history

- 属性: length
- 方法:
  - back()
  - forward()
  - go()

#### 3.3 location

- 属性:
  - href
  - protocol
  - hostname
  - host
  - pathname
  - search
  - hash
- 方法:
  - reload()
  - assign()
  - replace()

#### 3.4 screen

- 属性
  - width   屏幕宽度
  - height   屏幕高度

#### 3.5 navigator



# window操作

```
    <h1>window</h1>
    <hr>
    <button onclick="run()">打个招呼</button>

    <hr>
    <button onclick="window.open()">打开一个新窗口</button>
    <button onclick="window.open('http://www.163.com')">open : 163.com</button>
    <button onclick="window.open('http://m.baidu.com','', 'width=300,height=600')">open(指定大小)</button>
    <button onclick="window.open('http://m.toutiao.com','jianjian')">open(指定在哪个窗口打开)</button>


    <button onclick="window.close()">关闭窗口</button>
    <button onclick="window.print()">打印</button>

    <script>
    window.name = 'jianjian';


    var obj = {name:"静静"}

    console.log(obj);
    console.log(window.obj);

    var a = 110;
    console.log(window.a);

    function demo(){
        console.log('呆毛...');
    }

    window.demo();

    // - alert()    警告框
    // var a = alert('警告框');
    // console.log(a); // undefined
    // - confirm()  确认框
    // var a = confirm('确认框');
    // console.log(a); // true/false
    // - prompt()   输入框
    // var a = prompt('请输入您的银行卡密码:');
    // console.log(a); // ...

    // if (confirm('你喜欢球吗??')) {
    //     alert('好巧,我也喜欢!');
    // } else {
    //     alert(prompt('为什么不喜欢???'));
    // }
    
    function run(){
        do {
            // 弹出输入框
            var name = prompt('您贵姓?');
            //  确认信息框
            var content = confirm('您输入的是: [ ' + name + ' ]\n,是否确认?');
        } while (!content);

        alert('Hi~ o(*￣▽￣*)ブ,  小'+ name+name);
    }

    </script>
```

# history操作

```
    <h1>history</h1>
    <hr>

    <button onclick="history.back()">上一步(后退)</button>
    <button onclick="history.forward()">下一步(前进)</button>

    <button onclick="history.go(1)">下一步</button>
    <button onclick="history.go(-2)">上2步</button>

    <script>
    console.log(window.history);

    console.log(history.length); // 当前本页面打开过的历史记录数量

    </script>
```



# location操作

```
    <h1>location</h1>
    <hr>

    <button onclick="location.reload()">刷新</button>

    <!-- JS 跳转一个页面 -->
    <button onclick="location.assign('http://acfun.cn')">assign</button>
    <button onclick="location.replace('http://bilibili.com')">replace</button>
    <button onclick="location.href='http://xiazaiav.com'">href</button>

    <script>
    // console.log(window.location);
    console.log('URL: ' + location.href);

    console.log('协议: ' + location.protocol);
    console.log('主机名: ' + location.hostname);
    console.log('主机名+端口号: ' + location.host);

    console.log('路径: ' + location.pathname);
    console.log('参数: ' + location.search);
    console.log('锚点: ' + location.hash);

    // location.href = 'http://acfun.cn';
    // location.search = '?age=18';
    location.hash = '#p18';



    </script>
```

# screen-navigator操作

```
    <h1>screen / navigator</h1>
    <hr>


    <script>
    console.log(window.screen);
    console.log(window.screen.availHeight);
 
    console.log(window.navigator);
    console.log(window.navigator.appVersion);
    console.log(window.navigator.userAgent);

    // 检测用户的终端设备
    
    var browser = {
        versions: (function(){
            var u = navigator.userAgent;
            var app = navigator.appVersion; 
            return {
                trident: u.indexOf('Trident')     > -1,                                   // IE内核
                presto : u.indexOf('Presto')      > -1,                                   // Opera内核
                webKit : u.indexOf('AppleWebKit') > -1,                                   // 苹果谷歌内核
                gecko  : u.indexOf('Gecko')       > -1 && u.indexOf('KHTML') == -1,       // 火狐内核
                mobile : !!u.match(/AppleWebKit.*Mobile.*/) || !!u.match(/AppleWebKit/),  // 是否为移动端
                ios    : !!u.match(/\(i[^;]+;( U;)? CPU.+Mac OS X/),                      // ios终端
                android: u.indexOf('Android')     > -1 || u.indexOf('Linux') > -1,        // android终端 或 uc浏览器
                iPhone : u.indexOf('iPhone')      > -1 || u.indexOf('Mac') > -1,          // 是否为iPhone 或 QQHD浏览器
                iPad   : u.indexOf('iPad')        > -1,                                   // 是否为iPad
                webApp : u.indexOf('Safari')      == -1                                   // 是否为web应用程序,没有头部和底部
            };
        })()
    }

    document.write('是否为移动端:' + browser.versions.mobile + '<br>');
    document.write('是否为ios端:' + browser.versions.ios + '<br>');
    document.write('是否为android终端:' + browser.versions.android + '<br>');
    document.write('是否为chrome浏览器:' + browser.versions.webKit + '<br>');
    document.write('是否为FireFox浏览器:' + browser.versions.gecko + '<br>');

    </script>
```

]]></content>
      <categories>
        <category>学习笔记</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
        <tag>JS BOM</tag>
      </tags>
  </entry>
  <entry>
    <title>JavaScript 基础05-JS DOM</title>
    <url>/2018/06/21/JavaScript%20%E5%9F%BA%E7%A1%8005-DOM/</url>
    <content><![CDATA[
# DOM

## 1. DOM基本介绍

DOM 是 Document Object Model 文档对象模型

- HTML DOM
- XML DOM

## 2. HTML DOM 对象参考

- 2.1 document 对象
  - 属性: 
    - domain
    - lastModified
    - referrer
    - URL
    - cookie
    - 集合属性all 获取所有元素(IE中为true,非IE为false)
  - 方法: 

- 2.2 form 对象
  属性:

  ```
  -length 元素个数
  -elements 元素数组
  ```

  方法:
      - submit() 提交指定的表单
      - reset()  重置指定的表单
  事件:
          -onsubmit="return false"    阻止提交表单,submit()方法可绕过
          -onreset="return false"     阻止重置表单,reset()方法可绕过

- 2.3 image 对象

- 2.4 anchor 对象

- 2.5 base 对象

- 2.6 canvas 对象
  http://echarts.baidu.com/

- 2.7 Event 对象

- 2.8 input 系列对象

  - blur()
  - focus()
  - select()
    复制 flash或clipboard.js组件

- 2.9 select 对象

- 2.10 option 对象

- 2.11 style 对象

- 2.12 table 对象

- 2.13 tableRow 对象

- 2.14 tableCell 对象

## 3.XML DOM 节点

### 1.节点介绍

- 1.1 什么是节点 node

HTML 文档中 所有的组成部分 称之为节点

- doucment  文档
- element   标签
- attr      属性 (attribute)
- comment   注释
- text      文本
- 1.2 节点树
  子节点
  父节点
  同辈节点
  后代节点
  先辈节点
- 1.3 节点的访问
  - 得到节点
    - doucment  文档
      document
    - element   标签
      ByID...
    - attr      属性 (attribute)
      getAttributeNode(attrname)
    - comment   注释
      子节点
    - text      文本
      子节点
  - 获取子节点
    childNodes
  - 获取子元素节点
    children
  - 获取第一个子节点
    firstChild
  - 获取最后一个子节点
    lastChild
  - 获取父节点
    parentNode
  - 获取父元素节点
    parentElement
  - 获取前一个节点
    previousSibling
  - 获取后一个节点
    nextSibling

- 1.4 节点属性
  - nodeName 
    - doucment  #document
    - element   标签名
    - attr      属性名
    - text      #text
    - comment   #comment
  - nodeValue 
    - doucment  null
    - element   null
    - attr      属性值
    - text      文本内容
    - comment   注释内容
  - nodeType 
    - doucment  9
    - element   1
    - attr      2
    - text      3
    - comment   8

### 2.节点操作

2.1 获取节点

- element   ById/子节点/父节点/同辈节点/后代
- attr      getAttributeNode('attrname');  获取属性节点
      element.attr; 获取属性值
      getAttribute('attrname');  获取属性值

2.2 改变节点(改变节点的值) nodeValue

- element   无意义
- attr      
      setAttribute('attrname', 'value');
      element.attr = value;

2.3 删除节点

- attr      removeAttribute('attrname');
- element   把值赋值为空 或 removeChild(node) 需要找到父节点

2.4 替换节点

- attr      setAttribute('attrname', 'value');
- element   replaceChild(new_node, old_node)  需要找到父节点

2.5 插入节点

- attr      
      setAttribute('attrname', 'value');
      setAttributeNode('attrname');
- element   
      appendChild(node)   追加
      insertBefore(new_node, old_node)      指定位置

2.6 创建节点

- attr      document.createAttribute(attrname);
- element   document.createElement('tagName');

2.7 克隆节点

- cloneNode()  参数默认为false / 可选 true



### 3. XML 对象

- node
- nodeList
- document
- element
- attr
- text
- comment

### 4. HTMLElement对象

```
className   类名

scrollLeft  滚动条至 左边界像素
scrollTop   滚动条至 上边界像素

offsetLeft  距离已定位父元素的 左偏移量
offsetTop   距离已定位父元素的 上偏移量

innerHTML   元素内部的内容(不含标签)
innerText   元素内部所有的文本内容
outerHTML   元素的内容(含标签)

offsetWidth  盒子模型,实际的宽: 内容+内边距+边框
offsetHeight  盒子模型,实际的高: 内容+内边距+边框

clientWidth  宽 + 内边距
clientHeight 高 + 内边距

scrollWidth  宽 + 内边距 + 计算里面元素的大小
scrollHeight 高 + 内边距 + 计算里面元素的大小

document.documentElement.clientHeight  视口高度
document.documentElement.scrollHeight  文档高度
```

# PS. 补充

- PS1. DOM 元素对象的 属性和方法
  http://www.runoob.com/jsref/dom-obj-all.html
- PS2. MDN文档
  - Mozilla 开发者社区(MDN):
    https://developer.mozilla.org/zh-CN/
  - JavaScript MDN文档
    https://developer.mozilla.org/zh-CN/docs/Web/JavaScript

# 特效-全选复制按钮

```
    <h1>input</h1>
    <hr>

    <input type="text" id="s"> <button>百度一下</button>

    <hr>
    <br>
    
    <button onclick="selectAll()">全选</button>
    <button onclick="copyAll()">全选复制</button>

    <button class="btn" data-clipboard-target="#content">全选复制(clip)</button>
    <br>
    <br>
    <textarea name="weibo" id="content" cols="40" rows="10">诗人对宇宙人生，须入乎其内，又须出乎其外。入乎其内，故能写之。出乎其外，故能观之。入乎其内，故有生气。出乎其外，故有高致。美成能入而不出。白石以降，于此二事皆未梦见。</textarea>


    <script src="./clipboard.min.js"></script>
    <script>
    s.focus();

    function selectAll(){
        content.select();
    }

    function copyAll(){
        // 判断 剪切板对象 是否可用
        if (window.clipboardData) {
            // IE
            window.clipboardData.setData('text', content.value);
            alert('已复制到剪切板!');
        } else {
            // 非IE
            content.select();
            alert('请按 Ctrl + C 复制!');
        }
    }

    var clipboard = new ClipboardJS('.btn');

    clipboard.on('success',function(e){
        console.log(e);
        alert('已复制到剪切板(clip)');
    });


    </script>
```

# 特效-瀑布流效果

```
    <h1>瀑布流效果</h1>
    <hr>
    
    <div id="imglist">
        <img c-src="./imgs/mm021.jpg">
        <img c-src="./imgs/mm022.jpg">
        <img c-src="./imgs/mm023.jpg">
        <img c-src="./imgs/mm024.jpg">
        <img c-src="./imgs/mm025.jpg">
        <img c-src="./imgs/mm026.jpg">
        <img c-src="./imgs/mm027.jpg">
        <img c-src="./imgs/mm028.jpg">
        <img c-src="./imgs/mm029.jpg">
        <img c-src="./imgs/mm030.jpg">
        <img c-src="./imgs/mm031.jpg">
        <img c-src="./imgs/mm032.jpg">
        <img c-src="./imgs/mm033.jpg">
        <img c-src="./imgs/mm034.jpg">
        <img c-src="./imgs/mm035.jpg">
        <img c-src="./imgs/mm036.jpg">
        <img c-src="./imgs/mm037.jpg">
        <img c-src="./imgs/mm038.jpg">

    </div>

    <script>
   	var picNum = 3
    setTimeout('loadPic(picNum)',1000);
    var imgs = imglist.children;

	function loadPic(x){
		// 获取所有图片节点
    	console.log(cl);
    	var i = 0;
    	var cl = setInterval(function(){
    		imgs[i].setAttribute('src',imgs[i].getAttribute('c-src'));
    		console.log(i);
    		i++;
    		if (i >= x) {
    			clearInterval(cl);
    		}
    	},10)

    }

    // if (true) {}
    
    window.onscroll = function(){
    	
	    var clientY = document.documentElement.clientHeight;
	    var scrollY = document.documentElement.scrollHeight;
	    var top = document.documentElement.scrollTop;
	    console.log(top);
	    if (scrollY-clientY-1000 <= top) {
	    	picNum+=1;
	    	console.log(picNum);
	    	loadPic(picNum);

	    }
    }

    </script>
```

]]></content>
      <categories>
        <category>学习笔记</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
        <tag>JS DOM</tag>
      </tags>
  </entry>
  <entry>
    <title>JavaScript 特效</title>
    <url>/2018/06/21/JavaScript%20%E7%89%B9%E6%95%88/</url>
    <content><![CDATA[
## 特效扩展

### 银行卡自动截断

```
    <h1>请输入银行卡:</h1>
    <hr>

    <input type="text" id="bankCard" maxlength="23">

    <script>
        var input = document.getElementById('bankCard');

        if (document.all) {
            input.onpropertychange = ckInput;
        } else {
            input.oninput = ckInput;
        }


        function ckInput(){
            // 将输入范围限定在数字范围之内
            // A: 
            /*input.value = input.value
                .replace(/\D/g, '')
                .replace(/(\d{4})/g, '$1-')
                .replace(/-$/g, '');*/
            // B: 
            input.value = input.value
                .replace(/\D/g, '')
                .replace(/(\d{4})(?=\d)/g, '$1-')
        }

        /*
        (?:)    忽略子模式的匹配
        (?=)    正向预查/先行断言
                匹配过程中,需要用到这个子模式的条件
                但是,获取匹配结果时,忽略该子模式的条件
         */

    </script>
```



### 轮播图(Banner)

```
<head>
    <meta charset="UTF-8">
    <title>轮播图</title>
    <style>
		*{
			list-style:none;
		}
		#box{
			width: 400px;
			height: 300px;
			margin: 0 auto;
			border: 1px solid #000;
		}
		#container{
			position:relative;
		}
    	#imglist img{
    		width: 400px;
    		height: 300px;
    	}
    	#iconlist{
    		position: absolute;
    		right:110px;
    		bottom:10px;
    	}
    	#iconlist ul li{
    		width: 30px;
    		height: 30px;
    		border-radius: 50%;
    		float: left;
    		background: rgba(0,200,255,0.4);
    		line-height: 30px;
    		text-align: center;
    		margin-left: 10px;
			cursor: pointer;
    	}


    </style>
</head>
<body>
    <h1>轮播图</h1>
    <hr>
    
    <div id="box">
    	<div id="container">
    		<div id="imglist">
    			<img src="./imgs/mm041.jpg" style="display:block">
    			<img src="./imgs/mm042.jpg" style="display:none">
    			<img src="./imgs/mm043.jpg" style="display:none">
    			<img src="./imgs/mm044.jpg" style="display:none">
    			<img src="./imgs/mm045.jpg" style="display:none">
    		</div>
    		<div id="iconlist">
    			<ul>
    				<li style="color:red;background: rgba(0,255,255,1);">1</li>
    				<li>2</li>
    				<li>3</li>
    				<li>4</li>
    				<li>5</li>
    			</ul>
    		</div>
    	</div>
		<button onclick="previous()">previous</button>
		<button onclick="next()">next</button>
    </div>


    <script>
    	
    	var imgs = imglist.children;
    	var lis = document.getElementsByTagName('li');
    	console.log(lis);

    	var t = 0;
    	function run(){
	    	t++;
    		if (t>=imgs.length) {
	    		t=0;
    		}
    		showPic(t);
    		showBtn(t);
	    	console.log(t);
    	}
    	var cl1 = setInterval(run,1000); 

    	function showPic(t){
    		for (var i = 0; i < imgs.length; i++) {
    			imgs[i].style.display="none";
    		}
    		imgs[t].style.display="block";
    	}

    	function showBtn(t){
    		for (var i = 0; i < lis.length; i++) {
    			lis[i].setAttribute('style','');
    		}
    		lis[t].setAttribute('style',"color:red;background: rgba(0,255,255,1);");
    	}

    	// 鼠标划入时,解除定时器
    	container.onmouseover = function(){
    		clearInterval(cl1);
    	}
    	container.onmouseout = function(){
    		cl1 = setInterval('run()',1000);
    	}

    	// 鼠标滑过按钮时,切换为绑定页面
    	for (var i = 0; i < lis.length; i++) {
    		(function(i){
    			lis[i].onmouseover = function(){
    				t=i;
    				showPic(t);
    				showBtn(t);
    			}

    		})(i);
    	}

    	// 按钮控制下一张上一张
    	function previous(){
    		clearInterval(cl1);
    		console.log(t);
    		t--;
    		if (t<0) {
    			t=(imgs.length-1);
    		}
    		showPic(t);
    		showBtn(t);
    		cl1 = setInterval(run,1000);
    		
    	}
    	function next(){
    		clearInterval(cl1);
    		t++;
    		if (t>(imgs.length-1)) {
    			t=0;
    		}
    		showPic(t);
    		showBtn(t);
    		cl1 = setInterval(run,1000);
    	}


    </script>

</body>
```



### 图片无缝轮滚

```
    <meta charset="UTF-8">
    <title>Document</title>
    <style type="text/css">
        #box{
            width: 800px;
            height: 220px;
            margin: 0 auto;
            margin-top: 50px;
            border: 1px solid #000;
            /*overflow: auto;*/
            overflow: hidden;
        }
        #content{width: 10000px;}
        #imglist{float: left;}
        #imglist img{
            width: 300px;
            height: 200px;
            float: left;
        }
    </style>
</head>
<body>
    <h1>图片无缝轮滚</h1>
    <hr>

    <div id="box">
        <div id="content">
            <div id="imglist">
                <img src="./imgs/mm041.jpg">
                <img src="./imgs/mm042.jpg">
                <img src="./imgs/mm043.jpg">
                <img src="./imgs/mm044.jpg">
                <img src="./imgs/mm045.jpg">
                <img src="./imgs/mm046.jpg">
                <img src="./imgs/mm047.jpg">
                <img src="./imgs/mm048.jpg">
                <img src="./imgs/mm049.jpg">
                <img src="./imgs/mm050.jpg">
                <img src="./imgs/mm051.jpg">
                <img src="./imgs/mm052.jpg">
                <img src="./imgs/mm053.jpg">
                <img src="./imgs/mm054.jpg">
                <img src="./imgs/mm055.jpg">
            </div>
        </div>
    </div>

    <script>
    var width = imglist.offsetWidth;
    // console.log(width);
    // 将图片集合 复制一份,并追加到当前图片集合之后
    content.appendChild(imglist.cloneNode(true));

    // box.scrollLeft = 500;
    function scrollImage(){
        if (box.scrollLeft >= width) {
            box.scrollLeft = 0;
        }
        box.scrollLeft += 1;
        // console.log(box.scrollLeft);
    }
    setInterval(scrollImage, 50);
    
    </script>
</body>
```

```
<head>
    <meta charset="UTF-8">
    <title>图片跑马灯儿</title>
    <style>
    	#show{
    		margin: 10px auto;
    		width: 1202px;
    		height: 302px;
    		border: 1px solid #000;
    		/*overflow: scroll;*/
    		overflow: hidden;
    	}
    	#imgList{
    		height: 300px;
    		width: 4800px;
    		white-space:nowrap;

    	}
    	img{
    		width: 400px;
    		height: 300px;
    		margin: 0;
    		padding: 0;
    		float: left;

    	}
    </style>
</head>
<body>
    <h1>图片跑马灯儿</h1>
    <hr>
    
    <div id="show">
    	
    	<div id="imgList">
    		<img src="./imgs/mm021.jpg">
    		<img src="./imgs/mm022.jpg">
    		<img src="./imgs/mm023.jpg">
    		<img src="./imgs/mm024.jpg">
    		<img src="./imgs/mm025.jpg">
    		<img src="./imgs/mm026.jpg">
    		<img src="./imgs/mm021.jpg">
    		<img src="./imgs/mm022.jpg">
    		<img src="./imgs/mm023.jpg">
    		

    </div>
	
	<script>
		
		setInterval(function(){
			show.scrollLeft++;
			if (show.scrollLeft == 2400) {
				show.scrollLeft = 0;
			}
		},1)

	</script>


</body>
```



### 下滑加载图片

```
<head>
    <meta charset="UTF-8">
    <title>Document</title>
    <style type="text/css">
        #imglist{
            width: 90%;
            margin: 0 auto;
        }
        #imglist img{
            width: 600px;
            height: 400px;
            background: url(./imgs/loading.gif) no-repeat center center;
        }
    </style>
</head>
<body>
    <h1>下滑加载图片</h1>
    <hr>

    <div id="imglist">
        <img data-src="./imgs/mm041.jpg">
        <img data-src="./imgs/mm042.jpg">
        <img data-src="./imgs/mm043.jpg">
        <img data-src="./imgs/mm044.jpg">
        <img data-src="./imgs/mm045.jpg">
        <img data-src="./imgs/mm046.jpg">
        <img data-src="./imgs/mm047.jpg">
        <img data-src="./imgs/mm048.jpg">
        <img data-src="./imgs/mm049.jpg">
        <img data-src="./imgs/mm050.jpg">
        <img data-src="./imgs/mm051.jpg">
        <img data-src="./imgs/mm052.jpg">
        <img data-src="./imgs/mm052.jpg">
        <img data-src="./imgs/mm050.jpg">
        <img data-src="./imgs/mm050.jpg">
        <img data-src="./imgs/mm050.jpg">
        <img data-src="./imgs/mm053.jpg">
        <img data-src="./imgs/mm054.jpg">
        <img data-src="./imgs/mm055.jpg">
        <img data-src="./imgs/mm055.jpg">
    </div>

    <script>

        var imgs = imglist.getElementsByTagName('img');

        // 获取 imglist 的宽度
        var box_width = imglist.offsetWidth;

        // 获取 视口高度
        var view_height = document.documentElement.clientHeight;
        // console.log(view_height);
        // 计算 横着 能加载几张图片
        var x_number = Math.floor(box_width / imgs[0].offsetWidth);
        // console.log(x_number);
        
        // 首屏图片数量
        // Math.ceil((视口的高度 - 首图到顶部的偏移量) / img的高度) * x_number
        var first_number = Math.ceil((view_height - imgs[0].offsetTop) / imgs[0].offsetHeight) * x_number;
        // console.log(first_number);
        
        // loadImage(0, 4);
        // loadImage(4, 2);
        // 全局计数的变量,用于记录加载到第几张
        var m = 0;
        // 加载第一屏的图片
        loadImage(m, first_number);
        // 更新加载记录数
        m += first_number;

        /**
         * 加载图片
         * @param   start   从第几张开始加载
         * @param   length  加载几张图片
         */
        function loadImage(start, length){
            for (var i = start; i < (start+length); i++) {
                // 判断图片集合是否加载完毕
                if (i >= imgs.length) return;

                // console.log(i);
                (function (i){
                    setTimeout(function(){
                        imgs[i].src = imgs[i].getAttribute('data-src');
                    }, 500);
                })(i);
            }
        }

        // 绑定滚动事件
        window.onscroll = function (){
            // 判断图片集合是否加载完毕
            if (m >= imgs.length) return;
            // 获取 滚动条滚过的距离
            var top= document.body.scrollTop || document.documentElement.scrollTop;

            // 还未加载的首图 到顶部的偏移量
            var img_top = imgs[m].offsetTop;

            // console.log(top, img_top);
            // 判断加载下一批图片的临界点
            if ((top + view_height) >= img_top) {
                // 加载下一批图片
                loadImage(m, x_number);
                m += x_number;
            }
        }

    </script>
</body>
```



### 蛇形文字

```
<head>
    <meta charset="UTF-8">
    <title>Document</title>
    <style>
        .strstyle {
            font-size:20px;
            color: #f00;
            font-weight:700;
            position:absolute;
            top:-50px;
        }
    </style>
</head>
<body>
    <h1>蛇形文字</h1><hr>


    <script>
        //文字输出
        var msg = "JavaScript 蛇形文字...";
        for (var i = 0; i < msg.length; i++) {
            document.write('<span id="str'+i+'" class="strstyle">');
            document.write(msg[i]);
            document.write('</span>');
        }

        //绑定鼠标移动事件,得到鼠标位置
        document.onmousemove = function(e){
            e = e || window.event;
            document.title = 'X:'+e.clientX+'Y:'+e.clientY;

            //让每个字之间 有延迟的统一行动!
            var m = 0;
            var timer = setInterval(function(){
                // console.log(m);
                // 根据字数 控制次数 不能无限循环定时
                if(m < msg.length) {
                    // 调用文字运动轨迹函数
                    // x坐标,y坐标,第几个字
                    snake(e.clientX, e.clientY, m);
                    m++;
                }else{
                    //如果 次数大于等于字数,就清除定时
                    clearInterval(timer);
                }
            },50);
        }

        // 文字运动轨迹函数
        function snake(x,y,i){
            //获得每一个span元素对象
            var span = document.getElementById('str'+i);
            // console.log(span);
            span.style.left = x + (i*25) + 'px';
            span.style.top = y + 'px';
        }

    </script>
</body>
```



### 模态框(Modal)

```
<head>
    <meta charset="UTF-8">
    <title>模态框</title>
    <style>
        *{
            margin: 0;
            padding: 0;
            list-style: none;
            text-decoration: none;
        }
        a{
            font-size: 40px;
        }
        #modal {
            width: 100%;
            height: 100%;
            display: none;
            position: fixed;
            left: 0;top: 0;
            right: 0;bottom: 0;
            background: rgba(55,55,55,0.55);
        }
        #modalCeng{
            width: 400px;
            height: 200px;
            background-color: #eee;
            border: 3px solid #f00;
            display: none;
            position: fixed;
            margin: 100px 50%;
            left: -200px;
            z-index: 99;
        }
        #closeBtn{
            position:absolute;
            right:5px;
        }
    </style>
</head>
<body>
    <div class="container">
        <a href="#" onclick="show()">点击登录</a>
    </div>
    <div id="modalCeng">
        <button onclick="dis()" id="closeBtn">　X　</button>
        <br><br><br>
        用户名: <input type="text" name="name"><br>
        密码: <input type="password" name="pass">
        <br>
        <button>登录</button>
        <button onclick="dis()">取消</button>
    </div>
    <div id="modal"></div>

    <hr>
    <p>line 1</p>
    <p>line 2</p>
    <p>line 3</p>
    <p>line 4</p>
    <p>line 5</p>
    <p>line 6</p>
    <p>line 7</p>
    <p>line 8</p>
    <p>line 9</p>
    <p>line 10</p>
    <p>line 11</p>
    <p>line 12</p>
    <p>line 13</p>
    <p>line 14</p>
    <p>line 15</p>
    <p>line 16</p>
    <p>line 17</p>
    <p>line 18</p>
    <p>line 19</p>
    <p>line 20</p>
    <p>line 21</p>
    <p>line 22</p>
    <p>line 23</p>
    <p>line 24</p>
    <p>line 25</p>
    <p>line 26</p>
    <p>line 27</p>
    <p>line 28</p>
    <p>line 29</p>
    <p>line 30</p>
    <p>line 31</p>
    <p>line 32</p>
    <p>line 33</p>
    <p>line 34</p>
    <p>line 35</p>
    <p>line 36</p>
    <p>line 37</p>
    <p>line 38</p>
    <p>line 39</p>
    <p>line 40</p>



<script>
    var modal = document.getElementById('modal');
    var mc = document.getElementById('modalCeng');

    function show () {
        modal.style.display = 'block';
        mc.style.display = 'block';
    }

    function dis () {
        modal.style.display = 'none';
        mc.style.display = 'none';
    }
</script>
</body>
```



### 自定义输出表格(节点方式)

```
<head>
    <meta charset="UTF-8">
    <title>JS</title>
</head>
<body>
    <h1>XML DOM Table - 自定义</h1>
    <hr>
    行:<input type="text" name="num1" id="num1">
    列<input type="text" name="num1" id="num2">
    <button onclick="createTab()" id="tabshow">建立表格</button>
    <div id="tables"></div>

<script>
    function createTab () {
        //获取要生成的行列数
        var rows = document.getElementById('num1').value;
        var cols = document.getElementById('num2').value;
        //创建table 和 tr节点
        var tab = document.createElement('table');
        var tr = document.createElement('tr');

        tab.width = '800';
        tab.border = '1';
        tab.cellSpacing = '0';
        tables.appendChild(tab);//添加节点 table
        tab.appendChild(tr);//添加节点 tr

        //th 表头部分
        for (var i = 0; i < cols; i++) {
            var th = document.createElement('th');
            tr.appendChild(th);
            th.innerHTML = i;
        }

        //rows x cols 创建表格内容
        for (var i = 0; i < rows; i++) {
            tr = document.createElement('tr');
            tab.appendChild(tr);
            if (i%2 == 0 ) {
                tr.style.backgroundColor='#f90';
            }
            for (var j = 0; j < cols; j++) {
                var td = document.createElement('td');
                tr.appendChild(td);
                td.innerHTML = i +'-'+ j;
            }
        }
    }
</script>
</body>
```



]]></content>
      <categories>
        <category>实际演练</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title>LINUX基础操作(PHP版)</title>
    <url>/2019/01/12/LINUX%E5%9F%BA%E7%A1%80%E6%93%8D%E4%BD%9C(PHP%E7%89%88)/</url>
    <content><![CDATA[
## ssh - Secure Shell  

> 安全外壳协议(安全的远程连接)

### 1.服务器端配置安装:

- 安装:`yum install openssh -server`
- 启动:`service sshd start`
- 设置开机运行:`chkconfig sshd on`

> 查看启动服务: `ps -ef|grep ssh`

### 2.客户端配置:

Windows: `XShell/Putty`

Linux: `yum install openssh-clients`

### 3.ssh使用

`ssh 用户名@IP地址`(22端口)

### 4.SSH config配置

存放路径: `~/.ssh/config`

```
多用户分配
touch config
vim config
host "laowang"
	HostName 192.168.0.15
	User root
	Port 22
```

> IdentityFile ~/.ssh/id_rsa.pub
>
> IdentitiesOnly yes

效果: `ssh laowang`直接登录

### 5.SSH安全免密登录(ssh key)

> 公钥公开, 私钥保存本地~/.ssh/authorized_key
>
> 若服务器上已有该文件 , 将公钥文件内容添加至服务器文件即可

生成:

`ssh-keygen -t rsa`

`ssh-keygen -t dsa`

添加配置私钥至ssh服务(本地linux端)

`ssh-add ~/.ssh/naxx_rsa`

### 6.SSH端口安全

修改服务端口

> 文件路径/etc/ssh/sshd_config

1.`vim /etc/ssh/sshd_config`

2.修改port 

<hr>

## Linux常用命令:

### 1.软件操作命令

​	软件包-`yum`

​	安装: `yum install xxx`

​	卸载:`yum remove xxx`

​	搜索:`yum search xxx`

​	清理缓存:`yum clean packages`

​	已安装列表:`yum list`

​	软件包信息:`yum info xxx`

### 2.服务器资源命令

​	内存大小:`free -m`

​	磁盘大小:`df -h`

​	分区信息:`fdisk -lu`

​	负载:`w/top`  (一般0.6~0.7)

​	cpu个数和核数:`cat /proc/cpuinfo`

### 3.文件/文件夹操作

#### 1).文件目录结构

```
- 根目录`/`
- 家目录`/home`
- 临时目录`/tmp`
- 配置目录`/etc`
- 用户程序目录`/usr`
```

![1567947579354](/images/imgs/1567947579354.png)



#### 2).基本操作命令

​		- 查看目录下文件:`ls -al`

​		- 新建文件:`touch`

​		- 新建文件夹:`mkdir`     -p

​		- 进入目录:`cd`

​		- 删除文件/目录:`rm`

​		- 复制:`cp`

​		- 移动/剪切:`mv`

​		- 显示路径:`pwd`

#### 3).文本编辑Vim

```
	- 插入模式编辑`i`
	- 首行`G`
	- 尾行`gg`
	- 删除一行`dd`
	- 回复`u`
	- 复制一行`yy`
	- 粘贴`p`
	- 退出`:q`
	- 保存`:w`
```

#### 4).文件权限421

| r       | w        | x            |
| ------- | -------- | ------------ |
| 读-read | 写-write | 执行-execute |
| 4       | 2        | 1            |

​		更改权限`chmod -R 777 runtime/`

> 更改文件所有者 : `sudo chown -R naxx:naxx /data/test.txt`

#### 5).搜索/查找/读取

```
	- 从文件尾部开始读:`tail`		`tail -f xxx`
	- 从文件头部开始读:`head`
	- 读取整个文件:`cat`
	- 分页读取:`more`
	- 可控分页:`less`
	- 搜索关键字:`grep`			`grep -n "123" xxx.php`
	- 查找文件:`find` 				`find /etc/ -name "naxx"`
	- 统计个数:`wc`  					`cat index.php | wc -l`
```

#### 6).文件压缩/解压

​		**tar**

```
	- 压缩:`tar -cf naxx.tar 文件名`      `.gz格式压缩:tar -czvf naxx.tar.gz 文件名 `
	- 解压缩:`tar -xf naxx.tar`       `.gz解压:tar -xzvf naxx.tar.gz`
	- 查看:`tar -tvf naxx.tar`         `.gz查看:tar -tzvf naxx.tar.gz`
```

### 4.系统用户操作

​	1.添加用户 `useradd 用户名`

​	2.添加用户`adduser 用户名`

```
> 区别:(Ubuntu)
>
> 在root权限下，useradd只是创建了一个用户名，如 （useradd  +用户名 ），它并没有在/home目录下创建同名文件夹，也没有创建密码，因此利用这个用户登录系统，是登录不了的，为了避免这样的情况出现，可以用 （useradd -m +用户名）的方式创建，它会在/home目录下创建同名文件夹，然后利用（ passwd + 用户名）为指定的用户名设置密码。
>
> 可以直接利用adduser创建新用户（adduser +用户名）这样在/home目录下会自动创建同名文件夹
```

​	3.删除用户`userdel -r 用户名` (同时删除用户文件夹)

​	4.设置密码`passwd 用户名`

### 5.防火墙设置

```
> 保护服务器安全/设置规则/关闭防火墙
>
> 一般配置: (开放指定端口)
```

​	1.安装

​	`yum install firewalld`

​	2.启动

​	`service firewalld start`

​	3.检查状态

​	`service firewalld status`

​	4.关闭/禁用防火墙

​	`service firewalld stop/disable`

​	5.查看安装状态

​	`yum list | grep firewall`

​	6.查看服务状态

​	`ps -ef | grep firewall`

> firewall-cmd 操作

### 6.提权及文件传输

#### 1.提权: `sudo` 

​	`visudo `

```
- root账号登录: ssh root@192.168.1.xxx
- 打开权限文件: visudo
- 输入`/all`搜索后添加内容
	## Allows people in group wheel to run all commands
	# %wheel        ALL=(ALL)       ALL
	%naxx        ALL=(ALL)       ALL
- :wq保存退出,提权完成
```

#### 2.文件下载

​	`wget / curl ` 

```
wget https://www.baidu.com/     -存为index.html
curl -o baidu.html https://www.baidu.com/     -存为百度.html
```

#### 3.文件上传

​	linux系统:`scp ` 

```
- 以naxx账号的权限上传到/tmp目录:`scp test.txt naxx@192.168.1.xxx:/tmp/`
- 以naxx账号权限下载指定文件到本地:`scp naxx@192.168.1.xxx:/tmp/test.txt ./`
```

​	Windows:`lrzsz`

```
- 服务器安装`sudo yum install lrzsz`
- 上传文件 `rz`  (弹窗选择上传文件)
- 下载文件 `sz test.txt`  (弹窗选择本地保存路径)
```

## Apache

### 1.基本操作

安装: `yum install httpd`

启动: `service httpd start`

停止: `service httpd stop`

查看: `ps -ef | grep http`

端口: `sudo netstat -anpl | grep http`

### 2.文件目录

#### 1.配置虚拟主机

```
- /etc/httpd
- config文件中配置虚拟主机
- 搜索/virtual
	#virtual host being defined.
	<VirtualHost *:80>
		ServerName www.naxx.test
		DocumentRoot /data/www
		<Directory "/data/www/">
			Options Indexes FollowSymlinks
			AllowOverride None
			Require all granted
		</Directory>
	</VirtualHost>
- 重启服务 service httpd restart
```

```
修改host `vim /etc/host`
192.168.1.xxx www.naxx.test
```

> setenforce :  0-关闭selinux防火墙   1- 开启

#### 2.伪静态:

​	`mod_rewrite.so`

​	conf文件中添加: `LoadModule rewrite_module modules/mod_rewrite.so`

## Nginx

### 1.基本操作

- 安装  `yum install -y nginx`

  > 先添加资源库:
  >
  > `sudo rpm -Uvh http://nginx.org/packages/centos/7/noarch/RPMS/nginx-release-centos-7-0.el7.ngx.noarch.rpm`

- 启动  `service nginx start`

- 停止  `service nginx stop`

- 重载  `service nginx reload`  (无缝重启动)

  > 安装完毕后/etc/nginx

### 2.扩展

#### 1.虚拟主机

> 配置文件目录: /etc/nginx/conf.d/*.conf  (具体查看nginx.conf)
>
> cp default.conf.

```
server{
	listen 		 80;
	server_name  www.naxx.test;
	root   /usr/share/nginx/html;
	index  index.html index.htm;
}
```

> Apache和Nginx不能同时运行, 默认端口都是80端口

#### 2.多域名、多端口

```
server{
	listen 		80;
	listen      9988;
	server_name www.naxx.test www.naxxx.test;
	root  /data/www;
	index index.html index.htm;
}
```

#### 3.伪静态

```
server{
	listen 		80;
	server_name www.naxx.test;
	root  /data/www;
	index index.html index.htm;
	location / {
		rewrite ^(.*)\.htmp$ /index.html;
	}
}	
```

#### 4.日志格式化

> 格式设置在 nginx.conf文件中
>
> 默认日志文件目录 : /var/log/nginx/access.log
>
> 单虚拟主机配置单日志: access_naxx_log  /var/log/nginx/access.log  格式名;

```
http{
	log_format main 'xxx';
	log_format 添加新格式名 '格式参数';
	
	access_log /var/log/nginx/access.log 格式名;
}
```

#### 5.反向代理/负载均衡

1.原理

反向代理: 用户->Nginx服务器->真实资源服务器

负载均衡: 多服务器承载相同的请求

![1568001116845](/images/imgs/1568001116845.png)

2.配置

```
文件路径: conf.d/naxx.conf
upstream naxx_hosts{
	server xxx.xxx.xxx.xx1:80 weight=5; #(权重配置)
	server xxx.xxx.xxx.xx2:80 weight=1;
}
server{
	listen 		80;
	server_name www.naxx.test;
	root  /data/www;
	index index.html index.htm;
	location / {
		proxy_set_header Host www.ni9ne.net;
		proxy_pass http://naxx_hosts;
		
	}
}	
```

#### 6.调试技巧

单行调试功能

```
add_header Content-Type "text/plain;charset=utf-8";
return 200 "$http_host";
```

## MySQL

### 1.基本操作

​	安装: `yum install mysql-community-server`

​	启动: `service mysqld start/restart`

​	停止: `service mysql stop`

### 2.MySQL安装

```
-CentOS7默认安装mariadb数据库,先移除
	yum remove mariadb-libs.x86_64
-下载Mysql源
	https://dev.mysql.com/downloads/repo/yum/
-安装源
	yum localinstall mysql57-community-release-el7-8.noarch.rpm
-安装mysql服务
	yum install mysql-community-server
-默认密码
	cat /var/log/mysqld.log | grep "password"
-修改密码
	SET PASSWORD = PASSWORD('123123123');
```

> 下载 : `wget https://dev.mysql.com/get/mysql80-community-release-el7-3.noarch.rpm`

### 3.扩展知识

#### 1.远程连接

```
开启远程连接功能
mysql -h127.0.0.1 -uroot -p
xxxxxx
show databases; --查看数据库
use mysql;
show tables;  --查看表
select * from user \G;  --格式化显示表内容
updata user set host = '%' where Host = "localhost" and User = "root";  --修改权限
flush privileges; --刷新权限
--配置防火墙开启3306端口
```

#### 2.开启Genelog

> 记录所有的数据库操作日志文件

```
mysql> set global general_log_file="/tmp/geberal.log"; --设置保存位置
mysql> set global general_log=on; --打开配置
```

#### 3.新建用户和权限操作

**创建用户**

```
mysql> create user 'naxx'@'%' identified by '123123123';
```

> 密码策略改变(简单密码可用):
>
> mysql> set global validate_password_policy=0;
>
> mysql> set global validate_password_length=1;

**赋予权限**

```
mysql> grant all privileges on *.* to 'naxx'@'%' identified by '123123123' with grand option;
mysql> flush privileges;
```

> all privileges 代表所有权限, 可以使用'insert,select,update,delete'代替

**回收权限**

```
mysql> revoke all privileges on *.* from naxx;
mysql> flush privileges;
```

#### 4.忘记root密码

**跳过密码验证**

```
- vim /etc/my.cnf
	添加: skip-grant-tables
- service mysqld restart
- mysql> use mysql;
- mysql> update user set authentication_string = password('123123') where user = "root";
- mysql> flush privileges;
- 删除之前配置文件中添加的skip-grant-tables,登录
```

### 4.MySQL客户端工具

SQLyog / Navicat / HeidiSQL / S-equal Pro / phpMyadmin

## 缓存服务

### 1.memcached

#### 1.基本操作

- 安装: `yum install memcached`

- 启动: `memcached -d -l -m -p`

  > d:作为守护进程来运行
  >
  > m:分配给Memcached的内存
  >
  > l: Memcached监听的IP地址
  >
  > p:Memcached监听的端口
  >
  > u: 运行Memcached的用户
  >
  > memcached -d -m 10 -u root -l 192. 168. 1. 130 -p 11211

- 停止: `kill pid`

```
telnet简介
作用 - 判断端口是不是通畅 / 发送命令
安装 - yum install telnet.*
使用 - telnet 127.0.0.1 80
```

#### 2.常用命令

设置: `set naxx 0 60 5`

获取: `get naxx`

删除: `delete naxx`

退出: `quit`

### 2.redis

#### 1.基本操作

- 安装: `源码编译安装` 

  > `wget 下载网址`
  >
  > `tar -xzvf redis.tar.gz`
  >
  > `make`  (若gcc不存在, `yum install gcc`)
  >
  > `make MALLOC=libc`
  >
  > `make install`

  | 命令             | 简介                  |
  | ---------------- | --------------------- |
  | redis-server     | Redis服务器端启动程序 |
  | redis-cli        | Redis客户端操作工具   |
  | redis-benchmark  | Redis性能测试工具     |
  | redis-check-aof  | 数据修复工具          |
  | redis-check-dump | 检查导出工具          |

  **默认端口: 6379 ** 

- 启动: `redis-server start/restart` 

- 停止: `redis-server stop `

- 客户端: `redis-client `

#### 2.扩展知识

- redis支持多种类型的数据结构: list set hash string
- 支持数据备份, mster-slave模式的数据备份
- 数据持久化, 可以将内存中的数据保存在磁盘中, 重启的时候重载

#### 3.命令

设置: `set naxx hello`

获取: `get naxx`

删除: `del naxx`

> 需要使用telnet链接 , 在服务器端redis-cli界面输入: `CONFIG SET protected-mode no`, 即可
>
> `telnet 102.168.1.xxx 6379`

还支持**list** ,**hash** ,**set** 等多种格式数据]]></content>
      <categories>
        <category>开发资料</category>
      </categories>
      <tags>
        <tag>SSH</tag>
        <tag>Linux</tag>
        <tag>Apache</tag>
        <tag>Nginx</tag>
        <tag>Memcache</tag>
        <tag>Redis</tag>
      </tags>
  </entry>
  <entry>
    <title>Memcache存放SESSION</title>
    <url>/2018/09/07/Memcache%E5%AD%98%E6%94%BESESSION/</url>
    <content><![CDATA[
# Memcached

> 什么是Memcached?

- 免费并且开源，高性能的分布式内存对象缓存系统，通过减轻数据库负载来加速动态web应用程序的使用。
- 一种内存中的键值存储，用于从数据库调用、API调用或页面呈现的结果中获得少量任意数据(字符串、对象)
- PHP 的扩展(服务名)

> 优点

- 简单而强大
- 促进了快速部署，简化了开发
- 解决大型数据缓存面临的许多问题
- 它的API适用于大多数流行语言
- 支持 binary protocol 协议
- 支持对同一key的多进程的并发处理问题



> 安装

```
1. 安装phpize
	apt-get install php7.0-dev
2. 安装memcached&依赖
	apt-get install memcached
	apt-get install libmemcached11 libmemcached-dev libmemcachedutil2
3. 安装memcached拓展
	1. apt-cache search -n php7.0  # 查看 php7.-0 的软件包
	2. git clone https://github.com/php-memcached-dev/php-memcached.git	# 下载 memcached 到本地仓库，并切换到 php7 版本
	3. cd php-memcached/	# 进入memcached目录
	4. git checkout php7	# 切换分支
	5. phpize
	6. ./configure --disable-memcached-sasl 
	7. apt-get install pkg-config (如果第六步有报错执行该步骤在执行第六步,如果没有则直接跳过)
	8. make && make install	# 编译安装(编译安装完成后会返回 buil completed 提示信息以及你的扩展地址,记住该路径)
	9. vi /etc/php/7.0/fpm/conf.d/memcached.ini	#把扩展添加进php中
	10. extension=/usr/lib/php/20151012/memcached.so	#完成第9步之后写入该步骤的内容
	11. vi /etc/php/7.0/apache2/php.ini	# 把扩展添加进php中
	12. extension=/usr/lib/php/20151012/memcached.so	#完成第11步之后写入该步骤的内容(写入到差不多866行左右的位置)
	13. 重启Apache2 
	14. 访问phpinfo看是否有memcached拓展
```



# Memcache

> 什么是Memcache?

- 免费并且开源，高性能的分布式内存对象缓存系统，通过减轻数据库负载来加速动态web应用程序的使用。
- 一种内存中的键值存储，用于从数据库调用、API调用或页面呈现的结果中获得少量任意数据(字符串、对象)
- PHP 的扩展(服务名)

> 优点

- 简单而强大
- 促进了快速部署，简化了开发
- 解决大型数据缓存面临的许多问题
- 它的API适用于大多数流行语言
- 支持对同一key的多进程的并发处理问题



> 安装

```
1. 安装phpize(如果已经安可直接跳过)
	apt-get install php7.0-dev
2. 安装memcache
	1. git clone https://github.com/websupport-sk/pecl-memcache memcache	# # 下载 memcached 到本地
	2. cd memcache	# 进入memcache目录
	3. phpize
	4. whereis php-config    # 查找php-config目录
		php-config: /usr/bin/php-config /usr/share/man/man1/php-config.1.gz
		
	5. ./configure --enable-memcache --with-php-config=/usr/bin/php-config --with-zlib-dir	# 编译
	6. make && make install		# 编译安装(编译安装完成后会返回 buil completed 提示信息以及你的扩展地址,记住该路径)
	7. vi /etc/php/7.0/apache2/php.ini	# 把扩展添加进php中
	8. extension=/usr/lib/php/20151012/memcached.so	#完成第7步之后写入该步骤的内容(写入到差不多866行左右的位置)
	9. 重启Apache2 
	10. 访问phpinfo看是否有memcached拓展
```





# Memcache存放SESSION

> 1. 修改php.ini配置文件

```
1. vi /etc/php/7.0/apache2/php.ini	# 打开php.ini配置文件
2. 找到session.save_handler，并设为 session.save_handler = memcache，把session.save_path前面的分号去掉，并设置为 session.save_path = “tcp://127.0.0.1:11211″
3. 重启服务sudo service apache2 restart
```



> 2. .htaccess

```
php_value session.save_handler “memcache”
php_value session.save_path “tcp://127.0.0.1:11211″
```



> 3. 临时生效

```
ini_set(“session.save_handler”, “memcache”);
ini_set(“session.save_path”, “tcp://127.0.0.1:11211″);
```

]]></content>
      <categories>
        <category>开发资料</category>
      </categories>
      <tags>
        <tag>Memcache</tag>
      </tags>
  </entry>
  <entry>
    <title>Memcache</title>
    <url>/2018/09/05/Memcache/</url>
    <content><![CDATA[
### 1.背景:

随着计算机性能的发展 , 内存空间的加大 , 原本被存储在硬盘中的数据库数据可以被存入读取速度更快的内存当中

管理服务器数据存入内存的软件--->memcache

### 2.流程

安装--->启动(memcached)--->链接(port:11211)---->发送命令(get/set)

存储格式:hash键值对

key(键)		value(值)		length		time(存活时间)

注: memcache重启,内存中数据也就消失.

​	使用内存较多 , CPU使用少 , 与Apache相反 

使用:缓存sql语句 , 会话控制机制

### 3.安装

Windows 32x 64x

Linux

### 4.启动

Windows:

常用参数:

 `-p<num>` 	设置链接端口号(默认不设置为11211)

`-U<num>`		UDP监听端口(默认11211,0时关闭)

`-l<ip_address>` 	绑定地址(默认无论内外网或本地ip都允许,有安全隐患,若设置为127.0.0.1就只能本机访问)

`-d` 	独立进程运行

- `-d start` 	启动memcached服务
- `-d restart`    重启memcached服务
- `-d stop|shutdown`    关闭正在运行的memcached服务
- `-d install`    安装memcached服务
- `-d uninstall`    卸载memcached服务

`-u <username>`     绑定使用指定用户运行进程

`-m <num>`    允许最大内存使用量 , 单位M (默认为64M)

`-P <file>`    将PID写入文件`<file>`,配合 `-d` 一起使用

`-M`     内存耗尽时返回错误 , 而不是删除项

`-c`     最大同时连接数 , 默认是1024

`-f`    块大小增长因子 , 默认是1.25

`-n`    最小分配空间 , key+value+flags默认是48

`-h`    显示帮助

```
#/usr/local/memcached/bin/memcached -d -m 256 -p 11211 -u www -l 127.0.0.1
#/usr/local/memcached/bin/memcached -d -m 1024 -p 11211 -u root -c 1000
```

### 5.基础常用命令(客户端)

--`stats` : 当前所有memcached服务器运行的状态信息

--`add` : 添加一个数据到服务器

--`set` : 替换一个已经存在的数据 , 如果数据不存在 , 则和add命令相同

--`get` : 从服务器端提取指定的数据

--`delete` : 删除指定的单个数据 , 如果要清除所有的数据 , 请使用`flush_all`指令

- 客户端链接直接操作memcached

  `telnet localhost 11211`

- 添加数据

  `add 键名(key) 标志(flag) 存活时间(time) 长度(length) `

  `输出数据(长度与设定长度相同)`

  eg: `add name x1 30 5       回车换行        tomey`

  注 : 时间设为0永久存在

- 删除所有数据

  `flush_all`

- `stats`     得到memcached 的运行状态

- `stats items`    显示各 item 的数目和最老 item 的年龄

- `stats cachedump 2(item后数字) n(0-得到全部)` 展示某个slab中的前n个key列表

### 6.PHP操作

 	memcache 函数库(基于php开发)(面向对象和面向过程)

​	`memcache_add()  或者   memcache_obj->add()`

​	memcached 函数库(基于c++开发)(只有面向对象使用)

> 安装memcache 和memcached扩展: ....

```
	<?php
		// 创建一个memcache对象
		$mem = new Memcache;
		
		// 链接memcache服务器
		$mem->connect('127.0.0.1',11211);
		
		// 操作(增删改查)
		//add添加
		$mem->add('one','test code string',MEMCACHE_COMPRESSED,60*60*24*7);
				#时间不能设置超过30天,否则会变成时间戳格式,推荐使用time()+秒数
				#设置为0则永久存在
		$mem->add('two',array('111','222','333'),MEMCACHE_COMPRESSED,0)
				#数组/对象会在memcache中以序列化的方式存在
		
		//set设置(==replace覆盖)
		$mem->set('one','demo',MEMCACHE_COMPRESSED,0);
		
		//get取值(存进去是什么类型数据,取出来还是什么类型)
		var_dump($mem->get('one'));
		var_dump($mem->get(array('one','two')));
		
		//delete删除
		$mem->delete('one');
		$mem->delete('two',10);  #10秒后删除,0为立即删除
		
		//flush删库
		$mem->flush();
		
		// 关闭链接
		$mem->close();
	
	?>
```

其他常用函数:

​	自增: increment(key [, num]);

​	查看状态: getStats(type);

### 7.分布式配置

​	多服务器机器利用哈希算法共同分担压力 , 共同提供数据库服务

​	addServer('主机名',端口号,[持久链接],[权重],[超时时间],[重试间隔])

​	`$mem->addServer('192.168.14.112',11211)` 

### 8.安全防护

1. 内网访问

   `memcached -d -m 1024 -u root -l 192.168.xx.xx(内网ip) -p 11211 -c 1024 start`

2. 设置防火墙

   ```
   指定访问类型
   iptables -F
   iptables -P INPUT DROP
   iptables -A INPUT -p tcp -s 192.168.xx.xx --dport 11211 -j ACCEPT
   iptables -A INPUT -p udp -s 192.168.xx.xx --dport 11211 -j ACCEPT
   ```

​	

### 9.实际使用memcache读取数据

​	多用户大批量访问下 , 重复读取数据 , 服务器压力太大 , 使用memcache在查询时 , 缓存一份 , 以后的查询可以从memcache缓存中获取 , 当数据有变化时在更新缓存内容 , 以减轻负载压力

```
<?php 

    // 创建memcache对象
    $mem = new Memcache;

    // 连接memcache数据库
    $mem->addServer('192.168.14.48','11211');
    $mem->addServer('192.168.14.49','11211');

    // 设置sql语句和mem缓存的键
    $sql = 'select id,name,sex,age,email from users order by id';
    $key = md5($sql);

    //从mem内存中获取数据
    $data = $mem->get($key);

    //数据库操作
    if (empty($data)) {
        //链接
        try {
            $pdo = new PDO('mysql:host=localhost;dbname=test','root','123456');
        } catch (Exception $e) {
            echo '数据库链接失败:'.$e->getMessage();
        }
        // 获取数据 , 执行查询语句
        $PDOstatement = $pdo->prepare($sql);

        $PDOstatement->exec();

        $data = $PDOstatement->fetchAll(PDO::FETCH_ASSOC);

        //将查询到的数据存入mem缓存
        $mem->set($key,$data,MEMCACHE_COMPRESSED,10);
    }

    print_r($data);

    // 关闭链接
    $mem->close();

 ?>
```

]]></content>
      <categories>
        <category>学习笔记</category>
      </categories>
      <tags>
        <tag>Memcache</tag>
      </tags>
  </entry>
  <entry>
    <title>MySQL 基础操作-增删改查</title>
    <url>/2018/04/05/MySQL%20%E5%9F%BA%E7%A1%80%E6%93%8D%E4%BD%9C-%E5%A2%9E%E5%88%A0%E6%94%B9%E6%9F%A5/</url>
    <content><![CDATA[
## 1.数据库

### 1.数据库基本操作

常见数据库包括：**MySQL**，Oracle，SQL server，Redis ...

1.定义

​	存储数据的仓库，即按照数据结构来组织，存储和管理数据的仓库

> 选择 MySQL 的原因有：免费，开源，跨平台，支持事务...

2.链接数据库的步骤

​	开启服务器——>设置主机IP——>用户名（默认root）——>密码（默认为空）

3.组成

​	一个完整的数据库由库（database），表（table）和数据（data）组成，先有库，再有表，最后才有数据的增删改查，也就是说先使用库，才能使用表

4.基本语法

​	MySQL 的每一条数据都是以分号( ; ) 作为结束符

5.常用SQL命令

​	打开命令窗口：	F6

​	使用数据库：	`use 库名;` 

​	创建数据库：	`create database [if not exists] 库名 default charset 编码方式;`  

​	删除数据库：	`drop database 库名;` 

​	查询数据库结构：	`show databases;`	注意：database需要加s，作为复数格式

​	查询数据表：	`show tables;` 	注意：在使用库之前，无法使用表

​	创建数据表：	

```
		create table if not exists 库名(
		
		字段名		字段类型		字段属性,
		字段名		字段类型		字段属性,
		字段名		字段类型		字段属性,
			...
		字段名		字段类型		字段属性,
		字段名		字段类型		字段属性
        
		)engine=myisam|innodb default charset=utf8;
```

​			**注意：每一组之间用逗号( , ) 隔开，最后一组字段不用加**

​	删除数据表：	`drop table 表名；` 

​	查看表结构：	`desc 表名；` 

​	查看建表语句：	`show create table 表名` 

​	注意：所有的库名，表名，字段名都需要加上反引号( ` )，所有的字符串需要加上单双引号

​		   反引号可以将库名，表名，字段名实体化，取消特殊意义





### 2.数据库数据操作

#### 1.插入数据（增）

1. ##### 插入单条数据：

   格式：

    `insert into 表名 values(值1，值2，值3，...);` 	

   注意点：

   ​	主键由于配合自增属性，所以不用主动设置，默认用`null`代替，值会自动根据最大记录+1；

   ​	如果有默认值，可以用`default`代替

2. ##### 插入单条数据部分字段：

   格式：

    `insert into 表名（字段1，字段2，字段3，....） vaules(值1，值2，值3，...);` 

   注意：

   ​	表名后面填了多少个字段，values就对应填多少个值；

   ​	如果字段具有not null属性，那么必须填写‘’

   使用场合：用户注册，不需要填写所有数据表单

3. ##### 插入多条数据：

   格式：

    `insert into 表名 values(...),(...),(...), ... (...);` 

4. ##### 插入多条数据部分字段

   格式：

    `insert into 表名（字段1，字段2，...）values(...),(...),(...), ... (...);`

#### 2.更新数据（改）

1. ##### 更新所有数据

   格式：

    `update 表名 set 字段1=值1，字段2=值2，...;` 

2. ##### 条件更新

   格式：

    `update 表名 set 字段1=值1，字段2=值2，... where 条件表达式` 

#### 3.删除数据（删）

1. ##### 全部删除

   格式：

   ​	 `delete from 表名；`

   注意：该删除方式只会删除数据，不会删除曾经的数据记录

2. ##### 全部删除（不留记录）

   格式：

   ​	 `truncate table 表名；` 

   注意：该删除方式会连着数据和记录一起删除，如果想清空表，推荐使用truncate

3. ##### 部分删除

   格式：

   ​	 `delete from 表名 where 条件表达式；` 

4. ##### 排序删除

   格式：

   ​	 `delete from 表名 [where 条件表达式] order by 字段 asc|desc limit 行数` 

   注意： `asc`为升序排序，`desc`为降序排序

### 3.函数

#### 1.聚合函数

- 统计总个数：count( )

  `select count(id) from user;`		统计user表中一共有几个id

- 求和：sum( )

  `select sum(age) from user;` 		统计user表中age的综合

- 求平均值：avg( )

  `select avg(age) from user;` 		统计user表中的平均年龄

- 求最大值：max( )

  `select max(age) from user;` 		获取user表中的最大年龄

- 求最小值：min( )

  `select min(age) from user;` 		获取user表中的最小年龄 

#### 2.字符串拼接函数

​	格式：`concat(s1,s2,s3,...)`

​	注意：s1,s2,s3可以代表字段名，也可以代表字符串值

​	`select concat(id,'......',nickname,'......',address) from user;` 

#### 3.数据库版本

​	`select version();`

#### 4.当前时间

​	`select now();`  

#### 5.md5加密

​	`md5('1234234');` 

#### 6.当前时间戳

​	`select unix_timestamp();` 

### 4.查询数据

#### 1.整体结构

```
	select  * | distinct | 字段名 | 字段名 as 别名 | 表名.字段名
	from    表名 | 表名1，表名2，...
	where   条件表达式
	group by 字段
	having 条件
	order by 条件
	limit 下标，行数
```

> 注意：以上为查询数据的基本结构，先后书序无法颠倒，但可以省略其中一部分

#### 2.具体查询

- 查询1：查询该表中的所有数据

  格式： `select * from 表名；` 		

  实例： `select * from user;` 

  **注意**： `*` 通配符代表所有的字段，查询所有的字段，推荐少用或不用

- 查询2：查询该表中的指定字段

  格式： `select 字段1，字段2，字段3，... from 表名；` 

  实例：`select tel pwd from user;` 

- 查询3：带条件查询

  格式：`select *|字段名 from 表名 where 条件；` 

  - `<` 查询所有未成年的名字

    `select name from user where age<18;` 

  - `>=`  查询所有成年的名字

    `select name from user where age>=18;` 

  - `=`  精确查询刚好18岁的名单

    `select name from user where age=18;`  

  - `!=`  查询所有不是18岁的名单

    `select name from user where age!=18;` 

  - `between A and B`  查询年龄在15到30之间的名单

    `select name from user where age between 15 and 30;` 

  - `not between A and B`  查询年龄不在20~30岁之间的名单

    `select name from user where age not between 20 and 30;` 

  - `like` 模糊查询 名字带有’小‘的名单

    `select name like "小"；` 

    `select name like "%小%";` 

    **注意**：`%` 通配符可匹配0个，1个或多个字符；

    ​	    `_` 通配符可以匹配一个字符

  - `in` 查询来自于召唤师峡谷的名单

    `select name,address from user where address in ('召唤师峡谷');` 

  - `not in` 查询地址信息不为空的名单

    `select name,address from user where address not in ('null');` 

  ------

  - 逻辑：与 `and`  |  或 `or` 

    - 查询 来自于召唤师峡谷的女孩子

      `select name,address,sex from user where address='召唤师峡谷' and sex=2;`  

    - 查询女孩子或者来自于xxx楼的名单

      `select name,address,sex from user where address like "%楼" or sex=2;`  

  - 空与非空： `is null ` 和 `is not null` 

    - 查询有住址的名单

      `select name from user where address is not null;` 

    - 查询住址信息为空的名单

      `select name from user where address id null;` 

  - `group by` 分组 :

    查询user中名单分别来自哪些地方

     `select address from user group by address;` 

    **注意**：一旦分组，就不能查询单一数据，必须按照“组”为单位来查询

  - `having` 筛选：

    筛选人数多于一个的地址

    `select address,count(id) from user group by address having count(id)>1;` 

    **注意**：`having`一般都是配合`group by`来使用，先分组再筛选

  - `order by` 排序

    按照生日从大到小查看名单

    `select nickname,birthday from user order by birthday desc;` 

    **注意**：`desc`为降序排序，`asc`为升序排序

  - `limit` 前几个

    查询user表单中的前3个人信息

     `select * from user limit 3;` 

    **注意**：标准格式为：`limit 下标，行数`,代表从下标开始的几行数据

### 5.多表查询

> 多张表同时查询

#### 1.条件限制：

​	多张表之间必须要求有联系

​	多表有相同字段时，必须声明是哪张表中的字段（表名.字段名）

​	n张表之间的联系至少有 n-1 条

#### 2.格式：

```
	select 字段
	from 表名1，表名2，表名3，...
	where 表名1.字段1 = 表名2.字段1 ...
	...
```

#### 3.实例：

​	查询每个人的昵称，住址，部门，薪资

```
	select uid,nickname,address,dep,money
	from user,salary
	where user.id=salary.uid
```

### 6.嵌套查询

> 将一条sql语句的结果作为另一条sql的条件来使用

实例

​	查询每个部门最高工资的uid

```
	select uid,money,dep
	from salary
	where money in ( select max(money) from salary group by dep )

```

### 7.多表+嵌套

​	查询每个部门最高工资的uid

```
	select uid,s.money,s.dep
	from salary as s,(
		select dep,max(money) as money 
		from salary 
		group by dep ) as t
	where s.dep=t.dep and s.money=t.money

```

### 8.别名

​	给字段，表名取个别名 `as` 

​	`select dep,max(monry) as money from salary as s group bu dep;` 

### 9.取消重复

​	`select distinct address from user;`

]]></content>
      <categories>
        <category>学习笔记</category>
      </categories>
      <tags>
        <tag>MySQL</tag>
        <tag>数据库</tag>
      </tags>
  </entry>
  <entry>
    <title>MySQL- 事务操作</title>
    <url>/2018/05/15/MySQL-%20%E4%BA%8B%E5%8A%A1%E6%93%8D%E4%BD%9C/</url>
    <content><![CDATA[### 事务操作

```

	
	// 事务: 将 多条sql语句绑定为一个整体, 其中有任意一条sql 失败, 则整体失败.
	// 	
	// 	MyISAM 不支持事务 

	// 	InnoDB 支持事务


	// 自动提交:
	// 	默认情况下, sql一旦执行, 就会立马改变sql的状态
	// 	关闭自动提交, sql一旦执行, 能得到sql的状态结果, 但是sql不会真正的改变

	
	try {
		$pdo = new PDO('mysql:host=localhost;dbname=s86;charset=utf8','root','pass');
	} catch (Exception $e) {
		echo '数据库链接失败'; die;
	}


	// 事务操作步骤

	try {
		// 1. 关闭自动提交
			$pdo->setAttribute(PDO::ATTR_AUTOCOMMIT, 0);

		// 2. 开启一个事务 (游戏中的存档)
			$pdo->beginTransaction();

		// 3. 执行sql
			# 1) 扣钱  -10W 
			$sql = "UPDATE `salary` SET  `money`=`money`-100000 WHERE `uid` = 5 ";
			$rows = $pdo->exec($sql);
			if($rows < 1){
				throw new Exception('工资转出失败');
			}

			# 2) 加钱  +10W
			$sql = "UPDATE `salary` SET  `money`=`money`+100000 WHERE `uid` = 4 ";
			$rows = $pdo->exec($sql);
			if($rows < 1){
				throw new Exception('工资转入失败');
			}


		// 4. 执行成功, 提交事务, 真正的改变sql状态
			$pdo->commit();

	} catch (Exception $e) {
		// 4. 执行失败,  回滚事务, 回到开始事务时的sql状态
		echo $e->getMessage();
		$pdo->rollBack();  # 读档
	}
	

	// 5. 开启自动提交
	$pdo->setAttribute(PDO::ATTR_AUTOCOMMIT, 1);




```

]]></content>
      <categories>
        <category>学习笔记</category>
      </categories>
      <tags>
        <tag>PHP</tag>
        <tag>后端 - MySQL</tag>
      </tags>
  </entry>
  <entry>
    <title>PHP 基础01- 数据类型</title>
    <url>/2017/11/21/PHP%20%E5%9F%BA%E7%A1%8001-%20%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/</url>
    <content><![CDATA[
# 1.PHP

**PHP特性**：

1.PHP文件或者文件夹命名中不能有中文，不能有中文路径。

2.PHP文件存放位置：`wamp/www/`目录下。

3.访问PHP脚本的步骤：

​	开启wamp服务——>在浏览器地址栏中输入：`localhost`

4.**PHP是什么**：（`Professional Hypertext Preprocessor`）超文本预处理器

**一句话**：**一种用来开发动态网站的服务器脚本语言**。

5.**PHP定界符**

​	格式：`<?php       PHP代码         ?>`

​	只有在定界符内的代码才会被PHP解析

6.向浏览器输出一句话：`echo 'hello,world!';`

7.**PHP设置编码**（一般情况下，该编码声明写在文件头部）

​	`header('content-type:text/html;charset="utf-8"');`

8.**注释**

单行注释：`#注释内容`	or	`//注释内容`

多行注释：`/*注释内容*/`

9.**PHP基本语法**

- 每一条命令均以分号（；）结尾，代表这条命令已经结束。
- 只有最后一条可以不加，但推荐都加上。

10.查询PHP相关信息

​	`phpinfo();`

11.若只想输出一句话，可以使用如下格式：

​	`<?='hello,world!'?>`

​	`<?php echo 'hello,world!'?>`

## 2.变量var

1.**变量**，即未知数（variable）,主要是负责指向（引用）一个值，值不是固定的。

​		`$a=10;`

2.**格式**：$变量名=值；

> 值必须给定，不给会报错，称之为“未定义变量”

3.**变量命名**

- 右数字，字母和下划线组成；
- 不能以数字开头；
- 变量严格区分大小写；
- 支持中文，但不推荐

4.**变量技巧**

1）可变变量：将一个变量的值作为另一个变量的名字来使用

```
	$山鸡 = '陈小春';
	$陈小春 = '应采儿';

	echo $陈小春;		#输出应采儿
	echo $$山鸡;		#输出应采儿
```

引用变量名为另一个变量值的变量值，可以使用两个$直接引用

2）**传值**：将一个变量的值赋予另一个变量

```
	$a=10;
	$b=$a;				
	$b=5;
	echo $a;			#输出10
	echo $b;			#输出5
```

3）**传址**：将一个变量的内存地址赋予另一个变量

```
	$a=10;
	$b=&$a;				
	$b=5;
	echo $a;		#输出5
	echo $b;		#输出5
```

## 3.数据类型

PHP中的数据类型包括：

**标量类型**：	

- 整型	`Int`
- 浮点型       ` Float`
- 布尔型       ` Bool`
- 字符型       ` String`

**复合类型**：

- 数组	`array`
- 对象       `object`

**特殊类型**：

- 资源         `resource`
- 空类型        ` NULL`

## 4.整型int

1.**最大整型**：`PHP_INT_MAX`

> 最大整型就是php中数据显示为整型的最大值，为2的31次方
>
> 若某个值比PHP_INT_MAX还大，则自动转为float型

2.**检测是否为整型**：`is_int();`

> 输出值为bool值

3.**进制**

|          | 基数 |  前缀  |
| :------: | :--: | :----: |
|  二进制  | 0/1  |   0b   |
|  八进制  | 0~7  |   0    |
|  十进制  | 0~9  | 无前缀 |
| 十六进制 | 0~f  |   0x   |

4.**计算方法**：

1）任何进制转为十进制：

次方求和法：∑（基数*进制^次方）

2）十进制转化为其他进制：

除基数取余法：当商比任意进制基数还小时，停止除法运算；将余数倒排序，即得到结果。

> 快捷方法：
>
> 2048 1024 512 256    128 64 32 16    8 4 2 1

## 5.浮点型 float

1.**科学计数法**：

```
	$num=2e3;
	var_dump($num);			#输出为浮点型
```

如果使用科学计数法，则默认该值为浮点型数据

2.**判断是否为浮点型数据**：`is_float();`

3.**精度**：

浮点型数据在php显示结果中只显示14位有效数字，故在浮点运算中，结果并不精确，浮点型数据不适合做二进制计算，同时也尽量不要用小数做等值判断，防止数值误差产生，得到错误结果

```
	$a=0.1+0.2;
	var_dump($a);
	if($a==0.3){
		echo 'true';
	}else{
		echo 'false';	#运算结果为false
	}

	if($a>0.3){
		echo 'true';
	}else{
		echo 'false';	#运算结果为true
	}
```

## 6.布尔型 bool/boolean

1.**值**：false 	true

2.**作用**：代表两种极端状态，常用与判断比较等

3.**判断数据是否属于bool值**：`is_bool();`

4，**等价判断**：以下7种情况与false等价

- false
- 0
- 0.0
- ''   or    '0'
- NULL空类型
- 空数组
- 未定义变量

## 7.字符串string

1.**作用**：

用于存储or表达信息，包含数字，字母，标点，汉字等

2.**格式**：

- 小段内容：单双引号

  ```
  	$a='dead man may never die';
  	$b='winter is coming';
  	var_dump($a);
  	var_dump($b);
  ```

- 大段内容：heredoc结构

  ```
  	$c=<<<xxx
  曾经跟媳妇吵架, 吵到最激烈的时候, 我就想: 一个大老爷们跟老娘们较什么劲. 当时就跟媳妇道歉了,媳妇挺开心的... 他哥就放下菜刀, 他妹松开了拽着我头发的手, 老丈人拿起了电话: 棺材退了吧. 夫妻之间只要多沟通, 生活还是很和谐.
  xxx;
  	var_dump($c);
  ```

  **注意**：

  1）xxx可以替换成任意其他结构次（自制）

  2）保证首尾一致

  3）开始结构词的后面不能有任何多余的字符（包括空格）

  4）结尾结构词的前后不能有任何多余的字符（包括空格）

3.**检测类型**：

- 是否为字符串：`is_string();`
- 是否为数字或数字字符串：`is_numaric();`
- 是否为标量类型：`is_scalar();`

4.**单双引号的区别**

- 单引号：不能识别变量，执行速度快；但不能识别解析转义字符，
- 双引号：可以识别变量，执行速度较慢；可以识别解析转义字符。

> 转义字符：\
>
> 能够给普通字母赋予特殊意义，也可以把特殊意义的字符变成普通字符输出。

**常见转义字符**：

| `\n` |   换行    |
| :--: | :-------: |
| `\r` |   回车    |
| `\t` | 制表符Tab |
| `\'` |    `'`    |
| `\"` |    `"`    |
| `\$` |    `$`    |



## 8.数组 Array

1.**简述**：键值对；

2.**定义**：数据的集合；

3.**格式**：`$数组名[]=数组值` 或者 `$数组名=[值1，值2，值3，...]`

4.**显示格式**：

```
							显示：	array (size=7)
	$bag[]='三国演义';				0 => string '三国演义' (length=12)
	$bag[]='水浒传';				 1 => string '水浒传' (length=9)
	$bag[]='红楼梦';				 2 => string '红楼梦' (length=9)
	$bag[]='西游记';				 3 => string '西游记' (length=9)
	$bag[]='10000';				   4 => string '10000' (length=5)
	$bag[]=NULL;				   5 => null
	$bag[]=1000;				   6 => int 1000
	var_dump($bag);
```

5.**数组操作**：

- 查询数组中的一个值：通过键来查询；      `var_dump($bag[2];)`
- 修改数组中的某个值：通过已经存在的键来修改；     `$bag[1]='菜根谭'；`
- 新增数组中的某个值：通过不存在的键来新增；     `$bag[9]='说文解字’；`
- 删除数组中的某个值：通过键来操作（**unset**）；       `unset($bag[1]);`

## 9.空类型 Null

**1.定义**：null代表什么都没有，常用于先占据内存，供后期使用；

2.以下三种情况，直接显示null：

- 直接赋值null		`$a=null;`

- 未定义变量		`var_dump(@$b);`

  > @为错误抑制符，可以临时屏蔽$b的错误；

- 被删除的变量               `unset($c);`

**注意：只要与false等价，基本都与null等价**

## 10.对象 Object 

1.**对象**：在PHP中，一切皆对象

​	获取一个对象:

```
$a=new stdClass;		
var_dump($a);		#显示：object(stdClass)[1]
```

## 11 资源 Resource

2.**资源**：所有的文件都是资源

​	获取一个资源：

```
$b=fopen('./ex.html');		
var_dump($b);		#显示：resource(3, stream)

```

]]></content>
      <categories>
        <category>学习笔记</category>
      </categories>
      <tags>
        <tag>PHP</tag>
        <tag>后端</tag>
      </tags>
  </entry>
  <entry>
    <title>PHP 简介02-数据类型转化</title>
    <url>/2017/12/04/PHP%20%E5%9F%BA%E7%A1%8002-%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E8%BD%AC%E5%8C%96/</url>
    <content><![CDATA[
## 1.几个常用函数

1.释放内存：`unset（）；`

2.检测一个变量是否为空：`empty();`

> 实质上为检测是否与false等价		空=true		非空=false

3.检测一个变量是否设置：`isset();`

> 实际上为检测是否为null或未定义变量		已设置：true		未设置：false

```
	$a=10;		#未空，已设置
	$a=0;		#空，已设置
	$a=0.0;		#空，已设置
	$a=false;	#空，已设置
	$a=[];		#空，已设置
	$a='0';		#空，已设置
	$a=null;	#空，未设置
	$a=$b;		#空，未设置
	$a=$obj;	#未空，已设置
	$a=$resource;	#非空，已设置

```

## 2. 输出方式

PHP中常用输出方式常见的有4种：

1.**echo**

​	为PHP基本语法，支持int，float，string，resource类型的数据输出

​	格式：`echo '输出内容'；`

2.**print / print（）**

​	print为基本语法结构，print（）为函数，返回值为int

​	支持int，float，string，resource类型的数据输出

​	格式：`print 输出内容`		`print（输出内容）；`

3.**print_r（）**

​	print_r（） 为函数，返回值为bool

​	支持int，float，string，array，resource，object类型的数据输出

4.**var_dump（）**

​	var_dump（）为函数，无返回值。可以支持任何类型的数据

> print_r() 和 var_dump() 的区别：
>
> print_r() 理论上可以输出无数个数据，但实际上受到内存大小的限制
>
> var_dump() 最多只能输出128条数据，其他的隐藏

**print_r() 的美化：**

```
	print_r('<pre>');
	print_r($arr);
	print_r('</pre>');

```

## 3. 数据类型转化 DateType

运算本质是同类型的数据之间的运算

标量数据的转换分为两种：自动类型转换 和 强制类型转换

### **1.自动类型转换**：隐式转换

- 布尔型（bool）转为整型（int）

  ```
  var_dump(true+10);			#11			true->1
  var_dump(false+10);			#10			false->0
  
  ```

  

- 布尔型（bool）转为浮点型（float）

  ```
  var_dump(true+10.5);	#11.5	true->1.0
  var_dump(false+10.5);	#10.5	false->0.0
  
  ```

  

- 字符串（string）转为整型（int）

  ```
  	var_dump('abc'+10);			#10
  	var_dump('123'+10);			#133
  	var_dump('1a2b'+10);		#11
  	var_dump('a1b3'+10);		#10
  	var_dump('12av'+10);		#22
  
  ```

  - 从前往后，保留前面的数字，从第一个非数字开始向后全部抛弃（包括后面的数字）

- 字符串（string）转为浮点型（float）

  ```
  	var_dump( '1.2' + 10.5 );			#11.7
  	var_dump( '1a.2' + 10.5 );			#11.5
  	var_dump( 'a1.2' + 10.5 );			#10.5
  	
  	var_dump( '1.2e3' + 10.5 );			#1210.5
  	var_dump( '1.2e3e4' + 10.5 );		#1210.5
  	var_dump( '1.2.3.4' + 10.5 );		#11.7
  
  
  ```

  - 从前往后，保留前面的数字，从第一个非数字开始向后全部抛弃（包括后面的数字）
  - 识别第一个科学计数法和第一个小数点

- 整型（int）转为浮点型（float）

  ```
   	var_dump( 1 + 2.5 ); 		# 3.5 		1 -> 1.0
  
  
  ```

### **2.强制类型转换**：强制转换

- **临时转换**

  - **通过运算符来强制转换**（值适用于标量和复合数据，不包含特殊类型的数据）

    ```
    	var_dump((int)$str);
    	var_dump((float)$str);
    	var_dump((bool)$str);
    	var_dump((string)$str);
    	var_dump((object)$str);
    	var_dump((array)$str);
    
    
    ```

  - **通过函数来强制转换**

    ```
    	var_dump(intval($str));
    	var_dump(floatval($str));
    	var_dump(boolval($str));
    	var_dump(strval($str));			#字符串转化是strval，而不是stringval
    
    
    ```

- **永久转换**

  通过函数   `settype(变量名，类型)`   来永久转换数据，之后数据不一定能转换回原数据

  ```
  		settype($str,'int');
  		var_dump($str);
  
  		settype($str,'string');
  		var_dump($str);
  
  
  ```

## 4. 常量 Define

**1.常量**：经常固定不变的量（constant）

**2.格式**：`格式：const 常量名=常量值；`	或者      `define(常量名，常量值)`

```
		const CHINA = '中国';			
		var_dump( CHINA );
		
		define('NUME',1000);
		var_dump(NUME);


```

**注意**：

​	常量名默认区分大小写，推荐使用大写，与变量区分；

​	define函数的完整格式为`define（常量名，常量值，bool值）`，其中总bool值默认值为`false`，代表区分大小写，若为`true`则不区分大小写；

**3.魔术常量**：

​	`__FILE__`  当前文件路径

​	`__LINE__`  当前代码行号

​	`__DIR__`    当前文件目录

```
		var_dump(__FILE__);		#:string 'D:\wamp\www\XIA\0409\08-define.php' (length=34)	
		var_dump(__LINE__);		#:int 39
		var_dump(__DIR__);		#:string 'D:\wamp\www\XIA\0409' (length=20)


```

**4.预定义常量**：

​	`PHP_INT_MAX`	显示最大整型常量

​	`PHP_INT_MIN`	显示最小整型常量

​	`M_PI`		      圆周率

​	`PHP_VERSION`	显示当前PHP版本号

​	`PHP_OS`		   显示当前使用操作系统（Windows都显示WINNT）

```
	var_dump(PHP_INT_MAX)；			#:int 2147483647
	var_dump(PHP_INT_MIN)；			#:int -2147483648
	var_dump(M_PI)；					#:float 3.1415926535898
	var_dump(PHP_VERSION)；			#:string '7.0.4' (length=5)
	var_dump(PHP_OS);				 #:string 'WINNT' (length=5)


```

## 5. 运算符  Operation

PHP中运算符主要有以下**七种**：

- 算术运算符
- 自增/自减运算符
- 赋值运算符
- 比较运算符
- 拼接运算符
- 逻辑运算符
- 三元运算符

1.**算术运算符**：

​	`加	        减	乘	除	取模（取余）`

​	`+ 	      -	         *	  /	       %`

​	**取模（%）详解**：

​	1)**普通取模**：

```
	var_dump(5%2);		#1
	var_dump(1%2);		#1
	var_dump(2%2);		#0


```

​	2)**高阶取模**

​		①**取模的正负**：取决于被除数的正负

```
		var_dump(5%2);		#1
		var_dump(5%-2);		#1
		var_dump(-5%2);		#-1
		var_dump(-5%-2);	#-1


```

​		

​		②**取模结果的范围：x~y**

```
	     var_dump(0%3);		#0				# %3
	   	 var_dump(1%3);		#1
	   	 var_dump(2%3);		#2
	   	 var_dump(3%3);		#0
	   	 var_dump(4%3);		#1
    	 var_dump(5%3);		#2
	   	 var_dump(6%3);		#0
    	 var_dump(7%3);		#1				# %3的结果永远在0~2之间，都小于3


```

​    	   

```
	     var_dump(0%5);		#0				# %5
	   	 var_dump(1%5);		#1
	   	 var_dump(2%5);		#2
	   	 var_dump(3%5);		#3
	   	 var_dump(4%5);		#4
	   	 var_dump(5%5);		#0
	   	 var_dump(6%5);		#1
	   	 var_dump(7%5);		#2				# %x的结果永远在0~x-1之间，都小于x


```

​			

​		若需求2~5，如何才能达到需求：

```
			0	~	？		#？=5-2=3	0~3为%4的结果
		+	2
		-----------------
			2	~	5		#即要达到2~5的结果，需要%4+2


```

​		

​		推理到x~y，则有：`%(y-x+1)+x`

```
			0	~	?			# ?=y-x 	为%[(y-x)+1]的结果
		+	x
		----------------
			x	~	y			# 即要达到x~y的结果，需要%（y-x+1）+x


```

]]></content>
      <categories>
        <category>学习笔记</category>
      </categories>
      <tags>
        <tag>PHP</tag>
        <tag>后端</tag>
      </tags>
  </entry>
  <entry>
    <title>PHP 简介03-运算符/流程控制</title>
    <url>/2017/12/13/PHP%20%E5%9F%BA%E7%A1%8003-%E8%BF%90%E7%AE%97%E7%AC%A6.%E6%B5%81%E7%A8%8B%E6%8E%A7%E5%88%B6/</url>
    <content><![CDATA[
# 1. 运算符  Operation

PHP中运算符主要有以下**七种**：

- 算术运算符
- 自增/自减运算符
- 赋值运算符
- 比较运算符
- 拼接运算符
- 逻辑运算符
- 三元运算符

### 1.**算术运算符**：

​	`加	        减	乘	除	取模（取余）`

​	`+ 	      -	         *	  /	       %`

​	**取模（%）详解**：

​	1)**普通取模**：

```
	var_dump(5%2);		#1
	var_dump(1%2);		#1
	var_dump(2%2);		#0

```

​	2)**高阶取模**

​		①**取模的正负**：取决于被除数的正负

```
		var_dump(5%2);		#1
		var_dump(5%-2);		#1
		var_dump(-5%2);		#-1
		var_dump(-5%-2);	#-1

```

​		

​		②**取模结果的范围：x~y**

```
	     var_dump(0%3);		#0				# %3
	   	 var_dump(1%3);		#1
	   	 var_dump(2%3);		#2
	   	 var_dump(3%3);		#0
	   	 var_dump(4%3);		#1
    	 var_dump(5%3);		#2
	   	 var_dump(6%3);		#0
    	 var_dump(7%3);		#1				# %3的结果永远在0~2之间，都小于3

```

​    	   

```
	     var_dump(0%5);		#0				# %5
	   	 var_dump(1%5);		#1
	   	 var_dump(2%5);		#2
	   	 var_dump(3%5);		#3
	   	 var_dump(4%5);		#4
	   	 var_dump(5%5);		#0
	   	 var_dump(6%5);		#1
	   	 var_dump(7%5);		#2				# %x的结果永远在0~x-1之间，都小于x

```

​			

​		若需求2~5，如何才能达到需求：

```
			0	~	？		#？=5-2=3	0~3为%4的结果
		+	2
		-----------------
			2	~	5		#即要达到2~5的结果，需要%4+2

```

​		

​		推理到x~y，则有：`%(y-x+1)+x`

```
			0	~	?			# ?=y-x 	为%[(y-x)+1]的结果
		+	x
		----------------
			x	~	y			# 即要达到x~y的结果，需要%（y-x+1）+x

```

​		

### 2.拼接运算符	string

1.符号：

​	`.`	小数点

2.作用 ：

​	拼接变量与字符串	/	拼接变量与变量

3.实例：

```
 	$a='winter';
 	$b='fall';
 	$c='winter fall is the home of arya';	
 	$c='$a $b is the home of arya';			#不识别，显示为$a $b
 	$c=$a.' '.$b.' is the home of arya';	#正常显示

 	echo $c;

```

### 3.赋值运算符	equal

主要有以下几种赋值运算符：

​	`变量=值`		赋值（先运算=右边的，再运算=左边的）

​	`变量+=值`		变量=变量+值
​	`变量-=值`		变量=变量-值
​	`变量*=值` 		变量=变量*值
​	`变量/=值 `		变量=变量/值
​	`变量%=值` 		变量=变量%值
​	`变量.=值 `		变量=变量.值

### 4.比较运算符	compare

​	1.比较的结果都是布尔值（bool）

​	2.运算符：

​	`>`	`>=`		大于，大于等于

​	`<`	`<=`		小于，小于等于

​	`==`			    等于	（判断=两端的值是否相等）

​	`===`			  全等于	（判断两边的值和数据类型是否全部相等）

​	`!=`			    不等于	（判断两边的值是否不相等）

​	`!==`			  全不等于	（判断两边的值和数据类型是不是都不相等）

### 5.逻辑运算符	logic

|  类型  | 运算符 |            运算规则            |
| :----: | :----: | :----------------------------: |
| 逻辑与 |   &&   | 两边全真才是真,一边为假即为假  |
| 逻辑或 |  \|\|  | 一边为真即是真，两边为假才是假 |
| 逻辑非 |   ！   |       真即是假，假即是真       |

### 6.自增/自减	increment

​	1.自增运算符：`++`

​	2.自减运算符：`--`

​	3.易混乱点：	

​		a++	先返回a值，再给a+1

​		++a	先给a+1，再返回a值

```
		$a=10;
		echo $a++;			#输出a	10
		echo $a;			#输出a+1	11
		echo ++$a;			#输出a+1	12
		echo $a;			#输出a	12

```

### 7.三元运算符	three

​	一元运算符：`！`	`a++`	`a--`	

​	二元运算符：`a=b`	`a%b`	`a-b`

​	三元运算符：`?:`

1.定义：简化的if-else结构

2.格式：条件表达式  ?  true环境  :    false环境；

3.运算规则：

​	当条件表达式成立时，进入true环境执行；当条件不成立时，进入false环境。

4.实例

​	`echo 1+1==2?'yes!':'no';`



### 补充：运算符优先级

![PHP运算符优先级](D:/wamp/www/XIA/0410/PHP%E8%BF%90%E7%AE%97%E7%AC%A6%E4%BC%98%E5%85%88%E7%BA%A7.png)

# 2. PHP流程控制

在PHP中，主要有四种结构：顺序结构，分支结构，循环结构和异常结构，其中异常结构主要适用于面向对象，先不进行介绍。

1.**顺序结构**：代码从上往下依次执行；（参考HTML中文档流）

2.**分支结构**：通过 `if` / `switch` 来进行分支选择

3.**循环结构**：通过 `for` / `while` 来重复执行某一部分的代码

以下详细介绍分支结构和循环结构的具体内容

### 1.顺序结构（不介绍）

### 2.分支结构

1.单一分支结构：（`if`）

- `if( 条件表达式 ) 一行代码；`

  该结构只能影响紧跟在 `if` 后面的第一行代码，从第二行开始，就不受 `if` 判断结果的影响

- `if( 条件表达式 ){ 一个代码块； }` 

  该结构后面可以跟一整个代码块，通过复合结构（代码块）， `if` 可以影响多条语句

2.双向分支结构（`else`）

- `if( 条件表达式 ){ 代码段;}else{ 代码段；}`

  `if` 语句的延伸，可以对不满足 `if` 条件的情况进行阐述

3.多向条件分支结构（`elseif`）

- `if(条件表达式){代码块}elseif（条件）{ ... }elseif(条件){ ... }...else{...}` 

  在 `elseif` 中只有一个被执行，多个条件是逻辑或的关系，只要有一个满足，就可以进入相应的true环境，优先处理包含范围较小的条件

4.巢状条件分支结构（`if` 嵌套）

- ```
      if(条件表达式){
             if(条件表达式){
                 if(条件表达式){
  					...
                 }else{ ... }
             }else{ ... }
         }else{ ... }
  
  ```

  这里的多个条件是逻辑与的关系，要同时满足才能进入最深的true环境

5.多向条件分支结构(`switch`)

- ```
  switch( 表达式 ){
         case 值1: 代码块1；break;
         case 值2： 代码块2;break;
         ...
         case 值n: 代码块n;break;
         default: 代码块n+1;
  }
  
  ```

  专门用于等值判断， `switch` 后面的表达式数据类型只能是整型或字符串，不能为`bool` 值;

  若不加 `break` ，会在匹配到值后继续向下执行后面的所有标识;

   `default` 代表不与之前所有值匹配的情况;

##### 6.练习  简易计算器

> 需求: 由用户输入两组 数值, 并选择运算符, PHP根据运算符结算结果

```
//1.接收数据：
	$n1=empty($_GET['num1'])? null :$_GET['num1'];	#三元运算符，若设置则赋值，未设置赋值null
//2.根据运算符选择计算方式
	$result = null;
		switch ($ope) {
			case '+': $result = $n1 + $n2; break;	
			case '-': $result = $n1 - $n2; break;
			case '*': $result = $n1 * $n2; break;
			case '/': $result = $n1 / $n2; break;
		}
//3.HTML表单提交
		<input type="text" name="num1" value="<?= $n1 ?>"> 

		<select name="ope">
			<option value="+" <?=  $ope == '+'?'selected':null   ?>  >+</option>
			<option value="-" <?=  $ope == '-'?'selected':null   ?>  >-</option>
			<option value="*" <?=  $ope == '*'?'selected':null   ?>  >&times;</option>
			<option value="/" <?=  $ope == '/'?'selected':null   ?>  >&divide;</option>
		</select>	#三元运算符，若选中默认显示，未选中为空

		<input type="text" name="num2" value="<?= $n2 ?>"> 	#value输入提交时默认显示
		
//4.HTML中输出结果
	<span> <?= $result ?> </span>


```

### 3.循环结构

#### 1.while循环（当）

- 格式：

```
	$sum=1;									初始化;
	while($num<=100){        				while(条件){
        echo $num;								代码块；
        $num++;								}
	}											

```

- 循环规则：

  ​	初始化 --> 条件  成立--> 代码块 -->条件（循环）

  ​				不成立 --> 跳出循环

注意： `while` 循环常用来控制循环次数未知的循环结构，条件表达式的结果必须为 `bool` 值

#### 2.do...while循环（直到）

- 格式：

```
	$num=1;								初始化;
	do{									do{
        echo $num;							代码块；
        $num++;							}while（条件）；
	}while($num<0);

```

- 循环规则：

  ​	初始化 --> 代码块 --> 条件 成立 --> 代码块（循环）

  ​						 不成立 --> 跳出循环

注意： `do...while` 是先执行一次代码块，然后判断是否符合条件，来决定是否继续循环；

​	    `while(条件)` 后面要加上分号 `；` 

​	    适合执行至少必须循环一次的情况。

#### 3.for循环

- 格式： `for( 初始化 ; 条件表达式 ; 增量 ){ 代码块; }` 

- 循环规则：

  初始化 --> 条件表达式  成立--> 代码块 --> 增量 --> 条件 --> 代码块（循环） 

  ​				    不成立--> 跳出循环

- 注意点：

  - for语句中的三部分可以部分或全部为空，如把第一部分初始化语句提到for语句之前，第二部分和第三部分提到for语句之内；（for的退化形式）

    - ```
      //把初始化提到for之前
      	$num=1;
      	for(;$num<10;$num++){echo $num;}
      
      ```

    - ```
      //把第三部分增量提到for之内
      	$num=1;
      	for(;$num<10;){
              echo $num;
              $num++;
      	}
      
      ```

    - ```
      //把第二部分条件表达式提到for之内
      	$num=1;
      	for(;;){
              if($num<10)break;
              echo $num;
              $num++;
      	}
      
      ```

  - for语句中的每个部分都可以写多个表达式，之间用 `,` 逗号隔开；

#### 4.循环语句之间的区别

- while语句先判断再执行，do...while语句先执行一次，再判断是否继续循环。
- while语句计算机执行速度较快，for语句代码书写方便，排版整洁，使用程度较高。

#### 5.for循环使用技巧

- 当条件表达式为空或非false值时，程序条件永远满足，产生死循环

  ```
  	$x=0;
  	for(;;){
  		echo $x.' ';
  		$x++;
  	}
  
  
  ```

- 当条件表达式为与false等价（0 , 0.0，‘ ‘，...）时，程序认为条件不满足，不会执行;

- 当初始化表达式为空时，false=0，初始值为0；

- 当增量为空时，若条件成立则一直循环输出初始值；z



### 4.特殊流程控制符

#### 1.continue

当执行到continue时，会准备进入下一轮循环

#### 2.break

当执行到break时，会马上结束当前循环或者分支结构

#### 3.die

当执行到die时，整个程序结束（后面全部不会执行）（？断点调试？）

### 5.扩展使用

​	**需求：输出0~9，如果碰到4，跳过**

```
	for($i=0;$i<10;$i++){
		if($i!==4){
            echo $i.' ';
		}
	}

```

```
	for($i=0;$i<10;$i++){
        if($i==4){
            continue;
        }echo $i.' ';
	}

```

​	**需求：输出0~9，如果碰到4，就结束循环**

```
	for($i=0;$i<10;$i++){
        if($i==4){
            break;
        }echo $i.' ';
	}

```

​	**需求：输出0~9，如果碰到4，就结束程序**

```
		for($i=0;$i<10;$i++){
            if($i==4){
                die('111');
            }echo $i.' ';
		}

```

​	结论：

- `continue` 只是跳过此次循环，继续下次循环；
- `break` 是结束本循环结构，继续后面的程序执行；
- `die` 是结束整个程序，后面的程序直接无效；（`exit` 同样）

## 5.HTML与PHP结合写法

1. `for`  和 HTML 混合写法：

   ```
   	<?php  for()  ?>
   		HTML代码块
   	<?php  endfor  ?>
   
   ```

   

2. `if` 和 HTML 混合写法：

   ```
           <?php  if()  ?>
               HTML代码块
           <?php  endif  ?>
   
               <?php  if()  ?>
                   HTML代码块(true环境)
               <?php  else:  ?>
                   HTML代码块(false环境)
               <?php  endif  ?>
               
              <?php  if():  ?>
   				html代码块 (true环境)
   			<?php elseif(): ?>
   				html代码块 (true环境)
   			<?php elseif(): ?>
   				html代码块 (true环境)
   			<?php elseif(): ?>
   				html代码块 (true环境)
   			<?php else(): ?>
   				html代码块 (false环境)
   			<?php  endif ?>
   
   ```]]></content>
      <categories>
        <category>学习笔记</category>
      </categories>
      <tags>
        <tag>PHP</tag>
        <tag>后端</tag>
      </tags>
  </entry>
  <entry>
    <title>PHP 简介04-函数</title>
    <url>/2017/12/27/PHP%20%E5%9F%BA%E7%A1%8004-%E5%87%BD%E6%95%B0/</url>
    <content><![CDATA[
## 1.函数 `function`

### 1.定义：

​	用来执行特定任务，实现某种功能

### 2.分类：

​	系统函数：PHP自带的函数，如数学，字符串，数组，时间...

​	自定义函数：用户根据具体的需求来设计的函数

### 3.自定义函数

​	1.格式：

​	 `function 函数名（参数1，参数2，...）{代码块}` 

​	2.注意事项：

​	1） `function` 关键字不能少；

​	2）函数名不区分大小写；

​	3）参数（也称形参）可以写也可以不写，具体根据需求决定；

​	4）代码块：函数功能的主要部分；

### 4.特性：

- 函数不调用不会自动执行
- 没有执行函数时，依旧会检测里面的语法，若有错误，程序报错
- 函数互不影响，可以互相调用
- 调用函数和定义函数的先后顺序没有要求

### 5.调用函数

​	`函数名（）;` 

### 6.函数名

#### 1 函数的命名规范：

​	由数字，字母和下划线组成，但不能由数字开头

#### 2 函数名不区分大小写

#### 3 函数命名要求

​	有意义，以提高可读性（动词＋名词）

#### 4 函数命名方式：

1.小驼峰命名法：

​	从第二个单词开始，首字母大写 `getUserName` 

2.大驼峰命名法（帕斯卡命名法）

​	每个单词的首字母都大写 `GetUserInfo` 

3,下划线命名法

​	每个单词之间用下划线隔开 `var_dump` 

#### 5 函数名不允许重复

### 7.返回值 return

1.关键字：

​	`return` 

2.格式：

​	 `return 内容` 

3.流程：

​	当程序执行到 `return` 时，马上将“内容”返回到调用函数的地方

4.返回状态：

- 自然返回：函数中的代码全部执行完，自动回到调用函数的地方

> 没有返回值时，强行接收，只能得到null

- 提前返回：函数中执行了return，马上结束函数，并返回到调用函数的地方

> 当程序执行到return时，立马返回，带了一个内容，如果想带两个变量回去，可以将多个变量存入同一个数组中，并return数组。

### 8.参数

1.定义：

​	参数分为**实参**（实际参数）和**形参**（形式参数）

​	实参—— `argument` ，在调用函数时给的具体参数

​	形参——`parameter` ，在定义函数时给的某一类参数形式

2.参数接收

1）**实参个数=形参个数**  （匹配完美）

​	实参与形参会一一对应，相互匹配接收

2）**实参个数>形参个数**

​	和形参匹配的前几个实参一一接收，后面多余的实参会被抛弃

3）**实参个数<形参个数**

​	多余的形参通常会采用之前设置的**默认值**，若没有默认值，则会被当做**未定义变量** 

### 9.可变长度参数的函数

当实参个数为一个不确定值时，称为可变长度参数的函数

- 接收所有实参（数组形式） `func_get_args()` 
- 单独获取键为N的实参 `func_get_arg(N)` 
- 统计一共有多少个实参 `func_num_args()` 

> 当不知道有多少实参时，形参一个都不要写，用上述函数接收数据

```
	// 需求:
	// 	根据传入的多个实参, 进行求和
	function add()
	{
        $sum=0;
        $count=$func_num_args();
        for($i=0;$i<$count;$i++){
            $sun+=func_get_arg($i);
        }
        return $sum;
	}
```

### 10.函数设计准备

#### 1.设计函数名：

​	具体功能描述

#### 2.考虑参数设置：

- 功能中需要输入几个参数
- 参数需不需要设置默认值

#### 3.核心功能

​	其中缺乏的数据，可以先模拟出来，保证结果是有效的

#### 4.补充

​	缺什么补什么，把模拟数据扩展为灵活数据

```
	//需求：获取 x~y 之间的偶数
	function getEven($x,$y)
	{
        for($i=$x;$i<$y;$i++){
            if($i%2 == 0){
                $result[]=$i;
            }
        }return $result;
	}
```

## 2.变量作用域

1.定义：

​	变量能够作用的区域。

2.分类

全局变量：在函数外部声明的变量

局部变量：在函数内部声明的变量

3.规则：

- 全局变量无法直接在局部作用域中使用
- 局部变量不能直接在全局作用域中使用

```
	$a=100;			#全局变量
	function demo()
	{
        $b=200;		#局部变量
        echo $a;	#失败
	}
	demo();			#null，函数内部声明的变量，在函数结束时，所有的值会被释放
	echo $b			#失败，输出时，会输出全局$b，若找不到就报错
```

4.改变作用域

- 将全局变量作用域扩展至局部变量：

  通过超全局数组获得全局变量， `$GLOBALS['a']` 用于存储所有全局可用的变量

- 将局部变量作用域扩展至全局；

  通过使用 `global` 给局部变量赋予令牌，使其能够在全局中使用。

5.常量

```
		const CHINA='zhongguo';		#全局定义常量
		function demo()
		{
            echo CHINA;				#正常输出，可以直接在局部中使用
            const NAME='cheng';		#不能在函数中通过const定义局部常量
            define('AGE',20);		#可以用define( )定义成功，但不推荐
            echo AGE
		}
		demo();
		echo AGE;
```

小结：常量在本质上是没有作用域的。

6.静态变量

​	1.定义：在函数中，被声明为静态变量的值，函数执行结束后不会被释放，而是在下一次调用同函数时，直接使用上一次的静态值结果。

​	2.关键字： `static` 

​	3.多个不同函数中，出现相同的静态变量，这些静态变量互不影响。

```
	function demo()
	{							
		static $num = 10;		# 静态初始值
		echo $num.'<br>';
		$num++;
	}
	demo();		#10
	demo();		#11
```

]]></content>
      <categories>
        <category>学习笔记</category>
      </categories>
      <tags>
        <tag>PHP</tag>
        <tag>后端</tag>
      </tags>
  </entry>
  <entry>
    <title>PHP 简介05-数组/正则/时间函数</title>
    <url>/2018/01/05/PHP%20%E5%9F%BA%E7%A1%8005-%E6%95%B0%E7%BB%84.%E6%AD%A3%E5%88%99.%E6%97%B6%E9%97%B4%E5%87%BD%E6%95%B0/</url>
    <content><![CDATA[
## 1.数组

### 1.数组

1.分类

​	索引数组：键为  `int` 

​	关联数组：键为  `string` 

​	混合数组：键为  混合类型（字母，数字，汉字，字符串....）

2.键：

​	别名：下标，偏移量，索引

3.值：

​	可以为任意类型

4.格式：

​	 `$数组名[ 键 ] = 值;` 

​	 `$数组名 = [ 键1 => 值1，键2 => 值2，键3 => 值3，... ]; ` 

5.索引数组

​	1）数组的键为一系列有一定规律的数字组成，当键不是 int 型时，会强制转化为 int 。

​	2）当没有指定键时：默认从0开始；从已有记录过的最大键开始+1；

6.关联数组

​	1）数组的键为字符串组成，没有特别的顺序和规律

​	2）如下一些键值可能会产生同样的效果：

​	 `# 1 = 1.xxx =true` 

​	 `# 0 = 0.0 = '0' = false  ` 

​	 `# null = 空字符串 = 未定义变量` 

​	 `# 非法键：数组，对象` 

​	 `# 资源虽然可以作为键，但是不推荐` 	

​	键既有数字，又有字符串，一般称之为混合数组

7.多维数组

​	数组间发生嵌套关系，即可称之为多维数组

​	多维数组的操作，需要操作几维数组，就需要几个[ ]	

```
$name=[
		['成龙', '洪金宝', '李连杰', '周润发'],
		['易筋经', '洗	髓经', '金钟罩', '童子功'],
		['象猴得度', '普度众生', '割肉喂鹰', '佛说前生'],
	];

```

另一个写法：

```
$name=['a'=>[1,2,3,4,5,],'b'=>[2,3,4,5,6,6]];

```

8.遍历数组

1.索引遍历	for

对于键为有规则的数字，可以用索引遍历

```
$name = ['貂蝉', '西施', '王昭君', '杨玉环'];
	for($i=0; $i<4; $i++){
		echo $name[$i].' ';
	}
	var_dump($name);

```

2.指针遍历	point

对于没有规则的数字键，是很难通过for遍历出来

常用函数：

​	 `key( )` 	返回当前指针所指向的键

​	 `current( )` 	返回当前指针所指向的值

​	相对移位：

​	 `next( )` 	下移一位

​	 `prev( )` 	上移一位

​	绝对移位：

​	 `reset( )` 	指针直接指向数组的第一个键值对

​	 `end( )` 	指针直接指向数组的最后一个键值对

注意点：

当使用 next 和 prev 移出范围之外时，无法通过next和prev再移动回来，返回键为 null ，值为 false。

一般使用键为null来作为遍历终止条件

```
$name = [4=>'貂蝉', 1=>'西施', 99=>'王昭君', 12=>'杨玉环'];
	// 利用指针 来遍历数组
	for(  ; !is_null( key($name) )  ;  next($name)  ){
		echo current($name).' ';
	}


```

3.指针遍历    each

 `each（）`函数自带` current+key+next ` 

```
$name = [4=>'貂蝉', 1=>'西施', 99=>'王昭君', 12=>'杨玉环'];

	for( ;  $x = each($name)  ; ){
		echo $x[0].'=======>'.$x[1].'<br>';
	}
	echo '<hr>';		#输出形式：0=key;1=value。


```

4.扩展循环结构： `foreach` 

格式：	

​		 `foreach( 数组 as  键 => 值  ){  代码块  }` 

简化版：当不需要使用键时

​		 `foreach( 数组 as  值 ）{  代码块  }` 

```
$name = [4=>'貂蝉', 1=>'西施', 99=>'王昭君', 12=>'杨玉环'];

	foreach($name as $k => $v){
		echo $k.'=======>'.$v.'<br>';
	}


```

### 2.预定义数组

1.$GLOBALS	存储全局环境中所有的可用变量

2.$_GET		接收所有以get方式传输的值

3.$_POST		接收所有以post方式传输的值

4.$_FILES		专门用于接收上传文件

5.$_COOKIE		存储浏览器中的cookie值

6.$_SESSION		存储服务器中的session值（不重复登录）

7.$_REQUEST		同时接收get，post，cookie 的值

8.$_SERVER		存储服务器相关的信息，包含地址，IP，服务器环境等

```
	var_dump($_SERVER)
		# $_SERVER['HTTP_HOST'] 	主机地址
		# $_SERVER['HTTP_USER_AGENT'] 	客户端的信息(设备, 浏览器信息)
		# $_SERVER['REMOTE_ADDR'] 客户端的IP地址 (常见面试题)
		# $_SERVER['HTTP_REFERER'] 获取上一级来源地址(你是从哪个页面来的)
		# $_SERVER['REQUEST_URI']  脚本地址(带参数)
		# $_SERVER['QUERY_STRING'] 获取参数
		# $_SERVER['SCRIPT_NAME']  脚本地址(不带参数)


```

9.当 `method=get` , `action`带参数时，`action` 的参数会被全部抛弃

​	解决方案：将 `action` 的参数通过隐藏域进行传递

```
<form action="http://localhost/s86/0416/09-server.php?name=999&age=99" method="get">
	<input type="text" name="age">
	<input type="hidden" name="name" value="999">
	<input type="hidden" name="age" value="99">
	<input type="submit">
</form>



```

10.上传文件

三个必要条件：

- file表单必须要有name，用以在PHP端接收内容
- form表单中  `method = post` 
- form表单中 `enctype=multipart/form-date` 

单文件上传：

​	`<input type="file" name="xxx">`

多文件上传：

​	1.需要在`name`值得最后面加 `[ ]`，形成数组接收多内容

​	2.`file` 添加 `multiple` 属性

### 3.字符串数组

把字符串当做数组来使用

```
$str = 'i love you';

	echo $str[0];
	echo $str[1];
	echo $str[2];
	echo $str[3];
	// ...
	echo $str[9];

	# 已经超出字符串范围
	echo @$str[10];
	var_dump( @$str[10] ); # 空字符串
	echo '<hr>';

	// for($i=0; $i<10; $i++){
	// 	echo $str[$i];
	// }

	for($i=0;  @$str[$i] !== ''  ; $i++){
		echo $str[$i];
	}



```

## 2.正则表达式

1.定义：正则表达式就是用某种模式去匹配字符串的公式

2.功能：主要用于字符串的查询，替换操作

3.组成：由正规字符和一些特殊字符组成

4.特征：

- 小而强大 的控制源（正则集的代数）
- 存储大
- 读取快

### 1正则语法规则：

包含：定界符，原子，元字符，模式修正符

### 2.定界符：

表示一个正则表达式的开始和结束，有以下三种方式：

- `/ [0-9] /`	一对斜线
- `#[0-9]#`           一对井号
- `{[0-9]}`           一对大括号

### 3.原子：

表达式中代表一个匹配单元的个体，分为可见原子和不可见原子

不可见原子：

- 换行符	`\n` 
- 回车          `\r` 
- 制表符        `\t` 
- 空格
- 其他不可见符号

### 4.元字符

1）原子的筛选方式：

- `|` 	匹配两个或多个分支选择
- `[ ]`         匹配方括号中的任意一个原子
- `[^]`         匹配除了方括号中的原子之外的任意字符

2）原子的集合（将某一类原子归类简化）

- `.` 	匹配除换行符之外的任意字符
- `\d`       匹配任意一个十进制数字，即`[0-9]` 
- ` \D`       匹配任意一个非十进制数字，即`[^0-9]` 
- `\s`       匹配一个不可见原子，即`[\n\t\r]` 
- `\S`       匹配一个可见原子，即`[^\n\t\r]` 
- `\w`       匹配一个数字、字母或下划线，即`[0-9a-zA-Z_]` 
- `\W`       匹配一个非数字、字母或下划线，即`[^0-9a-zA-Z_]` 

3）量词（查找字符串中某个原子连续出现多少次）

- `{n}`  	 表示其前面的原子出现n次
- `{n,}`         表示其前面的原子至少出现n次
- `{n,m}`       表示其天免得原子出现了n~m次
- `*`               匹配0次，1次或者多次其前的原子，即`{0,}` 
- `+`               匹配1次或者多次其前的原子，即`{1,}` 
- `?`               匹配0次或者1次其前的原子，即`{0,1}`  

4）便捷控制，模式单元和模式选择符

- `^`  	匹配字符串开始的位置
- `$`          匹配字符串结尾的位置
- `( )`      匹配其中的整体为一个原子
- `(|)`      匹配其中的两个或者更多的选择之一，分隔多选一模式

### 5.模式修正符

- 贪婪匹配

  `.*` 	匹配结果存在歧义时取其长（默认）

- 懒惰匹配

  `U`    	匹配结果存在歧义时取其短，同`.*?` 

- 忽略空白

  `x` 	   匹配结果忽略空白 

- 大小写匹配

  `i`   	匹配结果不区分大小写

- 中文适配

  `u` 	把中文汉字当做一个字符计算 

### 6.正则的基本使用

> 正则在PHP中就是字符串类型

1.函数：

1）`preg_match(正则，字符串 [,匹配结果])` （单词匹配函数）

​	返回值：匹配的次数（0-失败；1-成功）

2）`preg_match_all(正则，字符串 [,匹配结果])` （全部匹配函数）

​	返回值：字符串中匹配字符的个数

3）`preg_replace(正则，替换值，对象)` （替换匹配字符串函数）

​	返回值：替换之后的对象

4）`preg_grep(正则，数组)` （过滤函数）

​	返回值：符合过滤条件的字符串

2.后向引用

​	`\1`	代表将第一个（）内的内容复制到 `\1` 所在的位置

​	`\2`	代表将第一个（）内的内容复制到 `\2` 所在的位置

​	`\n`	代表将第一个（）内的内容复制到 `\n` 所在的位置



3.分组概念：（）模式单元

​	在正则中，一旦匹配（）的内容，会产生两个效果

​	1)将（）内的内容当成一个整体，以一个大原子的形式看待

​	2)将（）内的内容送入子模式匹配

​	参与子模式匹配，方便后向引用

> 若只是单纯想将（）内容当成一个整体，不想让（）内容参与子模式，可以取消子模式：`（?:正则内容）`

4.中文

中文在PHP中默认占3位，模式修正符 `u` 可以将中文当做一位.

若要统计字符串中有多少汉字，可以匹配 `\x{4e00}-\x{9fa5}` .

## 3.时间函数

### 1.时区

​	获取时区：`date_default_timezone_get()` 

​	设置时区：`date_default_timezone_set()` 

> 默认时区为UTC时区，世界标准时间（英国 格林威治时间）
>
> 中国时区为参数 PRC

### 2.Unix时间戳 `time()` 

​	`time( )` 获取的时间为自1970年一月一日开始到现在的秒数

### 3.时间戳格式化 `date()` 

​	`date(格式，时间戳)` 

格式：（严格区分大小写）

```
	// 	Y  	4位年份
	// 	y 	2位年份
	// 	M 	英文月份
	// 	m 	数字月份
	// 	w 	中文周几
	// 	W 	中文第几周
	// 	D 	英文周几
	// 	d 	天
	// 	H 	24小时
	// 	h 	12小时  配合a
	// 	i 	分钟
	// 	s 	秒数
	// 	z 	第几天


```

> 格式中除了字母外，其他字符都是原样输出

### 4.创建固定时间点 `mktime()` 

​	`mktime(时,分,秒,月,日,年)` 

> 创建的时间点格式也是Unix时间戳

### 5.英文时间命令 `strtotime()` 

​	`strtotime()` 

格式：

```
	//now			此刻时间
	//yesterday		昨天
	//tomorrow		明天
	//last year 	上一年
	//-2 day 		前两天
	//2 year 		两年后


```

时间上限：2037-12-31 23:59:59

### 6.延迟 `sleep()` 

​	`sleep(秒数)` 

### 7.微秒 `microtime()` 

​	`microtime()`  将时间戳微秒数显示出来

​	参数：false（默认）微秒数在前，较精确

​		    true   将微秒数置后，方便参数计算

]]></content>
      <categories>
        <category>学习笔记</category>
      </categories>
      <tags>
        <tag>PHP</tag>
        <tag>后端</tag>
      </tags>
  </entry>
  <entry>
    <title>PHP 简介06-错误处理</title>
    <url>/2018/01/17/PHP%20%E5%9F%BA%E7%A1%8006-%E9%94%99%E8%AF%AF%E5%A4%84%E7%90%86/</url>
    <content><![CDATA[
## 1.错误处理

### 1.分类

​	PHP的错误编码：

​	1.error错误  	错误号:1

​	致命错误，一旦碰到error错误，程序立马终止

​	2.warning错误	错误号：2

​	警告错误，一旦碰到warning错误，程序会给出错误警告，但不会终止程序的执行

​	3.notice错误	错误号：8

​	提示错误，可能是错误，也可能不是错误，不会终止程序的执行

### 2.错误的屏蔽

在上线项目中，不允许出现任何错误

#### 1.方法一：

通过错误抑制符@来屏蔽当前某一变量的错误

#### 2.方法二：（推荐）

通过error_reporting函数来屏蔽函数之后的错误

该函数一般写在程序的最前面

影响范围：该文件

- error_reporting(E_ALL) 显示所有的错误

- error_reporting(E_WARNING) 只显示warning级错误

- error_reporting(E_NOTICE) 只显示notice级错误

- error_reporting(E_ERROR) 只显示error级错误，一般屏蔽不掉

- error_reporting(E_ALL ^E_NOTICE)

  除了notice级错误，其余都报

- error_reporting(E_ALL & ~E_NOTICE)

- error_reporting(E_ALL ^E_EARNING)

  除了warning级错误，其余都报

- error_reporting(E_ALL & ~E_WARNING)

#### 3.方法三：

通过修改配置文件，来屏蔽错误

影响范围：整个服务器

配置文件位置：wamp\bin\apache\apache2.4.18\bin\php.ini

注意：修改任意配置后，都需要重启服务器

```
	//  修改内容2:
	//  error_reporting = 值 		
		该值与 屏蔽2的函数值一模一样


```

#### 4.方法四：

通过函数临时修改配置文件`ini_get() ` 或 `ini_set()` 

影响范围：当前文件

```
		var_dump( ini_get('display_errors') );
		ini_set('display_errors', 0);
		ini_set('display_errors', 'Off');
		ini_set('display_errors', 'On');
		var_dump( ini_get('display_errors') );

		# 32767 E_ALL
		# 1     E_ERROR
		# 2  	E_WARNING
		# 8 	E_NOTICE
		
		var_dump( ini_get('error_reporting') );
		ini_set('error_reporting', 1);
		ini_set('error_reporting', E_ERROR);
		ini_set('error_reporting', E_WARNING);
		ini_set('error_reporting', E_NOTICE);
		var_dump( ini_get('error_reporting') );

		echo $a;
		echo strrev();


```

### 3.PHP错误日志

日志函数：`error_log(日志信息，日志类型，目标文件)` 

日志类型：如果是写入日志，选择3

目标文件：当日志类型为3，才需要第三个参数

```
	$a = 10;
	$b = 0;

	if ($b == 0) {
		// 日志信息
		$ip = $_SERVER['REMOTE_ADDR']; # 客户IP
		$time = date('Y/m/d H:i:s');   # 访问时间
		$method = $_SERVER['REQUEST_METHOD']; # 访问方式
		$info = '除数不能为0'; # 错误信息
		$address = __FILE__;  # 错误文件地址
		$line = __LINE__;     # 当前行号

		# 记事本的换行: \r\n  先回车再换行
		$log = "{$ip} - -  [{$time}]  {$method}   {$info}  in {$address} on line {$line} \r\n";

		error_log($log, 3, './log.txt');


		// 自定义报错
		// trigger_error(报错信息, 错误类型)
		// 							E_USER_ERROR		用户自定义的致命错误
		// 							E_USER_WARNING		用户自定义的警告错误
		// 							E_USER_NOTICE		用户自定义的提示错误
		trigger_error($info, E_USER_NOTICE);

	}else{
		echo $a/$b;
	}


```

3.逻辑错误的处理

逻辑错误：既不报错，也不终止程序，主要因为设计错误

两种缩小排错范围的方法：

1.断点法：通过die/exit中断程序的执行，在die之前输出相关变量，查看是否与预想数值符合

2.注释法：通过注释局部代码，查看结果是否有变化

]]></content>
      <categories>
        <category>学习笔记</category>
      </categories>
      <tags>
        <tag>PHP</tag>
        <tag>后端</tag>
        <tag>错误处理</tag>
      </tags>
  </entry>
  <entry>
    <title>PHP 简介07-文件操作</title>
    <url>/2018/03/15/PHP%20%E5%9F%BA%E7%A1%8007-%E6%96%87%E4%BB%B6%E6%93%8D%E4%BD%9C/</url>
    <content><![CDATA[
## 1.文件操作函数

### 1.回顾：

文件常见分类：file（文件） 和 dir（文件夹）

路径：    相对路径 	.  当前目录              ..  上级目录

​		绝对路径	（盘符型，网址型，根www)

### 2.文件属性：

#### 1.文件类型：

​	`filetype（' 文件路径 '）`	输入一个文件路径，返回文件类型（file 文件|dir 文件夹）

#### 2.文件大小：

​	`filesize（' 文件路径 '）`	输入一个文件路径，检测文件大小，单位是字节（不支持文件夹，结果不准确，以最小文件单元(4096字节)作为单元计算）

#### 3.文件是否存在：

​	`file_exists（' 文件路径 '）`	输入一个路径，返回判断结果bool值

#### 4.文件是否可读可写

​	`is_readable（' 文件路径 '）`	输入一个路径，判断是否可读，返回bool值

​	`is_writeable（' 文件路径 '）`	输入一个路径，判断是否可写，返回bool值

#### 5.返回文件的创建/修改/访问时间

​	`filectime（' 文件路径 '）`	输入路径，返回文件的创建（creative）时间

​	`filemtime（' 文件路径 '）`	输入路径，返回文件的修改（modification）时间

​	`fileatime（' 文件路径 '）`	输入路径，返回文件的访问（access）时间

#### 6.获取目录/文件名

​	`dirname（' __FILE__ '）` 	输入当前文件路径，获取路径名（dir）

​	`basename（' __FILE__ '）` 	输入当前文件路径，获取文件名（file）

```
	需求：面试题 获取该地址的文件扩展名
	$url = 'http://www.baidu.com/av/gt18/ka.n.g.mp4?age=18&type=人兽#xxoo';
	$a=basename($url);
	$a=strtok($a,'?');
	$a=strrchr($a,'.');

```

#### 7.网址解析

​	`parse_url(' url ')`

```
	$url='http://www.baidu.com:80/av/gt18/ka.n.g.mp4?age=18&type=人兽#xxoo'
	var_dump(parse_url($ur;));
	/*array (size=6)
  		'scheme' => string 'http' (length=4)	#协议
  		'host' => string 'www.baidu.com' (length=13)	#域名
 		'port' => int 80	#端口
  		'path' => string '/av/gt18/ka.n.g.mp4' (length=19)	#路径
  		'query' => string 'age=18&type=人兽' (length=18)	#参数
 		'fragment' => string 'xxoo' (length=4)*/	#锚点

```

#### 8.盘符解析

​	`pathinfo(' $path ')`

```
	$path='D:\wamp\www\s86\0422\01-file.php';
	var_dump($path);
	/*array (size=4)
  		'dirname' => string 'D:\wamp\www\s86\0422' (length=20)	#路径名
  		'basename' => string '01-file.php' (length=11)	#文件名
  		'extension' => string 'php' (length=3)	#扩展名
  		'filename' => string '01-file' (length=7)*/		#文件名（无后缀）

```

### 3.递归函数（三元归一遍历）

#### 1.函数

​	`opendir(' path ')` 	打开一个目录，返回资源

​	`readdir(' resource name ')`	读取一个资源，返回当前资源名（实际上利用指针）

​	`close(' resource name ')` 	关闭一个资源，释放内存

#### 2.应用

​	需求：将`./demo1` 目录中的所有文件名，输出到屏幕上

​	1.原始访问方式：

```
	$handle=opendir('./demo1');		#windows中，每个文件夹中都有 . 和 .. 文件夹
	var_dump(readdir($handle));		#当前目录 .  
	var_dump(readdir($handle));		#上级目录 ..
	var_dump(readdir($handle));
	...
	var_dump(readdir($handle));
	
	var_dump(readdir($handle));		 #超出范围之外，返回false
	closedir($handle);

```

​	2.循环访问方式：

```
	$handle=opendir('./demo1');
	while( ($file=readdir($handle))!=false ){		#循环访问方式
        if($file=='.'||$file=='..'){			#排除显示 . 和 .. 
            continue;
        }
        echo $file;
        echo '<br>';
	}
	closedir($handle);			#关闭资源

```

#### 3.递归函数

##### 1.函数：

​	`is_file( 'path name' )`   	判断当前路径是否为文件

​	`is_dir( 'path name' )` 	    判断当前路径是否为目录

> ​     注：参数必须为完整的地址，否则输出false。相对，绝对都可以

##### 2.递归函数：

​	1）函数自己调用自己

​	2）必须要有终止条件

##### 3.应用

```
	1.需求：函数功能-输出所有子目录下的所有文件和子目录
	function getFile( $dir )
	{
        $handle=opendir($dir);			#打开目录，获取资源
        while(($file=readdir($handle))!=false){		#读取资源
            if($file=='.'|$file=='..'){		#排除 . 和 .. 文件夹
                continue;
            }
            $path=$dir.'/'.$file;		#拼凑完整路径
            if(is_file($path)){		#判断是否为文件，是则输出文件名
                echo $file.'<br>';
            }
            if(is_dir($path)){		#判断是否为目录，是则输出目录名，
            	echo $file.'<br>';
                getFile($path);		#调用函数打开子目录
            }
        }
        closedir($handle);		#关闭资源
	}

```

```
	2.需求：函数功能-获取某个目录的大小
	function getDirSize( $dir )
	{
        $handle=opendir($dir)；
        $sum=0;
        while(($file=readdir($handle))!=false){
            if($file='.'|'..'){
                continue;
            }
            $path=$dir.'/'.$file;
            if(is_file($path)){
                $sum=$sum+fileseze($path);
            }
            if(is_dir($path)){
                $sum+=getDieSize($path);
            }
        }
        closedir($handle);
        renturn $sum;
	}

```

```
	3.需求：函数功能-统计某个目录下有多少个文件和文件夹
	function getFileNumber( $dir )
	{
        $handle=opendir($dir);
        $dirSum=0;
        $fileSum=0;
        while(($file=readdir($handle))!=false){
            if($file='.'||$file='..'){
                continue;
            }
            $path=$dir.'/'.$file;
            if(is_file($path)){
                $fileSum+=1;
            }
            if(is_dir($path)){
            	$dirSum+=getFileNumber($path);
                $fileSum+=getFileNumber($path);
            }
        }
        closedir($handle);
	}

```

### 4.文件操作

#### 1.拷贝文件

​	copy( 来源地址，目标地址 )	将目标文件拷贝到目标文件中（不支持目录拷贝）

​	`copy('./01-file.php','./demo1/01-file.php');` 

#### 2.创建目录

​	mkdir( 目录路径 )  				在目标路径创建一个文件夹

​	mkdir( 目录路径，0777，true )	  在目标路径创建多级目录文件夹

​	`mkdir('./x/y/z', 0777, true);` 

#### 3.删除目录

​	rmdir( 目录路径 ) 		只能删除空文件夹

​	`rmdir('./x');` 

#### 4.创建/删除文件

​	touch( 文件名 )  	创建文件

​	unlink( 文件名 )	  删除文件

​	` touch('./demo1/test.php');` 	`unlink('./demo1/test.php');` 

#### 5.重命名/剪切文件

​	rename( 旧文件名，新文件名 )	修改目录，剪切

​	`rename('./test', './demo1/test.txt');	#修改目录，剪切` 

​	`rename('./test.txt', './testxxx.txt'); 	# 目录不变,重命名 ` 

### 5.文件编码问题

Windows默认gbk编码，PHP默认utf-8编码，编码不一致时，会发生编码解析问题

​	iconv( 源编码，目标编码，内容 )

​	`copy(iconv('utf-8','gbk','./递归.png'),'./xx.png')` 

### 6.baidu云盘递归遍历

```
<!DOCTYPE html>
<html lang="en">
<head>
	<meta charset="UTF-8">
	<title>百度云盘</title>
	<style>
		table{width: 500px;/*height: 60px;*/margin:20px auto;border-collapse:collapse;font-size: 14px;}
		table tr:hover{background: #f4fbff;}
		table tr:hover th{border-color: #cbedff;}
		table tr:hover td{border-color: #cbedff;}
		table th{text-align: left;border-bottom:1px solid #ccc;/*line-height: 30px;*/border-color: #999;}
		table td{border-bottom:1px solid #ccc;border-color: #999;}
		.dir{background:url('./Baidu/icon.png') -380px -627px;width: 26px;height: 26px;display:inline-block;vertical-align: middle;}
		.file{background:url('./Baidu/icon.png') -380px -627px;width: 26px;height: 26px;display:inline-block;vertical-align: middle;}
	</style>
</head>
<body>
	<table>
		<tr>
			<th>文件名</th>
			<th>大小</th>
			<th>修改日期</th>
		</tr>
<!-- 		<tr>
			<td><div class="dir"></div>我的卡包</td>
			<td>xxx</td>
			<td>xxxxxx</td>
		</tr> -->
<?php  
		$x=empty($_GET['path'])?'./demo1':$_GET['path'];
		getFileName($x);
?>

	</table>
</body>
</html>


<?php 

function getFileName($dir){

	$handle=opendir($dir);

	// $file=readdir($handle);

	while(($file=readdir($handle))!=false){

		echo '<tr>';

		if ($file=='.'||$file=='..') {
			continue;
		}

		$path=$dir.'/'.$file;

		if (is_file($path)) {
			echo '<td><div class="file"></div>'.$file.'</td>';
			echo '<td>'.filesize($path).'</td>';
		}

		if (is_dir($path)) {
			echo "<td><div class='dir'></div><a href='?path={$path}'>{$file}</a></td>";
			echo '<td> - </td>';
		}
		echo '<td>'.filemtime($path).'</td>';

		echo '</tr>';

	}

	closedir($handle);

}



 ?>


```



### 7.文件加载

1.函数：

​	`include ' 文件路径 '` 	#加载（当做关键字使用）	依赖	`require ' 文件路径 '` 

​	`include( 文件路径 )` 	#加载（当做函数使用）	      依赖	`require( 文件路径 )` 

​	`include_once( 文件路径 )` 	#加载一次			   依赖	`require_once( 文件路径 )` 

​	`include_once ' 文件路径 '` 	#加载一次			 依赖	 `require_once ' 文件路径 '` 

2.作用：

​	将文件A加载到文件B中，文件B从而可以使用文件A中的所有数据

​	相当于将文件A的所有代码复制到文件B中的 `include` / `require` 处

3.使用

​	`include './demo.php';`    			`require './demo.php';`  

​	`include_once './demo.php';` 		`require_once './demo.php';` 

4.特性

​	1.`include` / `require` 可以重复加载

​	2.但被重复加载的文件内部，函数和常量会被重定义，报错

​	3.避免重复加载，可以通过`include_once` / `require_once`只加载一次

​	4.`include` 加载出错，**不会**终止程序，`require` 加载出错，**立马**终止程序

​	5.支持相对路径，盘符路径，不支持网址路径

### 8.文件内容操作函数

#### 1.向文件赋予内容

​	 `file_put_contents('文件路径','文件内容')；` 

​	若文件路径不存在，则自动创建；若路径存在，则先将文件大小截为0，再写入内容（覆盖）

​	**代码实例**：`file_put_contents('./test.txt','how are you?');` 

#### 2.获取文件的所有内容

​	 `file_get_contents('文件路径');` 

​	支持全格式地址，若输入网址地址，则爬取跳转当前页面（只有外表，无功能）

​	**代码实例**：`echo file_get_contents('./test.txt');` 

​			   `echo file_get_contents('http://www.baidu.com');` 

#### 3.打开一个文件

​	`fopen('文件路径'，'打开模式')；` 	返回值：资源

​	#打开模式详解：

​		r 	只读，指针指向文件开头，若文件不存在，报错

​		w	只写，指针指向文件开头，若文件不存在，则自动创建，且大小截为0

​		a 	追加，指针指向文件末尾，若文件不存在，则自动创建

​		+ 	增强，既可以读又可以写，但需要以上模式配合

​	**代码实例**： `$handle=fopen('.test.txt','r');`

#### 4.读取内容

​	 `fread('文件资源'，'字节');` 读取资源，返回内容，每次读取指定字节数据

​	当函数读取资源超出资源范围时，返回空字符串

```
	读取方式1：
		while( ($x=fread($handle,1)) !== '' ){
            echo $x;
		}

```

```
	读取方式2：
	echo fread($handle,11);
	echo fread($handle,filesize('./test.txt'));

```

#### 5.写入内容

​	`fwrite('文件资源','内容')` 

​	将内容写入目标文件，写入方式由 `fopen()` 的打开模式决定

​	代码实例：   

```
	1.写入：
	$handle=fopen('./text.txt','w');
	fwrite($handle,'MVP');		#MVP

```

```
	2.追加：
	$handle=fopen('.text.txt','a');
	fwrite($handle,'ADD');		#MVPADD

```

```
	3.增强：r+
	$handle=fopen('./test.txt','r+');	
	fwrite($handle,'abc');		#abcADD(覆盖前面的)

```

```
	4.增强：w+
	$handle=fopen('./test.txt','w+');	
	fwrite($handle,'def');		#def(覆盖全部的)

```

```
	5.增强：a+
	$handle=fopen('./test.txt','a+');	
	fwrite($handle,'GG');		#defGG(覆盖全部的)

```

#### 6.关闭资源

​	`fclose($handle);` 	释放内存，节省空间

### 9.文件上传

#### 1.文件上传限制：

- 表单限制	`MAX_FILE_SIZE`	HTML页面自定义大小，一旦超过，error=2

  ​			可通过F12跳过限制（一般都是通过隐藏域MAX_FILE_SIZE修改赋值）

- post协议限制          `post_max_size`           一旦超过8M，$_FILES直接为空

- 服务器限制           `upload_max_filesize`         一旦超过2M，error=1

#### 2.文件上传相关函数

​	$_FILES		专门用于接收上传文件，返回结果为数组

​	$is_uploaded_file( 临时文件地址 )	检测是否通过post发送，返回bool值

​	uniqid（）	基于一微秒产生的唯一ID，适合低频率

​	file_exists( )	文件是否存在，返回bool

​	move_uploaded_file( 临时文件，目标文件 )	移动临时文件到存储目录

```
		array (size=1)
		  'icon' =>  	
		    array (size=5)
			    icon => file表单的name名
		   		name => 上传的文件名
		   		type => 上传的文件类型
		   		tmp_name => 临时文件
		   		error => 错误号 0:没错 	 非0:有错
		   		size => 上传的文件大小

```

​	

​	上传文件初版：

```
	function upload()
	{
		#1.检测文件是否符合服务器大小限制（$_FILES是否为空）
        $key=key($_FILES);			
        if(is_null($key)){			#若超过8M，错误号2，post协议不通过，FILES数组为空
            echo '文件太大，上传失败';
            echo <meta http-equiv="refresh"content="3;url='.$_SERVER['HTTP_REFERER'].'">;
            die;			#回到上一级
        }
        
        #2.获取错误号，输出错误信息
        $error=$_FILES[$key]['error'];		#获取当前错误号
        if($error!=0){				#若错误号不为0，即上传失败，输出原因
            switch($error){
                case1:echo '文件太大，上传失败';break;
                case2:echo '文件太大，上传失败';break;
                case3:echo '网络中断';break;
                case4:echo '未上传文件';break;
                case6:echo '服务器繁忙（服务器存储目录丢失）';break;
                case7:echo '服务器繁忙（权限不足）';break;
            }
            echo <meta http-equiv="refresh"content="3;url='.$_SERVER['HTTP_REFERER'].'">;
            die;
        }
        
        #3.检测是否是post上传过来的
        $tmp=$_FILES[$key]['tmp_name'];		#获取缓存目录
        if(!is_uploaded_file($tmp)){		#是否通过post发送
            echo '非法上传';
            echo <meta http-equiv="refresh"content="3;url='.$_SERVER['HTTP_REFERER'].'">;
            die;
        }
        
        #4.检测文件类型是否符合要求
        $type=strtok($_FILES[$key]['type'],'/');	#获取文件类型
        $allowType=['image'];						#准备允许的类型
        if(!in_array($type,$allowType)){
            echo '上传类型不符合要求'；
            echo <meta http-equiv="refresh"content="3;url='.$_SERVER['HTTP_REFERER'].'">;
        }
        
        #5.设计新的文件名（唯一）(格式：20190423xxxx.jpg)
        $suffix=strrchr($_FILES[$key]['name'],'.');		#4.1获取扩展名
        $filename=date('Ymd').uniqid().$suffix;	#产生唯一ID
        
        #6.设置存储目录	upload/年/月/日/
        $dir='upload/'.date('/Y/m/d/');
        if(!file_exists($dir)){
            mkdir($dir,0777,true);
        }
        #7.移动临时文件到存储目录
        if(move_upload_file($tmp,$dir.$filename)){
            echo '上传成功';
        }else{
            echo '上传失败';
        }
	}


```

​	上传文件完全版：

```
	/**
	 * upload 单文件上传
	 * @param  string $saveDir   存储目录
	 * @param  array  $allowType 允许类型
	 * @return string 错误信息            
	 * @return array  新的文件名            
	 */
	function upload($saveDir='uploads/',$allowType=['image'])
	{
		#1.检测文件是否符合服务器大小限制（$_FILES是否为空）
        $key=key($_FILES);			
        if(is_null($key)){			#若超过8M，错误号2，post协议不通过，FILES数组为空
            return '文件太大，上传失败';			#返回信息
        }
        
        #2.获取错误号，输出错误信息
        $error=$_FILES[$key]['error'];		#获取当前错误号
        if($error!=0){				#若错误号不为0，即上传失败，输出原因
            switch($error){
                case 1:return '文件太大，上传失败';break;
                case 2:return '文件太大，上传失败';break;
                case 3:return '网络中断';break;
                case 4:return '未上传文件';break;
                case 6:return '服务器繁忙（服务器存储目录丢失）';break;
                case 7:return '服务器繁忙（权限不足）';break;
            }
        }
        
        #3.检测是否是post上传过来的
        $tmp=$_FILES[$key]['tmp_name'];		#获取缓存目录
        if(!is_uploaded_file($tmp)){		#是否通过post发送
            return '非法上传';
        }
        
        #4.检测文件类型是否符合要求
        $type=strtok($_FILES[$key]['type'],'/');	#获取文件类型
        if(!in_array($type,$allowType)){
            return '上传类型不符合要求'；
        }
        
        #5.设计新的文件名（唯一）(格式：20190423xxxx.jpg)
        $suffix=strrchr($_FILES[$key]['name'],'.');		#4.1获取扩展名
        $filename=date('Ymd').uniqid().$suffix;	#产生唯一ID
        
        #6.设置存储目录	upload/年/月/日/
        $dir=$saveDir.date('/Y/m/d/');
        if(!file_exists($dir)){
            mkdir($dir,0777,true);
        }
        #7.移动临时文件到存储目录
        if(move_uploaded_file($tmp,$dir.$filename)){
            return [$filename];
        }else{
            return '上传失败';
        }
	}
	
	$result=upload();
	if(is_array($result)){
        notice('上传成功','http://www.baidu.con');
	}else{
        notice($result);
	}
	
	/**
	 * notice 提示信息
	 * @param  string  $info 提示信息
	 * @param  string  $url  提示之后的跳转地址
	 * @param  integer $time 几秒后进行跳转
	 */
	function notice($info,$url=null,$time=3)
	{
        echo $info;
        if($is_null($url)){
            $url=$_SERVER['HTTP_REFERER'];
        }
        echo "<meta http-equiv='refresh' content='{$time}; url={$url}'>";
        die;
	}

```

### 10.文件下载

#### 1.步骤

​	1.接收下载的文件名

```
	$name = $_GET['name'];
	$suffix=strchr($name,'');

```

​	2.凑完整的路径

```
	$path = './download/'.$name;

```

​	3.准备下载之后的名字

```
	$filename=str_shuffle(md5($name)).$suffix;
	header("content-disposition:attachment;filename={$filename}");

```

​	4.读取文件内容	

```
	readfile($path);

```



]]></content>
      <categories>
        <category>学习笔记</category>
      </categories>
      <tags>
        <tag>PHP</tag>
        <tag>后端</tag>
        <tag>文件操作</tag>
      </tags>
  </entry>
  <entry>
    <title>PHP接口开发常用API</title>
    <url>/2018/10/25/PHP%E6%8E%A5%E5%8F%A3%E5%BC%80%E5%8F%91%E5%B8%B8%E7%94%A8API/</url>
    <content><![CDATA[


## 1 接口 API


接口一 返回 json  新闻接口

    API地址    天行数据
    http://api.tianapi.com/keji/?key=你的APIKEY&num=20
        请求参数:
        必须参数:
            apikey: 必须有API密钥(url参数)
            num:  返回文章数量 默认10(url参数)
        可选参数:
            rand: 是否随机获取 默认0为不随机
            word: 关键字
            page: 分页 默认1

接口二 返回 xml 最新影讯信息

    API 地址    聚合数据文档:
    https://www.juhe.cn/docs/api/id/94

## 2 curl

curl_init()
curl_setopt()
curl_exec()
curl_close()

## 3.1 json处理

json_decode
json_encode

## 3.2 xml处理

 parseXML (XML解析器)
 XMLReader
 DOM
 SimpleXML

## 4 框架处理接口

https://blockchain.info/api/exchange_rates_api

## 5 范例

```
eg1 -- json 数据处理:
    // CURL
    $curl = curl_init();
    // var_dump($curl);

    $apikey = '请使用你自己的APIKEY';

    // url 编码数据
    $word = urlencode('大米');
    // var_dump($word);exit;

    $url = 'http://api.tianapi.com/keji/?key='.$apikey.'&num=20&word='.$word;

    // URL 设置
    curl_setopt($curl, CURLOPT_URL, $url);
    // 将curl_exec()获取的信息以字符串返回，而不是直接输出。
    curl_setopt($curl, CURLOPT_RETURNTRANSFER, TRUE);

    // CURL 执行
    $data = curl_exec($curl);

    curl_close($curl);

    // 判断 处理结果 $data...
    // var_dump($data);

    // 处理 JSON 数据
    $jsonObj = json_decode($data);
    // var_dump($jsonObj);
    // 提取文章信息
    $newslist = $jsonObj->newslist;
    // var_dump($newslist);
```



```
eg2 -- xml数据处理:

$movieName = empty($_GET['m'])?'':$_GET['m'];
$movie = urldecode($movieName);
$key = '请使用自己的APIKEY';
$url = 'http://op.juhe.cn/onebox/movie/video?key='.$key.'&dtype=xml&q='.$movie;

// CURL
$curl = curl_init();

// URL 设置
curl_setopt($curl, CURLOPT_URL, $url);
// 将curl_exec()获取的信息以字符串返回，而不是直接输出。
curl_setopt($curl, CURLOPT_RETURNTRANSFER, TRUE);

// CURL 执行
$data = curl_exec($curl);
$obj = simplexml_load_string($data);

echo '<pre>';
    // print_r($data);
    // print_r($obj);
    // var_dump($obj);
echo '</pre>';

curl_close($curl);
```



------------------------
## API平台

阿里云云市场: https://market.aliyun.com/
天行数据: https://www.tianapi.com/
聚合数据: https://www.juhe.cn/
易源数据: https://www.showapi.com/
百度API Store平台: http://apistore.baidu.com/
七牛云: https://www.qiniu.com
阿里大于(通信): https://dayu.aliyun.com/
容联云通讯: http://www.yuntongxun.com/

地图SDK:
高德地图开放平台: http://lbs.amap.com/
百度地图开放平台: http://lbsyun.baidu.com/

BAT:
微信开放平台: https://open.weixin.qq.com/
腾讯开放平台: http://open.qq.com/
百度开发者中心: https://developer.baidu.com/
淘宝开放平台: http://open.taobao.com/
阿里云开发者平台: https://dev.aliyun.com/search.html

支付接口:
支付宝开放平台(蚂蚁金服): https://open.alipay.com
微信支付: https://pay.weixin.qq.com/wiki/doc/api/index.html

登录/应用类:
QQ互联: https://connect.qq.com
新浪微博开放平台: http://open.weibo.com/
优酷开放平台: https://open.youku.com/
饿了么开放平台: http://openapi.eleme.io/
百度AI开放平台: https://ai.baidu.com/
讯飞开放平台: http://www.xfyun.cn/
百度翻译开放平台: http://api.fanyi.baidu.com/

工具:
百度富文本编辑器(UEditor):
http://ueditor.baidu.com/website/
ECharts 百度Javascript的图表库:
http://echarts.baidu.com/
蚂蚁金服数据可视化:
https://antv.alipay.com/zh-cn/index.html
BizCharts 数据可视化:
https://github.com/alibaba/BizCharts

---------------------------------------
PS.

精美图标 支持搜索
http://www.easyicon.net/

极验验证
http://www.geetest.com/

Amaze UI
http://amazeui.org/

MUI
http://dev.dcloud.net.cn/mui/

zui性感的框架
http://www.zui.sexy

Layui
http://www.layui.com/doc/
http://layer.layui.com/
]]></content>
      <categories>
        <category>开发资料</category>
      </categories>
      <tags>
        <tag>PHP</tag>
        <tag>后端</tag>
        <tag>接口</tag>
      </tags>
  </entry>
  <entry>
    <title>PHP-OOP面向对象</title>
    <url>/2018/05/13/PHP-OOP%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/</url>
    <content><![CDATA[
## 2.面向对象

### 1.类简介

> 主要内容包括 类 和 对象

1.类

​	class类中主要两种元素，函数（方法），变量（属性）

​	函数不调用不执行功能，类不实例化为对象无法使用

2. 设计类的时候，需要考虑什么：（一切皆对象）

   该类有什么（属性）？

   该类会什么（方法）？

3. 注意：

   - 类本身是无法执行的，本身是虚构的，不存在的
   - 对象才是真正能使用的

4. 类与对象之间的关系

   - 类 就是对象的抽象化
   - 对象 就是类的实例化

5. 格式

```
	class 类名
	{
        成员属性
        成员方法
	}

```

6.实例

```
	class Beauty
	{
		public $name = '迪丽热巴';		#属性
		public $age = 18;
		public $weight = '90斤';
		public $height = '180cm';

		public function skill1()		#方法
		{
			echo '吹';
		}
		public function skill2()
		{
			echo '拉';
		}
		public function skill3()
		{	
			echo '弹';
		}
		public function skill4()
		{	
			echo '唱';
		}
	}

	$obj = new Beauty;		#实例化

	echo $obj->name;		#对象 -> 属性名
	echo $obj->height;
	echo $obj->weight;
	
	$obj->skill1();		#对象 -> 方法名()
	$obj->skill2();
	$obj->skill3();

```

总结：

​	1、在使用之前，要先将类实例化为对象，即：`类->对象` 

​	 `$对象名 = new 类名;` 	

​	2、输出属性时，格式为：`对象 -> 属性名` 

​	 `echo $obj->name;`

​	3、调用方法时，格式为：`对象 -> 方法名()` 

​	 `$obj->skill();` 

### 2.伪对象

1.定义

​	在类的内部，可以使用自己的属性or方法，此时， `$this` 代表当前对象

称为伪对象

2.实例

```
class Beauty
	{
		public $name = '迪丽热巴';
		public $age = 18;
		public $weight = '90斤';
		public $height = '180cm';
		public function skill1(){echo '吹';}
		public function skill2(){echo '拉';}
		public function skill3(){echo '弹';}
		public function skill4(){echo '唱';}
		public function demo(){
// 类的内部, 使用自己的属性or方法
				$x = new Beauty;
				echo $x->name;
				$x->skill4();
				echo '<hr>';

				echo $this->name;
				$this->skill4();
				echo '<hr>';
				}
		}
	}

```

总结：

​	伪对象`$this `代表当前对象, 在哪个类中使用, 就相当于` $this = new 当前类名 ` 

​	 `$this `不需要实例化, 可直接使用. 

​	 `$this `只能在类内使用

### 3.连贯操作

​	若要在执行时连续调用方法，可采用如下格式：

​	1. `$obj->step1()->step2()->step3()...;`

​	2.将连续调用的前面的方法加上`return $this` 

注意：若直接采用1，而不return返回对象，会报错 `Call to a member function step2() on null` 相当于`null->step2()`

### 4.魔术方法

#### 1.定义：

​	魔术方法，就是在指定条件触发时，会自动调用的方法，这里主要介绍两种

​	`__construct()` 构造方法

​	`__destruct()` 析构方法

#### 2.构造方法

​	触发条件：在实例化时，自动触发

​	使用场合：常用于初始化属性

​	注意：一般构造都写在方法的最前面，属性的最后面

```
	class Lengend
	{
		#构造方法
		public function __construct()
		{
			echo '<h1>欢迎来到召唤师峡谷</h1>';
		}
		#普通方法
		public function demo()
		{
			echo '升段局，掉2挂1，人马加大树强撑40分钟，队友重连绝地翻盘<hr>';
		}
	}

	$obj=new Lengend;
	$obj->__construct();
	// $obj->demo();

```

#### 3.析构方法

​	触发条件：当对象被销毁时，自动触发，包括：

​		1）.程序全部执行完，自然销毁

​		2）.对象被主动删除了

​		3）.对象被覆盖了（更换）

​	使用场合：当对象使用完的一些扫尾操作（fclose、closedir）

​	注意：一般析构方法都写在方法的最后面

```
	class Lengend
	{
		public function demo()
		{
			echo '开始一盘游戏';
			echo '<hr>';
		}
		public function __destruct()
		{
			echo '关上电脑';
		}
	}
	$obj=new Lengend;
	$obj->demo();
	echo '断电了<br>';
	
	unset($obj);		#2)对象被主动删除

	$obj='迪丽热巴';		 #3)换对象了
							#1)自然结束，就会销毁$obj,从而触发析构

```



#### 4.实例化PDO类

​	PDO 数据抽象层，专门负责数据库操作管理

```
	$dsn='mysql:host=localhost;dbname='test';charset=utf8;
	$user='root';
	$pwd='';
	$pdo=new PDO($dsn,$user,$pwd);	#1.链接数据库
	$sql='select id,nickname,tel,address from user';  #2.编写sql语句
	$pdostatement=$pdo->query($sql);	#3.执行sql语句
	$result=$pdostatement->fetchAll(PDO::FETCH_NUM);	#4.解析对象
	var_dump($result);	#5.输出结果

```

总结：

​	1.`PDO类::方法` 

- PDO::query( )		执行一条SQL语句

  成功返回PSOStatement，适合查询，失败返回false

- PDO::exec( )                   执行一条SQL语句

  成功返回受影响的行数，适合增删改，失败返回false

- PDO::lastInsertId( )       获取最近一次插入的ID

  成功返回最新的id，失败返回 `'0'` 字符

- PDO::errorInfo( )           获取错误信息



​	2.`PDOStatement类::方法 `

- PDOStatement::fetch( )	  获取结果集中的一条数据（依靠指针）失败返回false
- PDOStatement::fetchAll( )     获取结果集中的所有数据，参数设置显示格式
  - PDO::FETCH_NUM	索引数组格式
  - PDO::FETCH_ASSOC     关联数组格式
  - PDO::FETCH_BOTH       混合数组格式

## 3.OOP面向对象

面向对象OOP的三大特性：1.封装性 ；2.继承性 ；3.多态性

### 1.封装性

- 定义：将对象的所有成员结合在一起，形成一个不可分割的独立单位

- 目的：尽可能的隐藏属性 和 方法，只留下部分接口与外部联系

- 提供以下三种修饰符，来控制与外部的联系

  |  修饰符   | 本类 | 继承类 | 类外 |          |
  | :-------: | :--: | :----: | :--: | :------: |
  |  public   |  √   |   √    |  √   |  公有的  |
  | protected |  √   |   √    |  x   | 受保护的 |
  |  private  |  √   |   x    |  x   |  私有的  |

  > 想要有高安全性 或者 只想自己使用的，最好设置为private。

### 2.魔术方法

> 如果在类外使用私有属性或方法，程序会立即终止并报错
>
> 为了避免终止程序，可以使用一些魔术方法做提示，并绕过error错误

- `__get($x)`

  当访问权限不足或不存在的属性时，自动触发，返回访问属性名

- `__set($x,$y)` 

  当设置权限不足或不存在的属性时，自动触发，返回设置属性名和值

- `__unset($x)` 

  当删除权限不足或不存在的属性时，自动触发，返回要删除的属性名

- `__isset($x)` 

  当判断是否存在的目标权限不足或不存在时触发，返回要判断的属性名

- `__call($x,$y)` 

  当访问权限不足或不存在的方法时，自动触发，返回方法名和实参

- `__tostring()` 

  当echo对象时触发，返回字符串值

### 3.继承性

1. 定义：**子类**（-派生类/扩展类）继承**父类**（基础类/基类）的一些属性和方法

2. 格式

   `class 子类 extends 父类 {}` 

3. 实例

   ```
   	class laozi
   	{
   		public $name = '老王';
   		public function skill()
   		{
   			echo  '喜欢去隔壁转转 <br>';
   		}
   	}
   	class son extends laozi
   	{
   	}
   	$obj = new son;		#实例化子类
   	echo $obj->name;	#直接调用子类继承的属性
   	$obj->skill();		#直接调用子类继承的方法
   
   
   ```

4. 特点

- 子类可以继承属性，方法（除了private）

- 子类可以重写属性，方法

- 子类可以扩展方法 `parent::父级方法名` 

- 访问级别：

  `private>protected>public` 

  子类继承父类时，修饰符可以保留等级，可以降级，就是不能升级

5. 继承方式
   1. 单继承（一个子级可以继承一个父级）
   2. 连续继承（爷->父->子->孙   依次继承）
   3. 多继承（无法在PHP中实现）





### 4.类静态

1.关键字：

​	 **static**   

2.格式：

​	`static 修饰符 $属性名=属性值；` 

​	`static 修饰符  function  方法名（）{};` 

3.使用格式：

​	`类名::静态属性名` / `类名::静态方法名()` 

​	self 代表当前的类名，只能在类内使用

​	$this 代表当前的对象

```
	class Beauty
	{
		static public $name = '小张';		#设置静态属性
		// public $age = 18;		#静态类内不能使用非静态属性
		static public function demo()	#设置静态方法
		{
			echo 'i am static demo <hr>';
			echo self::$name;	#类内调用静态属性
			echo '<hr>';
		}
	}
	Beauty::demo();		#引用静态方法

```



4.特性：

- 静态属性或方法 不需要实例化就可以直接使用
- 静态方法内部只能使用静态属性或方法
- 静态属性和方法可以继承

5.魔术方法

​	 `__callStatic($x,$y)` 

​	在访问不存在的静态方法时，自动触发，返回静态方法名和实参

### 5.类常量

1.格式

​	`const  类常量名=值；` 

2.使用类常量

​	`类名::类常量` 

3.特性

- 类常量可以继承，且可以重写一次
- 普通常量可以直接在类内使用（常量没有作用域）
- 类常量不能直接在类外使用，必须要通过类名来使用

```
	const NAME = '黑寡妇';
	class Beauty
	{
		const SEX = '美女';	#定义类常量
		public function demo()
		{
			echo self::SEX;
			echo NAME; 	# 直接输出类外的 普通常量NAME
		}
	}
	echo Beauty::SEX;	#输出类内常量

```

### 6.最终 final

#### 1.使用：

```
final class Beauty		#final 修饰类，保护不被继承
	{
		public $name = '陈琳琳';
	}
	------------------------------------------------------
class Father
	{
		final public function Order()	#final修饰方法
		{
			echo '这是祖辈留下的祖训: 不能吃猪肉 <br>';
		}
	}

```

#### 2.特性

- final 可以修饰类和方法，不能修饰属性
- final 修饰类，保护类不被继承
- final 修饰方法，保护方法不被继承方法重写

### 7.克隆对象 clone

#### 1.格式

​	 `副本对象 = clone 样本对象；` 

#### 2.使用

```
class Beauty
	{
		public $name = '米拉乔沃维奇';
	}

	$a = new Beauty;	#创建一个对象
	$b = clone $a;		#克隆对象

```

#### 3.特性

​	副本与样本对象完全一样，却互不影响，完全独立

> 克隆（clone）与复制出来的对象不一样，修改克隆副本对原样本没有任何影响，而修改复制对象则会影响原样本，相同点是删除副本对原样本都没有影响，原因如下：
>
> ​	变量与内存是通过标识来引用的；
>
> ​	删除原样本，只是删除元样本和标识之间 的联系，与复制副本无关；
>
> ​	息息相关的只是内存的内容

#### 4.克隆魔术方法 

##### 1.函数：

​	`__clone()` 

##### 2.作用：

​	克隆操作时触发，可以为克隆副本重新初始化属性

##### 3.实例

```
	class Demo
	{
		public $name='kamora';
		public function __clone()
		{
			$this->name='kamora2';	#克隆对象重写
		} 
	}

	$a=new Demo;
	$b=clone $a;	#克隆操作

	var_dump($a,$b);

```

### 8.串行化/序列化

#### 1.函数

​	串行化： `serialize( )` 

​	反串行化： `unserialize( ) ` 

#### 2.目的

​	将对象串行化为字符串

#### 3.使用场景

​	传参，存入文本，存数据库 ...

#### 4.实例

```
	$obj=new Game;			#创建一个对象
	$str= serialize($obj);		#串行化对象，存入变量
	file_put_contents('./save.txt',$str);	#将变量内容存入文件
	
	$newStr=file_get_contents('./save.txt');  #读取文件内容	
	$newObj=unserialize($newStr);	#对读取内容反串行化
	$newObj->skill();	#使用对象属性方法

```

#### 5.串行化魔术方法

##### 1.函数：

- `__sleep( )` 		

​	serialize串行化时触发,用以返回需要的信息(数组形式)

- `__wakeup( )`  	     

  unserialize反串行化时触发, 用以重新初始化属性

##### 2.应用:

```
  	class Game
  	{
  		public $name = 'DNF';
  		public $money = 200000;
  		public function skill()
  		{
  			echo '崩山斩';
  		}
  		public function __sleep()
  		{
  			// 返回需要显示的信息(以数组形式返回)
  			return ['name','nickname'];
  		}	//其余信息隐藏,实际上还是存在
  
  		public function __wakeup()
  		{
  			// 在唤醒时, 重新初始化属性
  			$this->money = 2;
  		}
  	}

```

### 9.魔术方法---自动加载

> 在真实项目中 , 一个PHP文件内 , 只有一个类 , 没有多余的代码，可以在多PHP相互加载的状态下的纯PHP界面省略定界符`<?= ?>` 中的后面部分，需要引入的HTML文件使用 `include / include ` 加载	

#### 1.格式

```
	function __autoload($x)
	{
        
	}

```

#### 2.作用 : 

​		在实例化一个不存在的类时 ,  自动触发 ,  返回要求实例化的类名

#### 3.使用场景 : 

​		使用数据库功能  ,  上传文件功能  ,  图形验证码功能等....

#### 4.实例:

```
	一次性加载所有的类文件:
	function __autoload()
	{							#如果相关类文件存在
        if( file_exists("./Model/{$x}.php") ){
            include "./Model/{$x}.php";
        }else{
            header('location:404.php');	#跳转到404页面
            die;
        }
	}
	$a=new DB;	#实例化数据库类
	$b=new Upload;	#实例化上传类


```





### 10.抽象

#### 1.抽象

> 抽象方法 : 没有方法体( 代码块 ) 的方法
>
> 抽象类 : 包含抽象方法的类

1.关键字

​	`abstract` 

2.特性

- 包含抽象方法的类必须为抽象类
- 抽象类不一定需要包含抽象方法
- 抽象类不能被实例化
- 抽象类必须被子类继承 , 并实现抽象方法

3.目的

​	强制约束子类继承并实现抽象方法

```
    abstract class Demo			#定义抽象类
	{
            public function func1()
            {
                echo '该项目已经完成了 20% <br>';
            }
            abstract public function func2(); 	#定义抽象方法
 	}
     class Friend extends Demo		#子类继承抽象类
     {
            public function func2()		#子类事项抽象方法
            {
                echo '该项目已经完成了 30% <br>';
            }
      }
	$obj = new Friend;		#实例化子类,调用方法

```

#### 2.接口

1.定义

​	当类中全部都是抽象方法时,可定义为接口	

​	即接口就是抽象类( 条件 : 内部方法全部为抽象方法 ) 

2.特性

​	接口继承是通过 `implements` 关键字继承的 (不是extends)

​	接口可以实现多继承( 可以有多个父类,分别实现各个父类继承的抽象方法 )

```
    interface Demo	#定义接口Demo
    {
        public function func1();	#内部方法全部为抽象方法
        public function func2();
        public function func3();
    }	
    class Friend implements Demo  #子类继承Demo
	{
		public function func1()		#子类实现继承的抽象方法
		{
			echo '该项目已经完成了 20% <br>';
		}

		public function func2()
		{
			echo '该项目已经完成了 50% <br>';
		}

		public function func3()
		{
			echo '该项目已经完成了 30% <br>';
		}
	}
	$obj = new Friend;	#实例化子类
	$obj->func1();		#调用Demo方法

```

#### 3.类型约束

> PHP支持的函数实参类型约束有**数组**和**对象** 

格式 : 方法名( 类名 变量 )|方法名( array 变量 )

```
function demo(array $x)	#约束送入的实参只能是数组类型
	{
		var_dump($x);
	}
	
	// demo($a=100);	#送入整型数据程序报错
	$b = [10,20,30];	
	demo($b);			#送入数组,正常输出

```

```
	class Demo1 {}

	class Demo2
	{
		public function Test(Demo1 $x)  #要求送入Demo1对象
		{
			var_dump($x);
		}
	}
	
	class Demo3 {}

	$demo1 = new Demo1;		#实例化类,得到对象
	$demo2 = new Demo2;
	$demo3 = new Demo3;

	$demo2->Test($var=100);		#送入整型数据,程序报错
	$demo1->Test($demo1);	#送入demo1,正常输出

```

#### 4.接口多态性

> 多态性 : 通过同一个接口 [ 抽象类|普通类 ] ,传入不同的设备,从而实现不同的效果
>
> ( 普通类没有强制约束子类执行指定方法的特征 , 不推荐使用 )

```
	interface USB		#定义接口
	{
        public function run();
	}					#指定抽象方法,一旦实现USB必须执行run方法
	class Mouse implements USB		#继承抽象类
	{
        public function run()		#实现抽象方法
        {
            echo '安装鼠标驱动';
        }
        public function double()	#扩展接入接口的子类方法
        {
            echo '双击功能实现';
        }
	}
	class Keyboard implements USB
	{
        public function run()
        {
            echo '安装键盘驱动';
        }
        public function click()
        {
            echo '击键功能实现';
        }
	}
	class Computer		#设置接口使用环境
	{
        public function Start(USB $x)	#接入接口
        {
            $x->run();
        }
	}
	
	$c=new Computer;		#实例化
	$m=new Mouse;
	$k=new Keyboard;
	
	$c->start($m);		#依接入类型运行接口方法
	$c->start($k);	#?如何使用double()

```

#### 5.foreach遍历对象

> foreach不但能够遍历数组,也可以遍历对象

```
	class Book
	{
        public $name;	#成员属性只能定义,不赋初值
        public $price;
        private $author;
        public function __construct($a,$b,$c)	#初始化属性
        {
            $this->name = $a;
            $this->price= $b;
            $this->author=$c;
        }
        $zhang=new Book('《新三国》','30元','小飞');
        $cheng=new Book('《旧三国》','50元','阿亮');
	}									#类外依旧受修饰符影响
	foreach($zhang as $key => $value){	
        echo $key.'------'.$value.'<br>';
	}
	foreach($cheng as $key => $value){
        echo $key.'------'.$value.'<br>';
	}
```

注意: 遍历对象是将对象中的  ( 属性名=>属性值 )  遍历显示

#### 6.对象相关函数

- 判断类是否存在

  `class_exists( '类名' )`	返回bool值

- 判断某个类下的属性是否存在

  `property_exists( '类名','属性名' )` 	返回bool值

  > 可以检测私有属性,但不显示具体值

- 获取类中的所有公有属性

  `get_class_vars( '类名' )`	返回数组, 包含属性名和属性值

- 获取对象中的所有公有属性

  `get_object_vars( '对象' )`	返回数组, 包含属性名和属性值

- 获取类中的所有公有方法

  `get_class_method( '类名' )`	返回索引数组, 包含所有方法名

- 获取某个对象的类名

  `get_class( '对象' )`	返回字符串, 类名

]]></content>
      <categories>
        <category>学习笔记</category>
      </categories>
      <tags>
        <tag>PHP</tag>
        <tag>后端</tag>
      </tags>
  </entry>
  <entry>
    <title>PHP 简介-背景特性</title>
    <url>/2017/11/14/PHP%E7%AE%80%E8%BF%B0-%E8%83%8C%E6%99%AF%E7%89%B9%E6%80%A7/</url>
    <content><![CDATA[
## 1. PHP应用领域

> 在浏览器端应用的软件, PHP都可以进行开发

- 门户网站: 新浪, 雅虎, 搜狐
- 电子商务: 淘宝, 京东
- 网页游戏的后台
- APP接口
- 企业级项目:
  - OA: 办公自动化系统   (学生, 员工档案, 考勤...)
  - CRM: 客户关系管理系统   (销售, 中介, ...)
  - ERP: 企业物资管理系统 ( 快递, 猎头, .. )



## 2. PHP市场行情

拉勾网

Boss直聘

含金量较高:  100Offer 		门槛: 2年以上的工作经验





## 3. 软件架构模式

### 	B/S

**brower/server**  浏览器/服务器

- 无需下载, 通过浏览器来使用
- 依赖HTTP协议
- 数据存储服务器上, 安全性高
- 维护更新, 相对方便, 不占用用户时间





### 	C/S

**client/server**  客户端/服务端

- 先下载安装, 通过特定的客户端来使用
- 通过多种协议进行通信
- 数据有的存储在本地, 有的存储在服务器上, 相比B/S安全性低
- 维护更新, 相对麻烦, 比较占用用户时间



## 4.动静态网站

### 静态网站

在线浏览网页, 但是不能输入数据, 没有数据的更新和交互

### 动态网站

有数据交互过程, 链接数据库



## 5. 浏览器

### 内核浏览器

**Trident**:  IE 	独流

**Webkit**:  chrome, safari 

**Gecko**: firefox

**Blink**: chrome



### 壳浏览器

360

QQ

搜狗

猎豹

UC

百度

## 6. 开发工具IDE

- Sublime Text 3   最轻量级的IDE
- PHPStrom   最专业, 最热门的IDE之一
- ATom
- Zend Studio
- VIM 
- NodePad++



## 7. LAMP 环境

LAMP : Linux + Apache + MySQL + PHP 

LNMP: Linux + Nginx + MySQL + PHP



操作系统: Linux

服务器: Apache, Nginx

数据库: MySQL

脚本工具: PHP

## 8.使用PHP的特性

**PHP特性**：

1.PHP文件或者文件夹命名中不能有中文，不能有中文路径。

2.PHP文件存放位置：`wamp/www/`目录下。

3.访问PHP脚本的步骤：

​	开启wamp服务——>在浏览器地址栏中输入：`localhost`

4.**PHP是什么**：（`Professional Hypertext Preprocessor`）超文本预处理器

**一句话**：**一种用来开发动态网站的服务器脚本语言**。

5.**PHP定界符**

​	格式：`<?php       PHP代码         ?>`

​	只有在定界符内的代码才会被PHP解析

6.向浏览器输出一句话：`echo 'hello,world!';`

7.**PHP设置编码**（一般情况下，该编码声明写在文件头部）

​	`header('content-type:text/html;charset="utf-8"');`

8.**注释**

单行注释：`#注释内容`	or	`//注释内容`

多行注释：`/*注释内容*/`

9.**PHP基本语法**

- 每一条命令均以分号（；）结尾，代表这条命令已经结束。
- 只有最后一条可以不加，但推荐都加上。

10.查询PHP相关信息

​	`phpinfo();`

11.若只想输出一句话，可以使用如下格式：

​	`<?='hello,world!'?>`

​	`<?php echo 'hello,world!'?>`]]></content>
      <categories>
        <category>杂谈</category>
      </categories>
      <tags>
        <tag>PHP</tag>
        <tag>后端</tag>
      </tags>
  </entry>
  <entry>
    <title>Redis-使用</title>
    <url>/2018/09/22/Redis%20%E4%BD%BF%E7%94%A8/</url>
    <content><![CDATA[
## 安装

```sudo apt-get install redis-server```

## 进入cli控制台

```redis-cli```

## str命令讲解

**set**
```set key value```

setnx  设置k  防止重复 .如果重复会直接返回0

```
setnx key value
```

setex 设置一个k  并且给有效期    expire
用法: setex k 生成时间(秒单位) v

```
setex key int(秒单位) value
```

ttl 以秒为单位返回 key的剩余生存时间
	key 不存在 -2
	key 存在没有设定时间  -1
	key 存在设定过期时间   返回剩余时间

```
ttl key
```

```
127.0.0.1:6379> set name yinkai
OK

127.0.0.1:6379> get name
"yinkai"

127.0.0.1:6379> set yinkai
(error) ERR wrong number of arguments for 'set' command
127.0.0.1:6379> set name anjing
OK
127.0.0.1:6379> get name
"anjing"
127.0.0.1:6379> setnx name yinkai
(integer) 0
127.0.0.1:6379> get name
"anjing"
127.0.0.1:6379> setnx age 18
(integer) 0
127.0.0.1:6379> setnx anage 18
(integer) 1
127.0.0.1:6379> get anage
"18"
127.0.0.1:6379> setex run 10 yinkaipaoyipao
OK
127.0.0.1:6379> get run
"yinkaipaoyipao"
127.0.0.1:6379> get run
(nil)
127.0.0.1:6379> setex action 30 macbookpro_2kuai
OK
127.0.0.1:6379> get action
"macbookpro_2kuai"
127.0.0.1:6379> ttl action
(integer) -2
127.0.0.1:6379> setex action 30 macbookpro_2kuai
OK
127.0.0.1:6379> ttl action
(integer) 28
127.0.0.1:6379> ttl action
(integer) 27
127.0.0.1:6379> ttl action
(integer) 26
127.0.0.1:6379> ttl action
(integer) 25
127.0.0.1:6379> ttl action
(integer) 24
127.0.0.1:6379> ttl name
(integer) -1
127.0.0.1:6379> 
```

------

批量设置 
mset k1 v1 k2 v2 k3 v3........

批量获取
mget k1 k2 k3 k4.......

```
127.0.0.1:6379> mset name luo age 18 sex 110
OK
127.0.0.1:6379> get sex
"110"
127.0.0.1:6379> mget name sex age
1) "luo"
2) "110"
3) "18"



```

批量设置不存在的 键和值(当其中有key不存在,则直接失败.)
msetnx k1 v1 k2 v2 k3 v3........

#### 1.str命令

**浏览量**(++ --)

```
incr  自增+1 返回自增之后的结果
decr  自减-1 返回自减之后的结果

incrby 键名 数值 (增加指定数量)
	(若该字段不存在,则会先创建默认值为0的字段)
	eg:incrby age 100
decrby 键名 数值 (减去指定数量)
	eg:decrby age 100

del 键名 (删除指定键)
```

#### 2.hash命令

**存放二维数组**

```
hset 键名 字段 字段值
hget 键名 字段
```

**批量处理**
	hmset 键名 字段1 值1 字段2 值2 字段3 值3 ...
	hmget 键名 字段1 字段2 字段3 ...

**批量获取**
	hkeys 键名 (返回指定键名中的所有字段名)
	hvals 键名 (返回指定键名中的所有字段值)
	hlen  键名 (返回指定键值对中含有的段数量)

```
hgetall 键名 (返回指定键中所有的字段名+字段值)
```

**增删**
	hincrby 键名 字段名 数值 (给hash键红指定的整形字段添加数值)
		eg:hincrby 001 age 10

```
hdel 键名 字段1 字段2 字段3 ....(删除指定字段)
	eg: hdel 001 age name 
```

------

**del 和 hdel 区别**
	del 删除一整个价值对

​	hdel 只删除某个键值对的一个字段

hash小结
hset
hmset
hdel  del
hget hmget  hgetall hkeys hvals
hincrby
判断:hexists
	hexists 键名 字段名   (查询指定键值对中是否存在该字段, 存在返回1,不存在返回0)

<hr/>
list 是链表

特点是 :  有序  队列

先进后出

------

#### 3.链表命令

**创建插入**
	lpush 从队列左边插入数据
	rpush 从队列右边插入数据

**从左到右显示**
	lrange 键名 起始下标 终止下标  
			(从队列中获取指定的值,从左边开始)

------

**下标指定**: 0 第一个 1 第二个

​		 	-1 最后一个  -2 倒数第二个

**指定位置插入**
	linsert 键名 after|before 原值 新值

**删除指定元素**

​	lrem 键名 数量&方向 值 (删除指定数量的指定值,返回删除的数量)

```
n > 0 从头向尾搜索,删除 n 个元素
n < 0 从尾向头搜索,删除 n 的绝对值个元素
n = 0 删除所有指定值得元素
```

------

**提取链表中信息**
	lindex 键名 下标 (提取列表中指定下标的元素的值) 

```
llen 键名  (获取列表的长度)
```

**设置链表信息**
	lset 键名 下标 内容 (设置指定下标内容,返回ok)

**删除元素(首尾)**
	lpop 键名 (左边删除一个元素,返回被删除的元素)
	rpop 键名 (右边删除一个元素,返回被删除的元素)

```
ltrim 键名 起始下标 截止下标  (截取指定首尾下标的元素)

rpoplpush 键名 源队列 目标队列  (从源队列右边移除最后一元素, 放入一个另一个队列的首部)
eg:
	127.0.0.1:6379> lrange list 0 -1
	7
	6
	5
	4
	3
	127.0.0.1:6379> lrange rlist 0 -1
	1
	2
	3
	4
	5
	6
	127.0.0.1:6379> rpoplpush list rlist
	3
	127.0.0.1:6379> lrange rlist 0 -1
	3
	1
	2
	3
	4
	5
	6
	127.0.0.1:6379> lrange list 0 -1
	7
	6
	5
	4
```

<hr/>
set 集合(string类型的无序集合,成员唯一)

```
集合中包含交集,并集,差集
(适用于推荐算法的实现)
```

####4.set命令

sadd 集合名 元素1 元素2 元素3 ...  (将一个或多个成员元素添加入集合)

smembers 集合名 (显示集合中所有的子元素)

srem 集合名 元素1 元素2 ...   (删除指定集合中一个或多个元素)

spop 集合名  (随机删除一个元素,并且返回删除的元素名)

sismember 集合名 元素  (判断指定元素是否在集合中,返回0/1)

scard 集合名 (统计集合元素的个数)

smove 来源集合 目标集合 元素 (将一个集合中的元素移动到另一个集合)

srandmember 集合名 [count] (返回一个或指定个随机元素组成的集合)

##### set 无序集合

1. **差集**
   sdiff 集合1  集合2 
   返回 集合1  集合2 的差集  以集合1 为主



```
127.0.0.1:6379> flushdb
OK
127.0.0.1:6379> sadd s85 1 2 3 4 5 6 7
(integer) 7
127.0.0.1:6379> sadd s86 6 7 8 9 
(integer) 4
127.0.0.1:6379> sdiff s85 s86
1) "1"
2) "2"
3) "3"
4) "4"
5) "5"
127.0.0.1:6379> sdiff s86 s85
1) "8"
2) "9"
127.0.0.1:6379> sdiffstore diff_s s85 s86
(integer) 5
127.0.0.1:6379> smembers diff_s
1) "1"
2) "2"
3) "3"
4) "4"
5) "5"
127.0.0.1:6379> 

```

------

2. **并集**
   sunion 集合1  集合2    并集

```
127.0.0.1:6379> sunion s85 s86
1) "1"
2) "2"
3) "3"
4) "4"
5) "5"
6) "6"
7) "7"
8) "8"
9) "9"
127.0.0.1:6379> sunionstore uni_s s85 s86
(integer) 9
127.0.0.1:6379> smembers uni_s
1) "1"
2) "2"
3) "3"
4) "4"
5) "5"
6) "6"
7) "7"
8) "8"
9) "9"
127.0.0.1:6379> 


```

------

3. **交集**
   sinter 集合1  集合2   交集

```
127.0.0.1:6379> smembers s85
1) "1"
2) "2"
3) "3"
4) "4"
5) "5"
6) "6"
7) "7"
127.0.0.1:6379> smembers s86
1) "6"
2) "7"
3) "8"
4) "9"
127.0.0.1:6379> sinter s85 s86
1) "6"
2) "7"
127.0.0.1:6379> sinter s86 s85
1) "6"
2) "7"
127.0.0.1:6379> sinterstore inter_s s85 s86
(integer) 2
127.0.0.1:6379> smembers inter_s
1) "6"
2) "7"
127.0.0.1:6379> 


```

------

4. store 存储结果集合

sdiffstore 新集合 集合1  集合2
把返回结果 写入新集合

sinterstore 新集合 集合1  集合2
把返回结果 写入新集合

sunionstore 新集合 集合1  集合2
把返回结果 写入新集合

smove 原集合 目标集合 值
把指定的值 从源集合 中 移动到目标集合

------

##### zset 有序集合

**区别**: set 无序  zset 有序

有序是如何有序的?
	使用 "分数"  .
	有序集合 给每一个元素 设定 "分数"

zadd key 分数1 v1 分数2 v2 分数3 v3 ......

zrange 集合 起始下标 截止下标 [withscores]

```
0 第一个   -1  最后一个
得到所有 0 -1

返回集合中  指定下标区间内元素
如果 加了 withscores  则 连分数一起返回

按照分数排序 **从小到大**
```

```
127.0.0.1:6379> zadd z85 120 yinkai 160 jq 170 xin 175 kui
(integer) 4
127.0.0.1:6379> zrange z85 0 -1
1) "yinkai"
2) "jq"
3) "xin"
4) "kui"
127.0.0.1:6379> zrange z85 0 -1 withscores
1) "yinkai"
2) "120"
3) "jq"
4) "160"
5) "xin"
6) "170"
7) "kui"
8) "175"

```

------

zrevrange 集合 起始下标 截止下标 [withscores]

```
0 第一个   -1  最后一个
得到所有 0 -1

返回集合中  指定下标区间内元素
如果 加了 withscores  则 连分数一起返回

按照分数排序 **从大到小**
```

------

zrem key 值1 [值2 .....]
删除   集合中 指定的值

zincrby key 增量 值
给 集合中指定值得分数(score) 加上 增量   

zrank key 值  
返回集合中指定值的下标  按照 (score)从小到大排序

zrevrank key 值
返回集合中指定值的下标  按照 (score)从大到小排序

zcount key 起始分数  截至分数
统计 该集合 score 在给定分数区间内的元素个数

zcard key
返回集合元素个数



zinterstore key 取交集集合个数 集合1 集合2  [集合3....]
交集 存新集合

zunionstore 取并集集合个数 集合1 集合2  [集合3....]
并集存新集合

总结 :

1. **区别**
        是否允许重复元素   是否有序   有序的实现方式      应用场景
   集合               F                         F                null                     社交 好友推荐等
   有序集合        F                         T                分数                    排行榜 
   列表               T                         T                索引下标             队列 抽奖

2. **使用场景**

string
	计数器
	系统缓存(把对象 数组 串行化再存入string)

list
	队列
	最新N个数据
	实时分析正在发生的情况
	数据统计 
	防止垃圾邮件(set)

hash
	用户数据

set
	unique 操作 获取某段时间内所有数据的排重值
	共同好友  推荐好友
	统计网站访问的所有 独立IP(唯一性)
	实时反垃圾系统

zset
	排行榜(取 top N操作)
	需要 精准设定过期的应用(时间戳 score )

------

公司想要使用reids?怎么做?

第一步: 安装配置 redis
第二步: 安装配置 phpredis
第三步: 得知道基本的语句 5种数据类型  CURD操作

]]></content>
      <categories>
        <category>实际演练</category>
      </categories>
      <tags>
        <tag>Redis</tag>
      </tags>
  </entry>
  <entry>
    <title>Redis-常用操作</title>
    <url>/2018/09/24/Redis%20%E5%B8%B8%E7%94%A8%E6%93%8D%E4%BD%9C/</url>
    <content><![CDATA[
## php操作redis常用方法

1.connect

描述：实例连接到一个Redis.
参数：host: string，port: int
返回值：BOOL 成功返回：TRUE;失败返回：FALSE
示例：

```
<?php  
redis = new redis();  
result = redis->connect('127.0.0.1', 6379);  
var_dump(result); //结果：bool(true)  
?>  
```

2，set
描述：设置key和value的值
参数：Key Value
返回值：BOOL 成功返回：TRUE;失败返回：FALSE
示例：

```
<?php  
redis = new redis();  
redis->connect('127.0.0.1', 6379);  
result = redis->set('test',"11111111111");  
var_dump($result);    //结果：bool(true)  
?>  
```

3，get
描述：获取有关指定键的值
参数：key
返回值：string或BOOL 如果键不存在，则返回 FALSE。否则，返回指定键对应的value值。
范例：

```
<?php  
redis = new redis();  
redis->connect('127.0.0.1', 6379);  
result = redis->get('test');  
var_dump($result);   //结果：string(11) "11111111111"  
?>  
```

4，delete

描述：删除指定的键
参数：一个键，或不确定数目的参数，每一个关键的数组：key1 key2 key3 … keyN
返回值：删除的项数
范例：

```
<?php  
redis = new redis();  
redis->connect('127.0.0.1', 6379);  
redis->set('test',"1111111111111");  
echo redis->get('test');   //结果：1111111111111  
redis->delete('test');  
var_dump(redis->get('test'));  //结果：bool(false)  
?>  
```

5，setnx
描述：如果在数据库中不存在该键，设置关键值参数
参数：key value
返回值：BOOL 成功返回：TRUE;失败返回：FALSE
范例：

```
<?php  
redis = new redis();  
redis->connect('127.0.0.1', 6379);  
redis->set('test',"1111111111111");  
redis->setnx('test',"22222222");  
echo redis->get('test');  //结果：1111111111111  
redis->delete('test');  
redis->setnx('test',"22222222");  
echo redis->get('test');  //结果：22222222  
?>  
```

6，exists
描述：验证指定的键是否存在
参数key
返回值：Bool 成功返回：TRUE;失败返回：FALSE
范例：

```
<?php  
redis = new redis();  
redis->connect('127.0.0.1', 6379);  
redis->set('test',"1111111111111");  
var_dump(redis->exists('test'));  //结果：bool(true)  
?>  
```

7，incr
描述：数字递增存储键值键.
参数：key value：将被添加到键的值
返回值：INT the new value
实例：

```
<?php  
redis = new redis();  
redis->connect('127.0.0.1', 6379);  
redis->set('test',"123");  
var_dump(redis->incr("test"));  //结果：int(124)  
var_dump($redis->incr("test"));  //结果：int(125)  
?>
 
```

8，decr
描述：数字递减存储键值。
参数：key value：将被添加到键的值
返回值：INT the new value
实例：

```
<?php  
redis = new redis();  
redis->connect('127.0.0.1', 6379);  
redis->set('test',"123");  
var_dump(redis->decr("test"));  //结果：int(122)  
var_dump($redis->decr("test"));  //结果：int(121)  
?>
```

9，getMultiple
描述：取得所有指定键的值。如果一个或多个键不存在，该数组中该键的值为假
参数：其中包含键值的列表数组
返回值：返回包含所有键的值的数组
实例：

```
<?php  
redis = new redis();  
redis->connect('127.0.0.1', 6379);  
redis->set('test1',"1");  
redis->set('test2',"2");  
result = redis->getMultiple(array('test1','test2'));  
print_r($result);   //结果：Array ( [0] => 1 [1] => 2 )  
?>
```

10，lpush
描述：由列表头部添加字符串值。如果不存在该键则创建该列表。如果该键存在，而且不是一个列表，返回FALSE。
参数：key,value
返回值：成功返回数组长度，失败false
实例：

```
<?php  
redis = new redis();  
redis->connect('127.0.0.1', 6379);  
redis->delete('test');  
var_dump(redis->lpush("test","111"));   //结果：int(1)  
var_dump($redis->lpush("test","222"));   //结果：int(2)  
?>
```

11，rpush
描述：由列表尾部添加字符串值。如果不存在该键则创建该列表。如果该键存在，而且不是一个列表，返回FALSE。
参数：key,value
返回值：成功返回数组长度，失败false
范例：

```
<?php  
redis = new redis();  
redis->connect('127.0.0.1', 6379);  
redis->delete('test');  
var_dump(redis->lpush("test","111"));   //结果：int(1)  
var_dump(redis->lpush("test","222"));   //结果：int(2)  
var_dump(redis->rpush("test","333"));   //结果：int(3)  
var_dump($redis->rpush("test","444"));   //结果：int(4)  
?>
```

12，lpop
描述：返回和移除列表的第一个元素
参数：key
返回值：成功返回第一个元素的值 ，失败返回false
范例：

```
<?php  
redis = new redis();  
redis->connect('127.0.0.1', 6379);  
redis->delete('test');  
redis->lpush("test","111");  
redis->lpush("test","222");  
redis->rpush("test","333");  
redis->rpush("test","444");  
var_dump(redis->lpop("test"));  //结果：string(3) "222"  
?>
```

13，lsize,llen
描述：返回的列表的长度。如果列表不存在或为空，该命令返回0。如果该键不是列表，该命令返回FALSE。
参数：Key
返回值：成功返回数组长度，失败false
范例：

```
<?php  
redis = new redis();  
redis->connect('127.0.0.1', 6379);  
redis->delete('test');  
redis->lpush("test","111");  
redis->lpush("test","222");  
redis->rpush("test","333");  
redis->rpush("test","444");  
var_dump(redis->lsize("test"));  //结果：int(4)  
?>
```

14，lget
描述：返回指定键存储在列表中指定的元素。 0第一个元素，1第二个… -1最后一个元素，-2的倒数第二…错误的索引或键不指向列表则返回FALSE。
参数：key index
返回值：成功返回指定元素的值，失败false
范例：

```
<?php  
redis = new redis();  
redis->connect('127.0.0.1', 6379);  
redis->delete('test');  
redis->lpush("test","111");  
redis->lpush("test","222");  
redis->rpush("test","333");  
redis->rpush("test","444");  
var_dump(redis->lget("test",3));  //结果：string(3) "444"  
?>
```

15，lset
描述：为列表指定的索引赋新的值,若不存在该索引返回false.
参数：key index value
返回值：成功返回true,失败false
范例：

```
<?php  
redis = new redis();  
redis->connect('127.0.0.1', 6379);  
redis->delete('test');  
redis->lpush("test","111");  
redis->lpush("test","222");  
var_dump(redis->lget("test",1));  //结果：string(3) "111"  
var_dump(redis->lset("test",1,"333"));  //结果：bool(true)  
var_dump(redis->lget("test",1));  //结果：string(3) "333"  
?>
```

16，lgetrange
描述：
返回在该区域中的指定键列表中开始到结束存储的指定元素，lGetRange(key, start, end)。0第一个元素，1第二个元素… -1最后一个元素，-2的倒数第二…
参数：key start end
返回值：成功返回查找的值，失败false
范例：

```
<?php  
redis = new redis();  
redis->connect('127.0.0.1', 6379);  
redis->delete('test');  
redis->lpush("test","111");  
redis->lpush("test","222");  
print_r(redis->lgetrange("test",0,-1));  //结果：Array ( [0] => 222 [1] => 111 )  
?>
```

17,lremove
描述：从列表中从头部开始移除count个匹配的值。如果count为零，所有匹配的元素都被删除。如果count是负数，内容从尾部开始删除。
参数：key count value
返回值：成功返回删除的个数，失败false
范例：

```
<?php  
redis = new redis();  
redis->connect('127.0.0.1', 6379);  
redis->delete('test');  
redis->lpush('test','a');  
redis->lpush('test','b');  
redis->lpush('test','c');  
redis->rpush('test','a');  
print_r(redis->lgetrange('test', 0, -1)); //结果：Array ( [0] => c [1] => b [2] => a [3] => a )  
var_dump(redis->lremove('test','a',2));   //结果：int(2)  
print_r(redis->lgetrange('test', 0, -1)); //结果：Array ( [0] => c [1] => b )  
?>
```

18，sadd
描述：为一个Key添加一个值。如果这个值已经在这个Key中，则返回FALSE。
参数：key value
返回值：成功返回true,失败false
范例：

```
<?php  
redis = new redis();  
redis->connect('127.0.0.1', 6379);  
redis->delete('test');  
var_dump(redis->sadd('test','111'));   //结果：bool(true)  
var_dump(redis->sadd('test','333'));   //结果：bool(true)  
print_r(redis->sort('test')); //结果：Array ( [0] => 111 [1] => 333 )  
?>
```

19，sremove
描述：删除Key中指定的value值
参数：key member
返回值：true or false
范例：

```
<?php  
redis = new redis();  
redis->connect('127.0.0.1', 6379);  
redis->delete('test');  
redis->sadd('test','111');  
redis->sadd('test','333');  
redis->sremove('test','111');  
print_r($redis->sort('test'));    //结果：Array ( [0] => 333 )  
?>
```

20,smove
描述：将Key1中的value移动到Key2中
参数：srcKey dstKey member
返回值：true or false
范例

```
<?php  
redis = new redis();  
redis->connect('127.0.0.1', 6379);  
redis->delete('test');  
redis->delete('test1');  
redis->sadd('test','111');  
redis->sadd('test','333');  
redis->sadd('test1','222');  
redis->sadd('test1','444');  
redis->smove('test',"test1",'111');  
print_r(redis->sort('test1'));    //结果：Array ( [0] => 111 [1] => 222 [2] => 444 )  
?>
```

21，scontains
描述：检查集合中是否存在指定的值。
参数：key value
返回值：true or false
范例：

```
<?php  
redis = new redis();  
redis->connect('127.0.0.1', 6379);  
redis->delete('test');  
redis->sadd('test','111');  
redis->sadd('test','112');  
redis->sadd('test','113');  
var_dump($redis->scontains('test', '111')); //结果：bool(true)  
?>
```

22,ssize
描述：返回集合中存储值的数量
参数：key
返回值：成功返回数组个数，失败0
范例：

```&lt;?php  
<?php  
redis = new redis();  
redis->connect('127.0.0.1', 6379);  
redis->delete('test');  
redis->sadd('test','111');  
redis->sadd('test','112');  
echo redis->ssize('test');   //结果：2  
?>
```

23，spop
描述：随机移除并返回key中的一个值
参数：key
返回值：成功返回删除的值，失败false
范例：

```
<?php  
redis = new redis();  
redis->connect('127.0.0.1', 6379);  
redis->delete('test');  
redis->sadd("test","111");  
redis->sadd("test","222");  
redis->sadd("test","333");  
var_dump($redis->spop("test"));  //结果：string(3) "333"  
?>
```

24,sinter
描述：返回一个所有指定键的交集。如果只指定一个键，那么这个命令生成这个集合的成员。如果不存在某个键，则返回FALSE。
参数：key1, key2, keyN
返回值：成功返回数组交集，失败false
范例：

```
<?php  
redis = new redis();  
redis->connect('127.0.0.1', 6379);  
redis->delete('test');  
redis->sadd("test","111");  
redis->sadd("test","222");  
redis->sadd("test","333");  
redis->sadd("test1","111");  
redis->sadd("test1","444");  
var_dump($redis->sinter("test","test1"));  //结果：array(1) { [0]=> string(3) "111" }  
?>
```

25,sinterstore
描述：执行sInter命令并把结果储存到新建的变量中。
参数：
Key: dstkey, the key to store the diff into.
Keys: key1, key2… keyN. key1..keyN are intersected as in sInter.
返回值：成功返回，交集的个数，失败false
范例:

```
<?php  
redis = new redis();  
redis->connect('127.0.0.1', 6379);  
redis->delete('test');  
redis->sadd("test","111");  
redis->sadd("test","222");  
redis->sadd("test","333");  
redis->sadd("test1","111");  
redis->sadd("test1","444");  
var_dump(redis->sinterstore('new',"test","test1"));  //结果：int(1)  
var_dump(redis->smembers('new'));  //结果:array(1) { [0]=> string(3) "111" }  
?>
```

26,sunion
描述：
返回一个所有指定键的并集
参数：
Keys: key1, key2, … , keyN
返回值：成功返回合并后的集，失败false
范例：

```
<?php  
redis = new redis();  
redis->connect('127.0.0.1', 6379);  
redis->delete('test');  
redis->sadd("test","111");  
redis->sadd("test","222");  
redis->sadd("test","333");  
redis->sadd("test1","111");  
redis->sadd("test1","444");  
print_r($redis->sunion("test","test1"));  //结果：Array ( [0] => 111 [1] => 222 [2] => 333 [3] => 444 )  
?>
```

27,sunionstore
描述：执行sunion命令并把结果储存到新建的变量中。
参数：
Key: dstkey, the key to store the diff into.
Keys: key1, key2… keyN. key1..keyN are intersected as in sInter.
返回值：成功返回，交集的个数，失败false
范例:

```
<?php  
redis = new redis();  
redis->connect('127.0.0.1', 6379);  
redis->delete('test');  
redis->sadd("test","111");  
redis->sadd("test","222");  
redis->sadd("test","333");  
redis->sadd("test1","111");  
redis->sadd("test1","444");  
var_dump(redis->sinterstore('new',"test","test1"));  //结果：int(4)  
print_r(redis->smembers('new'));  //结果:Array ( [0] => 111 [1] => 222 [2] => 333 [3] => 444 ) 
?>
```

28,sdiff
描述：返回第一个集合中存在并在其他所有集合中不存在的结果
参数：Keys: key1, key2, … , keyN: Any number of keys corresponding to sets in redis.
返回值：成功返回数组，失败false
范例：

```
<?php  
redis = new redis();  
redis->connect('127.0.0.1', 6379);  
redis->delete('test');  
redis->sadd("test","111");  
redis->sadd("test","222");  
redis->sadd("test","333");  
redis->sadd("test1","111");  
redis->sadd("test1","444");  
print_r($redis->sdiff("test","test1"));  //结果：Array ( [0] => 222 [1] => 333 )  
?>
```

29,sdiffstore
描述：执行sdiff命令并把结果储存到新建的变量中。
参数：
Key: dstkey, the key to store the diff into.
Keys: key1, key2, … , keyN: Any number of keys corresponding to sets in redis
返回值：成功返回数字，失败false
范例：

```
<?php  
redis = new redis();  
redis->connect('127.0.0.1', 6379);  
redis->delete('test');  
redis->sadd("test","111");  
redis->sadd("test","222");  
redis->sadd("test","333");  
redis->sadd("test1","111");  
redis->sadd("test1","444");  
var_dump(redis->sdiffstore('new',"test","test1"));  //结果：int(2)  
print_r(redis->smembers('new'));  //结果:Array ( [0] => 222 [1] => 333 )  
?>
```

30,smembers, sgetmembers
描述：
返回集合的内容
参数：Key: key
返回值：An array of elements, the contents of the set.
范例：

```
<?php  
redis = new redis();  
redis->connect('127.0.0.1', 6379);  
redis->delete('test');  
redis->sadd("test","111");  
redis->sadd("test","222");  
print_r(redis->smembers('test'));  //结果:Array ( [0] => 111 [1] => 222 )  
?>
```

]]></content>
      <categories>
        <category>开发资料</category>
      </categories>
      <tags>
        <tag>Redis</tag>
      </tags>
  </entry>
  <entry>
    <title>Redis-简介</title>
    <url>/2018/09/15/Redis%20%E7%AE%80%E4%BB%8B/</url>
    <content><![CDATA[
# Redis

## 1.非关系型数据库 NoSQL

```
NoSQL（NoSQL = Not Only SQL），意即“不仅仅是SQL”，指的是非关系型的数据库。
是一项全新的数据库革命性运动，早期就有人提出，发展至2009年趋势越发高涨。
随着互联网web2.0网站的兴起，传统的关系数据库在应付web2.0网站，
特别是超大规模和高并发的SNS类型的web2.0纯动态网站已经显得力不从心，
暴露了很多难以克服的问题，NoSQL的拥护者们提倡运用非关系型的数据存储，
相对于铺天盖地的关系型数据库运用，这一概念无疑是一种全新的思维的注入。
而非关系型的数据库则由于其本身的特点得到了非常迅速的发展。
```

### Nosql特点

```
它们可以处理超大量的数据。

它们运行在便宜的PC服务器集群上。
    PC集群扩充起来非常方便并且成本很低，避免了“sharding”操作的复杂性和成本。
它们击碎了性能瓶颈。
    通过NoSQL架构可以省去将Web或Java应用和数据转换成SQL友好格式的时间，执行速度变得更快。
    “SQL并非适用于所有的程序代码，” 对于那些繁重的重复操作的数据，SQL值得花钱。
    但是当数据库结构非常简单时，SQL可能没有太大用处。
没有过多的操作。
    虽然NoSQL的支持者也承认关系数据库提供了无可比拟的功能集合，
    而且在数据完整性上也发挥绝对稳定，他们同时也表示，企业的具体需求可能没有那么多。
```

### NoSQL适用场景

```
1. 对数据高并发读写
2. 对海量数据的高效率存储和访问
3. 对数据的高可扩展性和高可用性
```

## 2.Redis

```
Redis is an open source, advanced key-value store.
It is often referred to as a data structure server since keys can contain
strings, hashes, lists, sets and sorted sets. 

Redis是一个开源的，先进的key-value存储。
它通常被称为数据结构服务器，因为键可以包含字符串，哈希，链表，集合和有序集合。
```

### Redis 简介

```
Redis 是完全开源免费的，遵守BSD协议，是一个高性能的key-value数据库。
Redis 与其他 key - value 缓存产品有以下三个特点：
Redis支持数据的持久化，可以将内存中的数据保存在磁盘中，重启的时候可以再次加载进行使用。
Redis不仅仅支持简单的key-value类型的数据，同时还提供list，set，zset，hash等数据结构的存储。
Redis支持数据的备份，即master-slave模式的数据备份。
```

### Redis 优势

```
性能极高 – Redis能读的速度是110000次/s,写的速度是81000次/s 。
丰富的数据类型 – Redis支持二进制案例的 Strings, Lists, Hashes, Sets 及 Ordered Sets 数据类型操作
原子 – Redis的所有操作都是原子性的，同时Redis还支持对几个操作全并后的原子性执行。
丰富的特性 – Redis还支持 publish/subscribe, 通知, key 过期等等特性。
```

### Redis与其他key-value存储有什么不同？

```
Redis有着更为复杂的数据结构并且提供对他们的原子性操作，这是一个不同于其他数据库的进化路径。
Redis的数据类型都是基于基本数据结构的同时对程序员透明，无需进行额外的抽象。
Redis运行在内存中但是可以持久化到磁盘，所以在对不同数据集进行高速读写时需要权衡内存，
因为数据量不能大于硬件内存。在内存数据库方面的另一个优点是，相比在磁盘上相同的复杂的数据结构，
在内存中操作起来非常简单，这样Redis可以做很多内部复杂性很强的事情。
同时，在磁盘格式方面他们是紧凑的以追加的方式产生的，因为他们并不需要进行随机访问。
```

### Redis 安装

#### Window 下安装

```
下载地址：https://github.com/MSOpenTech/redis/releases。
Redis 支持 32 位和 64 位。这个需要根据你系统平台的实际情况选择，
这里我们下载 Redis-x64-xxx.zip压缩包到 C 盘，解压后，将文件夹重新命名为 redis。

打开一个 cmd 窗口 使用cd命令切换目录到 C:\redis 运行 redis-server.exe redis.windows.conf 。
如果想方便的话，可以把 redis 的路径加到系统的环境变量里，这样就省得再输路径了，
后面的那个 redis.windows.conf 可以省略，如果省略，会启用默认的。


这时候另启一个cmd窗口，原来的不要关闭，不然就无法访问服务端了。
切换到redis目录下运行 redis-cli.exe -h 127.0.0.1 -p 6379 。
设置键值对 set myKey abc
取出键值对 get myKey
```

#### Linux 下安装

下载地址：http://redis.io/download，下载最新文档版本。

本教程使用的最新文档版本为 3.0.0，下载并安装：

```
$ wget http://download.redis.io/releases/redis-3.0.0.tar.gz -O redis-3.0.0.tar.gz
$ tar xzf redis-3.0.0.tar.gz
$ cd redis-3.0.0
$ make
$ make PREFIX=/usr/local/redis install  （非必需）
```

如果失败可能为gcc没有安装。make完后目录下会出现编译后的redis服务程序redis-server。

注意：这种方式启动redis 使用的是默认配置。也可以通过启动参数告诉redis使用指定配置文件使用下面命令启动。

#### 配置redis使用环境：

```
新建目录 /usr/local/redis/etc ,
把原redis.conf 复制到该目录下

vim redis.conf
将 daemonize no 改为 yes   意为后台启动

启动服务
$ /usr/local/redis/bin/redis-server /usr/local/redis/etc/redis.conf
```

## Redis 数据类型

Redis常用的五种数据类型：

string（字符串），hash（哈希），list（列表），set（集合）及zset(sorted set 有序集合)。

详细格式看手册

#### String（字符串）

string是redis最基本的类型，你可以理解成与Memcached一模一样的类型，一个key对应一个value。

string类型是二进制安全的。意思是redis的string可以包含任何数据。比如jpg图片或者序列化的对象 。

string类型是Redis最基本的数据类型，一个键最大能存储512MB。

1. set
2. get
3. setnx
4. setex
5. setrange
6. getrange
7. mset
8. mget
9. msetnx
10. getset
11. incr
12. incrby
13. decr
14. decrby
15. append
16. strlen

#### Hash（哈希）

Redis hash 是一个键值对集合，一个string类型的field和value的映射表，hash特别适合用于存储对象。

1. hset
2. hget
3. hsetnx
4. hmset
5. hmget
6. hgetall
7. hexists
8. hlen
9. hkeys
10. hvals
11. hincrby
12. hdel

#### List（列表）

Redis 列表是简单的字符串列表，按照插入顺序排序。你可以添加一个元素到列表的头部（左边）或者尾部（右边）。

1. lpush
2. lrange
3. rpush
4. linsert
5. lset
6. lrem
7. ltrim
8. lpop
9. rpop
10. rpoplpush
11. lindex
12. llen

#### Set（无序集合）

Set是string类型的无序集合，通过哈希表实现的，所以添加，删除，查找的复杂度都是O(1)。

1. sadd
2. smembers
3. srem
4. spop
5. srandmember
6. scard
7. sismember
8. sdiff
9. sdiffstore
10. sinter
11. sinterstore
12. sunion
13. sunionstore
14. smove

#### zset(sorted set：有序集合)

zset 和 set 一样也是string类型元素的集合,且不允许重复的成员，不同的是每个元素都会关联一个double类型的分数。redis正是通过分数来为集合中的成员进行从小到大的排序。zset的成员是唯一的,但分数(score)却可以重复。

1. zadd
2. zrange
3. zrevrange
4. zrangebyscore
5. zrevrangebyscore
6. zrem
7. zcard
8. zcount
9. zincrby
10. zrank
11. zrevrank
12. zremrangebyrank
13. zremrangebyscore
14. zinterstore
15. zunionstore
16. zscore

### Others

1. keys
2. exists
3. del
4. expire
5. persist
6. ttl
7. select
8. move
9. randomkey
10. rename
11. type
12. ping
13. echo
14. quit
15. save
16. bgsave
17. dbsize
18. config get
19. info
20. flushdb
21. flushall

#### Redis命令（截至到3.2.8）共174个，此文只介绍常用的，还有很多的不常用命令在《Redis命令补充》中说明，此处不提



]]></content>
      <categories>
        <category>学习笔记</category>
      </categories>
      <tags>
        <tag>Redis</tag>
      </tags>
  </entry>
  <entry>
    <title>HTML (基本01)</title>
    <url>/2017/09/21/html%20-01/</url>
    <content><![CDATA[
# 一.HTML (基本01)

## 准备工作

> 1.常见的几种文件类型：
>
> *.html	*.css	*.js	*.php	*.sql
>
> 2.wamp存放位置：~/wamp/www/
>
> 3.运行：打开wamp
>
> ​		打开浏览器
>
> ​		地址栏输入localhost

### 1.HTML简介

```基本语法
<!DOCTYPE html>   <!--声明-->
<html lang="en">   <!--语言-->
<head>
	<meta charset="UTF-8">  <!--编码-->
	<title>标题</title>
</head>
<body>
	正文内容
</body>
</html>
```

​	以上为基本的一段html代码，包含**版本声明**，**编码**，**标题**，其中全局架构标签为**html**，**head**，**body**。**body**标签内部的才是文字，图片，音视频等内容需要占用的位置。

> 编码：
>
> 计算机早期, 世界只有**ASCII**编码, 只有128个, 不认识汉语, 韩语, 日语
> 新一代的编码 **Unicode**编码, 支持世界上绝大多数的语言, 数字, 字母, 标点, 汉字等都占4个字节
> 升级版 **UTF-8** 编码 (万国码), 数字,字母,标点占1B,  汉字占3B

### 2.基本语法

#### ①.全局架构标签

- html
- head
- body

#### ②.注释

注释是对代码的描述，不会显示在页面上，但可以增加代码的可读性

格式：<!--注释内容-->

**注意：不能嵌套使用**

#### ③.标签格式

网页全部是由标签组成的，标签分为两种：

- 单标签：<开始标签/>      如:`<br/>,<hr/>,<img/>,<meta/>`
- 双标签：<开始标签>正文内容<结束标签/>   如： ` <p> </p>`

#### ④.标签属性

格式：`<开始标签  属性名=“属性值”  属性名=“属性值”  ...>`

标签属性写在标签内部，每对属性之间至少保留一个空格

> **标签名和属性名不区分大小写**

### 3.浏览器特性

```浏览器特性
<!DOCTYPE html>
<html lang="cn">
<head>
    <meta charset="UTF-8">
    <title>浏览器特性</title>
</head>
<body>
    <h1>浏览器特性</h1>
    <hr>
    
	亚洲有四大邪术:
		日本的化妆术
		韩国的整容术
		泰国的变性术
		中国的PS术
</body>
</html>
```

虽然在代码中进行了排版，但实际效果是：

![无标题](D:/wamp/www/XIA/0329/%E4%BA%8C%E7%BB%84%E4%BD%9C%E4%B8%9A0329/%E5%BC%A0%E4%BB%A4%E5%B8%9B/md%E6%95%B4%E7%90%86/%E6%97%A0%E6%A0%87%E9%A2%98.jpg )

***注意***：浏览器中，任何多的空格和回车，要么**不解析**，要么解析为**一个空格**，利用这个特性，可以在代码中做好排版和注释。

> **一个职业程序员，应该有良好的注释习惯及排版审美**

### 4.文本格式标签

#### ①.标题标签

`<h1>标题</h1>`

从`<h1>`到`<h6>`,标题格式由高层级向低层级转化。一般常用的为h1到h4

其中h1标签在一个页面中最好只用**一次**，因为h1可以用于**提高搜索排名**，而使用两次及以上，则会被搜索引擎拉入**黑名单**。

### ②.段落标签

`<p>正文</p>`

在p标签中的文字，为一个段落。不同段间上下行间间距较大，自动换行

#### ③.样式标签

- `<b>bold</b>`			<b>加粗</b>
- `<i>italic</i>`                    <i>倾斜</i>
- `<u>underline</u>`              <u>下划线</u>
- `<del>delete</del>`             <del>删除线</del>

> 只负责表面样式，不具备实际意义。

#### ④.语义化标签

- `<strong> strong</strong>`        <strong>强调</strong>
- `<em>emphasize</em>`                    <em>加强</em>

> 不仅负责表面样式，还具备方便浏览器解析的特性

#### ⑤.上、下标

- `x<sup>2</sup>`         上标     x<sup>2</sup>
- `CO<sub>2</sub>`        下标    CO<sub>2</sub>

#### ⑥.原样输出

- `<pre> </pre>`              保持代码样式格式输出

### 5.列表标签

**场景**: 一排排 or 一列列长的差不多, 样式相似, 都可以用列表

- 有序列表ol（ordered list）

```有序列表
《回乡偶书》
	<ol>
		<li>瘦小离家老大回</li>
		<li>乡音未改肉成堆</li>
		<li>儿童相见不相识</li>
		<li>请问胖子你是谁</li>
	</ol>
```

- 无序列表ul（UNordered list）

```无序列表
《静夜思》
	<ul>
		<li>窗前明月光</li>
		<li>地上鞋两双</li>
		<li>一对狗男女</li>
		<li>其中就有你</li>
	</ul>
```

- 定义列表dl（defined list）

```定义列表
<dl>
		<dt>帮助中心</dt>
		<dd>账户管理</dd>
		<dd>购物指南</dd>
		<dd>订单操作</dd>
	</dl>
```

> 在实际开发中, ul 使用频率比较 ol 高, 原因是ul解析不用排序，速度比ol快一点 

### 6.实体符号

| 基本格式： | &符号代码； |      |
| :--------: | :---------: | :--: |
|    空格    |   &nbsp；   |      |
|    小于    |    &lt；    |  <   |
|    大于    |    &gt；    |  >   |
|    版权    |   &copy；   |  ©   |
|   人民币   |   &yen；    |  ¥   |

其余实体符号具体参考**实体符号速查表**

|  符号代码  |   释义   |   表现   |      |
| :--------: | :------: | :------: | :--: |
| `&hearts;` |   爱心   | &hearts; |      |
|  `&euro;`  |   欧元   |  &euro;  |      |
| `&frac25;` |   分数   | &frac25; |      |
|  `&uarr;`  | 向上箭头 |  &uarr;  |      |
|  `&larr;`  | 向左箭头 |  &larr;  |      |

### 7.超链接

- 标签名：a
- 属性：
  - href        链接地址
  - target     在制定窗口打开链接
    - _self 	在本窗口打开链接，默认
    - _blank      在新的空白页打开链接
    - _top         在顶级窗口打开链接
    - 自定义name窗口

**注意点：链接地址为协议+域名，若不写地址，则默认跳转到当前页面**

1. 任意一个地址只会对应一个文件

2. 在任意目录下，命名为 ***index.html*** 或者 ***index.php*** 的文件，访问该目录时会自动执行index文件。

3. URL：网址

   在完整地址中，第一个？是文件与参数的分隔符

4. 参数

   格式：参数名1="参数值1"  参数名1="参数值1"  

   > 多个参数之间有&隔开

5. 锚点

   格式：  #锚点名

   > 必须在锚点名前加#号

```地址
<a href="http://www.xxx.com:80/image/av/a.jpg?name=yuhan&age=18#xxoo"> 瞎编的完整地址 </a>
```

### 8.锚点

**作用**：跳转至某一页面或者某一节点

**步骤**：

​	1.确定锚点：HTML4	name="锚点名"

​        		       HTML5	id="锚点名"

​	2.跳转到锚点：

​		`<a href="url+#锚点名">点击跳转</a>`

**注意点：链接地址为协议+域名，若不写地址，则默认跳转到当前页面**

<a href="www.baidu.com">baidu</a>	]]></content>
      <categories>
        <category>学习笔记</category>
      </categories>
      <tags>
        <tag>HTML</tag>
      </tags>
  </entry>
  <entry>
    <title>HTML (基本02)</title>
    <url>/2017/09/27/html%20-02/</url>
    <content><![CDATA[
# 二.HTML (基本02)

## 1. 多媒体标签

### 1.图片标签

标签名：   **img**

属性：	

```属性
	src			图片来源地址	

	width	   	图片宽度调节

	height	  	图片高度调节

	title		鼠标悬停显示文本

	alt			图片加载失败替代文本 

```

**注意：**高度属性和宽度属性一般不同时使用，避免影响图片固有宽高比。

> 计算机常用长度单位：px （像素）

```代码
<img src="图片路径" width="20px" title="picture" alt="~"
```

### 2.音频标签

标签名：  **audio**

属性：

```属性
	src			音频来源路径
	controls	控制器
	loop		循环播放
	autoplay	自动播放

```

```代码
<audio src="音频路径" controls loop autoplay>音频播放异常
</audio>


```



媒介标签——**source**

```媒介标签
<audio controls>
	<source src="./music.mp3">
	<source src="./music.amv">
	<source src="./music.fac">
</audio>


```

> 媒介标签提供了一种可能：当所用浏览器不支持某种格式的音频时，有替代格式的同一音频可以正常播放。

### 3.视频标签

标签名：  **video**

属性：

```属性
	src 		视频来源地址
	controls	控制器
	weight		视频宽度
	height		视频高度
	loop  		循环播放
	autoplay	自动播放


```

```代码
<video src="视频地址" wieght="200" controls loop autoplay>


```

媒介标签——**source**

```媒介代码
<video controls>
	<source src="./video.mp4">
	<source src="./video.flv">
	<source src="./video.avi">
</video>


```

> 媒介标签提供了一种可能：当所用浏览器不支持某种格式的音频时，有替代格式的同一音频可以正常播放。

### 4.地址路径

计算机文件路径分为 **绝对路径** 和 **相对路径** 。

#### 相对路径

​	.			当前路径，默认

​	..		       上一级路径

```eg
<img src="1.jpg">
<img src="./1.jpg">
<!--以上均为在当前目录下寻找1.jpg文件-->

<img src="../1.jpg">
<img src="../../1.jpg">
<!--以上两个分别为在上层目录和上上层目录中寻找1.jpg-->



```

#### 绝对路径

盘符式：	x:/.../.../...

网址式：	http://.../.../...

根目录：	/.../.../...

> 此处的根目录，在wamp中代表www目录

```
<img src="D:/wamp/www/3.jpg">
<img src="http://localhost/3.jpg" width="300">
<img src="/3.jpg" width="300">



```



### 5.表单声明

> 表单---常用于和用户做交互

**标签名**：	**form**（表单声明标签）

**属性**：

```属性
	action			指定一个地址，将表单内容提交给服务器
					若属性值为空，则默认提交给自己
	
	method			指定页面内容传输方式；
		get			明文传输，为默认传输方式；
	   （查）		  速度快，但安全性较低；
					传输大小在http协议上没有限制，
					实际上受到浏览器限制,
					大多数<2KB = 2048 B；
					
		post		密文传输；
	  （增删改）	 	 速度相对get要慢，但安全性高；
					传输大小在http协议上没有限制，
					实际上受到服务器限制；
	
	enctype	= "multipart/form-date"
					专用于提交文件给服务器



```

**使用**

```实例
<form action="http://www.baidu.com/s" method="post">
	百度：<input type="text" name="word"><br/>
	密码：<input type="password" name="pwd"><br/>
		<input type="submit">
</form>



```

### 6.表单标签

- 标签名：	**input**
- 特殊属性：
  - **name**	给当前标签命名，只有命名之后，服务器才能知道接收的信息属于谁。一般情况下，所有的表单都需要name。
  - **value**         给当前标签赋予默认值，其中可手动输入标签，value值可写可不写，不可手动输入标签必须写入value值。
- 常用属性： 
  - **type**

```属性值
type属性值：
		text		文本域，默认
		password	密码域（输入不可见）
		radio		单选（配合name使用）
		checkbox	多选
		email		邮箱（确保输入"xxx@xxx"格式）
		number		数字（只能输入数字）
		url			地址（确保输入"xxx://xxx"格式）
		date		日期选择
		file		文件提交
		hidden		隐藏域
		search		搜索
		submit		提交
		button 		按钮（必须配合js使用）
		



```

```代码
<form action="./demo.php" method="post" enctype="multipart/form-date">
默认文本框：<input> <br>
用户名：<input type="text" name="userName" value="id"><br>
密码：<input type="password" name="psd"><br>
手机号：<input type="number" name="tel"><br>
性别：<input type="radio" name="sex" value="man">男
	<input type="radio" name="sex" value="female">女
	<br>
爱好:<input type="checkbox" name="hobby[]" value="book">book
	<input type="checkbox" name="hobby[]" value="sports">sports
	<input type="checkbox" name="hobby[]" value="game">game
	<input type="checkbox" name="hobby[]" value="bike">bike
	<br>
<!--checkbox要将name值后补上[]，才能形成真正的多选 -->

邮箱：<input type="email" name="email"><br>
生日:<input type="date" name="birthday"><br>
搜索：<input type="search" name="search"><br>
头像：<input type="file" name="icon"><br>

<!--上传文件的3个必要条件-->
<!--
	1.file表单必须要有name属性
	2.form表单的属性method=post
	3.form表单的属性enctype=multipart/form-date
-->

隐藏域：<input type="hidden" name="id" value="0328"><br>
URL:<input type="url" name="url"><br>
<input type="submit" value=""><br>
<!--默认为提交-->
按钮：<input type="button" value="insure">

</form>



```



> 其中由于默认文本框中标签未添加name属性，提交后无法查看相应内容，更改为`<input name="default">`后提交可正常显示



## 2. 表单

### 1.下拉框

#### 表单标签

**声明标签**：	*select*

​	属性：	name

**字内容标签**：	*option*

​	属性：value

> option标签若没有value值则会将正文内容提交给服务器

```代码
户籍：
	<select name="address">
		<option>choice</option>
		<option value="1">shanghai</option>
		<option value="2">zhejiang</option>
		<option value="3">jiangsu</option>
		<option value="4">shadong</option>
		<option value="5">hunan</option>
		<option value="6">hubei</option>
		<option value="7">jiangxi</option>
	</select>


```

![](D:/wamp/www/XIA/0329/%E4%BA%8C%E7%BB%84%E4%BD%9C%E4%B8%9A0329/%E5%BC%A0%E4%BB%A4%E5%B8%9B/md%E6%95%B4%E7%90%86/1555.jpg)

### 2.快捷键

快捷键：	

```快捷键
快捷键：	
		ctrl + c   			光标只要在当前行即可
		ctrl + v			马上在上一行进行粘贴

		ctrl + shift + d	复制当前行到下一行

		ctrl + x			删除（本质为剪切）

		ctrl + alt + 方向键		快速选中 同列光标

		ctrl + /			快速注释


		emmet插件快速编写类似html标签：

		$ 		索引， 本质就是数字，默认从1开始
		
		$@num 	索引， 默认从num开始计数

		*		乘以几次，重复几次，出现几个标签
		
		[]		属性  [属性名=属性值]

		{} 		正文内容


```

实例

```
<select name="test">	
	<!-- option{$}*5 -->
	<option value="">1</option>
	<option value="">2</option>
	<option value="">3</option>
	<option value="">4</option>
	<option value="">5</option>
	
	<!-- option[value=$]*5 -->
	<option value="1"></option>
	<option value="2"></option>
	<option value="3"></option>
	<option value="4"></option>
	<option value="5"></option>
	
	<!-- option[value=$]{$@1990}*5 -->
	<option value="1">1990</option>
	<option value="2">1991</option>
	<option value="3">1992</option>
	<option value="4">1993</option>
	<option value="5">1994</option>
</select>


```

### 3.多文本域

**标签名**：	texterea

​     **属性**:	  rows ——  行

​			cols   ——  列

> 之前input，select 默认值都是value
> textarea 的默认值是正文内容，而非value

`<textarea rows="5" cols="50"></textarea>`

### 4.button标签

```
<form action="">
	 	<input type="text" name="userName">
	 	<button> button按钮</button>
	 	<input type="submit">
</form>


```

form表单中的独立button按钮，默认值也是正文内容

默认效果是将表单内容提交给服务器（同type-submit）

后期更多是配合js，实现更多的效果。

**注意：不同于input标签下的type属性值**

`<input type="button" value="提交">`

### 5.表单常用属性

常见属性：

```属性
	placeholder			背景虚化字
	minlength			输入值最小长度
	maxlength			输入值最大长度
	autofocus			自动获取光标
	autocomplete		自动提示历史记录
		——  on		开启，默认
		——  off		关闭
	required			输入不能为空
	checked				单选/复选默认勾选项
	selected			下拉框默认显示项
	readonly			只读，只能看不能改，提交给服务器
	disabled			禁用，只能看不能改，不能提交给服务器
	multiple			开启多选选项


```

### 6.头标签设置

```
	<!-- 1.设置编码 <meta charset="UTF-8"> -->
	<meta charset="UTF-8">

	<!-- 2.设置标题 <title></title> -->
	<title>head标签</title>

	<!-- 3.搜索引擎关键字 -->
	<meta name="keywords" content="keyword1,keyword2,...">

	<!-- 4.设置描述 -->
	<meta name="description" content="描述内容">

	<!-- 5.网页重定向 -->
	<!-- <meta http-equiv="refresh" content="3;url=./041.html" -->
	
	<!-- 6.导入css -->
	<link rel="stylesheet" href="./demo.css">

	<!-- 7.导入js -->
	<script src="./demo.js"></script>

	<!-- 8.导入icon图标 -->
	<link rel="icon" href="favicon.ico">


```

### 7.表格

表格声明：		table

表格标题：		caption

​	表行：		tr		table row

​	表头：		th		table head

表格描述：		td		table description

> 设计：先看行，再看列



属性：

```属性
	border				边框宽度
    cellspacing			外边距（单元格之间的距离）
    cellpadding			内边距（单元格与内容之间的距离）
    width				表格宽度
    height				表格高度
    colspan				列合并
    rowspan				行合并
    align				水平对齐：（left/center/right）
    valign（vertical）   垂直对齐：（top/middle/bottom）
    bgcolor				背景颜色
    background			背景图片


```



### 8.下拉框

## 表单标签

**声明标签**：	*select*

​	属性：	name

**字内容标签**：	*option*

​	属性：value

> option标签若没有value值则会将正文内容提交给服务器

```代码
户籍：
	<select name="address">
		<option>choice</option>
		<option value="1">shanghai</option>
		<option value="2">zhejiang</option>
		<option value="3">jiangsu</option>
		<option value="4">shadong</option>
		<option value="5">hunan</option>
		<option value="6">hubei</option>
		<option value="7">jiangxi</option>
	</select>


```

![](D:/wamp/www/XIA/0329/%E4%BA%8C%E7%BB%84%E4%BD%9C%E4%B8%9A0329/%E5%BC%A0%E4%BB%A4%E5%B8%9B/md%E6%95%B4%E7%90%86/1555.jpg)

### 9.快捷键

快捷键：	

```快捷键
快捷键：	
		ctrl + c   			光标只要在当前行即可
		ctrl + v			马上在上一行进行粘贴

		ctrl + shift + d	复制当前行到下一行

		ctrl + x			删除（本质为剪切）

		ctrl + alt + 方向键		快速选中 同列光标

		ctrl + /			快速注释


		emmet插件快速编写类似html标签：

		$ 		索引， 本质就是数字，默认从1开始
		
		$@num 	索引， 默认从num开始计数

		*		乘以几次，重复几次，出现几个标签
		
		[]		属性  [属性名=属性值]

		{} 		正文内容


```

实例

```
<select name="test">	
	<!-- option{$}*5 -->
	<option value="">1</option>
	<option value="">2</option>
	<option value="">3</option>
	<option value="">4</option>
	<option value="">5</option>
	
	<!-- option[value=$]*5 -->
	<option value="1"></option>
	<option value="2"></option>
	<option value="3"></option>
	<option value="4"></option>
	<option value="5"></option>
	
	<!-- option[value=$]{$@1990}*5 -->
	<option value="1">1990</option>
	<option value="2">1991</option>
	<option value="3">1992</option>
	<option value="4">1993</option>
	<option value="5">1994</option>
</select>


```

### 10.多文本域

**标签名**：	texterea

​     **属性**:	  rows ——  行

​			cols   ——  列

> 之前input，select 默认值都是value
> textarea 的默认值是正文内容，而非value

`<textarea rows="5" cols="50"></textarea>`

### 11.button标签

```
<form action="">
	 	<input type="text" name="userName">
	 	<button> button按钮</button>
	 	<input type="submit">
</form>


```

form表单中的独立button按钮，默认值也是正文内容

默认效果是将表单内容提交给服务器（同type-submit）

后期更多是配合js，实现更多的效果。

**注意：不同于input标签下的type属性值**

`<input type="button" value="提交">`

### 12.表单常用属性

常见属性：

```属性
	placeholder			背景虚化字
	minlength			输入值最小长度
	maxlength			输入值最大长度
	autofocus			自动获取光标
	autocomplete		自动提示历史记录
		——  on		开启，默认
		——  off		关闭
	required			输入不能为空
	checked				单选/复选默认勾选项
	selected			下拉框默认显示项
	readonly			只读，只能看不能改，提交给服务器
	disabled			禁用，只能看不能改，不能提交给服务器
	multiple			开启多选选项


```



### 13.头标签设置

```
	<!-- 1.设置编码 <meta charset="UTF-8"> -->
	<meta charset="UTF-8">

	<!-- 2.设置标题 <title></title> -->
	<title>head标签</title>

	<!-- 3.搜索引擎关键字 -->
	<meta name="keywords" content="keyword1,keyword2,...">

	<!-- 4.设置描述 -->
	<meta name="description" content="描述内容">

	<!-- 5.网页重定向 -->
	<!-- <meta http-equiv="refresh" content="3;url=./041.html" -->
	
	<!-- 6.导入css -->
	<link rel="stylesheet" href="./demo.css">

	<!-- 7.导入js -->
	<script src="./demo.js"></script>

	<!-- 8.导入icon图标 -->
	<link rel="icon" href="favicon.ico">


```

### 14.表格

表格声明：		table

表格标题：		caption

​	表行：		tr		table row

​	表头：		th		table head

表格描述：		td		table description

> 设计：先看行，再看列



属性：

```属性
	border				边框宽度
    cellspacing			外边距（单元格之间的距离）
    cellpadding			内边距（单元格与内容之间的距离）
    width				表格宽度
    height				表格高度
    colspan				列合并
    rowspan				行合并
    align				水平对齐：（left/center/right）
    valign（vertical）   垂直对齐：（top/middle/bottom）
    bgcolor				背景颜色
    background			背景图片


```



## 3. 布局

### 1.大分帧

> 大分帧：**frameset** 

> （在 **html5** 中已经淘汰，但很多较老的网页还在用大分帧布局）

> （**frameset** 与 **body** 标签不能共存）

**标签名**： frameset       	设置窗口（分帧）

**格式**：

```frameset格式
<frameset rows="x%,x%">			<frameset col="x%,x%">
	<frame>							<frame>
	<frame>							<frame>
</frameset>						</frameset>

<!--可以嵌套使用，嵌套时，将下次要分频的frame标签替换为frameset-->


```

**属性**： 	rows		行分

​			     cols		 列分

​				*		   剩余空间

​			     noresize	 固定分频区域

​			     frameborder  分频边框关闭(=0)或开启(非0)



**子标签名**： frame		窗口（分帧）

**属性**：	src			窗口内容来源地址

​			   name		   给当前窗口命名

​			   scrolling	       设置滚动条启用(=yes)或禁用(=no)



```代码实例
<!-- 设置上，下（左，右）分频，并自定义内容-->
<frameset rows="10%,90%" noresize frameborder="1">
	<frame src="./topPage.jpg" name="top" scrolling="no">
	<frameset cols="20%,*">
		<frame src="xxx.html" name="left" scrolling="no">
		<frame src="xxx.html" name="right">
	</frameset>
</frameset>	


```

### 2.小分帧

**标签名**： iframe

**属性** ：   scrolling		滚动条（yes/no）

​		src			 引用来源

​		width		    小分帧宽度

​		height		   小分帧高度

​		frameborder	小分帧边框显示（0/非0）

​		name		     给小分帧命名

**格式**：

```格式
<iframe src="广告来源地址" scrolling="no" width="500" height="200" frameborder="no">
</iframe>


```

]]></content>
      <categories>
        <category>学习笔记</category>
      </categories>
      <tags>
        <tag>HTML</tag>
      </tags>
  </entry>
  <entry>
    <title>微信开发</title>
    <url>/2018/09/23/%E5%BE%AE%E4%BF%A1%E5%BC%80%E5%8F%91/</url>
    <content><![CDATA[
### 微信开发

**前提**: 

​	一台云服务器

**分类:**

服务号 | 订阅号 | ~~企业号~~ | 小程序(Vuejs封装)

​	订阅号 --账号主体:个人(仅仅文章,发说说)(推送一天一条消息)

​				 --账号主体:公司

​	服务号 --单独一个聊天框 , 不在订阅号标签内(推送一个月四条)

​	企业号 --内部管理沟通的平台

**两个接口**

​	微信支付接口 , 微信登录接口



**后台**: mp.weixin.qq.com



**开发：** 

百度搜索

微信开放平台    微信登陆相关接口

微信公众平台	微信开发

​	认证 - 300/年

​	微信测试号（不认证测试开发）(一年有效期)

**功能：**

​	1.自定义菜单

​	2.自动回复

 	3.展示页面

**高级接口**:

​	语音识别: 微信对外开放了语音识别的接口

​	客服接口: 可在12小时内持续对发消息用户沟通

​	网页授权: 可使用qq,微信登录

​	生成参数二维码: 分析用于来源或用户绑定

​	获取用户基本信息: openid 获取用户头像,名称,性别等

​	获取关注者列表: 获取所有关注者

​	用户分组接口: 为关注者分组

​	上传下载文件: 可将内容在自己的服务器中上传下载

**环境搭建**

​	打通自己的云服务器和微信接口平台的通道

​	token:可以表明自己身份的令牌(同一个服务器同时支持多个微信平台)

​	为保障安全,使用的是https协议

**第三方网络服务:**

​	百度bae , 新浪sae , 腾讯云 , 各种**云服务器** , 租用虚拟主机 , 自己传服务器

​	应用引擎(一键创建应用环境)

​	版本控制(SVN/Git)

**测试号管理：**

​	测试号信息：id+pass

​	接口配置: 服务器url + 令牌验证token

**PHP编辑开发:**

```
数据交换:  
	get/post使用的是XML/json格式
	xml优势:既可以存数据,又可以存格式;可做数据交换(各种语言均可以解析)
	PHP函数: 
		simplexml_load_string() 函数
		作用: 将XML数据转成PHP对象 
	simplexml_load_string('xml字符串','对象名','参数')
	simlpexml_load_string($str,'SimpleXMLElement',LIBXML_NOCDATA)
	--第三个参数为了解析传过来的xml对象数据,全部是包裹在<!CDATA[]>中

```

```
信息格式(msgtype):
	文本--text
	语音--voice
	视频--video
	图片--image
	位置--location
	链接--link
	
```



```
1.上传接口代码到自己的服务器
代码:
	定义了tokenchangliang
	将三个参数字典排序拼接为一个字符串,sha1加密,之后与第四个参数对比
	返回结果给请求方
2.完成接口配置
3.消息管理

```

客服消息

php curl (在PHP中模拟浏览器发起http请求--get/post)

手册--聚合代码 代码:**curl**_setopt方法

```
function https_request(url,data=null)
{
	//初始化
	//判断get/post
	//执行
}
用处:模拟登陆|爬取数据
//获取access_token(全局唯一接口调用凭据)
$turl = '';()接口文档模板
$tres = https_request($turl);

//提取返回的json数据
$data = json_decode($tres,true);
$access_token = $data['access_token'];

客服发消息接口
$url = '';
$data={
	'touser':'OPENID',
	'msgtype':'text',
	'text':{
		'content':'内容'
	}
}
$res=https_request($url,$data);
```

> API数据:聚合科技(www.juhe.cn)

模板消息

```
1.设置模板
    {{first.DATA}}
    商品名:{{keword1.DATA}}
    价格:{{keword2.DATA}}
    订单日期:{{keword3.DATA}}
    {{remark.DATA}}
2.修改模板程序,填写参数
```

自定义菜单

3个以及菜单 , 每个一级菜单最多包含5个二级菜单 , 4 - 7 个汉字

点击事件: click 

跳转url: view  

扫码: scancode_push scancode_waitmsg

发送图片: pic_sysphoto

拍照/本地发送: pic_phpoto_or_album

pic_weixin

弹出地理位置: location_select

发送消息: media_id

跳转图文消息: view_limited

作业:

聚合->查快递, 天气

token 提取出来



## ps:代码资料

1.验证token

```
//define your token
define("TOKEN", "s86");  // 定义常量
$wechatObj = new wechatCallbackapiTest();
$wechatObj->valid();

class wechatCallbackapiTest
{
	public function valid()
    {
        $echoStr = $_GET["echostr"];

        //valid signature , option
        if($this->checkSignature()){
        	echo $echoStr;
        	exit;
        }
    }

    public function responseMsg()
    {
		//get post data, May be due to the different environments
		$postStr = $GLOBALS["HTTP_RAW_POST_DATA"];

      	//extract post data
		if (!empty($postStr)){
                /* libxml_disable_entity_loader is to prevent XML eXternal Entity Injection,
                   the best way is to check the validity of xml by yourself */
                libxml_disable_entity_loader(true); // xml 保护模式开启
              	$postObj = simplexml_load_string($postStr, 'SimpleXMLElement', LIBXML_NOCDATA);
                $fromUsername = $postObj->FromUserName;
                $toUsername = $postObj->ToUserName;
                $keyword = trim($postObj->Content);
                $time = time();
                $textTpl = "<xml>
							<ToUserName><![CDATA[%s]]></ToUserName>
							<FromUserName><![CDATA[%s]]></FromUserName>
							<CreateTime>%s</CreateTime>
							<MsgType><![CDATA[%s]]></MsgType>
							<Content><![CDATA[%s]]></Content>
							<FuncFlag>0</FuncFlag>
							</xml>";             
				if(!empty( $keyword ))
                {
              		$msgType = "text";
                	$contentStr = "Welcome to wechat world!";
                	$resultStr = sprintf($textTpl, $fromUsername, $toUsername, $time, $msgType, $contentStr);
                	echo $resultStr;
                }else{
                	echo "Input something...";
                }

        }else {
        	echo "";
        	exit;
        }
    }
		
	private function checkSignature()
	{
        // you must define TOKEN by yourself
        if (!defined("TOKEN")) {
            throw new Exception('TOKEN is not defined!');
        }
        
        $signature = $_GET["signature"];
        $timestamp = $_GET["timestamp"];
        $nonce = $_GET["nonce"];
        		
        $token = TOKEN;

        // 加密/校验流程如下：

// 1）将token、timestamp、nonce三个参数进行字典序排序 
// 2）将三个参数字符串拼接成一个字符串进行sha1加密 
// 3）开发者获得加密后的字符串可与signature对比，标识该请求来源于微信
		$tmpArr = array($token, $timestamp, $nonce);
        // use SORT_STRING rule
		sort($tmpArr, SORT_STRING);
		$tmpStr = implode( $tmpArr );
		$tmpStr = sha1( $tmpStr );
		
		if( $tmpStr == $signature ){
			return true;
		}else{
			return false;
		}
	}
}
```

2.接受数据/回复数据

```
// 全局接收 psot数据  一般情况 禁用 因为不安全
// $postStr = $GLOBALS["HTTP_RAW_POST_DATA"];

// 使用 php://input
$postStr = file_get_contents('php://input');

// 把微信请求到的数据   poststr
// 存入文件
file_put_contents('./s.txt', $postStr);

libxml_disable_entity_loader(true); // xml 保护模式开启
// 把xml 转为对象
$postObj = simplexml_load_string($postStr, 'SimpleXMLElement', LIBXML_NOCDATA);
$fromUsername = $postObj->FromUserName;   // 用户id
$toUsername = $postObj->ToUserName;             // 商户id
$keyword = trim($postObj->Content);   // 内容
$time = time();


// 根据用户 不同的点击菜单 进行不同的回复
// 是事件
// 判断是 哪一个key

$evevnt = $postObj->Event;
$eventKey = $postObj->EventKey;

if ( $event == 'CLICK' ) {
  switch (variable) {
    case 'value':
      # code...
      break;
    
    default:
      # code...
      break;
  }

  echo $tpl;
}
```



微信开发原理

![1566817418172](/images/imgs/1566817418172.png)



环境搭建 : 

​	- 服务器

​	sae(新浪云应用) - 权限受限

​	bae(百度云应用)

​	-虚拟主机+域名解析(Apache-.vhost/Nginx-whereis nginx)

​	sftp(sublime插件 , 服务器即时代码变化)

日志记录:

​	1. 查看服务器传入内容 - wwwlog

2. 创建日志记录 file_put_content('log.txt',$str);

   动态查看日志`tail -F log.txt`	]]></content>
      <categories>
        <category>学习笔记</category>
      </categories>
      <tags>
        <tag>微信开发</tag>
      </tags>
  </entry>
  <entry>
    <title>五分钟配置好一台阿里云服务器</title>
    <url>/2018/10/27/%E4%BA%94%E5%88%86%E9%92%9F%E9%85%8D%E7%BD%AE%E5%A5%BD%E4%B8%80%E5%8F%B0%E9%98%BF%E9%87%8C%E4%BA%91%E6%9C%8D%E5%8A%A1%E5%99%A8/</url>
    <content><![CDATA[
## 准备工作

购买阿里云服务器 , 使用`微柳lamp`安装环境, 选择centos6.9/php7.0

向浏览器输入IP地址 , 即可查看到微柳首页

## 配置

`cd oneinstack/` 进入文件目录

`./change_php_version.sh ` 执行修改PHP版本, 选择7.0

### mysql配置

`./reset_db_root_password.sh ` 执行修改mysql默认密码

`iptables -nvL` 查看防火墙安全配置

`iptables -I INPUT 4 -p tcp -m state --state NEW -m tcp --dport 3306 -j ACCEPT` 打开3306端口

`service iptables save` 保存防火墙配置

`mysql -u root -p` 进入mysql环境

`grant all privileges on *.* to NI9NE@'%' identified by '123456';` 添加mysql数据库控制用户

`flush privileges;` 刷新权限

`exit` 退出mysql

使用Navicat使用非root账户登录云服务器数据库

### 安装composer

`curl -sS https://getcomposer.org/installer | php` 

`mv composer.phar /usr/local/bin/composer ` 

`composer self-update` 

`composer config -g repo.packagist composer https://mirrors.aliyun.com/composer/` 使用阿里云源

`composer config -g -l `  查看全局配置

### 安装tp5

`cd /data/wwwroot/default/` 移动到默认页面地址

`composer create-project topthink/think=5.0.* tp5  --prefer-dist` 安装tp5项目文件夹

### 同步本地和云端代码

#### 配置服务器Git环境

`git config --global user.name "NI9NE" ` 配置全局变量

`git config --global user.email "ni9ne@outlook.com"` 

`git config -l` 检查是否设置完成

`cd ~/.ssh/` 进入公钥文件夹

`ssh-keygen -t rsa -C "ni9ne@outlook.com"` 生成公钥

`cat id_rsa.pub ` 查看并复制公钥, 并添加到github账号中

`ssh -T git@github.com` 检测是否链接成功

#### 提交到Git

`git init` 初始化

`git remote add origin git@github.com:NI9NE/thinkphp5.git` 链接仓库分支

`git remote -v` 查看链接情况

`git add . ` 

`git commit -m "部署tp5"`

`git push origin master`

#### 下拉代码到本地端

在本地环境目录打开cmd 

`git clone git@github.com:NI9NE/thinkphp5.git tp5` 

 `cd tp5` 

`composer install` 安装依赖

> thinkphp由于被添加进ignore目录,所以没有在git中上传 , 也无法拉到本地, 所以需要重新安装依赖

### 配置虚拟主机]]></content>
      <categories>
        <category>开发资料</category>
      </categories>
      <tags>
        <tag>框架开发</tag>
        <tag>云服务器</tag>
      </tags>
  </entry>
  <entry>
    <title>框架开发 TP5-助手函数</title>
    <url>/2018/10/21/%E6%A1%86%E6%9E%B6%E5%BC%80%E5%8F%91%20TP5-%E5%8A%A9%E6%89%8B%E5%87%BD%E6%95%B0/</url>
    <content><![CDATA[
### ThinkPHP helper函数

| 函数            | 功能                                                         | 参数                                                         | 返回值                                       |
| --------------- | ------------------------------------------------------------ | ------------------------------------------------------------ | -------------------------------------------- |
| import()        | 导入所需要的类库                                             | 类库命名空间字符串(`$class`),起始路径`$$baseURL`,导入文件扩展`$ext` | bool值                                       |
| load_trait()    | 快速导入trait                                                | trait库`$class`,类库扩展名`$ext`                             | bool值                                       |
| exception()     | 抛出异常                                                     | 异常消息`$msg`,异常代码`$code`=0,异常类`$exception`          | 异常对象                                     |
| debug()         | 记录时间(微秒)和内存使用情况                                 | 开始标签`$start`,结束标签`$end`,小数位`$dec`(等于m代表统计内存占用) | 混合数据                                     |
| lang()          | 获取语言变量值                                               | 语言变量名`$name`,动态变量值`$vars`=[],语言`$lang`=''        | 混合数据                                     |
| config()        | 获取和设置配置参数                                           | 参数名`$name`='',参数值`$value`=null,作用域`$range`=''       | 混合数据                                     |
| input()         | 获取输入数据,支持默认值和过滤                                | 获取的变量名`$key`='',默认值`$default`=null,过滤方法`$filter`='' | 混合数据                                     |
| widget()        | 渲染输出                                                     | widget名称`$name`,传入的参数`$data`=[]                       | 混合数据                                     |
| model()         | 实例化                                                       | Model名称`$name`='',业务层名称`$layer`='model',是否添加类名后缀`$appendSuffix`=false | \think\Model                                 |
| validate()      | 实例化验证器                                                 | 验证器名称`$name`='',业务层名称`$layer`='validate',是否添加类名后缀`$appendSuuffix`=false | \think\Validate                              |
| db()            | 实例化数据库                                                 | 操作的数据表名称(不含前缀)`$name`='',数据库配置参数`$config`=[],是否强制重新连接`$force`=false | \think\db\Query                              |
| controller()    | 实例化控制器                                                 | 资源地址`$name`,控制层名称`$layer`='controller',是否添加类名后缀`$appendSuffix`=false | \think\Controller                            |
| action()        | 调用模块的操作方法                                           | 调用地址`$url`,调用参数(数组/字符串)`$vars`=[],要调用的控制层名称`$layer`='controller',是否添加类名后缀`$appendSuffix`=false | 混合数据                                     |
| vendor()        | 快速导入第三方框架类库,多有第三方框架的类库文件统一放到系统的vendor目录下 | 类库`$class`,类库后缀`$ext`=EXT                              | bool值                                       |
| dump()          | 浏览器良好的变量输出                                         | 变量`$var`,是否输出`$echo`=true,标签`$label`=null            | void\|string                                 |
| url()           | 生成url                                                      | 路由地址`$url`='',变量`$vars`='',生成的URL后缀`$suffix`=true,域名`$domain`=false | url字符串                                    |
| session()       | Session管理                                                  | session名称`$name`(如果为数组表示进行session设置),session值`$value`='',前缀`$prefix`=null | 混合数据                                     |
| cookie()        | Cookie管理                                                   | cookie名称`$name`(如果为数组表示进行cookie设置),cookie值`$value`='',参数`$option`=null | 混合数据                                     |
| cache()         | 缓存管理                                                     | 缓存名称`$name`(如果为数组表示进行缓存设置),缓存值`$value`='',缓存参数`$option`=null,缓存标签`$tag`=null | 混合数据                                     |
| trace()         | 记录日志信息                                                 | log信息(支持字符串和数组)`$log`='[think]',日志级别`$level`='log' | void\|array                                  |
| request()       | 获取当前Request对象实例                                      | 输出数据`$data`=[],状态码`$code`=200,头信息`$header`=[],类型`$type`='html' | Response                                     |
| view()          | 渲染模板输出                                                 | 模板文件`$template`='',模板变量`$var`=[],模板替换`replace`=[],状态码`$code`=200 | \think\response\View                         |
| json()          | 获取\think\response\Json对象实例                             | 返回的数据`$data`=[],状态码`$code`=200,头部`$header`=[],参数`$options`=[] | \think\response\Json                         |
| jsonp()         | \think\response\Jsonp                                        | 返回的数据`$data`=[],状态码`$code`=200,头部`$header`=[],参数`$options`=[] | \think\response\Jsonp                        |
| xml()           | 获取\think\response\Xml对象实例                              | 返回的数据`$data`=[],状态码`$code`=200,头部`$header`=[],参数`$options`=[] | \think\response\Xml                          |
| redirect()      | 获取\think\response\Redirect对象实例                         | 重定向地址`$url`=[],额外参数`$params`=[],状态码`$code`=302,隐式转换`$with`=[] | \think\response\Redirect                     |
| abort()         | 抛出HTTP异常                                                 | 状态码或Response对象实例`$code`,错误信息`$message`=null,参数`$header`=[] |                                              |
| halt()          | 调试变量并且中断输出                                         | 调试变量或信息`$var`                                         |                                              |
| token()         | 生成表单令牌                                                 | 令牌名称`$name`='__token__',令牌生成方法`$type`='MD5'        | 字符串                                       |
| load_relation() | 延迟预载入关联查询                                           | 数据集`$resultSet`,关联`$relation`                           | 数组                                         |
| collection()    | 数组转换为数据集对象                                         | 数据集数组`$resultSet`                                       | \think\model\Collection或者\think\Collection |]]></content>
      <categories>
        <category>开发资料</category>
      </categories>
      <tags>
        <tag>框架开发</tag>
        <tag>ThinkPHP5</tag>
      </tags>
  </entry>
  <entry>
    <title>框架开发-Laravel</title>
    <url>/2018/11/12/%E6%A1%86%E6%9E%B6%E5%BC%80%E5%8F%91-Laravel/</url>
    <content><![CDATA[
## 0. 准备姿势 (安装部署)

1. composer(依赖管理工具) 安装/使用
   1.1. composer下载

   ```
   `https://getcomposer.org`     [composer官网]
   ```

   1.2. 环境检查
   1.3. 安装
   1.4. 源地址问题

   ```
   `https://developer.aliyun.com/composer` [Composer 阿里镜像]
   ```

   1.5. 使用composer

   ```
   PS. 下载量最高的 100 个 Laravel 扩展包推荐
   https://github.com/summerblue/laravel-package-top-100
   ```

------

2. Laravel安装

2.0 Laravel被称为“全栈”式框架,因为它能够处理从网络服务到数据库管理、HTML生成的一切事情,垂直集成的web开发环境给开发者提供了更好的体验

Laravel是一套简洁、优雅的PHP Web开发框架(PHP Web Framework)。它可以让你从面条一样杂乱的代码中解脱出来；它可以帮你构建一个完美的网络APP，而且每行代码都可以简洁、富于表达力。

2.1. 选择Lravel框架的版本 与 运行环境

Laravel 版本计划
    LTS 与 非LTS
        LTS意为: Long Time Support.
        非LTS: 更新频繁.

```
    Laravel 5.1 LTS – 2015 年 6 月份
        LTS 长久支持版本，Bug修复直到2017年6月份，安全修复直到2018年6月份.
    Laravel 5.2 – 2015 年 12 月份
        一般发行版，提供6个月的Bug修复支持，一年的安全修复支持.
    Laravel 5.3 – 2016 年 8 月份
        一般发行版，提供6个月的Bug修复支持，一年的安全修复支持.
    Laravel 5.4 – 2017 年 1 月份
        一般发行版，提供6个月的Bug修复支持，一年的安全修复支持.
    Laravel 5.5 LTS – 2017 年 7 月份
        下一个版本的LTS版本，会停止Laravel 5.1的Bug修复，安全修复直到2018年7月份.
```

2.2. 安装Laravel

```
`http://laravelacademy.org`

1). 通过Composer 安装 Laravel 安装器
2). 通过Composer Create-Project 新建项目

    composer create-project --prefer-dist laravel/laravel laravel-case 5.5.*
```

```
3). 复制已安装好的 laravel框架
```

2.3. 访问 / 配置虚拟主机

------

## 一. 初识佳人 (基本及配置)

1. Laravel的目录结构

   ![1567586616147](/images/imgs/客户端 浏览器.png)

1.1. Laravel的目录部署

```
    |-- app              应用目录(程序逻辑部分)
    |-- bootstrap        启动和自动载入配置目录
        |-- cache            存放框架启动缓存
        |-- app.php          创建框架应用实例
        |-- autoload.php     自动加载
    |-- config           配置文件目录
        |-- app.php          系统级配置文件
        |-- auth.php         用户身份认证配置文件
        |-- broadcasting.php 事件广播配置文件
        |-- cache.php        缓存配置文件
        |-- compile.php      编译额外文件和类需要的配置文件,一般用户很少用到
        |-- database.php     数据库配置文件
        |-- filesystems.php  文件系统配置文件,这里可以配置云存储参数
        |-- mail.php         电子邮件配置文件
        |-- queue.php        消息队列配置文件
        |-- services.php     可存放第三方服务的配置信息
        |-- session.php      配置session的存储方式和生命周期等信息
        |-- view.php         模板文件配置文件,包含模板目录和编译目录等
    |-- database         数据库迁移和填充文件目录
    |-- public           网站入口目录
        |-- css              前端CSS文件目录
        |-- js               前端JS文件目录
        |-- index.php        入口文件
        |-- .htaccess        Apache服务器用该文件重写URL
        |-- web.config       IIS服务器用该文件重写URL
    |-- resources        视图与原始资源文件目录
        |-- assets           可存放包含LESS、SASS、CoffeeScript在内的原始资源文件
        |-- lang             本地化文件目录
        |-- views            视图文件目录(view层文件就在这里)
    |-- routes           路由目录(3种路由文件)
        |-- web.php          包含的路由都会应用web中间件组
        |-- api.php          包含的路由应用了api中间件组
        |-- console.php      用于定义所有基于闭包的控制台命令
    |-- storage          本地存储:编译后的blade模板等文件目录
        |-- app              可用于存储应用程序所需的一些文件
        |-- framework        该目录下包括缓存、sessions和编译后的视图文件
        |-- logs             日志目录
    |-- tests            自动化测试目录
    |-- vendor           Composer依赖目录(Laravel框架源码和第三方类库)
    |-- .env             环境配置文件
    |-- .env.example     环境配置文件(示例)
    |-- .gitattributes   用于设置文件的对比方式(GIT)
    |-- .gitignore       忽略文件(GIT)
    |-- artisan          控制台命令文件
    |-- composer.json    Composer的依赖关系描述文件
    |-- composer.lock    Composer的锁定版本库文件
    |-- gulpfile.js      前端构建工具gulp的配置文件
    |-- package.json     npm的依赖模块配置文件
    |-- phpunit.xml      php单元测试文件
    |-- readme.md        读我.md
    |-- server.php       PHP内置web服务器的快速调试脚本
```

1.2. App应用目录

```
    @ 表示默认不存在,但可创建的内容
    |-- Console         命令行程序目录(自定义的Artisan命令)
        |-- Commands        包含了用于命令行执行的类,可在该目录下自定义类
        |-- Kernel.php      命令调用内核文件
    |-- Exception       异常处理器
    |-- Http            控制器、中间件以及表单请求等
        |-- Controllers     控制器目录
        |-- Middleware      中间件目录
       @|-- Requests        请求类目录
        |-- Kernel.php      包含http中间件和路由中间件的内核文件
    |-- Providers           服务提供者:绑定服务到容器、注册事件等
    User.php                ORM 模型类(对象关系映射)

   @|-- Events              事件类目录,处理应用事件的
   @|-- Jobs                队列任务
   @|-- Listeners           事件监听器
   @|-- Mail                邮件发送类
   @|-- Notifications       应用发送的所有通知
   @|-- Policies            授权策略类
```

------

2. Laravel的配置

2.1. 开发前的一些配置

```
1).目录权限问题
    /storage
    /vendor
    /bootstrap/cache

2).应用密钥 (APP_KEY)
    php artisan key:genera

3).时区设置

4).清空缓存
    php artisan cache:clear

```

2.2. 开发中用到的配置
    1). 环境配置文件说明
        .env
    2). 访问配置
    3). 配置缓存
        php artisan config:cache
    4). 维护模式(网站一键离线功能)
        php artisan down
        php artisan up

```
5). 错误&日志

```

```
6). HTTP 状态异常

```



------

## 二. 尝试接近 (路由)

1. 路由说明 文件位置



2. 基本路由

```
    Route::get('/get',function(){}); //GET方式
    Route::post('/post',function(){}); //POST方式
    Route::match(['get','post'],'/',function(){});//指定一组 允许的请求方式
    Route::any('/all',function(){});//可响应所有 HTTP请求
    Route::put(...); //不常用
    Route::delete(...); //不常用
    Route::options(...);//不常用
    以上请求方式中,只有get与options不需要csrf验证

```

PS.1  postman 请求工具

3. 参数路由
   3.1. 必选参数
   3.2. 可选参数
   3.3. 约束参数格式
   3.4. 多个参数
4. 命名路由

5. 路由组设置

6. 当前访问的路由信息
   返回数组,包含路由信息
   `$route = Route::current();`
   路由name的名字,放在控制器里执行
   `$name = Route::currentRouteName();`
   控制器里action名称
   `$action = Route::currentRouteAction();`

PS.2 Laravel-Debugbar 调试工具
    用于显示调试 及 错误信息 以方便开发.

------

PS.1 postman 请求工具
可指定模拟GET或POST等多种方式,去请求页面.
下载Postman程序 https://www.getpostman.com/
    GET方式,在URL地址栏里带参数,直接请求即可.
    POST方式: 要设置以下两项
        Headers (请求头数据类型,同表单enctype的默认值)
        Body (请求体)

------

PS.2 Laravel-Debugbar 调试工具
用于显示调试 及 错误信息 以方便开发.
!(只能在开发过程中 使用该扩展包:因为它会 显示框架信息 还对性能有影响)

1.安装 Debugbar
`barryvdh/laravel-debugbar`
https://packagist.org/packages/barryvdh/laravel-debugbar

使用方法,请参考文档!

## 三. 执子之手 (中间件)

0. 中间件介绍
1. 创建中间件
   `php artisan make:middleware Test`
2. 中间件功能设计
3. 注册中间件
   全局中间件:    $middleware
   中间件组:      $middlewareGroups
   指定路由中间件: $routeMiddleware
4. 使用中间件
5. CSRF保护
   HTML表单里设置CSRF令牌
   从CSRF保护中排除指定URL
   JQuery中的CSRF令牌处理

------

## 四. 正式交往 (控制器)

0. 控制器介绍
1. 创建控制器
   使用Artisan命令创建
   php artisan make:controller UserController
   php artisan make:controller OrderController
2. 使用路由访问控制器
   1. 普通访问
   2. 带参数访问
   3. 别名访问
3. 单动作控制器(单功能)
4. 控制器中间件
5. RESTful 资源控制器
   `php artisan make:controller PhotoController --resource`
6. 依赖注入 & 控制器
   0. 依赖注入说明
   1. 构造函数注入
   2. 方法注入
   3. GET参数 与 路由参数 的问题
7. 路由缓存 (基于控制器)
   生成路由缓存: `php artisan route:cache`
   移除路由缓存: `php artisan route:clear`

------

## 五. 提出要求 (HTTP请求)

1. HTTP请求的报文的说明
2. 基本信息获取
3. 请求参数的获取
4. 闪存信息
5. 文件信息处理

------

## 六. 满足要求 (HTTP响应)

1. 返回字串/数组/视图/json
2. 响应-下载
3. 跳转和重定向

------

## 七. 制造美好 (视图)

------

## 八. 人造人计划 (DB数据操作)

1. 连接数据库
2. 原生数据库操作
3. 查询构建器 



--

]]></content>
      <categories>
        <category>学习笔记</category>
      </categories>
      <tags>
        <tag>框架开发</tag>
        <tag>Laravel</tag>
      </tags>
  </entry>
  <entry>
    <title>框架开发-PSR/命名空间/trait/smarty</title>
    <url>/2018/09/30/%E6%A1%86%E6%9E%B6%E5%BC%80%E5%8F%91-PSR%20%E5%91%BD%E5%90%8D%E7%A9%BA%E9%97%B4%20trait/</url>
    <content><![CDATA[


# PSR 编码规范

```
PHP编码规范PSR（中文版）
https://github.com/PizzaLiu/PHP-FIG
```

====================================

# PDO

1. 复习 PDO
   - 实例化PDO  DSN: mysql:host=127.0.0.1;dbname=xx
   - 设置PDO的连接属性: setAttribute()  
     - 是否自动提交
       属性
           PDO::ATTR_AUTOCOMMIT
       值
           0 关闭 / 1 开启
     - SQL错误处理方式
       属性
           PDO::ATTR_ERRMODE
       值
           PDO::ERRMODE_SILENT    无提示(默认)
           PDO::ERRMODE_WARNING   报错WARNING
           PDO::ERRMODE_EXCEPTION 抛出异常
     - 返回结果集的形式
       属性
           PDO::ATTR_DEFAULT_FETCH_MODE
       值
           PDO::FETCH_ASSOC 关联
           PDO::FETCH_NUM   索引
           PDO::FETCH_OBJ   对象
           PDO::FETCH_BOTH  混合
   - PDO的增删改查
     exec()  返回受影响行数 用于增删改
     query() 返回PDOStatement的实例 用于查询
     处理查询结果集
         fetch() 单条数据/一维数组
         fetchAll() 所有数据/二维数组
         使用foreach遍历PDOStatement对象
   - PDO对象
     setAttribute()  设置连接属性
     getAttribute()  获取连接属性
     exec()          返回受影响行数
     query()         返回查询结果集对象
     lastInsertId()   返回自增ID
   - PDOStatement对象
     fetch()         单条数据
     fetchAll()      所有数据
     rowCount()      受影响行数
   - 预处理
     - 预处理的优点
       - 对用户的数据 进行过滤 提高安全性
       - 提高批量操作的性能
     - SQL的占位符
       - ? 
       - :
     - 绑定参数
       - bindValue()
       - bindParam()
       - execute()
     - 结果集的预处理
       - bindColumn()

```
- 事务操作

    将多条 SQL操作(增删改),作为一个 整体单元 来操作.
    都执行成功 则成功,有一条失败 则都失败.
    InnoDB  支持事务 / 行锁机制

    begin    开启一个事务的回滚点
    rollback 回滚一个事务,回到begin前的状态
    commit   提交一个事务,只有被提交的事务,才会被写入表中

    MySQL 默认是开启 自动提交的.
```



====================================

# 命名空间 (php 5.3 +)

1. 命名空间概述

2. 定义命名空间

语法
     namespace 命名空间名称;
特点
    1. namespace 需要 php 5.3 +
    2. namespace 前面不允许有任何的代码(除了namespace自己)
       它的作用范围 到下一个命名空间开始 或 脚本结束 为止
    3. namespace 只对本脚本起作用
    4. 文件里如果没有定义命名空间,则默认在全局空间之中

3. 定义子命名空间

   namespace a\b\c\d...

4. 在同一个文件中 定义多个命名空间
   1. 不推荐 一般一个文件中只有一个命名空间
   2. 万不得已 建议使用 {}  将对应的代码包裹

5. 使用命名空间：基础

非限定名称
    直接使用函数/类/常量,没有命名空间成分
限定名称
    有命名空间成分,但是不以反斜线开头的. (类似于相对路径)
完全限定名称
    以反斜线开头,又有命名空间成分. (类似于绝对路径)

6. 命名空间 和 动态语言特征

   如果把 函数名/类名/常量名 赋值给变量使用
   在命名空间里 `必须`使用完全限定名称
   PS. 注意完全限定名称时,必须使用单引号.

7. namespace 关键字 和 __NAMESPACE__ 常量

   - namespace 关键字
     - 定义命名空间
     - 用来简化调用
   - __NAMESPACE__ 常量
     - 获取本命名空间的名字

   ::class
       自 PHP 5.5 起，关键词 class 也可用于类名的解析。
       使用 ClassName::class 你可以获取一个字符串，包含了类 ClassName 的完全限定名称。
       这对使用了 命名空间 的类尤其有用。 

8. 使用命名空间：别名/导入
   别名
       use 命名空间 [as 别名];
   导入
       use 命名空间\类名 [as 别名]; 
       只能导入类 不能导入函数

9. 全局空间

namespace {}

10. 使用命名空间：后备全局函数/常量

11. 命名空间的实用

==============================================

# Trait (php 5.4 +)

1. Trait的概述
   Trait 是 PHP5.4 中的新特性，是 PHP 多重继承的一种解决方案。
   例如，需要同时继承两个类或抽象类，
   这将会是件很麻烦的事情，Trait 就是为了解决这个问题。

2. Trait的简单使用
   格式:
       trait 名字 { 属性 + 方法}
   特点:
       1. 不能有常量
       2. 不能被实例化的
       3. 在类中 使用use关键字 来混入trait

3. 多个Trait的引用

   use A,B;

4. Trait之间的嵌套

   一个trait可以由多个trait组成
   可以在trait中 使用use ...

5. Trait的属性

   在trait中 可以定义属性并且可以使用
   但是在使用了use 的类中,不允许重复定义与trait同名的属性

6. Trait的方法优先级

   class 中 如果有和trait重名的方法 则class附带trait
   继承时,trait方法会覆盖class的同名方法

7. Trait的修饰符
   static
       静态的属性只能静态读取,静态的方法可以 动/静 态调用
   abstract
       如果在trait中有抽象方法 则 在use的类中必须实现才可使用

8. Trait冲突
   1. 代替
      insteadof  指定替代的方法
   2. 起别名
      使用 as 给方法起别名

# 模版引擎

1. 什么是模板引擎

   1.1 定义
       模板引擎实现 前后端的分离

   1.2 优势
       分工明确
       程序灵活性
       代码可读性
       提高开发效率

   1.3 问题
       会降低执行效率

   1.4 模板引擎分类
       编译型
       解释型
       置换型

2. 选择 smarty 模板引擎

   2.1 为什么选择smarty
       1). 编译型 速度较快
       2). php 官方推荐
   2.2 smarty 优势
       1). 开源
       2). 插件机制
       3). 模板继承
       4). 缓存控制

3. 安装smarty及初始化配置

   3.1 获取smarty
       http://www.smarty.net/
   3.2 搭建smarty入口文件
       1). 导入smarty
       2). 实例化smarty
       3). 初始化 配置
            配置 模板文件 目录
            配置 编译文件 目录
            配置 配置文件 目录
            配置 缓存文件 目录
            配置 模板变量的定界符
            配置 缓存控制 (开启缓存/缓存时间)
       4). 分配变量 assign()
       5). 加载模板 display()

4. smarty的基本应用

   4.1 程序员(PHP)
       1). smarty初始化配置
       2). 运算操作： 数据库 文件， 数据计算...
       3). 缓存控制， 插件扩展...
   4.2 美工(模版)
       1). 把模板变量放在指定的位置
       2(). 其他操作： 遍历数据、 模板函数...

5. smarty设计的基本语法

   5.1 注释
       `{**}`

   5.2 模板中路径问题
       模版文件中所有的相对路径 都相对于 PHP定位
       link/script/img/a

   5.3 模板中读取变量
       输出规则 同 echo 一致

   5.4 在模板中定义变量
       {assign var="" value=""}
       {assign "param" "value"}
       {$param = value}

   5.5 忽略解析
       {literal}{/literal}

6. smarty模板中的变量应用

   6.1 在模板中遍历 数组
       {foreach}{/foreach}
       {section}{/section}

   6.2 模板中读取内置变量(保留变量)

   ```
       {smarty.post}        POST
       {smarty.get}         GET
       {smarty.request}     请求数据
       {smarty.session}     SESSION
       {smarty.cookies}     COOKIE
       {smarty.server}      服务器信息
       {smarty.const}       常量
       {smarty.version}     Smarty版本
       {smarty.template}    模板文件
       {smarty.current_dir} 模板文件目录
       {smarty.now}         当前时间
       {smarty.ldelim}      左定界符
       {$smarty.rdelim}     右定界符
   ```

7. 缓存控制

   7.1 缓存的配置
       caching           是否开启缓存
       cache_lifetime    缓存时间
       cache_dir         缓存目录

   7.2 默认 一个模板 对应一个缓存

   7.3 一个模板 产生 多个缓存
       display(url, 缓存号);

```
7.4 为缓存 减少开销
    isCached(url, 缓存号);

7.5 清除缓存
    clearCache(url, 缓存号);
    clearCache(url);
    clearAllCache();
```

8. 模板继承
   {extends file=""}
   {block name=""}{/block}

9. 内置函数
   9.1 内置函数
       {include}
       {config_load}
       {extends}
   9.2 内置块状函数
       {foreach}{/foreach}
       {if}{/if}
       {block}{/block}

# smarty模板引擎

> 版本不同,对于PHP的支持也不相同 , 推荐使用3.1.10版本

新建工作目录:

```
	/emplates/i.html
	/emplates/.htaccess(Apache的分布式配置文件)
	/libs(smarty库)
```

配置.htaccess文件,闲置用户直接访问模板引擎

```
	deny from all
```

创建基础配置文件init.php

```
// 1). 导入smarty
require './libs/Smarty.class.php';
// 2). 实例化smarty
$smarty = new Smarty();
// var_dump($smarty);
// 3). 初始化 配置
//         配置 模板文件 目录
$smarty->template_dir = './templates';
//         配置 编译文件 目录
$smarty->compile_dir = './templates_c';
//         配置 配置文件 目录
$smarty->config_dir = './configs';
//         配置 缓存文件 目录
$smarty->cache_dir = './caches';
//         配置 模板变量的定界符  
//   原有定界符为{},可能会和css及js使用冲突,建议修改
//   通常使用{{ }}或<{ }>   甚至<!-- --> 或 << >>
$smarty->left_delimiter = '{{';
$smarty->right_delimiter = '}}';

//         配置 缓存控制 (开启缓存/缓存时间)
           #不设置时间默认一个小时
$smarty->caching = false; #默认false关闭
$smarty->cache_lifetime = 10; #设置10s
```

创建入口文件index.php

```
require './init.php';
//    4). 分配变量 assign()
$smarty->assign('title','标题');
$smarty->assign('content1','内容1');
$smarty->assign('content2','内容2');
$smarty->assign('content3','内容3');
$smarty->assign('content4','内容4');
//    5). 加载模板 display()
$smarty->display('./1.html');

```

注释:

`{* 注释内容 *}` 

路径问题:

- 加载css或图片路径为当前入口位置(index.php)为基准
- 但在加载的css文件中引用图片路径时, 是以当前css文件为基准的

输出类型

> 模板中所有assign输出都是`echo` 机制 , true被解析为1 , false被解析为空字符串 , 不能输出数组 和 对象数据

- 对于数组, 可以使用 `{var_dump($arr)}` 的格式输出 , 也可以使用 `{$arr[2]}` 或 `{$arr.2}` 读取
- 对于obj对象 , 首先需要`$smarty->assign('obj',new User());` ,  然后在html模板中使用`    <p>{$obj->name}</p>` 或 `    <p>{$obj->demo()}</p>` 调用]]></content>
      <categories>
        <category>学习笔记</category>
      </categories>
      <tags>
        <tag>框架开发</tag>
        <tag>trait</tag>
        <tag>smarty</tag>
      </tags>
  </entry>
  <entry>
    <title>框架开发-TP5</title>
    <url>/2018/10/10/%E6%A1%86%E6%9E%B6%E5%BC%80%E5%8F%91-TP5/</url>
    <content><![CDATA[
## 一. 初识佳人 (ThinkPHP 5.0 基本)

### TP5 环境要求

PHP >= 5.4.0
PDO PHP Extension       PDO类
MBstring PHP Extension  多字节字符串函数

> 查询文档手册中mb字符串函数

CURL PHP Extension      钩子/爬虫

### 目录结构

1).部署框架 目录结构

```
        tp5
        ├─application     应用目录
        ├─extend          扩展类库目录（可定义）
        ├─public          网站对外访问目录
        ├─runtime         运行时目录（可定义）(linux777权限)
        ├─vendor          第三方类库目录（Composer）
        ├─thinkphp        框架核心目录
        ├─build.php       自动生成定义文件（参考）
        ├─composer.json   Composer定义文件
        ├─LICENSE.txt     授权说明文件
        ├─README.md       README 文件
        └─think           命令行工具入口
        !(如果在linux环境下面的话,需要给runtime目录755权限)
```

```
PS. 几个关键的路径:
```

```
        目录            说明             常量
        tp5             项目根目录       ROOT_PATH
        tp5/application 应用目录         APP_PATH
        tp5/thinkphp    框架核心目录     THINK_PATH
        tp5/exend       应用扩展目录     EXTEND_PATH
        tp5/vendor      Composer扩展目录 VENDOR_PATH
```

```
-------

2).核心框架 目录的结构
```

```
        ├─thinkphp 框架系统目录(请只读)
        │  ├─lang               语言包目录
        │  ├─library            框架核心类库目录
        │  │  ├─think          think 类库包目录
        │  │  └─traits         系统 traits 目录
        │  ├─tpl                系统模板目录(修改请保留源文件)
        │  │
        │  ├─.htaccess          用于 apache 的重写
        │  ├─.travis.yml        CI 定义文件
        │  ├─base.php           框架基础文件
        │  ├─composer.json      composer 定义文件
        │  ├─console.php        控制台入口文件
        │  ├─convention.php     惯例配置文件
        │  ├─helper.php         助手函数文件（可选）
        │  ├─LICENSE.txt        授权说明文件
        │  ├─phpunit.xml        单元测试配置文件
        │  ├─README.md          README 文件
        │  └─start.php          框架引导文件
```

```
-------

3).默认应用 目录结构:
```

```
        ├─application            应用目录（可设置）
        │  ├─index              模块目录(可更改)(可多模块)
        │  │  ├─config.php     模块配置文件
        │  │  ├─common.php     模块公共文件
        │  │  ├─controller     控制器目录
        │  │  ├─model          模型目录
        │  │  └─view           视图目录
        │  │
        │  ├─command.php        命令行工具配置文件
        │  ├─common.php         应用公共文件
        │  ├─config.php         应用配置文件
        │  ├─tags.php           应用行为扩展定义文件
        │  ├─database.php       数据库配置文件
        │  └─route.php          路由配置文件
```

### 架构总览

### 生命周期

### 入口文件 / 公共资源说明

public/static中的gitignore文件声明了所有该文件中的数据全部不会上传到git

方便采用本地调试 , 远程部署的设计结构(CDN服务/OSS)

### URL访问

### 调试模式

配置: 编程过程中只需要关注应用配置和模块配置就够了

application/config.php中配置

​	开发过程中开启app_debug, app_trace(配置位置为console台), 

​	**注意: 上线后必须将配置还原; 该配置打开可能会影响接口的调试和正常运行**

> phpstorm中可以完成git操作,并配合码云安装IDEA插件

### 控制器

新建模块
    `php think build --module admin` 
新建控制器
   ` php think make:controller admin/User --plain `

### 视图

> PHPstorm快捷键: 
>
> ​	美化 :Ctrl+Alt+L
>
> ​				Ctrl+Alt+Shift+L

## 二. 尝试接近 (CURD 操作 Db类)

### 数据库配置

application/database.php

> 本地使用时使用服务器ip , 和服务器专用账号, 上传时修改为本地ip
>
> 3306  
>
> 表前缀

### 查询数据

```
use think\Db;

 //原生sql
$list = Db::query('select * from users');
$list = Db::query('select * from users where id=?', [3]);

//DB类
$list = Db::table('users')->order(['id'=>'desc'])->select();

//助手函数(无需use think\Db 也可以使用)
$list = db('users')->order(['id'=>'desc'])->select();  
```

### 新增数据

```
//原生sql
$list = Db::execute("insert into users (id, name, age) values (null,'西格玛','22')");
$list = Db::execute('insert into users (id, name, age) values (:id, :name, :age)', ['id' => null, 'name' => 'tiger', 'age' => 13]);

//DB类
$list = Db::table('users')->data(['name'=>'cat','age'=>22])->insert();
$list = Db::table('users')->insert(['name'=>'cat','age'=>22]);
$list = Db::table('users')->insertGetId(['name'=>'cat1','age'=>12]);

//助手函数
$list = db('users')->insert(['name'=>'cat1','age'=>12]);
$list = db('users')->insertGetId(['name'=>'cat3','age'=>12]);
```

### 删除数据

```
//原生sql
$list = Db::execute('delete from users where name="cat1"');

//DB类
$list = Db::table('users')->delete(80); #主键才可以这么玩
$list = Db::table('users')->where(['name'=>'cat'])->delete();
$list = Db::table('users')->where('name','cat')->delete();

//助手函数
$list = db('users')->where('name','tiger')->delete();
```

### 更新数据

```
//原生sql
$list = Db::execute('update users set age=33 where name="西格玛"');

//DB类
$list = Db::table('users')->where(['id'=>'77'])>update(['name'=>'daboluo','age'=>'11']);
$list = Db::table('users')->where('id',77)->update(['name'=>'dalao','age'=>'11']);

//助手函数 
$list = db('users')->where('id',77)->update(['name'=>'dalao01','age'=>'11']);
```

------

> 若设置了表前缀功能 , 将table替换为name即可正常使用

## 三. 探索深入 (路由)

### 1.默认的URL规则

### 2.路由文件

​	1.配置文件目录

​	`application/config.php`

```
 推荐使用强制路由模式,配置后不再使用pathinfo格式的路径模式
 	// 是否开启路由
    'url_route_on'           => true,
    // 是否强制使用路由
	'url_route_must'         => true,
```

​	2.路由设置目录

​    `application/route.php`

```
use think\Route
//设置路由格式
Route::get('/','index/index/index');  
```

### 3.路由概念/规则

```
    从规则上区分 路由分为: 动态路由 和 静态路由 两种
    从设置方式上 路由分为: 动态注册 和 静态注册 两种

    路由规则中 包含变量的 就是动态路由,没有包含任何变量的称为静态路由.
    在路由文件中 return数组的 路由形式, 称之为 静态注册
    使用Route类的方法 注册的路由 称之为 动态注册(5.0推荐)
    以上两者 可同时使用.
```

### 3.定义路由

```
use think\Route
//设置路由格式
Route::get('/','index/index/index');  
Route::post('ppp','index/index/ppp');
//无参数模式
Route::get('/user','index/index/user');
//必须传参数模式
Route::get('/user/:id','index/index/user');
//可有可无参数模式
Route::get('/user/[:id]','index/index/user');
//匹配参数(只能匹配指定的参数,多了报错)
Route::get('/user/[:id]$','index/index/user');
//闭包
Route::get('/user:id',function($id){
	//执行体
});
```

### 4.闭包定义

### 5.路由参数

```
// 动态注册
// Route::rule('路由表达式','路由地址','请求类型','路由参数(数组)','变量规则(数组)');
Route::get('/userlist','admin/user/index',['ext'=>'html|shtml']);  #限制后缀名
```



### 6.变量规则

​    `php think make:controller index/Blog --plain`

```
若使用非路由模式,真实访问路径为:
http://www.tp5.com/index/blog/index/id/123
http://www.tp5.com/index/blog/read/name/naxx
http://www.tp5.com/index/blog/article/year/2015/month/11/day/20

使用路由控制
Route::get('/blog/:id$','index/blog/index',[],['id'=>'\d+']);
Route::get('blog/:name$','index/blog/read',[],['name'=>'\w+']);
Route::get('/blog/:year/:month/:day','index/blog/article',[],['year'=>'\d{4}','month'=>'\d{2}','day'=>'\d{2}']);
之后的路由路径变为:
http://www.tp5.com/blog/22
http://www.tp5.com/blog/anna
http://www.tp5.com/blog/2015/12/12
```

> 解决路由拦截的方法有两种 , 一种是将拦截范围越大的路由越向后移, 一种是在路由路径后加 `$` 截断 

### 7.路由分组

```
// 路由分组用来处理同一个模块下的不同路由
Route::group('blog', [
    ':id$' => 
        [
            'index/blog/index', 
            ['get'], 
            ['id' => '\d+']
        ],
    ':name$' => 
        [
            'index/blog/read', 
            ['get'], 
            ['name' => '\w+']
        ],
    ':year/:month/:day' => 
        [
            'index/blog/article', 
            ['get'], 
            ['year' => '\d{4}', 'month' => '\d{2}', 'day' => '\d{2}']
        ],
]);

```



### 8.生成URL地址

> 使用函数方法url()
>
> 或Url::bulid()

```
use think\Url;
echo Url::build('index/index/user','id=4444');
	# /user/4444.html
echo Url::build('index/index/user',['id'=>'43']);
	# /user/43.html
// 多参数模式
echo Url::build('index/blog/read',['name'=>'annakalina'],'xhtml',true);
	# http://www.tp5.com/blog/annakalina.xhtml
echo Url::build('index/blog/read',['name'=>'annakalina'],'xhtml','www.hao123.com');
	# http://www.hao123.com/blog/annakalina.xhtml
echo Url::build('index/blog/read@www.hao123.com',['name'=>'annakalina'],'xhtml');
	# http://www.hao123.com/blog/annakalina.xhtml
```

**第一个参数为pathinfo路径 , 第二个参数为参数 , 第三个参数为扩展名 , 第四个参数为域名(true表示当前域名 , 也可以写入其他域名)**  

------



------

## 四. 正式交往 (控制器)

### 控制器概念

- 接收路由分配过来的请求
- 接收各种的参数
- 调用模型 取得数据
- 调用模版 输出页面
- 业务逻辑 流程控制/分支/循环.
- 业务分层

### 控制器的定义

### 控制器初始化

> __construct()可能覆盖掉继承的父类同名方法,
>
> 应使用tp5中的_initialize()方法

前置操作: `$beforeActionList` 

```
// ['except' => '方法名,方法名'] #除了指定的方法之外都执行
// ['only' => '方法名,方法名']  #只有指定的方法可以执行
// 实例:
protected $beforeActionList = [
	'first',
	'second' => ['except'=>'hello'],
	'third' => ['only'=>'hello,data'],
]
```



### 跳转和重定向

1. 页面 跳转(存在缓冲时间)jump

```
use think\Controller;
return $this->success('程序执行成功','admin/user/index');
return $this->error('程序执行失败','admin/user/index');
```

> 第二个参数在路由表中包含指定路由的情况下可以直接写pathinfo路径

```
更改固有模板
模板路径: thinkphp/tpl/dispatch_jump.tpl
复制到模板所在目录,修改模板所在目录config.php文件
//配置文件
return [
    'dispatch_error_tmpl' => APP_PATH . 'admin/view/index/jump.html',
//默认成功跳转对应的模板文件
    'dispatch_success_tmpl' => APP_PATH . 'admin/view/index/jump.html',
];
即完成了更换模块模板文件的操作
```

2. 重定向(直接转)redirect

```
use think\Controller;
return $this->redirect('index/index/user','id=5');
return $this->redirect('http://bilibili.com');
```





### 空操作

### 空控制器

> 对于混合路由有效 , 访问到不存在的方法和类时触发 



------

## 五. 执子之手

 (增删改查 用户管理实例 RESTful资源控制器)

### 生成 rest模块的 User资源控制器

`php think build --module rest`
`php think make:controller rest/User`

### RESTful架构说明

www.ruanyifeng.com/blog/2011/09/restful.html
www.ruanyifeng.com/blog/2014/05/restful_api.html
www.ruanyifeng.com/blog/2018/10/restful-api-best-practices.html

![1567586616147](/images/imgs/1567586616147.png)

### 注册资源路由

```
在路由表中添加
Route::resource('users','rest/user');
```

```
// 动态注册
// Route::rule('路由表达式','路由地址','请求类型','路由参数（数组）','变量规则（数组）');
    路由规则:URL访问规则（包括静态规则和动态规则）,只有符合规则的路由才能正确访问;
    路由地址:实际访问的地址（可以是控制器操作、类的方法或者闭包）;
    请求类型:表示当前路由生效使用的请求类型,包括GET/POST/PUT/DELETE等,如果希望任何请求都能访问使用*号（默认值）。
    路由参数:路由匹配的条件约束或设置参数（用于检测或者解析）;
    路由变量:路由规则里面的动态变量以及PATH_INFO里面的参数都称之为路由变量;
    变量规则:路由规则中的变量的匹配规则（正则表达式）;

    支持任意请求规则
    Route::rule('new/:id','News/update');
    定义GET请求路由规则
    Route::get('new/:id','News/read');
    定义POST请求路由规则
    Route::post('new/:id','News/update');
    定义PUT请求路由规则
    Route::put('new/:id','News/update');
    定义DELETE请求路由规则
    Route::delete('new/:id','News/delete');
    所有请求都支持的路由规则
    Route::any('new/:id','News/read');
```



### RESTful实例

1. index  显示资源列表
2. create 显示创建资源表单页
3. save   保存新建的资源
4. read   显示指定的资源
5. edit   显示编辑资源表单页
6. update 保存更新的资源
7. delete 删除指定资源

### 使用实例

```
// 在User.php中获取数据,并使用模板
		$list = Db::name('user')
            ->field(['id', 'name'])
            ->order('id', 'asc')
            ->select();

        return view('user/index', [
            'title' => '用户列表',
            'list' => $list,
        ]);
// 在本模块view目录下创建模板(view/user/index.html)
// 引入css,js文件
    {css href="./static/css/bootstrap.min.css"}
    {css href="__INDEX__rest.css"}
   	{js href="__JS__jquery.min.js"}
	{js href="__JS__bootstrap.min.js"}
```

```
 	#引入文件时或在配置中定义常量
	// 视图输出字符串内容替换
    'view_replace_str'       => [
        '__INDEX__' => '/static/index/',
        '__CSS__' => '/static/index/css/',
        '__JS__' => '/static/index/js/',
    ],
    则变为{css href="__CSS__bootstrap.min.css"}
```

**注意**: 在模板中使用PHP函数时需要在其前添加冒号

​	`{:url()}` 

遍历  `{volist name="list" key="k" id="v"}{/volist}`

```
phpstorm快捷键
Alt+J  快速多选后面的选中元素
Ctrl+Alt+L   快速格式化代码
Ctrl+D   复制指定代码行
Ctrl+Shift+↑/↓   上下移动代码位置

Alt+←/→  切换代码窗口
Alt+↑/↓  快速切换方法
```



------

## 六. 人造人计划 (数据库 Db类)

### 数据库使用的补充

使用框架开发应用，一般不需要 直接操作数据库，而是通过 框架封装好的 数据库中间层 对数据库进行操作。
这样的好处 主要有两个：
一是简化数据库操作，二是做到跨数据库的一致性。

这种设计的中间层 通常称之为 数据库访问抽象层，简称数据访问层（DAL），ThinkPHP5的数据访问层 是基于PHP内置的PDO对象实现。一般抽象层本身 并不直接操作数据库，而是通过 驱动来实现具体的数据库操作。

php think make:controller admin/Test --plain

### 查询相关

2.1. 快捷查询
2.2. 批量查询
2.3. 区间查询
2.4. 多表查询
    1). 手动多表
    2). JOIN
    3). 视图
2.5. 聚合查询
2.6. 子查询
    1.fetchSql 方式
    2.buildSql 方式

------

## 七. 新生 (模型 Model)

ThinkPHP5.0的模型是一种对象-关系映射（Object/Relation Mapping，简称ORM）的封装，
并且提供了简洁的ActiveRecord实现。一般来说，每个数据表会和一个“模型”对应。

ORM的基本特性就是表映射到模型，记录映射到模型对象实例，字段映射到对象属性。

模型是一种对象化的操作封装，而不是简单的CURD操作，简单的CURD操作直接使用前面提过的Db类即可。

模型类和Db类的区别主要在于对象及业务逻辑的封装，Db类的查询默认返回的是数组（或者集合），而模型类返回的是当前的模型对象实例（或者集合），模型是比Db类更高级的数据封装，支持模型关联、模型事件和业务（逻辑）方法。

php think make:model rest/User

]]></content>
      <categories>
        <category>学习笔记</category>
      </categories>
      <tags>
        <tag>框架开发</tag>
        <tag>ThinkPHP5</tag>
      </tags>
  </entry>
  <entry>
    <title>框架开发-composer</title>
    <url>/2018/10/11/%E6%A1%86%E6%9E%B6%E5%BC%80%E5%8F%91-composer/</url>
    <content><![CDATA[
## composer(依赖管理工具) 安装/使用

### 1.1. composer下载

```
`https://getcomposer.org`       [composer官网]
`https://developer.aliyun.com/composer` [Composer 阿里镜像]
```

### 1.2. 环境检查

```
php -version
```

### 1.3. 安装

```
window:
    下载并运行 Composer-Setup.exe
Linux 和 Mac OS X 中运行如下命令:
    curl -sS https://getcomposer.org/installer | php
    mv composer.phar /usr/local/bin/composer
    或: 
    wget https://dl.laravel-china.org/composer.phar -O /usr/local/bin/composer
    chmod a+x /usr/local/bin/composer

更新:
    composer self-update
```

### 1.4. 源地址设置

```
添加镜像源配置:
    阿里云 Composer 全量镜像（推荐）
    镜像类型：全量镜像
    更新时间：1 分钟
    官方地址：https://developer.aliyun.com/composer
    镜像说明：阿里云 CDN 加速，更新速度快，推荐使用
    `composer config -g repo.packagist composer https://mirrors.aliyun.com/composer/`

    安畅网络镜像
    镜像类型：全量镜像
    更新时间：1 分钟
    官方地址：https://php.cnpkg.org/
    镜像说明：此 Composer 镜像由安畅网络赞助，目前支持元数据、下载包全量代理。
    `composer config -g repos.packagist composer https://php.cnpkg.org`

删除镜像配置
    `composer config -g --unset repos.packagist`
查看配置
    `composer config -g -l`
```

### 1.5. 使用composer

​    `https://packagist.org`    [composer包列表]

------

## 安装 ThinkPHP 5.0

0. Thinkphp官网
   `http://www.thinkphp.cn`
1. 使用composer安装
   composer create-project topthink/think=5.0.* tp5  --prefer-dist
2. 使用GIT安装
   ThinkPHP 远程仓库
   GitHub:
       应用项目：https://github.com/top-think/think
       核心框架：https://github.com/top-think/framework
   码云:
       应用项目： https://gitee.com/liu21st/thinkphp5
       核心框架： https://gitee.com/liu21st/framework.git

------

## ]]></content>
      <categories>
        <category>学习笔记</category>
      </categories>
      <tags>
        <tag>框架开发</tag>
        <tag>Composer</tag>
      </tags>
  </entry>
  <entry>
    <title>网页登录验证实现</title>
    <url>/2018/11/07/%E7%BD%91%E9%A1%B5%E7%99%BB%E5%BD%95%E9%AA%8C%E8%AF%81%E5%AE%9E%E7%8E%B0/</url>
    <content><![CDATA[


**第三方登录/短信验证/邮箱验证**

> 该登录注册基于tp5框架, 短信验证是基于`容联云短信平台`接口实现,邮件验证是通过`swiftmailer`插件实现

### 1.搭建前端页面

![1566974419742](/images/imgs/1566974419742.png)

![1566974429645](/images/imgs/1566974429645.png)

### 2.创建路由

### 3.书写注册,登录后台逻辑代码

### 4.创建验证器validate模块

​	validata模块使用basicValidate.php作为入口,其余验证器继承实现

```
<?php
namespace app\index\validate;

use think\Request;
use think\Validate;
use think\Exception;

class basicValidate extends Validate
{
    /** 获取http传入的参数,对这些参数做校验
     * @return bool
     */
    public function goCheck()
    {
        //获取http传入的参数
        // 对这些参数做校验
        $request = Request::instance();
        $params = $request->param();

        $result = $this->check($params);
        if (!$result){
            $error = $this->getError();
            return $error;
        }else{
            return true;
        }
    }


}
```

```
class registerValidate extends basicValidate
{
    protected $rule = [

        'nickname' => 'alphaDash|length:4,25',
        'email'=>['regex'=>'/^[0-9a-zA-Z-_!]{2,18}@[\da-zA-z]{1,10}\.(com|cn|net|org|edu|com\.cn|tv)$/'],
        'pwd'=>'alphaNum|length:4,20',
        'tel'=>['regex'=>'/^1(3\d|4[5-9]|5[0-35-9]|66|7[03-8]|8\d|9[89])\d{8}$/'],
        '__token__'=>'require|token',
    ];
    protected $message = [
        'nickname.alphaDash' => '只能为字母,数字,下划线',
        'nickname.length' => '用户名长度为4-25位',
        'email.regex'=>'邮箱格式错误',
        'pwd.alphaNum'=>'密码只能为数字字母组成',
        'pwd.length'=>'密码长度为4-20位',
        'tel.regex'=>'手机号格式错误',
        '__token__.require'=>'非法提交',
        '__token__.token'=>'请不要重复提交表单',
    ];


}
```





### 5.注册页面引入图形验证及验证码功能

#### 1.1引入图形验证码功能

- 安装

​	`composer require topthink/think-captcha 1.*`

- 引入页面

  `<img onclick="this.src='{:captcha_src(1)}?'+Math.random()" src="{:captcha_src(1)}" alt="captcha" />`

- 页面ajax验证

  ```
      function checkCode(){
          cap = $('#capCode').val();
          $.ajax({
              method: 'get',
              url: "{:url('index/index/verify')}?code=" + cap +"&id=1",
              async : 'false',
              dataType: 'json',
              success: function (data) {
                  console.log(data);
                  if(data){
                      sendMsg();
                  }else{
                      toastr.error('验证码填写出错');
                  }
              },
              error: function () {
                  alert('AJAX1 执行失败');
              }
          });
      }
  ```

- 后台验证

  ```
   use think\captcha\Captcha;
   
   	/**ajax检测验证码是否正确
       * @param $code
       * @param string $id
       * @return mixed
       */
      function verify($code, $id = '')
      {
          $captcha = new Captcha();
          return $captcha->check($code, $id);
      }
  ```

#### 1.2引入短信验证功能

- 依据容联云文档引入`REST.php`到`extend`目录

- 页面使用ajax发送短信请求

  ```
      function sendMsg() {
          tel = $('#name').val();
          console.log(tel);
          $.ajax({
              method: 'get',
              url: "{:url('index/index/send')}?tel=" + tel,
              dataType: 'json',
              success: function (data) {
                  console.log(data);
                  if (data.statusCode=='000000') {
                      toastr.success('短信发送成功');
                  } else {
                      toastr.error(data.statusMsg);
                  }
              },
              error: function () {
                  alert('AJAX 执行失败');
              }
          });
      }
  ```

- 后台处理发送请求

  ```
      // ajax请求发送短信
      public function send(Request $request)
      {
          $get = $request->get();
          $tel = $get['tel'];
          $server = $request->server();
          // 获取用户ip
          $ip = $server['REMOTE_ADDR'];
          $userre = $this->index->checkCount($ip);
          if (!$userre) {
              $data['statusMsg'] = '同一个ip24小时只能发送10条短信';
              $data['statusCode'] ="111111";
              return $data;
          }
          // 生成随机的验证码, 并存储至session
          $code = mt_rand(1000,9999);
          Session::set('code',$code);
          // 提示时间
          $time = 10;
          $data = [$code, $time];
          $result = $this->index->sendSMS($tel, $data, 1);
          return $result;
  
      }
      
          /**
       * 发送模板短信
       * @param to 手机号码集合,用英文逗号分开
       * @param datas 内容数据 格式为数组 例如：array('Marry','Alon')，如不需替换请填 null
       * @param $tempId 模板Id
       */
      function sendSMS($to,$datas,$tempId)
      {
          // 初始化REST SDK
          $rest = new REST('app.cloopen.com','8883','2013-12-26');
          // var_dump($rest);die;
          $rest->SetAccount('8a216da86a58af8b016a900b55cd1cb3','e4360fc2cfee49f6a5c1cb2c2fab73de');
          $rest->setAppId('8a216da86a58af8b016a900b56181cb9');
  
          // 发送模板短信
  //        echo "Sending TemplateSMS to $to <br/>";
          $result = $rest->sendTemplateSMS($to,$datas,$tempId);
          if($result == NULL ) {
              echo "result error!";
              return false;
          }
          if($result->statusCode!=0) {
  //            echo "error code :" . $result->statusCode . "<br>";
  //            echo "error msg :" . $result->statusMsg . "<br>";
              //TODO 添加错误处理逻辑
              return $result;
          }else{
  //            echo "Sendind TemplateSMS success!<br/>";
              // 获取返回信息
  //            $smsmessage = $result->TemplateSMS;
  //            echo "dateCreated:".$smsmessage->dateCreated."<br/>";
  //            echo "smsMessageSid:".$smsmessage->smsMessageSid."<br/>";
              //TODO 添加成功处理逻辑
              return $result;
          }
      }
  ```

  > 注意: 默认echo发送的消息可能干扰前端判断发送状态,推荐全部注释, 前端根据返回的statusCode和statusMsg来做做自己的逻辑
  >
  > 上线时注意要将`extends` 目录中的ignore文件删掉 , 不然上传不到git

#### 1.3引入邮件验证功能

- 安装swiftmail

​	`composer require "swiftmailer/swiftmailer:^6.0"`

- 前台ajax请求发送邮件

  ```
      function sendMail(){
          mail = $('#name').val();
          //console.log(mail);
          $.ajax({
              method: 'get',
              url: "{:url('index/index/sendMail')}?mail=" + mail,
              dataType: 'json',
              success: function (data) {
                  console.log(data);
                  if (data==1) {
                      toastr.success('确认邮件发送成功');
                  } else {
                      toastr.error('确认邮件发送失败');
                  }
              },
              error: function () {
                  alert('AJAX 执行失败');
              }
          });
      }
  ```

- 后台处理请求

  ```
      // ajax请求发送邮件
      public function sendMail($mail)
      {
  
          $transport = new \Swift_SmtpTransport('smtp.163.com', 25); // 邮箱服务器
          $transport->setUsername('xxx@163.com')  // 邮箱用户名
          ->setPassword('abc123456');   // 邮箱密码，有的邮件服务器是授权码
  
          $code = mt_rand(1000,9999);
          Session::set('code',$code);
          $mailer = new \Swift_Mailer($transport);
  
          $message = (new \Swift_Message('您的验证码如下:'.$code)) // 邮件标题
          ->setFrom(['xxx@163.com' => 'xxx有限责任公司']) // 发送者
          ->setTo([$mail => '用户']) //发送对象，数组形式支持多个
          ->setBody($code); //邮件内容
  
  
          $result = $mailer->send($message);
          return $result;
      }
  
  ```

  > 有许多网上的教程都是使用require_once来加载autoload文件, 通过composer安装后, 插件在/vendor文件夹下,不需要require/include 即可使用. 但在new的时候需要加 \ .
  >
  > 上线后由于阿里云服务器默认封禁25端口,就算在规则配置打开也没作用, 使用465端口, encryption 改用  ssl ,之后邮件服务才能正常实现

### 6.第三方登录实现



#### 1.微博

https://www.bilibili.com/video/av14869349/?p=2

1.前往微博开放平台注册开发者,创建应用,获取api key和secret

2.https://open.weibo.com/wiki/SDK 下载SDK

![1567663560489](/images/imgs/1567663560489.png)

3.拆分基础类, 放在`vendor/sina/`目录下, 符合tp5的命名规范

`[SaeTClientV2.php]` 和 `[SaeTOAuthV2.php]`

![1567663732898](/images/imgs/1567663732898.png)

![1567663753322](/images/imgs/1567663753322.png)

4.配置文件定义常量key/secret: 将其放在`public/index.php` 中

![1567663898668](/images/imgs/1567663898668.png)

`composer.json`中写入sina路径, 执行`composer dump-autoload`

![1567668181364](/images/imgs/1567668181364.png)

5.在调用微博登录的页面声明模板变量

```
use sina\SaeTClientV2;
use sina\SaeTOAuthV2;

		$sina = new SaeTOAuthV2(WB_AKEY,WB_SKEY);
        $codeUrl = $sina->getAuthorizeURL(WB_CALLBACK_URL);
        $this->assign('code_url',$codeUrl);
```

页面上应用该变量

![1567664233414](/images/imgs/1567664233414.png)

6.写接受回调函数

```
    public function callback()
    {
        $sina = new SaeTOAuthV2(WB_AKEY,WB_SKEY);
        $keys = array();
        $param = Request::instance()->param();
//        dump($param);
        $keys['code'] = $param['code'];
        $keys['redirct_uri']=WB_CALLBACK_URL;
        $token = $sina->getAccessToken('code',$keys);
//        halt($token);
        if ($token) {
            Session::set('token',$token);
            return $this->fetch();
        }else{
            return $this->error('登录授权失败');
        }
    }
```

7.铺设回调页面,获取当前用户信息,处理登录注册逻辑

```
    public function findUser()
    {
        $sina = new SaeTClientV2(WB_AKEY,WB_SKEY,Session::get('token')['access_token']);
        $ms = $sina->home_timeline();
        $uid_get = $sina->get_uid();
        $uid = $uid_get['uid'];
        $user_message = $sina->show_user_by_id($uid);
        return $user_message;
    }
```



#### 2.qq

##### 1.在 [QQ互联](https://connect.qq.com/) 注册开发者账号,

##### 2.创建应用,

​	审核通过后获取APPid 和 APPkey, 回调地址

![1567685344661](/images/imgs/1567685344661.png)

##### 3.下载PHP sdk开发包

​	[SDK下载](https://wiki.connect.qq.com/sdk下载)

##### 4.配置

在wamp环境运行D:\wamp\www\Connect2.1\index.php 并配置

![1567685542905](/images/imgs/1567685542905.png)

> 配置完成后会生成`API/comm/inc.php`文件, 有用

##### 5.修改类文件

将`Connect2.1\API\class`中的五个php类文件按照TP5的命名方式改造后放入TP5`extend/qq`文件夹

```
- 添加namespace
- 去除require_once
- 文件名改为类名
```

![1567685757072](/images/imgs/1567685757072.png)

![1567685822254](/images/imgs/1567685822254.png)

##### 6.应用

```
use qq\QC;

        $qq = new QC();
        $qqUrl = $qq->qq_login();
        $this->assign('qq_code_url',$qqUrl);

```

![1567686046099](/images/imgs/1567686046099.png)

##### 7.报错处理

​	1.使用后点击报错,未定义的ROOT常量, 查看源码 , 可以看出该处是读取我们开头配置生成的`comm/inc.php`配置文件, 我们直接将其内容赋予Recorder类 

![1567686194361](/images/imgs/1567686194361.png)

![1567686186865](/images/imgs/1567686186865.png)

![1567686361773](/images/imgs/1567686361773.png)

2.点击按钮不跳转, 查看源码发现,`qq_login`方法是直接重定向到指点登录网址, 而不是返回url, 修改之

![1567686653314](/images/imgs/1567686653314.png)

##### 8.处理回调





#### 3.微信







### 7.支付

1.支付宝

2.微信支付:

用户提交订单, 

商户服务器接受信息, 向微信服务器发送请求订单详情信息+商户信息(含回调)

微信服务器返回商户服务器一段字符串

商户利用qrcode生成二维码, 供用户扫码支付

用户扫码, 请求微信服务器完成订单支付

微信服务器返回支付成功或支付失败信息给商户服务器回调地址(异步)















]]></content>
      <categories>
        <category>开发资料</category>
      </categories>
      <tags>
        <tag>接口</tag>
        <tag>ThinkPHP5</tag>
        <tag>第三方登录</tag>
      </tags>
  </entry>
  <entry>
    <title>PHP设计模式详解</title>
    <url>/2020/01/07/PHP%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/</url>
    <content><![CDATA[


## 设计模式

### 定义

可以被反复使用,容易被他人理解的,可靠地代码设计的最佳实践

> 如 laravel中的单例模式,工厂模式,门面模式, 注册树模式(DI/IOC), 适配器模式, 观察者模式等

### 用途

- 良好的代码风格
- 易读性, 可维护性
- 可扩展性
- 稳定性

### 六大原则

```
- 单一职责原则 (single responsibility principle)
	一个类只负责一项职责
- 里氏代换原则 (liskov substitution principle)
	任何基类可以出现的地方, 子类一定可以出现
- 依赖倒置原则 (dependence inversion principle)
	针对接口编程, 依赖于抽象而不依赖于具体
- 接口隔离原则 (interface segregation principle)
	使用多个隔离的接口, 比使用单个接口要好, 即降低类之间的耦合度
- 迪米特原则/最少知道原则 (demeter principle)
	一个实体应当尽量少地与其他实体之间发生相互作用, 使得系统功能模块相对独立
- 开闭原则 (open close principle)
	对扩展开放, 对修改关闭, 实现热插拔的效果
```

### 原则详解

#### 单一职责原则

> 不要存在多于一个导致类变更的原因

当类存在多个职责时, 若其中一个职责需要变更修改, 可能导致其他职责功能受到影响, 从而出现故障风险

使用单一职责设计可以**降低类的复杂度, 可读性, 可维护性和变更引起的风险** 

#### 里氏代换原则

> 子类应扩展父类的功能, 但不能重写 改变父类原有的功能

#### 依赖倒置原则

> 高层模块不应依赖底层模块, 抽象不应依赖于细节, 都应依赖于抽象

高层模块A直接依赖底层模块B, 若需要更改为依赖底层模块C, 需要修改A代码, 会有一定的故障风险

将A修改为依赖接口X, B 和 C各自实现 X, 则会降低修改A的几率

#### 接口隔离原则

> 客户端不应该依赖它不需要的接口, 一个类对另一个类的依赖应该建立在最小的接口上

#### 迪米特原则

> 一个对象应该对其他对象保持最少的了解, 即高内聚低耦合, 内部属性能私有就私有化

#### 开闭原则

> 类、模块和函数应该对扩展开放, 对修改关闭

### 设计模式类型

- 创建型模式

  包括单例模式、工厂模式(简单工厂、抽象工厂)

- 结构型模式

  适配器模式、门面模式、装饰器模式、注册树模式、代理模式、管道模式

- 行为型模式

  策略模式、观察者模式、命令模式、迭代器模式

### 创建型模式

> 利用封装, 从直接获得一个对象修改为通过接口获取对象

#### 单例模式

> 通过使用静态方法, 使得每次都返回同一个实例

##### 用途

- 用于数据库应用, 避免大量数据库操作消耗资源
- 全局配置信息的存储缓存
- 分布式存储

##### 特点

```
- 私有化构造方法  private function __construction(){}
	防止外部代码new多个对象,即单例类不能在其他类中实例化,仅能被自身实例化
- 私有化静态属性  private static $instance;
	用于保存类的实例的静态成员变量
- 公有化静态方法  public static function getInstance(){}
	用于外部获取该实例, 可以通过instanceof判断是否实例化
- 私有化克隆方法  private function __clone(){}
	防止对象被克隆产生新对象
```

##### 案例

```php
class DB
{
    private function __construct(){}

    private static $instance = null;

    public static function getInstance()
    {
        if (self::$instance == null){
            self::$instance = new self();
        }
        return self::$instance;
    }

    private function __clone(){}
}
```

#### 工厂模式

> 从new一个对象改为接口, 还可以通过传参实例化不同的类

##### 简单工厂模式(静态工厂模式)

> 为不同的类提供一个生产对象的工厂, 获取对象仅通过工厂获取
>
> (增加新的对象类型需要修改工厂类代码, 违反开闭原则)

```php
class DBMysql
{
    public function connection()
    {
        echo '连接到MySQL数据库';
    }
}

class DBOracle
{
    public function connection()
    {
        echo '连接到Oracle数据库';
    }
}

class DBFactory
{
    public static function createObject(String $type)
    {
        switch ($type) {
            case 'mysql':
                return new DBMysql();
                break;
            case 'oracle':
                return new DBOracle();
                break;
            default:
                throw new ErrorException("No Support Type Like {$type}");
        }
    }
}

$DB = DBFactory::createObject('mysql');
$DB->connection();
```

##### 工厂方法模式

> 为工厂方法提供接口, 规范接口方法, 每个工厂针对一个类生产对象, 修复了简单工厂模式违反开闭原则的问题

```php
interface DB	# 接口规定连接动作
{
    public function connection();
}

class DBMysql implements DB		# 实现接口方法
{
    public function connection()
    {
        echo '连接到MySQL数据库';
    }
}

class DBOracle implements DB	# 实现接口方法
{
    public function connection()
    {
        echo '连接到Oracle数据库';
    }
}


interface Factory	# 接口规定工厂动作
{
    public static function createObject();
}

class mysqlFactory implements Factory	# 实现接口方法,返回对应对象
{
    public static function createObject()
    {
        return new DBMysql();
    }
}

class oracleFactory implements Factory	# 实现接口方法,返回对应对象
{
    public static function createObject()
    {
        return new DBOracle();
    }
}

$DB = mysqlFactory::createObject();
$DB->connection();

$DB = oracleFactory::createObject();
$DB->connection();

# 若需要添加sqlite, 添加如下类
class DBSqlite implements DB
{
    public function connection()
    {
        echo '连接到sqlite数据库';
    }
}
class sqliteFactory implements Factory
{
    public static function createObject()
    {
        return new DBSqlite();
    }
}
$DB = sqliteFactory::createObject();
$DB->connection();
```

##### 抽象工厂模式

> 在不指定具体类的情况下创建一系列相关或依赖对象, 创建的类都实现相同的接口
>
> (可以增加产品族, 但无法增加新的产品)

```php
interface Vehicle
{
    public function drive();
}

class ToyotaVehicle implements  Vehicle
{
    public function drive()
    {
        echo 'Toyouta 汽车';
    }
}

class AudiVehicle implements  Vehicle
{
    public function drive()
    {
        echo 'Audi 汽车';
    }
}

interface AirCondition
{
    public function blow();
}

class GreeAir implements AirCondition
{
    public function blow()
    {
        echo 'Gree 空调';
    }
}

class HaierAir implements AirCondition
{
    public function blow()
    {
        echo 'Haier 空调';
    }
}

interface Factory
{
    public static function productVehicle();
    public static function productAirCondition();
}

class ToyotaFactory implements Factory
{
    public static function productVehicle()
    {
        return new ToyotaVehicle();
    }

    public static function productAirCondition()
    {
        return new GreeAir();
    }
}

class AudiFactory implements Factory
{
    public static function productVehicle()
    {
        return new AudiVehicle();
    }

    public static function productAirCondition()
    {
        return new HaierAir();
    }
}
# 使用
$toyotaVehicle = ToyotaFactory::productVehicle();
$greeAirCondition = ToyotaFactory::productAirCondition();
$toyotaVehicle->drive();
$greeAirCondition->blow();

$audiVehicle = AudiFactory::productVehicle();
$HaierAirCondition = AudiFactory::productAirCondition();
$audiVehicle->drive();
$HaierAirCondition->blow();
```

组成:

- 抽象工厂 - 确定工厂的业务范围
- 具体工厂 - 每个具体工厂对应一个产品族
- 抽象产品 - 同一等级结构的抽象类
- 具体产品 - 可供生产的具体产品

### 结构型模式

> 解析类与对象的内部结构与外部组合, 通过优化程序结构解决模块的耦合问题

#### 适配器模式

> 将某个类的接口转换成与另一个接口兼容. 通过将原始接口进行转换, 给用户提供兼容接口, 使原来因为接口不同而无法一起使用的类可以得到兼容

适配器模式解决的问题是针对一些原有代码不便修改, 或第三方扩展包, 返回的数据与目标数据格式不同, 此时便可以使用适配器调整原有逻辑

```php
<?php

interface Weather
{
    public function showWeather();
}

class WeatherSerialized implements Weather
{
    public function showWeather()
    {
        $weatherInfo = ['weather'=>'wind','temperature' => '12'];
        return serialize($weatherInfo);
    }
}

# 使用
$weatherObj = new WeatherSerialized();
$info = $weatherObj->showWeather();
$info = unserialize($info);
echo "Today's weather is {$info['weather']}";

# 需求目标: 需要返回标准Json格式数据
interface WeatherAdapter
{
    public function getWeather();
}

class JsonWeather implements WeatherAdapter
{
    protected $instance;

    public function __construct(Weather $weather)
    {
        $this->instance = $weather;
    }

    public function getWeather()
    {
        $sourceWeather = $this->instance->showWeather();
        $weatherArray = unserialize($sourceWeather);
        return json_encode($weatherArray, 320);
    }
}

# 使用
$jsonWeather = new JsonWeather(new WeatherSerialized());
$weatherInfo = json_decode($jsonWeather, true);
echo "Today's weather is {$info['weather']}";
```

#### 装饰器模式

> 也叫装饰者模式, 在不改变原有类和不使用继承的情况下, 动态的扩展一个对象的功能

使用场景包括:

- 需要动态的给对象添加或撤销功能
- 需要增加由一些基本功能排列组合产生的大量功能, 继承关系可能非常复杂
- 不能采用生成子类的方法进行扩展, 可能是有大量独立扩展, 也可能是类定义被隐藏

```php
<?php
    
interface Component	# 组件对象接口
{
    public function display();
}

class Person implements Component	# 需要装饰的组件
{
    protected $name;

    public function __construct(string $name)
    {
        $this->name = $name;
    }

    public function display()
    {
        echo "装饰目标:{$this->name}" . PHP_EOL;
    }
}

class Decorator implements Component	# 装饰器父类
{
    protected $component;

    public function __construct(Component $component)
    {
        $this->component = $component;
    }

    public function display()	# 执行装饰动作
    {
        if (!empty($this->component))
            $this->component->display();
    }
}

class TShirt extends Decorator	# 具体的装饰器类
{
    public function display()
    {
        parent::display();
        echo "装饰T-Shirt";
    }
}

class Hat extends Decorator	# 具体的装饰器类
{
    public function display()
    {
        parent::display();
        echo "装饰帽子";
    }
}

// 客户端使用
$target = new Person('张三');
$target = new TShirt($target);
$target = new Hat($target);
$target->display();
/*
 * 运行结果:
 * 装饰目标:张三
 * 装饰T-Shirt装饰帽子
 */
```

#### 注册树模式

> 也叫注册模式或注册器模式, 即将对象实例注册到一颗全局的对象树上, 需要的时候取用即可

```php
<?php

interface DB
{
    public function connection();
}

class DBMysql implements DB
{
    public function connection()
    {
        echo "连接到mysql";
    }
}

class DBOracle implements DB
{
    public function connection()
    {
        echo "连接到Oracle";
    }
}

interface Factory
{
    public static function getInstance();
}

class MysqlFactory implements Factory
{
    public static function getInstance()
    {
        return new DBMysql();
    }
}

class OracleFactory implements Factory
{
    public static function getInstance()
    {
        return new DBOracle();
    }
}

class RegisterTree
{
    protected static $container;	# 注册容器

    public static function set($alias, $object)	# 注册到树
    {
        self::$container[$alias] = $object;
    }

    public static function get($alias)	# 从树上获取
    {
        return self::$container[$alias];
    }

    public static function delete($alias)	# 删除
    {
        unset(self::$container[$alias]);
    }
}

# 注册到树上
RegisterTree::set('mysql', MysqlFactory::getInstance());
RegisterTree::set('oracle', OracleFactory::getInstance());
# 使用
$mysql = RegisterTree::get('mysql');
$mysql->connection();
# 删除注册树内容
RegisterTree::delete('oracle');
```

#### 门面模式

> 又称外观模式, 用于为子系统中的一组接口提供一个一致的界面, 增加了子系统的独立性和易用性

```php
<?php

class Camera
{
    public function turnOn()
    {
        echo '开启摄像机';
    }

    public function turnOff()
    {
        echo '关闭摄像机';
    }
}

class Light
{
    public function turnOn()
    {
        echo '开启灯光';
    }

    public function turnOff()
    {
        echo '关闭灯光';
    }
}


class Facade
{
    public static $camera;
    public static $light;
    public function __construct()
    {
        self::$camera = new Camera();
        self::$light = new Light();
    }

    public function photoInDayTime()
    {
        self::$camera->turnOn();
    }

    public function photoInNight()
    {
        self::$camera->turnOn();
        self::$light->turnOn();
    }

    public function illumination()
    {
        self::$light->turnOn();
    }
}

// 客户端使用
$facade = new Facade();
$facade->photoInDayTime();  # 白天拍照
$facade->photoInNight();    # 晚上拍照
$facade->illumination();    # 照明
```

#### 管道模式

> 流水线式将数据传递到下一个任务序列中, 需要管道, 阀门 和 载荷

```php
<?php

interface PipelineBuilder
{
    public function __construct($payload);

    public function pipe(StageBuilder $stage);

    public function process();
}

class Pipeline implements PipelineBuilder
{
    protected $payload;

    protected $pipes = [];

    public function __construct($payload)
    {
        $this->payload = $payload;
    }

    public function pipe(StageBuilder $stage)	# 添加管道
    {
        $this->pipes[] = $stage;
        return $this;
    }

    public function process()	# 执行管道动作
    {
        foreach ($this->pipes as $pipe) {
            call_user_func([$pipe,'handle'], $this->payload);
        }
    }
}

interface StageBuilder
{
    public function handle($payload);
}

class StageOne implements StageBuilder	# 管道一
{
    public function handle($payload)
    {
        echo '步骤一' . PHP_EOL;
    }
}

class StageTwo implements StageBuilder	# 管道二
{
    public function handle($payload)
    {
        echo '步骤二' . PHP_EOL;
    }
}

// 客户端使用
$pipeline = new Pipeline('洗衣服');
$pipeline->pipe(new StageOne())->pipe(new StageTwo())->process();
```

#### 代理模式

> 透明置于两个不同对象之内的一个对象, 从而可以截取或代理这两个对象间的通信或访问



```php
<?php

interface Request
{
    public function request();
}

class RealRequest implements Request
{
    public function request()
    {
        echo '真实请求动作';
    }
}

class ProxyRequest implements Request
{
    protected $requestInstance;

    public function __construct(Request $instance)
    {
        $this->requestInstance = $instance;
    }

    public function request()
    {
        echo '代理器中的其他动作;';
        $this->requestInstance->request();
    }
}

// 客户端使用

$request = new ProxyRequest(new RealRequest());
$request->request();

```

代理模式与装饰器/适配器的区别

装饰器一般是对对象进行装饰, 增加其中的方法行为

适配器一般会改变方法行为, 目的是保持接口的统一

代理模式是让代理类替换真实类的操作

### 行为型模式

> 用于描述程序在运行时复杂的流程控制, 即描述多个类与对象间如何相互协作共同完成单个对象无法完成的任务, 涉及算法与对象间职责的分配

#### 策略模式

> 将一组特定的行为和算法封装, 以适应特定的上下文环境, 让它们可以相互替换

```php
<?php

interface Strategy	# 策略类接口
{
    public function Algorithm();
}

class ConcreteStrategyA implements Strategy	# 策略A
{
    public function Algorithm()
    {
        echo '算法A实现';
    }
}

class ConcreteStrategyB implements Strategy	# 策略B
{
    public function Algorithm()
    {
        echo '算法B实现';
    }
}

class ConcreteStrategyC implements Strategy # 策略C
{
    public function Algorithm()
    {
        echo '算法C实现';
    }
}

class Context
{
    protected $strategy;
    
    public function __construct(string $type)
    {
        switch ($type){
            case 'A':
                $this->strategy = new ConcreteStrategyA();
                break;
            case 'B':
                $this->strategy = new ConcreteStrategyB();
                break;
            case 'C':
                $this->strategy = new ConcreteStrategyC();
                break;
            default:
                throw new ErrorException('no this type strategy');
        }
    }

    public function processStrategy()
    {
        $this->strategy->Algorithm();
    }
}

// 客户端使用
$context = new Context('A');
$context->processStrategy();
```

#### 观察者模式

> 定义对象间的一对多的依赖关系, 当一个对象的状态改变时, 所有依赖于它的对象都得到通知并自动刷新

模式所需角色:

- 抽象主题(Subject) : 把所有观察者对象的引用保存到一个集合中, 每个主题都可以有任意数量的观察者, 它提供了一个接口, 可以增加/删除观察者对象
- 具体主题(ConcreteSubject) : 将有关状态存入具体观察者对象, 在具体主题内部状态改变时, 给所有观察者发出通知
- 抽象观察者(Observer) : 为所有具体观察者定义一个接口, 得到主题通知时更新自己
- 具体观察者(ConcreteObserver) : 实现抽象观察者定义的更新接口, 使自己的状态与主题状态协调

```php
<?php

interface Subject	# 抽象主题接口
{
    public function attach($observer);

    public function detach($observer);

    public function notify();
}

class ConcreteSubject implements Subject	# 具体主题
{
    protected $observers = [];

    public function attach($observer)	# 绑定观察者
    {
        array_push($this->observers, $observer);
    }

    public function detach($observer)	# 解绑观察者
    {
        $index = array_search($observer, $this->observers);
        if ($index === false) return false;
        unset($this->observers[$index]);
        return true;
    }

    public function notify()	# 通知变更
    {
        if (!is_array($this->observers)) return false;
        foreach ($this->observers as $observer) {
            call_user_func([$observer,'update']);
        }
        return true;
    }
}

interface Observer	# 抽象观察者接口
{
    public function update();
}

class ConcreteObserver implements Observer	# 具体观察者
{
    protected $name;
    public function __construct($name)
    {
        $this->name = $name;
    }

    public function update()	# 收到状态变更信息后执行动作
    {
        echo "监听者 {$this->name} 收到变更消息";
    }
}
// 客户端使用
$subject = new ConcreteSubject();
$subject->attach(new ConcreteObserver('一号'));
$subject->attach(new ConcreteObserver('二号'));
$subject->attach(new ConcreteObserver('三号'));
$subject->notify();
```

#### 命令模式

> 对命令的封装, 将发出命令的职责和执行命令的职责分割开, 委派给不同的对象

模式所需角色:

- 命令角色(Command) : 声明了一个给所有具体命令的抽象接口,需要实现接口方法execute()
- 具体命令(ConcreteCommand) : 定义接受者和行为之间的弱耦合, 实现执行方法execute()
- 请求者(Invoker) : 负责调用命令对象执行请求, 需要传入命令对象
- 接收者(Receiver) : 负责具体实施和执行请求, 实现action()方法

![image-20211109223010611](/images/imgs/image-20211109223010611.png)



```php
<?php

interface Command       # 命令角色
{
    public function execute();
}

class CopyCommand implements Command        # 具体命令,需要指定接收者
{
    private $receiver;

    public function __construct(Receiver $receiver)
    {
        $this->receiver = $receiver;
    }

    public function execute()
    {
        $this->receiver->action();
    }
}

class PasteCommand implements Command       # 具体命令
{
    private $receiver;

    public function __construct(Receiver $receiver)
    {
        $this->receiver = $receiver;
    }

    public function execute()
    {
        $this->receiver->action();
    }
}

interface Receiver      # 接收者
{
    public function action();
}

class CopyReceiver implements Receiver  # 具体接收者
{
    private $name;
    public function __construct($name)
    {
        $this->name = $name;
    }

    public function action()    # 接收者执行命令
    {
        echo "{$this->name} 执行 COPY 操作";
    }
}

class PasteReceiver implements Receiver  # 具体接收者
{
    private $name;
    public function __construct($name)
    {
        $this->name = $name;
    }

    public function action()    # 接收者执行命令
    {
        echo "{$this->name} 执行 PASTE 操作";
    }
}

class Invoker   # 请求者
{
    private $command;
    public function __construct(Command $command)
    {
        $this->command = $command;
    }

    public function handle()    # 调用命令
    {
        $this->command->execute();
    }
}

# 客户端使用
// 单命令执行
$copyCommand = new CopyCommand(new CopyReceiver('张三'));
$pasteCommand = new PasteCommand(new PasteReceiver('张三'));
$invoker = new Invoker($copyCommand);
$invoker->handle();
```

#### 迭代器模式

> 封装遍历数据集合模式, 提供访问容器对象内各个元素, 但又不暴露该对象的内部细节

需要角色:

- 迭代器(Iterator) : 迭代器定义访问和遍历元素的接口
- 具体迭代器(ConcreteIterator) : 实现迭代器接口, 对该聚合遍历时追送当前位置
- 聚合对象接口(Aggregate) : 聚合定义相应迭代器对象的接口
- 具体聚合(ConcreteAggregate) : 具体聚合实现创建相应迭代器的接口, 返回迭代器实例

```php
<?php

class ArrIterator implements Iterator	# 实现PHP迭代器接口
{
    private $data;

    private $index;

    public function __construct($data)
    {
        $this->data = $data;
        $this->index = 0;
    }

    public function current()
    {
        return $this->data[$this->index];
    }

    public function next()
    {
        $this->index ++;
    }

    public function key()
    {
        return $this->index;
    }

    public function valid()
    {
        return $this->index < count($this->data);
    }

    public function rewind()
    {
        $this->index = 0;
    }
}

// 客户端使用
$arr = ['one','two','three','four'];
$iterator = new ArrIterator($arr);
foreach ($iterator as $item) {
    echo $item;
}
```

]]></content>
      <categories>
        <category>学习笔记</category>
      </categories>
      <tags>
        <tag>PHP</tag>
        <tag>后端</tag>
        <tag>设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title>UML类图详解</title>
    <url>/2020/02/17/UML%E7%B1%BB%E5%9B%BE%E7%BB%98%E5%88%B6/</url>
    <content><![CDATA[


## UML类图

### 类图的基本元素

![image-20211110002022081](/images/imgs/image-20211110002022081.png)

如上为一个普通的类

可以看到, 一个类由三部分组成, 顶部的类名, 中部的属性, 以及最下方的方法

- 类名部分一般用正常粗体标识, 若为抽象类则使用斜体字粗体, 若为接口则需要在上方加上 `<<interface>>` 标识

  ![image-20211110003201542](/images/imgs/image-20211110003201542.png)

- 属性部分一个属性一行, 组成格式为: `可见性 属性名: 属性数据类型`

- 方法部分一个方法一行, 组成格式为: 

  `可见性 方法名([[类型] 参数,[类型] 参数]) [:返回值]`

可见性包含以下几种

```
-   代表私有属性 private
#   代表保护属性 protected
+   代表公有属性 public
```

### 类之间的关系

类关系主要有六种: 继承、实现、组合、聚合、关联和依赖, 由类之间的箭头线标识

![image-20211110003358920](/images/imgs/image-20211110003358920.png)

#### 继承(extends)和实现(implements)

如下所示

![image-20211110003736823](/images/imgs/image-20211110003736823.png)

#### 组合(composition)与聚合(aggregation)

> 组合关系表示部分与整体的强绑定关系, 若主体消失, 部分也随之失效,用实心菱形表示
>
> 聚合关系中部分可以脱离整体独立存在, 用空心菱形表示

![image-20211110004959767](/images/imgs/image-20211110004959767.png)

#### 关联关系(Association)

> 表示一类对象与另一类对象之间有联系, 如汽车与轮胎, 班级和学生, 节点与节点等
>
> 关联关系也细分为四种: 双向关联、单向关联、自关联
>
> 单向关联使用带箭头的实线表示
>
> 双向关联使用不带箭头的实线表示

![image-20211110010456667](/images/imgs/image-20211110010456667.png)

#### 依赖关系(Dependency)

> 即一个事物的使用需要依赖另一个事物, 如下方Driver类中drive()方法的实现, 需要Car对象传入作为依赖, 调用Car类中的move()方法

![image-20211110011234234](/images/imgs/image-20211110011234234.png)

### 总结

> 六种类关系中, 从强到弱依次为: 继承→实现→组合→聚合→关联→依赖

![image-20211110012924660](/images/imgs/image-20211110012924660.png)]]></content>
      <categories>
        <category>学习笔记</category>
      </categories>
      <tags>
        <tag>PHP</tag>
        <tag>后端</tag>
        <tag>UML类图</tag>
      </tags>
  </entry>
  <entry>
    <title>从零配置一台服务器</title>
    <url>/2021/03/22/%E7%A9%BA%E7%99%BD%E6%9C%8D%E5%8A%A1%E5%99%A8%E9%85%8D%E7%BD%AE/</url>
    <content><![CDATA[


# 从零配置一台服务器

> ubuntu server 18.04

## 基础服务器镜像安装

1.下载镜像

```
https://cn.ubuntu.com/download
```

2.使用创建VM虚拟机

> 在选择安装源的镜像地址时, 记得修改为国内源, 否则可能卡住
>
> ```
> http://mirrors.163.com/ubuntu
> http://mirrors.aliyun.com/ubuntu
> ```

3.测试登录

![image-20211110165537094](/images/imgs/image-20211110165537094.png)

4.使用XShell连接服务器

![image-20211110165842607](/images/imgs/image-20211110165842607.png)

5.修改root用户密码

```
sudo passwd root
```

```
ni9ne@ni9nes:$ sudo passwd root
[sudo] password for ni9ne: 
Enter new UNIX password: 
Retype new UNIX password: 
passwd: password updated successfully
```

## PHP环境搭建

1.复制环境搭建脚本

![image-20211110171403549](/images/imgs/image-20211110171403549.png)

2.脚本赋权

```shell
ni9ne@ni9nes:~$ sudo chmod -R 777 ./*
```

3.脚本文本格式转换

```shell
ni9ne@ni9nes:~$ apt-get install dos2unix
ni9ne@ni9nes:~$ sudo dos2unix ./*
dos2unix: converting file ./php_env_install.sh to Unix format...
dos2unix: converting file ./sudo_no_pass.sh to Unix format...
dos2unix: converting file ./vim_setnum.sh to Unix format...
```

4.执行脚本

- sudo命令无需输入密码

  ```shell
  ni9ne@ni9nes:~$ ./sudo_no_pass.sh 
  success get current user: ni9ne
  successd prepare permit_text: ni9ne ALL=(ALL:ALL) NOPASSWD: ALL
  ni9ne ALL=(ALL:ALL) NOPASSWD: ALL
  ni9ne ALL=(ALL:ALL) NOPASSWD: ALL
  check permit has not been done, do it
  successd chmod write permit to /etc/sudoers
  successd add permit_text [ ni9ne ALL=(ALL:ALL) NOPASSWD: ALL ] to /etc/sudoers
  successd reback permission /etc/sudoers to 440
  ```

- vim默认开启行号

  ```shell
  ni9ne@ni9nes:~$ ./vim_setnum.sh 
  vim 配置路径: /etc/vim/vimrc
  添加vim 默认行号开启
  ```

- php环境安装

  ```shell
  ni9ne@ni9nes:~$ ./php_env_install.sh
  ```

## shell脚本文件

### sudo_no_interupt.sh

```shell
#! /bin/bash
##
# Author: NI9NE
# Date: 2020/10/19
# Time: 11:32
# Description: 用于修复集团服务器sudo命令延迟并报错的问题
# Email: <ni9ne@outlook.com>
#/

current_hostname=`hostname`
echo "当前计算机名称为: ${current_hostname}"
current_hosts_contain=`sudo cat /etc/hosts`
current_word="127.0.0.1 ${current_hostname}"
echo "清空原有hosts数据"
sudo sh -c "echo '${current_word}' > /etc/hosts"
echo "添加当前计算机名称Hosts数据"
sudo sh -c "echo '${current_hosts_contain}' >> /etc/hosts"
```

### vim_setnum.sh

```shell
#! /bin/bash
##
# Author: NI9NE
# Date: 2020/10/19
# Time: 11:32
# Description: 用于将vim行号默认打开
# Email: <ni9ne@outlook.com>
#/

vimPath=`sudo find /etc/ -name vimrc`
echo "vim 配置路径: ${vimPath}"
sudo sh -c "echo 'set nu' >> ${vimPath}"
echo "添加vim 默认行号开启"
```

### php_env_install.sh

```shell
#! /bin/bash

##
# Author: NI9NE
# Time: 12:25
# Date: 2020/10/19
# Description: 用于安装PHP项目环境包括以下内容: tree/Git/Nginx/PHP/PHP扩展/MySql/Composer/libreoffice扩展
#              额外操作包括: Nginx项目目录www所属用户切换,当前用户添加到www组
#                          php-apcu扩展安装并打开
# Email: <ni9ne@outlook.com>
#/

echo '更新软件包源 : [ sudo apt-get update ]'
sudo apt-get update
echo '安装语言包'
sudo apt-get install -y language-pack-en-base
sudo locale-gen en_US.UTF-8
echo '安装tree'
sudo apt-get install -y tree
echo '安装nginx'
sudo apt-get install -y nginx
echo 'www文件夹权限添加'
sudo chmod g+w /var/www
echo 'www文件夹所属人变更为www-data'
sudo chown -R www-data:www-data /var/www
echo '当前用户添加到www-data组'
sudo usermod -g www-data `whoami`
echo '安装git'
sudo apt-get install -y git
echo '安装PHP'
sudo apt-get install -y php
sudo apt-get install -y php7.0-fpm
echo '安装PHP扩展:php7.0-mysql'
sudo apt-get install -y php7.0-mysql
echo '安装PHP扩展:php7.0-gd'
sudo apt-get install -y php7.0-gd
echo '安装PHP扩展:php7.0-soap'
sudo apt-get install php7.0-soap
echo '安装PHP扩展:php7.0-fileinfo'
sudo apt-get install -y php7.0-fileinfo
echo '安装PHP扩展:php7.0-mbstring'
sudo apt-get install -y php7.0-mbstring
echo '安装PHP扩展:php7.0-curl'
sudo apt-get install -y php7.0-curl
echo '安装PHP扩展:php7.0-zip'
sudo apt-get install -y php7.0-zip
echo '安装PHP扩展:php7.0-dom'
sudo apt-get install -y php7.0-dom
echo '安装PHP扩展:php7.0-odbc'
sudo apt-get install -y php7.0-odbc
echo '安装PHP扩展:php7.0-memcached'
sudo apt-get install -y php7.0-memcached
echo '安装PHP扩展:php7.0-memcache'
sudo apt-get install -y php7.0-memcache
echo '安装PHP扩展:php7.0-server'
sudo apt-get install -y mysql-server
echo '安装PHP扩展:php7.0-apcu'
sudo apt-get install php7.0-apcu
echo '安装PHP扩展:php7.0-apcu-bc'
sudo apt-get install php7.0-apcu-bc
echo '配置php-apcu 开启'
sudo sh -c "echo 'apc.enable_cli=On' >> '/etc/php/7.0/mods-available/apcu.ini'"
echo '重启php7.0'
sudo service php7.0-fpm restart
echo '添加仓库源'
sudo apt install software-properties-common
sudo add-apt-repository ppa:ondrej/php
echo '更新源'
sudo apt-get update
echo '升级 PHP'
sudo apt-get upgrade php
echo '更新驱动'
sudo apt-get install -y  php7.3-fpm
echo '切换 PHP 版本'
echo 1 | sudo update-alternatives --config php

echo '安裝libreoffice 扩展 :libreoffice-writer'
sudo apt-get install -y libreoffice-writer
echo '安裝libreoffice 扩展 :libreoffice-calc'
sudo apt-get install -y libreoffice-calc
echo '安裝libreoffice 扩展 :libreoffice-headless'
sudo apt-get install -y libreoffice-headless
echo '安裝composer'
php -r "copy('https://install.phpcomposer.com/installer', 'composer-setup.php');"
php composer-setup.php
php -r "unlink('composer-setup.php');"
echo '全局安装（环境变量）'
sudo mv composer.phar /usr/local/bin/composer
echo '更换composer阿里镜像'
composer config -g repo.packagist composer https://mirrors.aliyun.com/composer/
echo 'composer降低版本为1.0'
sudo composer self-update --1

# echo '生成git秘钥'
# ssh-keygen -t rsa -C "ni9ne@outlook.com"
# 
# echo '安装docker'
# curl -fsSL https://get.docker.com | bash -s docker --mirror Aliyun
# echo '添加用户到docker组'
# sudo usermod -aG docker `whoami`
```

]]></content>
      <categories>
        <category>实际演练</category>
      </categories>
      <tags>
        <tag>linux</tag>
        <tag>shell</tag>
        <tag>服务器</tag>
      </tags>
  </entry>
  <entry>
    <title>MySQL- 用户账号相关操作</title>
    <url>/2020/09/05/MySQL%20%E7%94%A8%E6%88%B7%E8%B4%A6%E5%8F%B7%E7%9B%B8%E5%85%B3%E6%93%8D%E4%BD%9C/</url>
    <content><![CDATA[
## MySQL 用户账号相关操作

### 具体操作命令格式

> 以下为常用命令

```
-- 查询用户
SELECT * FROM user;
-- 创建用户, 仅可看information_schema库
CREATE USER 'naxx'@'%' IDENTIFIED BY '111111';
-- 添加该用户对某个库的查询,更新权限
GRANT SELECT,UPDATE ON qjjfwpt_saas.* TO 'naxx'@'%';
-- 添加该用户对某个库的删除,更新权限
GRANT DELETE ON qjjfwpt_saas.* TO 'naxx'@'%';
-- 添加该用户对某个库的视图查询权限
GRANT SHOW VIEW ON qjjfwpt_saas.* TO 'naxx'@'%';
-- 刷新权限
FLUSH privileges;
-- 显示该用户在所有IP下的权限
SHOW GRANTS FOR 'naxx'@'%';
-- 显示该用户在指定IP下的所有权限
SHOW GRANTS FOR 'naxx'@'127.0.0.1';
-- 删除查看视图权限
REVOKE SHOW VIEW ON qjjfwpt_saas.* FROM 'naxx'@'%';
-- 删除指定用户
DROP USER 'naxx'@'%';
-- 修改用户密码
SET PASSWORD FOR 'naxx'@'%'=PASSWORD('123456789');
-- 密码过期(下次登录需要自行修改密码)
ALTER USER 'naxx'@'%' PASSWORD EXPIRE;
-- 锁定用户
ALTER USER 'naxx'@'%' account lock;
-- 解锁用户
ALTER USER 'naxx'@'%' account unlock;
```

### 权限设定关键字

![I3wLQVQjl9](/images/imgs/I3wLQVQjl9.png)

### 初始密码问题

```shell
刚安装好的mysql登录使用auth_socket
获取root权限
	$ su root
登录mysql
	$ mysql
执行SQL
	mysql> update mysql.user set host='%',plugin='mysql_native_password',authentication_string=password('123456789') where user='root';
	mysql> flush privileges;
	mysql> exit;
修改mysql配置
	$ sudo vi /etc/mysql/mysql.conf.d/mysqld.cnf
注释以下行
	# bind-address          = 127.0.0.1
重启mysql服务
	$ sudo service mysql restart
即可正常使用Navicat客户端连接数据库
```



]]></content>
      <categories>
        <category>学习笔记</category>
      </categories>
      <tags>
        <tag>PHP</tag>
        <tag>后端 - MySQL</tag>
      </tags>
  </entry>
  <entry>
    <title>Docker_文件数据备份实战</title>
    <url>/2021/07/15/Docker_%E6%96%87%E4%BB%B6%E6%95%B0%E6%8D%AE%E5%A4%87%E4%BB%BD%E5%AE%9E%E6%88%98/</url>
    <content><![CDATA[
## Docker文件数据备份

该脚本运行需要要求环境有 `scp` 应用, 配置好远端及本地备份路径后, 直接运行即可, 

### 配置文件目录:

 `config.sh`

### 功能:

```
拉取远端服务器文件到本脚本所在目录:File_Bak
```

### 常用命令

```bash
docker build --no-cache -t file_back_up .
docker run --name c_file_back_up -v [主机备份目录]:/File/[配置容器备份目录] -d file_back_up
```

### 容器自启动

```bash
docker update --restart=always c_file_back_up
```

### 查看crond日志详情

```
cat /var/log/crond.log
```

### 自定义逻辑

```
1.备份日志为/File/log.txt
2.crond定时任务日志在/var/log/crond.log
3.最新一次拉取日志debug信息在/File/currentlog.txt
4.备份文件在/File/File_Bak, 可以通过修改config.sh中[local_path]更改
5.ssh证书密钥请放在env文件中, 并修改config.sh读取路径
6.当前设置为每5分钟定时拉取一次, 失败尝试三次, 三次后放弃, 需要请修改时长
```

### Dockerfile文件

```dockerfile
FROM alpine:3.12.1

WORKDIR File

COPY . .

RUN sed -i 's/dl-cdn.alpinelinux.org/mirrors.aliyun.com/g' /etc/apk/repositories; \
    apk add --no-cache openssh tzdata; \
    cp /usr/share/zoneinfo/Asia/Shanghai /etc/localtime; \
    apk del tzdata; \
    apk add --no-cache dos2unix curl; \
    dos2unix *.sh; \
    dos2unix config; \
    apk del dos2unix; \
    chmod 600 ./env/id_rsa_190; \
    sed -i "s/#PermitRootLogin.*/PermitRootLogin yes/g" /etc/ssh/sshd_config; \
    ssh-keygen -t dsa -P "" -f /etc/ssh/ssh_host_dsa_key; \
    ssh-keygen -t rsa -P "" -f /etc/ssh/ssh_host_rsa_key; \
    ssh-keygen -t ecdsa -P "" -f /etc/ssh/ssh_host_ecdsa_key; \
    ssh-keygen -t ed25519 -P "" -f /etc/ssh/ssh_host_ed25519_key; \
    echo "root:admin" | chpasswd; \
    echo "*/2 * * * * cd /File && /bin/sh ./scp_back_up.sh > currentlog.txt" >> /var/spool/cron/crontabs/root;

EXPOSE 22

CMD crond -L /var/log/crond.log -f
```

### scp_back_up.sh脚本

```shell
#! /bin/sh

######################### ↓↓↓ 方法区域  ↓↓↓ ############################
sendMsg(){
    if [ ${production} -eq 'true' ]; then
        MessageUrl=${alert_notice_product}
    else
        MessageUrl=${alert_notice_debug}
    fi
    PostData="{\"msgtype\":\"markdown\",\"markdown\":{\"content\":\"### 项目: 文件备份\n >${IP}${NAME}\n${1}\n${2}\"}}"
    echo -e "\n ${current_time}" >> ${notice_file}
    echo "curl -H \"Content-Type: application/json;charset=utf-8\" -X POST -d \"${PostData}\" \"${MessageUrl}\"" >> ${notice_file}
    curl -H "Content-Type: application/json;charset=utf-8" -X POST -d "${PostData}" "${MessageUrl}" >> ${notice_file}
}

# 获取远端文件夹内创建时间在规定期间的文件
getFile(){
    echo "ssh -i ${identify_file} -o StrictHostKeyChecking=no -p ${PORT} ${USER}@${IP} \"find ${back_up_file_path} -type f -ctime ${back_time}\""
    ssh -i ${identify_file} -o StrictHostKeyChecking=no -p ${PORT} ${USER}@${IP} "find ${back_up_file_path} -type f -ctime ${back_time}" > ${current_time}.txt
}


######################### ↑↑↑ 方法区域  ↑↑↑ ############################

# 引入配置文件
source config
# 当前时间
current_time=`date "+%Y-%m-%d_%H:%M:%S"`

# 创建文件夹
if [[ ! -d ${local_tmp_path} ]]; then
        mkdir -p ${local_tmp_path}
fi

if [[ ! -d ${local_path} ]]; then
        mkdir -p ${local_path}
fi
if [[ ! -f ${log_file} ]]; then
        touch ${log_file}
fi
if [[ ! -f ${notice_file} ]]; then
        touch ${notice_file}
fi
if [[ ! -f ${current_time}.txt ]]; then
        touch ${current_time}.txt
fi
if [[ ! -f ${current_time}false.txt ]]; then
        touch ${current_time}false.txt
fi

getFile

if [ ! -s ${current_time}.txt ]; then
  rm -f ${current_time}.txt
  rm -f ${current_time}false.txt
  sendMsg "${IP}:${file_path}" "${current_time}备份文件为空,备份失败"
  exit 0
fi

cat ${current_time}.txt | while read LINE ; do
    file_path=${LINE}
    file_name=`basename ${LINE}`
    # 普通ssh登录
    # scp -r -v -p -P ${PORT} -l ${transfer_speed} ${USER}@${IP}:${back_up_file_path}${back_up_file_name} ${local_path}

    # 使用密钥文件登录
    count_times=0

    # 尝试最多三次拉取远端文件
    while [[ ${count_times} -lt 3 ]]; do
        count_times=`expr ${count_times} + 1`
        # echo "scp -r -v -p -i ${identify_file} -P ${PORT} -l ${transfer_speed} ${USER}@${IP}:${back_up_file_path}${back_up_file_name} ${local_tmp_path}"
        echo "scp -r -v -p -i ${identify_file} -o StrictHostKeyChecking=no -P ${PORT} -l ${transfer_speed} ${USER}@${IP}:${file_path} ${local_tmp_path}"
        scp -r -v -p -i ${identify_file} -o StrictHostKeyChecking=no -P ${PORT} -l ${transfer_speed} ${USER}@${IP}:${file_path} ${local_tmp_path}
        cmd_result=$?
        # 拉取成功后跳出
        if [[ ${cmd_result} -eq 0 ]]; then
                sh -c "echo '${current_time}第${count_times}次拉取数据${file_path}成功' >>  ${log_file}"
                break
        fi
        sleep 5
    done

    # 判读是否成功移动,写入日志
    if [[ ${cmd_result} -eq 0 ]]; then
        echo "${current_time}移动文件到缓存目录 ${local_tmp_path} 成功"
        sh -c "echo '${current_time}移动文件到缓存目录 ${local_tmp_path} 成功'  >> ${log_file}"
    else
        echo "${cmd_result}" > ${current_time}false.txt
        echo "!!! ${current_time}拉取远端文件到缓存目录 ${local_tmp_path} 失败"
        sh -c "echo '!!! ${current_time}拉取远端文件到缓存目录 ${local_tmp_path} 失败'  >> ${log_file}"
        # 调用通知函数发送失败通知
        sendMsg "${IP}${file_path}" "!!!${current_time}拉取远端文件到缓存目录${local_tmp_path}失败"
    fi

    # 从缓存目录移动文件到实际备份文件夹
    mv ${local_tmp_path}/${file_name} ${local_path}
    mv_result=$?
    if [[ ${mv_result} -ne 0 ]]; then
        echo "${mv_result}" > ${current_time}false.txt
        echo "!!! ${current_time}移动文件${local_tmp_path}${file_name} 到目录 ${local_path} 失败"
        sh -c "echo '!!! ${current_time}移动文件${local_tmp_path}${file_name} 到目录 ${local_path} 失败' >> ${log_file}"
        sendMsg "${IP}${file_name}" "!!!${current_time}移动文件${local_tmp_path}${file_name}到目录${local_path}失败"
    else
        echo "!!! ${current_time}移动文件${local_tmp_path}${file_name} 到目录 ${local_path} 成功"
    fi
    echo 'end'
done
# 删除文件清单
rm -r ${current_time}.txt

if [ ! -s ${current_time}false.txt ]; then
  sendMsg "${IP}:${file_path}" "${current_time}备份文件成功"
else
  sendMsg "${IP}:${file_path}" "!!!${current_time}备份文件有错误,请查看日志详情"
fi
rm -r ${current_time}false.txt
```

### config配置文件

```
# 远端配置
NAME='日常备份'              # 项目名称
USER='[使用用户]'                    # 用户名
IP='xxx.xxx.xxx.xxx'              # IP地址
PORT='[端口]'                    # 端口

# 功能配置
identify_file='./env/[公钥文件名]'                # 登录公钥文件
transfer_speed='200000'                           # 最大传输速度 kb/s

# 项目文件配置
back_up_file_path='/var/www/[备份文件夹名]/'                # 远端备份路径
local_tmp_path='/var/www/LocalCFS/temp'                      # 本地缓存路径
local_path='/File/File_Bak/[项目名]/'  	        # 本地存储路径
back_time='-1'                                  # 遵循find命令格式,-1代表一天之内的文件

# 日志文件/通知配置
alert_notice_product='https://qyapi.weixin.qq.com/cgi-bin/webhook/send?key=xxxxxx'
alert_notice_debug='https://qyapi.weixin.qq.com/cgi-bin/webhook/send?key=xxxxxx'
log_file='log.txt'                              # 日志名称
notice_file='notice.txt'                        # 消息日志名称
production=false                                # 消息发送环境设定
```



]]></content>
      <categories>
        <category>实际演练</category>
      </categories>
      <tags>
        <tag>PHP</tag>
        <tag>后端</tag>
        <tag>Docker</tag>
        <tag>Shell</tag>
      </tags>
  </entry>
  <entry>
    <title>Docker手动安装</title>
    <url>/2021/03/15/Docker%E6%89%8B%E5%8A%A8%E5%AE%89%E8%A3%85/</url>
    <content><![CDATA[
## Docker手动安装

安装环境: ubuntu

官方脚本

```
curl -fsSL https://get.docker.com | bash -s docker --mirror Aliyun
```

```
curl -sSL https://get.daocloud.io/docker | sh
```

手动安装

- 卸载

  ```
  $ sudo apt-get remove docker docker-engine docker.io containerd runc
  ```

- 设置仓库

  ```ssh
  # 更新包
  $ sudo apt-get update
  # 安装依赖(用以通过https获取仓库)
  $ sudo apt-get install apt-transport-https ca-certificates curl gnupg-agent software-properties-common
  # 添加官方GPG秘钥
  $ curl -fsSL https://mirrors.ustc.edu.cn/docker-ce/linux/ubuntu/gpg | sudo apt-key add -
  # 检索是否拥有指纹信息
  $ sudo apt-key fingerprint 0EBFCD88
  # 设置稳定版仓库
  $ sudo add-apt-repository "deb [arch=amd64] https://mirrors.ustc.edu.cn/docker-ce/linux/ubuntu/ $(lsb_release -cs) stable"
  ```

- 安装(Docker Engine-Community)

  ```ssh
  # 更新包
  $ sudo apt-get update
  # 安装最新版
  $ sudo apt-get install docker-ce docker-ce-cli containerd.io
  # 安装指定版本
  ## 列出您的仓库中可用的版本
  $ apt-cache madison docker-ce
   显示内容:
    docker-ce | 5:18.09.1~3-0~ubuntu-xenial | https://mirrors.ustc.edu.cn/docker-ce/linux/ubuntu  xenial/stable amd64 Packages
    docker-ce | 5:18.09.0~3-0~ubuntu-xenial | https://mirrors.ustc.edu.cn/docker-ce/linux/ubuntu  xenial/stable amd64 Packages
  ## 安装指定版本
  $ sudo apt-get install docker-ce=<VERSION_STRING> docker-ce-cli=<VERSION_STRING> containerd.io
  # 测试安装状态
  $ sudo docker run hello-world
  ```

- 当前用户添加组

  ```
  $ sudo usermod -aG docker your-user
  ```

  > 添加完成后当前用户断开ssh连接, 重新登录即可使用groups查看是否添加成功

]]></content>
      <categories>
        <category>环境配置</category>
      </categories>
      <tags>
        <tag>PHP</tag>
        <tag>后端</tag>
        <tag>Docker</tag>
      </tags>
  </entry>
  <entry>
    <title>Docker使用</title>
    <url>/2021/05/07/Docker%E4%BD%BF%E7%94%A8/</url>
    <content><![CDATA[
## 基本操作

### 1.使用镜像执行动作

```ssh
$ docker run ubuntu:15.10 /bin/echo 'hello docer'
```

```
结果:
Unable to find image 'ubuntu:15.10' locally
15.10: Pulling from library/ubuntu
7dcf5a444392: Pull complete 
759aa75f3cee: Pull complete 
3fa871dc8a2b: Pull complete 
224c42ae46e7: Pull complete 
Digest: sha256:02521a2d079595241c6793b2044f02eecf294034f31d6e235ac4b2b54ffc41f3
Status: Downloaded newer image for ubuntu:15.10
hello world
```

### 2.交互式运行

```ssh
$ docker run -i -t ubuntu:15.10 /bin/bash
$ docker run --interactive --tty ubuntu /bin/bash   #(不指定版本,默认latest)
```

### 3.守护进程运行

```ssh
$ docker run -d ubuntu:15.10 /bin/sh -c "while true; do echo hello world; sleep 1; done"
```

```
结果
2e3b96095dd69911032f02d44cb483b1d5cc824f15a3296a9ddbd1070b054b9e
2e3b96095dd6
```

### 4.查看当前守护进程运行的docker

```ssh
$ docker ps
```

```
结果
CONTAINER ID | IMAGE        | COMMAND     | CREATED       |STATUS      |PORTS      |NAMES
9e3c78addf64 | ubuntu:15.10 | "/bin/bash" | 13 minutes ago|Up 13 minutes|    |loving_shaw
```

### 5.退出当前docker

```ssh
$ exit
```

### 6.查看指定容器执行日志

```ssh
$ docker logs 9e3c78addf64
```

### 7.停止容器运行

```ssh
$ docker stop [9e3c78addf64/loving_shaw]
```

### 8.操作已运行容器

```ssh
$ docker exec -it 8dfd51f8b37c /bin/bash
```

### 9.删除未使用中容器

```ssh
$ docker rm [容器ID]
```

## 镜像操作

### 1.列出本机镜像

```ssh
$ docker images
```

```
结果
REPOSITORY          TAG                 IMAGE ID            CREATED             SIZE
hello-world         latest              bf756fb1ae65        9 months ago        13.3kB
ubuntu              15.10               9b9cb95443b5        4 years ago         137MB
```

### 2.查找镜像

```ssh
$ docker search httpd
```



| NAME                    | DESCRIPTION                                   | STARS | OFFICIAL | AUTOMATED |
| ----------------------- | --------------------------------------------- | ----- | -------- | --------- |
| httpd                   | The Apache HTTP Server Project                | 3219  | [OK]     |           |
| centos/httpd-24-centos7 | Platform for running Apache httpd 2.4 or bui… | 36    |          |           |
| centos/httpd            |                                               | 32    |          | [OK]      |

>  或者 [Docker Hub](https://hub.docker.com/) 

### 3.手动拉取镜像

```ssh
$ docker pull ubuntu:13.10
```

### 4.删除镜像

```ssh
$ docker rmi hello-world
```

```ssh
$ docker rmi --force hello-world:latest 
Untagged: hello-world:latest
Untagged: hello-world@sha256:8c5aeeb6a5f3ba4883347d3747a7249f491766ca1caa47e5da5dfcf6b9b717c0
Deleted: sha256:bf756fb1ae65adf866bd8c456593cd24beb6a0a061dedf42b26a993176745f6b
```

### 5.更新镜像

```ssh
$ docker commit -m='done some things' -a='ni9ne' cc7adb4b2145 ni9ne/ubuntu:V1
```

```
sha256:3de2fb0fa6533c64256e085959e358030544bbd819154a4ccb04ab902ffae6e0
$ docker images
REPOSITORY          TAG                 IMAGE ID            CREATED             SIZE
ni9ne/ubuntu        v1                  3de2fb0fa653        12 seconds ago      137MB
httpd               latest              3dd970e6b110        10 days ago         138MB
ubuntu              latest              9140108b62dc        3 weeks ago         72.9MB
ubuntu              15.10               9b9cb95443b5        4 years ago         137MB
ubuntu              13.10               7f020f7bf345        6 years ago         185MB
$ docker run -ti ni9ne/ubuntu
ni9ne/ubuntu     ni9ne/ubuntu:v1 
$ docker run -ti ni9ne/ubuntu:v1 /bin/bash
root@f8cab436a299:/#

```

### 6.创建镜像

```ssh
$ docker build -t ni9ne/centos6.7 docker/
```

> 指定以`docker`文件夹下的`Dockerfile`创建名为`ni9ne/centos6.7`的镜像

```
$ vi docker/Dockerfile
```

```vim
  1 FROM centos:6.7
  2 MAINTAINER Ni9ne "ni9ne@outlook.com" 
  3 
  4 RUN /bin/echo 'root:123456' | chpasswd
  5 RUN useradd ni9ne
  6 RUN /bin/echo 'ni9ne:ni9ne' | chpasswd
  7 RUN /bin/echo -e "LANG=\"en_US.UTF-8\"" > /etc/default/local
  8 EXPOSE 22
  9 EXPOSE 80
 10 CMD /usr/sbin/sshd -D
```

查看创建镜像

```
ubuntu@ubuntu:~$ docker images
REPOSITORY          TAG                 IMAGE ID            CREATED             SIZE
ni9ne/centos6.7     latest              95cc1d4ddbfe        11 minutes ago      191MB
 ...
```

### 7.为镜像添加tag

```ssh
$ docker tag 95cc1d4ddbfe ni9nee/centos6.7:dev
```

```
ubuntu@ubuntu:~$ docker images
REPOSITORY          TAG                 IMAGE ID            CREATED             SIZE
ni9nee/centos6.7    dev.1               95cc1d4ddbfe        13 minutes ago      191MB
ni9ne/centos6.7     latest              95cc1d4ddbfe        13 minutes ago      191MB
 ...
```

> 生成相同 `IMAGE ID` 的不同镜像

### 8.发布镜像到docker_hub

```ssh
$ docker login  / docker login -u [USER_NAME]         	# 登录docker_hub
$ docker tag [IMAGE_NAME] [USER_NAME]/[IMAGE_NAME]		# 给镜像打标签,重命名
$ docker push [USER_NAME]/[IMAGE_NAME]					# 推送
```



## 容器连接

### 1.端口开放

```ssh
$ docker run -d -P training/webapp python app.py
```

```
-d --detach 			守护进程运行并打印出容器id
-P --publish-all list 	将容器端口随机映射到主机高端口
-p --publish list 		将容器端口映射到指定主机端口
--name 					重命名为指定容器名
```

```ssh
$ docker run -d -p 127.0.0.1:5000:5000/udp training/webapp python app.py
```

### 2.查看容器端口开放状态

```ssh
$ docker port d1f753a28378
```

```
5000/tcp -> 0.0.0.0:32768
```

### 3.容器命名

除系统随机命名外, 还可用选项 `--name ` 指定该容器的名称

```ssh
$ docker run -d -P --name test_name ubuntu /bin/bash
```

```
e086aa4536def6b30efe6302e43d2dc457013cc3b4ddc32f0d8dc6b86e7af3dd
```

### 4.新建网络

```ssh
$ docker network create -d bridge test-net
```

```
c01cbf143f2ab43100d55b93910d0082980a99bbfb7a739f03fcd73625aec4f2
```

```
-d, --driver string        Driver to manage the Network (default "bridge")
						   指定 Docker 网络类型，有 bridge、overlay。
```

> docker network COMMAND

| 参数       | 功能                                                 |      |
| ---------- | ---------------------------------------------------- | ---- |
| connect    | Connect a container to a network                     |      |
| create     | Create a network                                     |      |
| disconnect | Disconnect a container from a network                |      |
| inspect    | Display detailed information on one or more networks |      |
| ls         | List networks                                        |      |
| prune      | Remove all unused networks                           |      |
| rm         | Remove one or more networks                          |      |

### 5.连接容器到网络

```ssh
$ docker run -itd --name test1 --network test-net ubuntu /bin/bash
```

```ssh
$ docker run -itd --name test2 --network test-net ubuntu /bin/bash
```

### 6.测试

```ssh
apt-get update
apt install iputils-ping
ping test1
```

### 7.配置DNS

#### 1.配置全局DNS

- 宿主机配置

```ssh
$ sudo vim etc/docker/daemon.json
```

```json
{
  "dns" : [
    "114.114.114.114",
    "8.8.8.8"
  ]
}
```

- 重启docker

```ssh
$ sudo service docker restart 
```

- 查看是否生效

```ssh
$ docker run -it --rm ubuntu cat etc/resolv.conf
```

#### 2.单容器配置DNS

>  启动时配置

```ssh
$ docker run -it --rm -h host_ubuntu --dns=114.114.114.114 --dns-search=test.com ubuntu
```

```
 --rm  					Automatically remove the container when it exits 
 						容器退出时自动清理容器内部的文件系统。
 -h, --hostname string 	Container host name
 						设定容器的主机名，它会被写到容器内的 /etc/hostname 和 /etc/hosts
 --dns=IP_ADDRESS       Set custom DNS servers
 添加 DNS 服务器到容器的 /etc/resolv.conf 中，让容器用这个服务器来解析所有不在 /etc/hosts 中的主机名
 --dns-search=DOMAIN    Set custom DNS search domains
  设定容器的搜索域，当设定搜索域为 .example.com 时，在搜索一个名为 host 的主机时，DNS 不仅搜索 host，还会搜索 host.example.com。
```

```
ubuntu@ubuntu:~$ docker run -it --rm -h host_ubuntu --dns=114.114.114.114 --dns-search=test.com ubuntu
root@host_ubuntu:/# cat /etc/hostname 
host_ubuntu
root@host_ubuntu:/# cat /etc/hosts    
127.0.0.1	localhost
::1	localhost ip6-localhost ip6-loopback
fe00::0	ip6-localnet
ff00::0	ip6-mcastprefix
ff02::1	ip6-allnodes
ff02::2	ip6-allrouters
172.17.0.2	host_ubuntu
root@host_ubuntu:/# cat /etc/resolv.conf 
search test.com
nameserver 114.114.114.114

```









 https://httpd.apache.org/security/vulnerabilities_24.html 









]]></content>
      <categories>
        <category>学习笔记</category>
      </categories>
      <tags>
        <tag>PHP</tag>
        <tag>后端</tag>
        <tag>Docker</tag>
      </tags>
  </entry>
  <entry>
    <title>Linux查询服务器硬件状态</title>
    <url>/2020/09/23/Linux%E6%9F%A5%E8%AF%A2%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%A1%AC%E4%BB%B6%E7%8A%B6%E6%80%81/</url>
    <content><![CDATA[
```shell
#! /bin/bash

echo 'CPU个数'
cat /proc/cpuinfo | grep "physical id" | uniq | wc -l
echo 'CPU核数'
cat /proc/cpuinfo | grep "cpu cores" | uniq
echo 'CPU型号'
cat /proc/cpuinfo | grep 'model name' |uniq


echo '内存大小'
cat /proc/meminfo | grep MemTotal

echo '查看内存使用量和交换区使用量'
free -m

echo '硬盘大小'
sudo fdisk -l | grep Disk

echo '系统版本'
head -n 1 /etc/issue
```

]]></content>
      <categories>
        <category>开发资料</category>
      </categories>
      <tags>
        <tag>Linux</tag>
        <tag>PHP</tag>
        <tag>后端</tag>
      </tags>
  </entry>
  <entry>
    <title>Linux常用命令详解</title>
    <url>/2021/06/12/Linux%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4%E8%AF%A6%E8%A7%A3/</url>
    <content><![CDATA[
## 目录

cp 复制命令

tar 压缩命令

split 切分文件命令

scp 数据传输命令

df 查看硬盘空间状态

du 查看指定文件夹

wc 统计命令

## cp 复制命令

```
在linux中怎样用命令完全拷贝一个目录下的所有文件（包括隐藏文件以及文件夹）到另外一个目录下，并且使得被复制的所有文件的属性等完全保持不变？ 注意，连原来的文件夹中所有的文件的属性、链接等都不能更改。也就是说，要建立原来文件夹的一份一模一样的拷贝！&n

在linux中怎样用命令完全拷贝一个目录下的所有文件（包括隐藏文件以及文件夹）到另外一个目录下，并且使得被复制的所有文件的属性等完全保持不变？
注意，连原来的文件夹中所有的文件的属性、链接等都不能更改。
也就是说，要建立原来文件夹的一份一模一样的拷贝！

# cp -avx /home/* /mnt/newhome

功能: 复制文件或目录
说明: cp指令用于复制文件或目录，如同时指定两个以上的文件或目录，且最后的目的地是一个已经存在的目录，则它会把前面指定的所有文件或目录复制到此目录中。若同时指定多个文件或目录，而最后的目的地并非一个已存在的目录，则会出现错误信息
参数:
-a 或 --archive 此参数的效果和同时指定"-dpR"参数相同
-b 或 --backup 删除、覆盖目的文件先备份，备份的文件或目录亦建立为符号链接，并指向源文件或目录链接的源文件或目录。假如没有加上这个参数，在复制过程中若遇到符号链接，则会直接复制源文件或目录
-f 或 --force 强行复制文件或目录， 不论目的文件或目录是否已经存在
-i 或 --interactive 覆盖文件之前先询问用户
-l 或 --link 对源文件建立硬链接，而非复制文件
-p 或 --preserve 保留源文件或目录的属性，包括所有者、所属组、权限与时间
-P 或 --parents 保留源文件或目录的路径，此路径可以是绝对路径或相对路径，且目的目录必须已经丰在
-r 递归处理，将指定目录下的文件与子目录一并处理。若源文件或目录的形态，不属于目录或符号链接，则一律视为普通文件处理
-R 或 --recursive 递归处理，将指定目录下的文件及子目录一并处理
-s 或 --symbolic-link 对源文件建立符号链接，而非复制文件
-S <备份字尾字符串> 或 --suffix=<备份字尾字符串> 用"-b"参数备份目的文件后，备份文件的字尾会被加上一个备份字符串。默认的备份字尾符串是符号"~"
-u 或 --update 使用这项参数之后，只会在源文件的修改时间(Modification Time)较目的文件更新时，或是名称相互对应的目的文件并不存在，才复制文件
-v 或 --verbose 显示执行过程
-V <备份方式> 或 --version-control=<备份方式> 指定当备份文件时，备份文件名的命名方式，有以下3种:
1.numbered或t, 将使用备份编号，会在字尾加上~1~字符串，其数字编号依次递增
2.simple或never 将使用简单备份，默认的备份字尾字符串是~, 也可通过-S来指定
3.existing或nil将使用当前方式，程序会先检查是否存在着备份编号，若有则采用备份编号，若无则采用简单备份
-x 或 --one-file-system 复制的文件或目录存放的文件系统，必须与cp指令执行时所处的文件系统相同，否则不复制，亦不处理位于其他分区的文件
--help 显示在线帮助
--sparse=<使用时机> 设置保存希疏文件的时机
--version 显示版本

示例:
.复制文件，只有源文件较目的文件的修改时间新时，才复制文件
cp -u -v file1 file2

.将文件file1复制成文件file2
cp file1 file2

.采用交互方式将文件file1复制成文件file2
cp -i file1 file2

.将文件file1复制成file2，因为目的文件已经存在，所以指定使用强制复制的模式
cp -f file1 file2

.将目录dir1复制成目录dir2
cp -R file1 file2

.同时将文件file1、file2、file3与目录dir1复制到dir2
　　 cp -R file1 file2 file3 dir1 dir2

.复制时保留文件属性
cp -p a.txt tmp/

.复制时保留文件的目录结构
cp -P /var/tmp/a.txt ./temp/

.复制时产生备份文件
cp -b a.txt tmp/

.复制时产生备份文件，尾标 ~1~格式
cp -b -V t a.txt /tmp 

.指定备份文件尾标 
cp -b -S _bak a.txt /tmp
```

## tar 压缩命令

### 分卷压缩

举例：将10G大小的log文件2017.log打包压缩并分割成多个100m的文件

```
# 分卷压缩gz
# tar zcf - 2017.log |split -d -b 100m - logs.tar.gz.
# 生成文件： logs.tar.gz.00 logs.tar.gz.01
# 分卷压缩bz2
# tar jcf - 2017.log |split -d -b 100m - logs.tar.bz2.
# 生成文件： logs.tar.bz2.00 logs.tar.bz2.01
```

最后要提醒但是那两个”-”不要漏了，那是tar的ouput和split的input的参数

### 合并分卷解压缩

```
# 解压gz分卷
# cat logs.tar.gz* | tar zx
# 解压bz2分卷
# cat logs.tar.gz* | tar jx
```

### tar 命令简述

```
参数:
-j : 通过bzip2进行压缩\解压文件*.tar.bz2
-z : 通过gzip进行压缩\解压文件*.tar.gz
-c : 新建打包文件,可搭配-v来查看过程中被打包的文件名
-t : 查看打包文件的内容有哪些文件名
-x : 解压打包文件.
-v : 在压缩/解压过程中,显示正在处理的文件名
-f : -f后面接被处理的文件名
-C(大写) : 后接目录
-p : 保留备份数据的原本权限与属性
-P :	保留绝对路径,即允许备份数据中含有根目录存在的目录(危险)
常用:欲压缩或打包的文件或目录(/*)
bzip2压缩命令:tar -jcv -f boot.tar.bz2 /boot
gzip压缩命令 :tar -zcv -f boot.tar.gz  /boot
bzip2查看命令:tar -jtv -f /dir/*.tar.bz2
gzip 查看命令:tar -ztv -f /dir/*.tar.gz
bzip2解压缩命令:tar -jxv -f /dir/*.tar.bz2 -C 欲解压缩的目录
gzip解压缩命令 :tar -zxv -f /dir/*.tar.gz 欲解压缩的目录
特殊:
备份重要的系统数据,包括其完整的权限(-p参数):     tar -jcvp -f /root/etc.tar.bz2 /etc
只解压压缩文件内的其中一个文件:                          tar -jxv -f /root/etc.tar.bz2 etc/shadow
打包目录,但不含该目录下的某些文件(--exclude):
tar -jcv -f /root/system.tar.bz2  --exclude=root/etc* --exclude=root/system.tar.bz2 /etc /root
仅备份比某个时刻还要新的文件:
备份    :tar -jcv -f /root/etc.newer.2011.02.16.tar.bz2 –newer-mtime='2011-02-16' /etc/*
查看备份:tar -jtv -f etc.newer.2011.02.16.tar.bz2
注意:在备份文件的时候也备份它的父目录
```

## split 切分文件命令

功能说明：切割文件。
语法：

```
split [--help][--version][-<行数>][-b <字节>][-C <字节>][-l <行数>][要切割的文件][输出文件名
```

补充说明：split可将文件切成较小的文件，预设每1000行会切成一个小文件。
参数：
-<行数>或-l<行数> 指定每多少行就要切成一个小文件。
-b<字节> 指定每多少字就要切成一个小文件。支持单位:m,k
-C<字节> 与-b参数类似，但切割时尽量维持每行的完整性。
–help 显示帮助。
–version 显示版本信息。
[输出文件名] 设置切割后文件的前置文件名，split会自动在前置文件名后再加上编号。
例子：

### 1.按100KB的测试文件拆分

```
# split -b 10k date.file
# ls
date.file xaa xab xac xad xae xaf xag xah xai xaj
```

件被分割成多个带有字母的后缀文件，如果想用数字后缀可使用-d参数，同时可以使用-a length来指定后缀的长度：

```
# split -b 10k date.file -d -a 3
# ls
date.file x000 x001 x002 x003 x004 x005 x006 x007 x008 x009
```

为分割后的文件指定文件名的前缀：

```
# split -b 10k date.file -d -a 3 split_file
# ls
date.file split_file000 split_file001 split_file002 split_file003 split_file004 split_file005 split_file006 split_file007 split_file008 split_file009
```

### 2.按行数拆分

```
# split -l 10 date.file
```

## scp 数据传输命令

### 语法:

```
scp [-1246BCpqrv] [-c cipher] [-F ssh_config] [-i identity_file]
[-l limit] [-o ssh_option] [-P port] [-S program]
[[user@]host1:]file1 [...] [[user@]host2:]file2
```

### 参数

```
-1： 强制scp命令使用协议ssh1
-2： 强制scp命令使用协议ssh2
-4： 强制scp命令只使用IPv4寻址
-6： 强制scp命令只使用IPv6寻址
-B： 使用批处理模式（传输过程中不询问传输口令或短语）
-C： 允许压缩。（将-C标志传递给ssh，从而打开压缩功能）
-p：保留原文件的修改时间，访问时间和访问权限。
-q： 不显示传输进度条。
-r： 递归复制整个目录。
-v：详细方式显示输出。scp和ssh(1)会显示出整个过程的调试信息。这些信息用于调试连接，验证和配置问题。
-c cipher： 以cipher将数据传输进行加密，这个选项将直接传递给ssh。
-F ssh_config： 指定一个替代的ssh配置文件，此参数直接传递给ssh。
-i identity_file： 从指定文件中读取传输时使用的密钥文件，此参数直接传递给ssh。
-l limit： 限定用户所能使用的带宽，以Kbit/s为单位。
-o ssh_option： 如果习惯于使用ssh_config(5)中的参数传递方式，
-P port：注意是大写的P, port是指定数据传输用到的端口号
-S program： 指定加密传输时所使用的程序。此程序必须能够理解ssh(1)的选项。
```

### 使用

#### 从远端下载到本地

> 注意: 秘钥文件权限必须是600

```
格式:
scp -r -i [秘钥文件路径] -P [远端端口] -l [限速速度(kb/s)] [远端用户]@[远端IP]:[远端文件] [本地路径]
例如:
scp -r -v -p -i /home/ubuntu/file/id_rsa_2048 -P 22 -l 1000 [用户名]@[IP]:/home/xxx/windowsfonts /home/ubuntu/file
```

#### 从本地推送到远端

```
格式:
scp -r -i [秘钥文件路径] -P [远端端口] -l [限速速度(kb/s)] [本地上传文件路径] [远端用户]@[远端IP]:[远端保存路径]
例如:
scp -i /home/ubuntu/file/id_rsa_2048 -P 22 -l 1000 /home/ubuntu/file/TeamCity-2020.1.5.tar.gz [用户名]@[IP]:/home/xxx
```

即从远端下载数据可以用如下命令

```
echo [秘钥文件密码] | scp -i /home/ubuntu/file/id_rsa_2048 -P 22 -l 1000 /home/ubuntu/file/TeamCity-2020.1.5.tar.gz [用户名]@[IP]:/home/xxx
```

### 前提:

设置时区:

```
sudo cp /usr/share/zoneinfo/Asia/Shanghai /etc/localtime
```

## df 查看硬盘空间状态

`df -h`

```
Filesystem      Size  Used Avail Use% Mounted on
udev            3.9G     0  3.9G   0% /dev
tmpfs           786M   84M  702M  11% /run
/dev/vda1        50G   37G  9.7G  80% /
tmpfs           3.9G   24K  3.9G   1% /dev/shm
tmpfs           5.0M     0  5.0M   0% /run/lock
tmpfs           3.9G     0  3.9G   0% /sys/fs/cgroup
tmpfs           786M     0  786M   0% /run/user/500
/dev/vdb         99G   60M   94G   1% /var/www/Daily_Backup
172.17.0.12:/   1.1T  498G  563G  47% /var/www/Cloud_CFS
tmpfs           786M     0  786M   0% /run/user/1009

```

## du 查看指定文件夹

### 参数详解

- **-s**：对每个Names参数只给出占用的数据块总数。
- **-a**：递归地显示指定目录中各文件及子目录中各文件占用的数据块数。若既不指定-s，也不指定-a，则只显示Names中的每一个目录及其中的各子目录所占的磁盘块数。
- **-b**：以字节为单位列出磁盘空间使用情况（系统默认以k字节为单位）。
- **-k**：以1024字节为单位列出磁盘空间使用情况。
- **-c**：最后再加上一个总计（系统默认设置）。
- **-l**：计算所有的文件大小，对硬链接文件，则计算多次。
- **-x**：跳过在不同文件系统上的目录不予统计。
- **-h**：以K，M，G为单位，提高信息的可读性。

### 查看指定文件夹大小

`sudo du -sh /var/www/`

```
511G	/var/www/
```

### 查看当前目录大小

`du -sh`

```
1.8G	.
```

### 指定深度

`du -h / --max-depth=1`

### 排序

`du -h / --max-depth=1|sort -n`

### 前几个

`du -h / --max-depth=1|sort -n|head -5`

### 根目录文件夹大小

`sudo du -sh /*`

```
16M	/bin
751M	/boot
4.0K	/data
0	/dev
160M	/etc
1.8G	/home
0	/initrd.img
0	/initrd.img.old
3.5G	/lib
4.0K	/lib64
16K	/lost+found
8.0K	/media
4.0K	/mnt
47M	/opt
0	/proc
199M	/root
84M	/run
13M	/sbin
4.0K	/spare
4.0K	/srv
0	/sys
1.7G	/tmp
3.6G	/usr
523G	/var
0	/vmlinuz
0	/vmlinuz.old
```

## wc 统计命令

统计文件个数

```shell
ls -lR | grep "^-" |wc -l
ls -lR | grep "^d" | wc -l
```

]]></content>
      <categories>
        <category>开发资料</category>
      </categories>
      <tags>
        <tag>Linux</tag>
        <tag>PHP</tag>
        <tag>后端</tag>
      </tags>
  </entry>
  <entry>
    <title>Shell_文件恢复脚本</title>
    <url>/2021/07/25/Shell_%E6%96%87%E4%BB%B6%E6%81%A2%E5%A4%8D%E8%84%9A%E6%9C%AC/</url>
    <content><![CDATA[
## Shell文件恢复脚本

该脚本为快速恢复本地文件数据到指定服务器指定位置

### 配置文件目录:

 `config`

### 功能:

```
恢复本地文件数据到指定服务器指定位置, 交互型命令行输入
```

### 常用命令

```bash
sudo chmod 600 env/id_rsa_114
su root
./resolve.sh
```

### resolve.sh脚本

```shell
#! /bin/sh

# --------------------------方法区域-------------------------------------

# * [连接远端执行命令(使用秘钥文件_无密码)]
execOrigin(){
	echo "${current_time}ssh -i ${identify_file} -o StrictHostKeyChecking=no -p ${PORT} ${USER}@${IP} ${1}" >> "${2}"
	ssh -i "${identify_file}" -o StrictHostKeyChecking=no -p "${PORT}" "${USER}@${IP}" "${1}"
}

#/**
# * [使用scp传输文件到远端]
# * @parame ${1} [需要传输的文件清单]
# * @parame ${2} [最大尝试次数]
# */
scpRecover(){
	cat ${1} | while read LINE ; do
	    file_path=${LINE}
	    file_name=`basename ${LINE}`
		count_times=0
	    # 尝试最多三次拉取远端文件
	    while [ ${count_times} -lt ${2} ]; do
	        count_times=`expr ${count_times} + 1`
	        scp -r -v -p -i ${identify_file} -o StrictHostKeyChecking=no -P ${PORT} -l ${transfer_speed}  ${file_path} ${USER}@${IP}:${origin_tmp_dir}
	        cmd_result=$?
	        # 推送成功后跳出
	        if [ ${cmd_result} -eq 0 ]; then
	        	echo "${current_time}第${count_times}次推送数据${file_path}成功"
               	echo "${current_time}第${count_times}次推送数据${file_path}成功" >>  ${log_file}
                break
	        fi
	        sleep 5
	    done

	    # 判读是否成功移动,写入日志
	    if [ ${cmd_result} -eq 0 ]; then
	        echo "${current_time}推送文件到远端缓存目录 ${origin_tmp_dir} 成功"
	        echo "${current_time}推送文件到远端缓存目录 ${origin_tmp_dir} 成功"  >> ${log_file}
	    else
	        echo ${cmd_result} > ${dir_choice2}
	        ${current_time}推送文件到远端缓存目录 ${origin_tmp_dir}
	        ${current_time}推送文件到远端缓存目录 ${origin_tmp_dir}   >> ${log_file}
	    fi
	done
	if [ ! -f ${dir_choice2} ]; then
        touch ${dir_choice2}
	fi
	final_result=`cat ${dir_choice2}`
	rm -f ${dir_choice2}
	if [ "${final_result}" != '' ]; then
		echo "${IP}:${file_path}" "!!!${current_time}备份文件恢复有错误,请查看日志详情"
    else
    	echo "${IP}:${file_path}" "!!!${current_time}备份文件恢复成功"
	fi

}

#/**
# * [使用scp传输文件到远端]
# * @parame ${1} [需要传输的文件清单]
# * @parame ${2} [最大尝试次数]
# */
scpRecoverByPass(){
		count_times=0
    # 尝试最多三次推送远端文件
    while [ ${count_times} -lt ${2} ]; do
        count_times=`expr ${count_times} + 1`
        scp -r -v -p -o StrictHostKeyChecking=no -P ${PORT} -l ${transfer_speed} ${1} ${USER}@${IP}:${origin_tmp_dir}
        cmd_result=$?
        # 推送成功后跳出
        if [ ${cmd_result} -eq 0 ]; then
          echo "${current_time}第${count_times}次推送数据${1}成功"
              echo "${current_time}第${count_times}次推送数据${1}成功" >>  ${log_file}
              break
        fi
        sleep 5
    done

    # 判读是否成功移动,写入日志
    if [ ${cmd_result} -eq 0 ]; then
        echo "${current_time}推送文件到远端缓存目录 ${origin_tmp_dir} 成功"
        echo "${current_time}推送文件到远端缓存目录 ${origin_tmp_dir} 成功"  >> ${log_file}
    else
        echo ${cmd_result} > ${dir_choice2}
        ${current_time}推送文件到远端缓存目录 ${origin_tmp_dir}
        ${current_time}推送文件到远端缓存目录 ${origin_tmp_dir}   >> ${log_file}
    fi

	if [ ! -f ${dir_choice2} ]; then
     touch ${dir_choice2}
	fi
	final_result=`cat ${dir_choice2}`
	rm -f ${dir_choice2}
	if [ "${final_result}" != '' ]; then
		echo "${IP}:${1}" "!!!${current_time}备份文件恢复有错误,请查看日志详情"
    else
    	echo "${IP}:${1}" "!!!${current_time}备份文件恢复成功"
	fi

}




# --------------------------方法区域-------------------------------------

# [[ 定义公共参数 ]]
## 引入基础配置文件
. ./baseconfig
echo "使用本地备份文件目录: ${backfile}"
## 当前时间
current_time=`date "+%Y-%m-%d_%H:%M:%S"`

## 本地缓存文件
project_list=${current_time}project.txt
project_choiced=${current_time}choice.txt
file_choice=${current_time}file.txt
cmd_result=${current_time}cmd.txt
dir_choice2=${current_time}dir.txt
log_file=log.txt




## 创建缓存文件
if [ ! -f ${log_file} ]; then
        touch ${log_file}
fi
if [ ! -f ${dir_file} ]; then
        touch ${dir_file}
fi

# [[ 开始流程-用户自定选项 ]]
echo '欢迎使用图凌备份还原系统'

## 1.列出现有备份文件夹
echo "请选择你需要还原的备份"
count=1
find ${backfile} -maxdepth 1 -mindepth 1 -type d | while read line; do
	dirname=`basename ${line}`
	echo "${count}.${dirname}" > ${project_list}
	count=`expr ${count} + 1`
done
### 1.1空值判定(文件夹为空)
if [ ! -s ${project_list} ]; then
	echo "指定备份文件夹${backfile}没有备份文件,退出"
	rm -f ${project_list}
	exit 000001
fi
### 1.2输出备份文件夹内容
echo `cat ${project_list}`

## 2.依用户输入获取使用项目包名
read -p "输入要做恢复操作的项目备份包文件夹编号(数字) ## " index
line_index=${index}
### 2.1输入空值验证
if [ "${line_index}" = '' ]; then
  echo "输入编号不能为空"
  rm -f  ${project_list}
  exit 000002
fi
echo '输入字符为'${line_index}
### 2.2匹配输入编号对应项目
cat ${project_list} | while read project; do
	txt_index=`expr substr "${project}" 1 1`    # 获取字符串第一位
	txt_file=`expr substr "${project}" 3 300`   # 获取第三位到300位

	if [ "${line_index}" -eq "${txt_index}" ]; then
		echo ${txt_file} > ${project_choiced}
		break
	fi
done
#### 2.2.1回收缓存文件
rm -f  ${project_list}
### 2.3验证是否有匹配值
request_file=`cat ${project_choiced}`
if [ "${request_file}" = '' ]; then
	echo '请输入正确的编号'
	rm -f ${project_choiced}
	exit 000003
else
	echo "您选定的为${request_file}项目"
fi
#### 2.3.1回收缓存文件
rm -f ${project_choiced}

## 3.确认使用项目
read -p "是否确认使用该备份恢复项目(y默认/n) ## " confirm
if [ "${confirm}" = 'y' ] || [ "${confirm}" = 'Y' ] || [ "${confirm}" = '' ]; then
	back_project="${backfile}/${request_file}"
	echo "备份项目所在目录为${back_project}"
else
	echo '放弃使用,中断'
	exit 000004
fi

## 4.确认配置文件
project_file=${request_file}
config_file="config/${request_file}"
echo "该备份项目配置文件为: ${backfile}/${config_file}"
if [ ! -f ${config_file} ]; then
	echo '该项目没有默认配置文件,请创建后继续'
	exit 000005
fi
echo "引入配置文件:${project_file}"
. ${config_file}
## 4.1创建项目执行远端命令日志
log_record="${NAME}.txt"
if [ ! -f ${log_record} ]; then
  touch ${log_record}
fi

## 5.展示配置文件
default='n'

until [ "${default}" = 'y' ] || [ "${default}" = 'Y' ] || [ "${default}" = '' ]; do

	echo " # # # # # # # 该项目使用配置如下:"
	echo "------1.恢复目标: ${USER}@${IP}:${PORT}  使用身份秘钥: ${identify_file}"
	echo "------2.备份文件默认恢复到远端文件夹: ${back_up_file_path}"
	echo "------3.最大传输速度为: ${transfer_speed}kb/s"

  ### 5.1 确认是否使用默认配置
	read -p "是否使用当前配置(y默认/n) ## " default
  ### 5.2 自定义配置
	if [ "${default}" = 'y' ] || [ "${default}" = 'Y' ] || [ "${default}" = '' ]; then
		echo "${request_file}使用当前配置"
	else
		read -p "需要修改哪条配置(仅本次生效) ## " config_index
		if [ ${config_index} -eq 1 ]; then
			echo "修改恢复目标请配置config文件"
			read -p "请输入使用身份秘钥路径 > " id_file
			if [ "${id_file}" != '' ]; then
				identify_file=${id_file}
			fi
		elif  [ ${config_index} -eq 2  ]; then
			read -p "请输入远端恢复目标文件夹 > " origin_file
			if [ "${origin_file}" != '' ]; then
				back_up_file_path=${origin_file}
			fi
		elif  [ ${config_index} -eq 3  ]; then
			read -p "请输入最大传输速度 > " trans_speed
			if [ "${trans_speed}" != '' ]; then
				transfer_speed=${trans_speed}
			fi
		else
			echo '请输入正确的编号'
		fi
	fi
done
### 5.3展示修改后当前配置
echo "---------------------------------------------------------------------"
echo " 确认该项目使用配置如下:"
echo "1.恢复目标: ${USER}@${IP}:${PORT}  使用身份秘钥: ${identify_file}"
echo "2.备份文件默认恢复到远端文件夹: ${back_up_file_path}"
echo "3.最大传输速度为: ${transfer_speed}kb/s"
echo "---------------------------------------------------------------------"

# 6.判断需要全量恢复还是指定日期恢复
read -p "请选择恢复类型(1.全量(默认)/2.指定日期之前/3.指定日期之后) ## " recover_type

if [ "${recover_type}" = '1' ] || [ "${recover_type}" = '' ]; then
	rec_type="all"
elif [ "${recover_type}" = '2' ]; then
	read -p "请输入需要恢复多少天前的备份(纯数字天数) ## " pre_date
	if [ ${pre_date} -gt 0 ] 2>/dev/null; then
		echo "输入${recover_type}"
	else
		echo '输入格式错误'
		exit 000006
	fi
	rec_type="+${pre_date}"

elif [ "${recover_type}" = '3' ]; then
	read -p "请输入需要恢复多少天前的备份(纯数字天数) ## " aft_date
	if [ ${aft_date} -gt 0 ] 2>/dev/null; then
		echo "输入${recover_type}"
	else
		echo '输入格式错误'
		exit 000007
	fi
	rec_type="-${aft_date}"
else
	echo "输入${recover_type}不符合规则"
	exit 000010
fi
echo "恢复类型${rec_type}(参考find -ctime 命令)"

# 7.判断恢复是全部覆盖还是存在的文件不覆盖
echo "---------------------------------------------------------------------"
echo "---1.全部覆盖(默认)"
echo "---2.当目标文件不存在时才执行操作"
echo "---3.不要覆盖任何"
echo "---4.存在时,备份覆盖"
echo "---------------------------------------------------------------------"
read -p "请选择数据覆盖类型 ## " cover_type
if [ "${cover_type}" = '1' ] || [ "${cover_type}" = '' ]; then
	cover_type="-f"
elif [ "${cover_type}" = '2' ]; then
	cover_type="-f"
elif [ "${cover_type}" = '3' ]; then
	cover_type="-n"
elif [ "${cover_type}" = '4' ]; then
	cover_type="-b"
else
	echo "输入${cover_type}不符合规则"
	exit 000011
fi
echo "覆盖类型${cover_type}"

# 8.判断需要使用密码登录传输还是公钥文件传输
read -p "请选择连接类型(1.使用配置密钥（慢速）/2.密码登录（快速）) ## " link_type

if [ "${link_type}" = 1 ] || [ "${link_type}" = '' ]; then
  send_type='pubkey'
elif [ "${link_type}" = 2 ]; then
  send_type='pass'
else
  echo "输入${link_type}不符合规则"
	exit 000012
fi
echo "验证连接方式: ${send_type}"

# 9.执行备份文件传输
## 9.1 前置准备工作
### 9.1.1 测试远端命令是否执行成功
execOrigin "ls -ahl" "${log_record}"
if [ $? -ne 0 ]; then
    echo "远端命令不可用,无法连接,中断"
    exit 000013
fi
### 9.1.2 远端创建备份文件夹(大容量)
echo "创建远端缓存文件夹: ${mk_tmp_dir}"
origin_mk_tmp_dir="mkdir ${origin_tmp_dir}"
execOrigin "${origin_mk_tmp_dir}" "${log_record}"

exit

## 9.2 获取需要传输的文件(打包/清单)
project_dir=${back_project}

### 9.2.1 创建缓存文件夹
temp_tar="${request_file}${current_time}.tar" # 打包备份文件名: 项目名+时间.tar
temp_dir="${project_dir}/../../temp" # 打包备份文件夹
if [ ! -d ${temp_dir} ]; then
   mkdir ${temp_dir}
fi
### 9.2.2 打包/列出 需要回复的备份文件
if [ ${rec_type} = "all" ]; then
	find ${project_dir} -type f > ${file_choice}
	# 空值判定
  if [ ! -s ${file_choice} ]; then
    echo '指定日期没有备份文件,退出'
    rm -f ${file_choice}
    exit 000014
  fi
	if [ "${send_type}" = 'pass' ]; then
	  echo "---使用文件:"
	  echo `cat ${file_choice}`
	  echo "---创建压缩包: ${temp_dir}/${temp_tar}"
	  find ${project_dir} -type f | xargs tar -cvf "${temp_dir}/${temp_tar}"
	fi
else
	find ${project_dir} -type f -mtime ${rec_type} > ${file_choice}
	# 空值判定
  if [ ! -s ${file_choice} ]; then
    echo '指定日期没有备份文件,退出'
    rm -f ${file_choice}
    exit 000015
  fi
	if [ "${send_type}" = 'pass' ]; then
	  echo "---使用文件:"
	  echo `cat ${file_choice}`
	  echo "---创建压缩包: ${temp_dir}/${temp_tar}"
	  find ${project_dir} -type f -mtime ${rec_type} | xargs tar -cvf "${temp_dir}/${temp_tar}"
	fi
fi

## 9.3 传输文件到远端
if [ "${send_type}" = 'pass' ]; then
  echo "使用密码方式传输文件: ${temp_dir}/${temp_tar}"
  scpRecoverByPass "${temp_dir}/${temp_tar}" 3
  # 解压远端总包
  cmd_eject="cd ${origin_tmp_dir} && tar -xvpf ${temp_tar}) --force-local && rm -f ${temp_tar}"
  execOrigin "${cmd_eject}" "${log_record}"
  rm -f "${temp_dir}/${temp_tar}"
else
  echo "使用秘钥文件${identify_file}传输文件"
  scpRecover ${file_choice} 3
fi
## 9.3.1 解压远端文件
### 9.3.1.1 拼接解压命令
cmd_line="cd ${origin_tmp_dir}"
cat ${file_choice} | while read eachLine; do
	echo "待解压:${eachLine}"
	# 文件名
	file_name=`basename ${eachLine}`
	echo "文件名: ${file_name}"
	# 文件后缀
	file_ext=`expr "${file_name}" : '.*\(\..*\)'`
	echo "后缀名: ${file_ext}"
	if [ "${file_ext}" = '.tar' ]; then
		cmd_tar="tar -xvpf ${file_name} --force-local"
	elif [ "${file_ext}" = '.gz' ]; then
		cmd_tar="tar -xzvpf ${file_name} --force-local"
	elif [ "${file_ext}" = '.bz2' ]; then
		cmd_tar="tar -xjvpf ${file_name} --force-local"
	elif [ "${file_ext}" = '.Z' ]; then
		cmd_tar="tar –xZvpf ${file_name} --force-local"
	elif [ "${file_ext}" = '.rar' ]; then
		cmd_tar="unrar e ${file_name}"
	elif [ "${file_ext}" = '.zip' ]; then
		cmd_tar="unzip ${file_name}"
	else
		echo "未知格式${file_ext}"
		continue
	fi
	echo "日志文件: ${log_record}"
	echo "执行命令: ${cmd_tar}"
	echo "删除命令: rm -f ${file_name}"
	# 进入文件夹,解压文件
	cmd_line="${cmd_line} && ${cmd_tar}"
	# 删除原包
	cmd_line="${cmd_line} && rm -f ${file_name}"
	echo ${cmd_line} > ${cmd_result}
done
### 9.3.1.2 执行远端解压命令
cmd_total=`cat ${cmd_result}`
### 9.3.1.3 删除缓存文件
rm -f ${file_choice}
rm -f ${cmd_result}
echo "解压命令为: ${cmd_total}"
execOrigin "${cmd_total}" "${log_record}"

## 9.4 从缓存文件夹移动备份文件夹到源目录

echo "----------------正在覆盖文件到${back_up_file_path}----------------------"
# 创建文件夹
cmd_mkf="mkdir ${back_up_file_path}"
execOrigin "${cmd_mkf}" "${log_record}" 2>/dev/null # 创建新文件夹
# 移动文件到目标文件夹
config_lever=${package_level}
# cmd_move="mv ${cover_type} ${origin_tmp_dir}${config_lever}/* ${back_up_file_path}/"
cmd_move="cp -rf ${origin_tmp_dir}/${config_lever}/* ${back_up_file_path}/"
execOrigin "${cmd_move}" "${log_record}"
#cmd_remove="rm -rf ${origin_tmp_dir}"
#execOrigin "${cmd_remove}" "${log_record}"
echo "------------------- 文件恢复完毕,ENJOY ---------------------------------"
```

### config配置文件

```
backfile='/var/www/File'
```

### config/[项目名] 配置文件

```
# 远端配置
NAME='测试服数据恢复'         # 项目名称
USER='ubuntu'                   # 用户名
IP='xxx.xxx.xxx.xxx'            # IP地址
PORT='22'                       # 端口
# 功能配置
identify_file='./env/id_rsa_114'                # 登录公钥文件
transfer_speed='2000000'                           # 最大传输速度 kb/s
# 项目文件配置
origin_tmp_dir='/var/www/tmp'
back_up_file_path='/var/www/[项目名]/uploadfiles1'                # 远端备份路径
package_level='[压缩包内文件名,可多层]'                                     # 包层级

```



]]></content>
      <categories>
        <category>实际演练</category>
      </categories>
      <tags>
        <tag>PHP</tag>
        <tag>后端</tag>
        <tag>Shell</tag>
      </tags>
  </entry>
  <entry>
    <title>Shell脚本编程</title>
    <url>/2020/12/03/Shell%E8%84%9A%E6%9C%AC%E7%BC%96%E7%A8%8B/</url>
    <content><![CDATA[
### 脚本运行环境

#### 1.脚本权限

需要当前用户有执行权限, 可以使用如下命令给当前目录下的`test.sh`添加权限

```
sudo chmod +x ./test.sh   或者 sudo chmod 777 ./test.sh
```

#### 2.运行方式

```
# 运行当前脚本, 不可直接使用 test.sh 方式运行
./test.sh				

# 选择编译器运行
/bin/sh test.sh
/bin/bash test.sh
```

> 若采用第二种方式运行脚本, 脚本第一行的解释器信息可以不写

#### 3.字符编码格式

由于windows(`\r\n`)和linux(`\n`)中定义换行方式不同,

 导致直接将windows中编写的shell脚本放入linux可能出现执行报错, 解决方式有如下几种

- vim 

  ```
  $ vi test.sh
  :set ff				# 查看编码: 显示dos
  :set ff=unix		# 转换编码为unix
  ```

- sublime编辑器

  ```
  点击 [首选项(preferences)->设置(settings)]
  在对象数组中添加:  "default_line_ending": "unix",
  ```

- Phpstorm

  ```
  点击右下角按钮, 浮现 line seperator,选择LF  (默认是CRLF)
  ```

- linux工具: dos2unix

  ```
  $ apt-get install dos2unix
  $ dos2unix ./*.sh
  ```

### 脚本编写

#### 1.指定自执行解释器

```
#!/bin/sh     首行, 指定使用的执行解释器
```

#### 2.脚本注释简介

```
##-----------------------------------------------
 # Created For Project qbweb_linux
 # Author: NI9NE
 # DateTime: 2020/11/25 11:11
 # Email: <ni9ne@outlook.com>
 # Usage: 用于每日备份新增加的文件
##-----------------------------------------------
```

#### 3.脚本命名

linux中脚本扩展名并不影响执行, 以`.sh`结尾只是为了见名知意

#### 4.简单脚本

```
#!/bin/sh
echo 'hello world!'
```

### 脚本书写规则

#### 1.变量

##### 1.1 定义/使用变量

在linux中, 变量定义不用加`$`符号, 使用时才需要

```
#!/bin/sh
string="hello world!"
echo $string # 或者
echo ${string}
```

同时, 定义变量应该注意以下几点

- 变量名只能使用英文字母，数字和下划线，首个字符不能以数字开头。

- 变量名和等号之间不能有空格

- 不可使用bash里的关键字

  ```
  包括: 
  new,open,edit,list,cd,pwd,set,clear,help,quit,ssh,telnet,rlogin,sftp,ftp,disconnect,reconnect 等
  ```

##### 1.2 只读变量/删除变量

定义只读变量, 防止后面修改, 可以使用

```
#!/bin/sh
string="hello world!"
readonly string
string="hello shell!"  # 脚本报错
```

删除变量

```
#!/bin/sh
string="hello world!"
unset string
echo ${string}		# 无任何输出
```

#### 2.字符串

##### 2.1 单双引号的区别

定义字符串时, 使用单/双引号均可, 也可以不用引号(这种情况只适用于没有空格的字符)

单引号中的字符都会原样输出,如果需要用到变量, 最好用双引号

```
#!/bin/sh
string=hello
string1="hello world!"
string2='hello world!'
combine1='${string1} welcome'  
echo ${combine1}     # 输出:  ${string1} welcome
combine2="${string1} welcome"
echo ${combine2}	 # 输出:  hello world! welcome
```

##### 2.2 反引号

在shell中, 反引号代表命令替换, 既将一个命令的标准输出插在一个命令行中任何位置, 使用`$(..)`同理

```
#!/bin/sh
string='当前用户为:'`whoami`
# 或者
string='当前用户为:'$(whoami)
echo ${string}  # 此时输出 当前用户为:ubuntu
```

#### 3.注释

##### 3.1 单行注释

以 `#` 开头的行就是注释，会被解释器忽略。

##### 3.2 多行注释

```
:<<EOF
注释内容...
注释内容...
注释内容...
EOF
```

#### 4.函数

>  使用函数, 需要注意, 函数定义必须处于调用点之前, 为方便书写, 通常将函数定义置于脚本开始部分

##### 4.1 定义函数

可以使用如下方法

```
#!/bin/bash
function testFunc(){
	...
}
# 或者
testFunc(){
 	...
}
```

##### 4.2 调用函数

直接输入函数名即可

```
#!/bin/bash
testFunc
```

##### 4.3 返回值

shell脚本中的返回值也可以定义, 但限制为在0-255的数字, 作为函数执行的状态结果

```
#!/bin/bash
testFunc(){
	echo '执行函数testFunc'
	return 0
}
testFunc
echo $?   # 输出0
```

>$? 在shell中代表上一条命令的执行返回结果, 通常0代表执行正确, 非0代表有错误, 可以通过这个验证代码的执行状态

##### 4.4 参数

函数参数并不需要再定义函数时的()中指定, 默认参数按照数字排序, 第一个参数为`${1}`, 第10个参数为`${10}`

传入参数只需要调用时, 以空格为分隔符跟在函数名后面即可

```
#!/bin/bash
testFunc(){
	echo '执行函数testFunc'
	echo ${1}
}
testFunc '参数1'  # 执行结果为输出:  执行函数testFunc /n  参数1
```

#### 5.流程控制

##### 5.1 if-else

与PHP不同, shell中的流程控制不能为空, 如果else分支没有语句执行，就不要写这个else.

```
if [ conditon ]; then
    command1 
elif [ conditon ]; then
	command2
else
	command3
fi
```

比如下面的判断目录是否存在, 不存在创建的命令

```
#!/bin/bash
if [ ! -d ${local_path} ]; then
    echo '目录不存在'
    mkdir ${local_path}
else
	echo '目录存在,无需创建'
fi
```

##### 5.2 for循环

```
#!/bin/bash
for loop in 1 2 3 4 5
do
    echo "The value is: ${loop}"
done
```

##### 5.4 while语句

```
while [ condition ]; do
	command
done
```

```
#!/bin/bash
int=1
while [ $int <= 5 ]
do
    echo $int
    int=`expr ${int} + 1`
done
```

##### 5.5 until 循环

```
until [ condition ]
do
    command
done
```

```
#!/bin/bash
a=0
until [ ! ${a} -lt 10 ]
do
   echo $a
   a=`expr ${a} + 1`
done
```

##### 5.6 case

```
case 值 in
模式1)
    command1
    ;;
模式2）
    command2
    ;;
esac
```

```
#!/bin/bash
echo '输入 1 到 4 之间的数字:'
echo '你输入的数字为:'
read aNum			# 读取用户输入
case $aNum in
    1)  echo '你选择了 1'
    ;;
    2)  echo '你选择了 2'
    ;;
    3)  echo '你选择了 3'
    ;;
    4)  echo '你选择了 4'
    ;;
    *)  echo '你没有输入 1 到 4 之间的数字'
    ;;
esac
```

##### 5.6 break/continue 跳出循环

#### 6.运算符

##### 6.1 算数运算符

原生bash不支持简单的数学运算，但是可以通过其他命令来实现，例如 awk 和 expr，expr 最常用

```
#!/bin/bash
val=`expr 2 + 2`
echo "两数之和为 : ${val}"
```

> 注意: 运算符之间必须有空格

常用运算符有: 

| 运算符 | 说明                                          | 举例                           |
| :----- | :-------------------------------------------- | :----------------------------- |
| +      | 加法                                          | `expr $a + $b` 结果为 30。     |
| -      | 减法                                          | `expr $a - $b` 结果为 -10。    |
| *      | 乘法(使用时需用`\`转义)                       | `expr $a \* $b` 结果为  200。  |
| /      | 除法                                          | `expr $b / $a` 结果为 2。      |
| %      | 取余                                          | `expr $b % $a` 结果为 0。      |
| =      | 赋值                                          | `a=$b `将把变量 b 的值赋给 a。 |
| ==     | 相等。用于比较两个数字，相同则返回 true。     | `[ $a == $b ]` 返回 false。    |
| !=     | 不相等。用于比较两个数字，不相同则返回 true。 | `[ $a != $b ] `返回 true。     |

> **注意：**条件表达式要放在方括号之间，并且要有空格，例如: `[$a==$b]` 是错误的，必须写成 `[ $a == $b ]`。

##### 6.2 关系运算符

关系运算符只支持数字，不支持字符串，除非字符串的值是数字。

下表列出了常用的关系运算符，假定变量 a 为 10，变量 b 为 20：

| 运算符 | 说明                                                  | 举例                         |
| :----- | :---------------------------------------------------- | :--------------------------- |
| -eq    | 检测两个数是否相等，相等返回 true。                   | `[ $a -eq $b ] `返回 false。 |
| -ne    | 检测两个数是否不相等，不相等返回 true。               | `[ $a -ne $b ] `返回 true。  |
| -gt    | 检测左边的数是否大于右边的，如果是，则返回 true。     | `[ $a -gt $b ] `返回 false。 |
| -lt    | 检测左边的数是否小于右边的，如果是，则返回 true。     | `[ $a -lt $b ]` 返回 true。  |
| -ge    | 检测左边的数是否大于等于右边的，如果是，则返回 true。 | `[ $a -ge $b ] `返回 false。 |
| -le    | 检测左边的数是否小于等于右边的，如果是，则返回 true。 | `[ $a -le $b ] `返回 true。  |

##### 6.3 布尔运算符

下表列出了常用的布尔运算符，假定变量 a 为 10，变量 b 为 20：

| 运算符 | 说明                                                | 举例                                       |
| :----- | :-------------------------------------------------- | :----------------------------------------- |
| !      | 非运算，表达式为 true 则返回 false，否则返回 true。 | `[ ! false ] `返回 true。                  |
| -o     | 或运算，有一个表达式为 true 则返回 true。           | `[ $a -lt 20 -o $b -gt 100 ] `返回 true。  |
| -a     | 与运算，两个表达式都为 true 才返回 true。           | `[ $a -lt 20 -a $b -gt 100 ] `返回 false。 |

##### 6.4 逻辑运算符

以下介绍 Shell 的逻辑运算符，假定变量 a 为 10，变量 b 为 20:

| 运算符 | 说明       | 举例                                        |
| :----- | :--------- | :------------------------------------------ |
| &&     | 逻辑的 AND | `[[ $a -lt 100 && $b -gt 100 ]]` 返回 false |
| \|\|   | 逻辑的 OR  | `[[ $a -lt 100 || $b -gt 100 ]]` 返回 true  |

##### 6.5 字符串运算符

下表列出了常用的字符串运算符，假定变量 a 为 "abc"，变量 b 为 "efg"：

| 运算符 | 说明                                         | 举例                       |
| :----- | :------------------------------------------- | :------------------------- |
| =      | 检测两个字符串是否相等，相等返回 true。      | `[ $a = $b ]` 返回 false。 |
| !=     | 检测两个字符串是否相等，不相等返回 true。    | `[ $a != $b ] `返回 true。 |
| -z     | 检测字符串长度是否为0，为0返回 true。        | `[ -z $a ]` 返回 false。   |
| -n     | 检测字符串长度是否不为 0，不为 0 返回 true。 | `[ -n "$a" ] `返回 true。  |
| $      | 检测字符串是否为空，不为空返回 true。        | `[ $a ]` 返回 true。       |

##### 6.6 文件测试运算符

| 操作符  | 说明                                                         | 举例                      |
| :------ | :----------------------------------------------------------- | :------------------------ |
| -b file | 检测文件是否是块设备文件，如果是，则返回 true。              | [ -b $file ] 返回 false。 |
| -c file | 检测文件是否是字符设备文件，如果是，则返回 true。            | [ -c $file ] 返回 false。 |
| -d file | 检测文件是否是目录，如果是，则返回 true。                    | [ -d $file ] 返回 false。 |
| -f file | 检测文件是否是普通文件（既不是目录，也不是设备文件），如果是，则返回 true。 | [ -f $file ] 返回 true。  |
| -g file | 检测文件是否设置了 SGID 位，如果是，则返回 true。            | [ -g $file ] 返回 false。 |
| -k file | 检测文件是否设置了粘着位(Sticky Bit)，如果是，则返回 true。  | [ -k $file ] 返回 false。 |
| -p file | 检测文件是否是有名管道，如果是，则返回 true。                | [ -p $file ] 返回 false。 |
| -u file | 检测文件是否设置了 SUID 位，如果是，则返回 true。            | [ -u $file ] 返回 false。 |
| -r file | 检测文件是否可读，如果是，则返回 true。                      | [ -r $file ] 返回 true。  |
| -w file | 检测文件是否可写，如果是，则返回 true。                      | [ -w $file ] 返回 true。  |
| -x file | 检测文件是否可执行，如果是，则返回 true。                    | [ -x $file ] 返回 true。  |
| -s file | 检测文件是否为空（文件大小是否大于0），不为空返回 true。     | [ -s $file ] 返回 true。  |
| -e file | 检测文件（包括目录）是否存在，如果是，则返回 true。          | [ -e $file ] 返回 true。  |

#### 7.输入输出重定向

| 命令            | 说明                                               |
| :-------------- | :------------------------------------------------- |
| command > file  | 将输出重定向到 file。                              |
| command < file  | 将输入重定向到 file。                              |
| command >> file | 将输出以追加的方式重定向到 file。                  |
| n > file        | 将文件描述符为 n 的文件重定向到 file。             |
| n >> file       | 将文件描述符为 n 的文件以追加的方式重定向到 file。 |
| n >& m          | 将输出文件 m 和 n 合并。                           |
| n <& m          | 将输入文件 m 和 n 合并。                           |
| << tag          | 将开始标记 tag 和结束标记 tag 之间的内容作为输入。 |

```
#!/bin/bash
echo `cat test.txt` > test2.txt   # 将test.txt内容覆盖test2.txt
echo `cat test.txt` > test3.txt   # 将test.txt内容追加test3.txt
```

##### 7.1不显示执行输出结果

```
$ command > /dev/null
```

/dev/null 是一个特殊的文件，写入到它的内容都会被丢弃；如果尝试从该文件读取内容，那么什么也读不到。但是 /dev/null 文件非常有用，将命令的输出重定向到它，会起到"禁止输出"的效果。

如果需要屏蔽输出和错误, 可以这样写

```
$ command > /dev/null 2>&1
```

> **注意：**0 是标准输入（STDIN），1 是标准输出（STDOUT），2 是标准错误输出（STDERR）。
>
> *这里的* 2 和 > 之间不可以有空格，2> 是一体的时候才表示错误输出]]></content>
      <categories>
        <category>学习笔记</category>
      </categories>
      <tags>
        <tag>PHP</tag>
        <tag>后端</tag>
        <tag>Shell</tag>
      </tags>
  </entry>
  <entry>
    <title>Linux扩容及挂载硬盘</title>
    <url>/2020/09/22/Linux%E6%89%A9%E5%AE%B9%E5%8F%8A%E6%8C%82%E8%BD%BD%E7%A1%AC%E7%9B%98/</url>
    <content><![CDATA[
### 环境: 

集团派发文件服务器(118)

### 问题: 

计划任务调用自动备份后, Tab键自动补全失效

### 报错: 

`cannot create temp file for here-document: No space left on device`

### 查看系统状态: 

```
ubuntu@TS-CLOUD-NFS:/var/www$ df -hl
Filesystem                         Size  Used Avail Use% Mounted on
udev                               3.9G     0  3.9G   0% /dev
tmpfs                              797M   17M  780M   3% /run
/dev/mapper/ZS--RCDT--AP--vg-root   97G   97G  0G  	  100% /
tmpfs                              3.9G     0  3.9G   0% /dev/shm
tmpfs                              5.0M     0  5.0M   0% /run/lock
tmpfs                              3.9G     0  3.9G   0% /sys/fs/cgroup
/dev/sda1                          472M   58M  390M  13% /boot
tmpfs                              797M     0  797M   0% /run/user/1000
```

```
ubuntu@TS-CLOUD-NFS:/var/www$ sudo fdisk -l | grep Disk
Disk /dev/sda: 2 TiB, 2199023255552 bytes, 4294967296 sectors
Disklabel type: dos
Disk identifier: 0x99527f79
Disk /dev/mapper/ZS--RCDT--AP--vg-root: 98.6 GiB, 105830678528 bytes, 206700544 sectors
Disk /dev/mapper/ZS--RCDT--AP--vg-swap_1: 980 MiB, 1027604480 bytes, 2007040 sectors
```

### 分析: 

当前环境下使用硬盘`2TB`, 但实际使用的只有`100G`, 其余空间未挂载

### 对策: 

创建新分区, 并挂载使用

#### 1.创建新分区

```
$ sudo fdisk /dev/sda
> m    						#(获取帮助)
> print						#(打印现状)
    Device     Boot   Start       End   Sectors  Size Id Type
    /dev/sda1  *       2048    999423    997376  487M 83 Linux
    /dev/sda2       1001470 209713151 208711682 99.5G  5 Extended
    /dev/sda3        999424   1001469      2046 1023K 83 Linux
    /dev/sda5       1001472 209713151 208711680 99.5G 8e Linux LVM
> n							#(创建新分区)
  Partition type
   p   primary (2 primary, 1 extended, 1 free)
   l   logical (numbered from 5)
  Select (default p): p
  Selected partition 4
  First sector (209713152-4294967295, default 209713152):
  Last sector, +sectors or +size{K,M,G,T,P} (209713152-4294967294, default 4294967294): +1.2T
  Created a new partition 4 of type 'Linux' and of size 1.2 TiB.
> print						#(打印现状)
  	Device     Boot     Start        End    Sectors  Size Id Type
    /dev/sda1  *         2048     999423     997376  487M 83 Linux
    /dev/sda2         1001470  209713151  208711682 99.5G  5 Extended
    /dev/sda3          999424    1001469       2046 1023K 83 Linux
    /dev/sda4       209713152 2776627199 2566914048  1.2T 83 Linux
    /dev/sda5         1001472  209713151  208711680 99.5G 8e Linux LVM
> w							#(写入保存退出)
```

>若有红色报警
>
>```
>The size of this disk is 2 TiB (2199023255552 bytes). DOS partition table format can not be used on drives for volumes larger than 2199023255040 bytes for 512-byte sectors. Use GUID partition table format (GPT).
>```
>
>解决
>
>```
>- 如果系统盘在该盘上(仅创建新分区)
>sudo parted /dev/sda
>> mkpart
>> primary
>> ext4
>> 300GB
>> 1900GB
>> quit
>sudo partprobe  # 刷新
>sudo mkfs -t ext4 /dev/sda3
>
>
>- 如果为空初始盘,(格式化盘,并创建新分区)可操作如下:
>sudo parted /dev/sda #进入parted 
>mklabel gpt #将磁盘设置为gpt格式，
>mkpart logical 0 -1 #将磁盘所有的容量设置为GPT格式
>print #查看分区结果
>
>这个时候应该是默认进行分了一个/dev/sda1这个分区
>然后退出parted，在终端输入 sudo mkfs -t ext4 /dev/sda1 
>将刚刚分出来的sda1格式化为ext4的格式，然后就可以设置开机自动挂载了。
>```
>
>
>
>

#### 2.将新分区格式化为ext4

```
$ sudo mkfs -t ext4 /dev/sda4
```

> 若报错: 
>
> ```
> The file /dev/vda3 does not exist and no size was specified
> ```
>
> 解决:
>
> ```
> 查看文件:
> $ ls -l /dev/sda*
>  brw-rw---- 1 root disk 8, 0 Nov 19 15:02 /dev/sda
>  brw-rw---- 1 root disk 8, 1 Nov 19 15:02 /dev/sda1
>  brw-rw---- 1 root disk 8, 2 Nov 19 15:02 /dev/sda2
>  brw-rw---- 1 root disk 8, 3 Nov 19 15:02 /dev/sda3
>  brw-rw---- 1 root disk 8, 5 Nov 19 15:02 /dev/sda5
> 原因为系统未读取分区信息, 执行以下命令重新生成
> $ sudo partprobe
> ```

#### 3.创建挂载点, 挂载分区

```
$ sudo mkdir /var/www/LocalCFS
$ sudo mount /dev/sda4 /var/www/LocalCFS
```

#### 4.查看挂载状况

```
ubuntu@TS-CLOUD-NFS:/var/www$ df -hl
Filesystem                         Size  Used Avail Use% Mounted on
udev                               3.9G     0  3.9G   0% /dev
tmpfs                              797M   17M  780M   3% /run
/dev/mapper/ZS--RCDT--AP--vg-root   97G   88G  4.3G  96% /
tmpfs                              3.9G     0  3.9G   0% /dev/shm
tmpfs                              5.0M     0  5.0M   0% /run/lock
tmpfs                              3.9G     0  3.9G   0% /sys/fs/cgroup
/dev/sda1                          472M   58M  390M  13% /boot
tmpfs                              797M     0  797M   0% /run/user/1000
/dev/sda4                          1.9T   67M  1.8T   1% /var/www/LocalCFS
```

#### 5.配置自动挂载

```
$ sudo blkid			#(查看分区ID)

/dev/sda4: UUID="ca6874b1-60b1-4864-a8cd-c5eff3075395" TYPE="ext4"
```

```
$ sudo vi /etc/fstab
最后面添加:
UUID=ca6874b1-60b1-4864-a8cd-c5eff3075395 /var/www/LocalCFS  ext4  defaults    1    2
/dev/sda3 /var/www ext4 defaults 0 0 
```





]]></content>
      <categories>
        <category>开发资料</category>
      </categories>
      <tags>
        <tag>Linux</tag>
        <tag>PHP</tag>
        <tag>后端</tag>
      </tags>
  </entry>
  <entry>
    <title>导入导出系统使用手册</title>
    <url>/2020/05/22/%E7%94%A8%E6%88%B7%E6%89%8B%E5%86%8C/%E5%AF%BC%E5%85%A5%E5%AF%BC%E5%87%BA%E7%B3%BB%E7%BB%9F%E4%BD%BF%E7%94%A8%E6%89%8B%E5%86%8C/</url>
    <content><![CDATA[
导入系统是作为项目初始化或批量数据生成的一种方式, 将符合格式的数据批量导入项目数据库, 通常只有管理员才可以操作, 入口如下:

![1592370680273](/images/imgs/导入导出系统使用手册/1592370680273.png)

### 注意事项:

#### 1.请使用导入样板

系统导入应使用【导入样板】, 非系统导入样板格式的Excel无法导入数据:

![1592370897448](/images/imgs/导入导出系统使用手册/1592370897448.png)

#### 2.导入样板使用

点击【导入样板】后, 选择需要导入的模块(主表或子表), 第一个总为主表, 点击确定, 即可导出模板文件

![1592371007355](/images/imgs/导入导出系统使用手册/1592371007355.png)

#### 3.导入样板格式讲解

【导入样板】的格式如下， **第一行** 为系统内部对应的字段名， **第二行** 为对应的中文名， 也就是系统中显示的名称， 在对应的字段下填入数据 .

【导入样板】中的字段为系统允许导入的所有字段, **视图列** 和**无导入 **字段不在其中, 如果某个字段下没有数据或置空, 系统默认 **不导入** 该条数据的该字段

> 注意: 导入时最好检查数据格式是否为文本格式
>
> 例如: 15100，100.11  为货币格式数据, 导入数据库时可能会失败, 修改为15100100.11即可

![1592371132605](/images/imgs/导入导出系统使用手册/1592371132605.png)

#### 4.导入--字段检查

导入时, 首先会判断**模板中字段是否属于该模块**, 如果不存在该字段, 则会报错如下:

![1592371670842](/images/imgs/导入导出系统使用手册/1592371670842.png)

![1592371687035](/images/imgs/导入导出系统使用手册/1592371687035.png)

#### 5.导入--视图列/无导入字段检测

导入时, 会判断字段中**是否有用户自己添加的字段** (视图列/无导入), 若存在, 会有如下报错:

![1592371835238](/images/imgs/导入导出系统使用手册/1592371835238.png)

![1592371842702](/images/imgs/导入导出系统使用手册/1592371842702.png)

#### 6.导入--关联数据预查询

导入时, 如果有关联字段, 会先查询**导入的数据**是否在对应模块中**存在**, 如果不存在, 会有如下报错:

> 关联字段导入既可以导入显示中文字, 也可以导入对应的真实存储值, 但不能同时使用
>
> 若采用显示值导入, 当显示值对应的真实值有多个时, 会提示: [存在多个关联的数据, 请使用真实关联值方式导入]

![1592374878840](/images/imgs/导入导出系统使用手册/1592374878840.png)

![1592375037592](/images/imgs/导入导出系统使用手册/1592375037592.png)

![1592375141927](/images/imgs/导入导出系统使用手册/1592375141927.png)

#### 7.导入--导入数据转化

导入时, 会对数据做处理如下:

英文格式的单引号`'`, 双引号`"`,逗号`,`, 会自动转化为中文格式, 

除了大文本格式的数据之外, 其他格式数据中的回车换行会自动转化为空格,

货币格式和整数类型的数据, 其中的逗号(中英文) 会被删除

数据结尾出现的反斜线`\`会被去除

#### 8.导入--数据检测_外键

导入子表时, 若没有所在**主表的编号**, 会有如下提示:

![1592376007223](/images/imgs/导入导出系统使用手册/1592376007223.png)

#### 9.导入--数据检测_主键

##### 1.非本站点数据

- 导入数据如果包含**主键编号**, 则系统会从数据库中检索是否有该条数据, 若该编号**不属于本站点**, 有如下提示:

  ![1592376266692](/images/imgs/导入导出系统使用手册/1592376266692.png)

##### 2.更新数据_流程锁定

- 如果该条数据主键编号**存在**, 系统默认**修改** 

  - 如果该条数据已经有审批流程, 即在审批中或已归档, 除管理员角色外, 无法导入该条数据

    ![1592376530653](/images/imgs/导入导出系统使用手册/1592376530653.png)

##### 3.新增数据

- 如果该条数据主键编号**不存在**, 系统默认**新增** 

#### 10.导入结果

导入完成后, 右下方会出现导入**结果弹窗**

![1592376717559](/images/imgs/导入导出系统使用手册/1592376717559.png)

 点击详情可以查看具体导入内容

![1592376808171](/images/imgs/导入导出系统使用手册/1592376808171.png)

]]></content>
      <categories>
        <category>开发手册</category>
      </categories>
      <tags>
        <tag>PHP</tag>
        <tag>后端</tag>
        <tag>项目</tag>
      </tags>
  </entry>
  <entry>
    <title>Libreoffice升级指南</title>
    <url>/2021/01/15/Libreoffice%E5%8D%87%E7%BA%A7%E6%8C%87%E5%8D%97/</url>
    <content><![CDATA[
由于低版本libreoffice转化PDF时, 会存在样式错误, 需要提高到6.4以上才能避免

如果服务器已有libreoffice, 可通过命令查看版本`soffice --version` 或 `libreoffice --version`

```
升级命令: 
 sudo add-apt-repository ppa:libreoffice/ppa
 sudo apt update
 sudo apt-get install -y libreoffice
 该命令为完整安装升级, 大约占用250M空间, 可酌情使用(推荐)
```

```
手动安装
- 访问网址 , 下载最新安装包 
https://www.libreoffice.org/download/download/
移动安装包到服务器, 执行解压安装命令
或
- 命令下载
1: wget https://mirrors.nju.edu.cn/tdf/libreoffice/stable/7.0.4/deb/x86_64/LibreOffice_7.0.4_Linux_x86-64_deb.tar.gz

2: wget https://download.documentfoundation.org/libreoffice/stable/7.0.4/deb/x86_64/LibreOffice_7.0.4_Linux_x86-64_deb.tar.gz

```

```shell
安装
tar zxvf LibreOffice_$version_Linux_x86-deb.tar.gz 
cd LibreOffice_$version_Linux_x86-deb/DEBS
sudo dpkg -i *.deb
```

]]></content>
      <categories>
        <category>环境配置</category>
      </categories>
      <tags>
        <tag>PHP</tag>
        <tag>后端</tag>
        <tag>LibreOffice</tag>
      </tags>
  </entry>
  <entry>
    <title>Navicat通过ssh-秘钥方式登录</title>
    <url>/2021/01/15/MySQL%20navicat%E9%80%9A%E8%BF%87ssh-%E7%A7%98%E9%92%A5%E6%96%B9%E5%BC%8F%E7%99%BB%E5%BD%95/</url>
    <content><![CDATA[
### 1.准备私钥文件:

 `id_rsa_2048.pub`

![1596767009388](/images/imgs/Navicat使用/1596767009388.png)

### 2.转换.pub文件为PEM文件

#### 2.1.使用`xshell`, 打开`工具`-`用户秘钥管理者`

![1596767129649](/images/imgs/Navicat使用/1596767129649.png)

#### 2.2.点击选中秘钥, 点击导出

> 如果没有秘钥, 请手动生成并将其发给管理员, 供其写入服务器验证文件

![1596767239840](/images/imgs/Navicat使用/1596767239840.png)

#### 2.3.选择保存目录及文件名, 默认为PEM格式, 不用修改

![1596767321155](/images/imgs/Navicat使用/1596767321155.png)

#### 2.4.输入密码, 导出完成(无提示)

![1596767348706](/images/imgs/Navicat使用/1596767348706.png)

### 3.使用`Navica`t链接数据库

#### 3.1.打开Navicat, 选择新建链接

> 不要在原有数据库链接上修改, 否则有可能报错: `connectiong has been used`

![1596767449908](/images/imgs/Navicat使用/1596767449908.png)

#### 3.2.填写常规项

![1596767605626](/images/imgs/Navicat使用/1596767605626.png)

#### 3.3.填写SSH项

勾选使用SSH通道, 填写内容, 选择验证方法为公钥

![1596767822670](/images/imgs/Navicat使用/1596767822670.png)

3.4.选择生成的PEM公钥文件

![1596767945543](/images/imgs/Navicat使用/1596767945543.png)

#### 3.5.输入生成公钥时的密码,测试连接

![1596768055237](/images/imgs/Navicat使用/1596768055237.png)]]></content>
      <categories>
        <category>环境配置</category>
      </categories>
      <tags>
        <tag>MySQL</tag>
        <tag>PHP</tag>
        <tag>后端</tag>
      </tags>
  </entry>
  <entry>
    <title>Bat脚本编写用例</title>
    <url>/2021/05/07/Bat%E8%84%9A%E6%9C%AC%E7%BC%96%E5%86%99%E7%94%A8%E4%BE%8B/</url>
    <content><![CDATA[
## 一次Bat脚本的尝试

记录一次Bat脚本的编写使用,

本意是在Windows服务器上用Git实现文件的备份和实时拉取, 但由于仓库的大小限制失败, 改为其他方式实现, 以下为具体bat脚本代码



### 1_rar_gitpush.bat

```powershell
@echo on

rem 设置运行脚本变量
:::: 压缩执行文件路径
set rar_exe="C:\Program Files\WinRAR\Rar.exe"
:::: 文件压缩拆分大小
set file_size=49m
:::: SQL自动备份文件夹路径,要带\
set sql_back_file_path=F:\BashTest\sqlfile\
::::上传git仓库文件夹路径,要带\
set git_file_path=F:\BashTest\filename3\
::::git拉取同步分支
set git_branck=master

:: 创建日志文件
set dir_path=%~dp0
set log_path=%dir_path%push_log.txt
set now_time=%date:~0,4%-%date:~5,2%-%date:~8,2% %time:~0,2%:%time:~3,2%:%time:~6,2%  

echo %log_path%
if not exist %log_path% (
		echo "Backup Log">%log_path%
	)



rem 拉取最新代码
cd %git_file_path%
if %errorlevel% neq 0 goto fail
git reset --hard
if %errorlevel% neq 0 goto fail
git fetch --all
if %errorlevel% neq 0 goto fail
git pull origin %git_branck%
::if %errorlevel% neq 0 goto fail


:::: 删除obj文件
rem rd /s /q .git\objects 
rem if %errorlevel% neq 0 goto fail
rem md .git\objects
rem if %errorlevel% neq 0 goto fail
rem rd /s /q .git/refs/original/
rem if %errorlevel% neq 0 goto fail
rem git reflog expire --expire=now --all
rem git gc --prune=now

rem 删除原有数据
del filefolder\*.rar
if %errorlevel% neq 0 goto fail
git add . 
::if %errorlevel% neq 0 goto fail
git commit -m "daily backup clean"
::if %errorlevel% neq 0 goto fail
git push origin %git_branck%:%git_branck%
::if %errorlevel% neq 0 goto fail



rem rem 清除大文件
::git filter-branch --index-filter "git rm --cached --ignore-unmatch *" -- --all
git filter-branch --force --index-filter "git rm -r --cached --ignore-unmatch filefolder" --prune-empty --tag-name-filter cat -- --all
rd /s /q .git\refs\original\
if %errorlevel% neq 0 goto fail
rd /s /q .git\logs\
if %errorlevel% neq 0 goto fail
git reflog expire --expire=now --all
if %errorlevel% neq 0 goto fail
git gc --prune=now --aggressive
if %errorlevel% neq 0 goto fail
git add .
git commit -m "data clean"
git push origin --force --all
::if %errorlevel% neq 0 goto fail
rem rem 清空分支
rem git checkout %git_branck%
rem if %errorlevel% neq 0 goto fail
rem git checkout --orphan master-new-line;
rem if %errorlevel% neq 0 goto fail
rem git add -A
rem if %errorlevel% neq 0 goto fail
rem git commit -am "init project"
rem if %errorlevel% neq 0 goto fail
rem git branch -D %git_branck%
rem if %errorlevel% neq 0 goto fail
rem git branch -m %git_branck%
rem if %errorlevel% neq 0 goto fail
rem git push -f origin %git_branck%:%git_branck%
rem if %errorlevel% neq 0 goto fail


rem git pack-refs --all --prune
rem git reflog expire --all
rem git repack -d -l
rem git prune --expire
rem git rerere gc

rem git checkout -b %git_branck%
rem git fetch --all

rem 分卷压缩指定文件夹内文件
:started
set now_day_format=%date:~0,4%_%date:~5,2%_%date:~8,2%
%rar_exe% a -m5 -v%file_size% -ta%now_day_format% -agYYYYMMDD %git_file_path%filefolder\ %sql_back_file_path%
if %errorlevel% neq 0 goto fail

rem 提交gitee
:gitpush
cd %git_file_path%
if %errorlevel% neq 0 goto fail
git add .
if %errorlevel% neq 0 goto fail
git commit -m "daily backup"
if %errorlevel% neq 0 goto fail
git push origin %git_branck%:%git_branck%
if %errorlevel% neq 0 goto fail

rem rem 上传完毕,清空仓库
rem :dellocal
rem del filefolder\*.rar
goto success

:fail
echo %now_time%%now_day_format%" daily backup failed">>%log_path%
echo "daily backup failed,please retry later!" && goto exited

:success
echo %now_time%%now_day_format%" daily backup success">>%log_path%
echo "backup success" && goto exited

:exited
pause
exit

```

### 2_gitpull_move.bat

```powershell
@echo off

rem 设置运行脚本变量

::::下载git仓库文件夹路径,要带\
set git_file_path=F:\BashTest\filename3\
::::本地存储文件夹路径,要带\
set storage_file_path=F:\BashTest\filename2\
::::git拉取同步分支
set git_branck=file

:: 创建日志文件
set dir_path=%~dp0
set log_path=%dir_path%pull_log.txt
set now_time=%date:~0,4%-%date:~5,2%-%date:~8,2% %time:~0,2%:%time:~3,2%:%time:~6,2%  

echo %log_path%
if not exist %log_path% (
		echo "Backup Pull Log">%log_path%
	)

rem 拉取最新代码
cd %git_file_path%
if %errorlevel% neq 0 goto fail

git reset --hard
if %errorlevel% neq 0 goto fail

git fetch --all
if %errorlevel% neq 0 goto fail

git pull origin %git_branck%
if %errorlevel% neq 0 goto fail

rem 移动到备份
:movefile
move %git_file_path%\test\* %storage_file_path%
if %errorlevel% neq 0 goto fail
goto success

:fail
echo %now_time%" daily backup pull failed">>%log_path%
echo "daily backup failed,please retry later!" && goto exited

:success
echo %now_time%" daily backup pull success">>%log_path%
echo "backup success" && goto exited

:exited
pause
exit
```









]]></content>
      <categories>
        <category>实际演练</category>
      </categories>
      <tags>
        <tag>后端</tag>
        <tag>Bat</tag>
      </tags>
  </entry>
  <entry>
    <title>码云 Fork+PR 模式使用流程</title>
    <url>/2020/10/05/Gitee%20%E7%A0%81%E4%BA%91Fork+PR%E6%A8%A1%E5%BC%8F%E4%BD%BF%E7%94%A8%E6%B5%81%E7%A8%8B/</url>
    <content><![CDATA[
## 码云 Fork+PR 模式使用流程

流程图展示

![image-20200915122128429](/images/imgs/gitee/image-20200915122128429.png)

## 一.拉取仓库

### 1.加入项目组. fork项目源仓库

![image-20200915104911706](/images/imgs/gitee/image-20200915104911706.png)

### 2.本地Clone拷贝项目

![image-20200914181253718](/images/imgs/gitee/image-20200914181253718.png)

### 3.添加源项目Remote

#### -git bash 操作 (二选一)

`git remote add resource https://gitee.com/NI9NE/laravel_permission_test.git` 

`git remote add [自定义远端名称,类似于origin] [源Fork仓库url/路径]` 

#### -sourcetree操作 (二选一)

- 点击**设置** 

  ![image-20200914181550749](/images/imgs/gitee/image-20200914181550749.png)

- 点击**添加** 

  ![image-20200914181620180](/images/imgs/gitee/image-20200914181620180.png)

- **填写**remote信息

  ![image-20200914181757757](/images/imgs/gitee/image-20200914181757757.png)

- 完成后**显示** 

  ![image-20200914182016101](/images/imgs/gitee/image-20200914182016101.png)

### 4.拉取最新远端信息

- 点击**获取** 

  ![image-20200914182334388](/images/imgs/gitee/image-20200914182334388.png)

- 确认勾选, 点击**确定** 

  ![image-20200914182358232](/images/imgs/gitee/image-20200914182358232.png)

- 显示远端分支与最新提交记录

  ![image-20200914182432946](/images/imgs/gitee/image-20200914182432946.png)

## 二.基于dev分支开发

### 1.获取远端origin/dev分支

![image-20200914182754870](/images/imgs/gitee/image-20200914182754870.png)

![image-20200914182842254](/images/imgs/gitee/image-20200914182842254.png)

### 2.检查分支代码

**注意**:  若 `origin/dev` 分支与 `resource/dev `分支提交记录不在同一条, 如下所示:

​		需要 **拉取最新源仓库代码** 后开始开发

![image-20200914183552091](/images/imgs/gitee/image-20200914183552091.png)

- 获取最新提交记录

  > 等同于`git fetch --all`

  ![image-20200914184401421](/images/imgs/gitee/image-20200914184401421.png)

- 确认当前所在本地分支为想要拉取同步的分支, 右键点击`resource/dev`所在提交, 合并到同名本地分支`dev`

  > 等同于`git checkout dev`  +  `git merge resource/dev` 

  ![image-20200914183703744](/images/imgs/gitee/image-20200914183703744.png)

- 点击确定

  ![image-20200914184448309](/images/imgs/gitee/image-20200914184448309.png)

- 合并完成后点击推送到拷贝仓库`origin/dev` 

  > 注意: 如果提示冲突, 请手动处理冲突后提交至拷贝仓库 `origin` 3.

  ![image-20200914184540196](/images/imgs/gitee/image-20200914184540196.png)

### 3.代码书写

​	......

### 4.提交代码

![image-20200915112403299](/images/imgs/gitee/image-20200915112403299.png)

### 5.检查书写代码期间是否有相关提交

#### - 拉取最新提交

![image-20200915112545436](/images/imgs/gitee/image-20200915112545436.png)

#### - 查看源仓库分支变动

![image-20200915112739052](/images/imgs/gitee/image-20200915112739052.png)

#### -  合并源仓库分支代码到拷贝仓库分支

![image-20200915113030531](/images/imgs/gitee/image-20200915113030531.png)

#### - 若有冲突, 处理冲突

![image-20200915113125306](/images/imgs/gitee/image-20200915113125306.png)

- 查看冲突所在文件

  ![image-20200915113154978](/images/imgs/gitee/image-20200915113154978.png)

- 处理冲突

- 提交代码

  ![image-20200915113918846](/images/imgs/gitee/image-20200915113918846.png)

### 6.提交PR(Pull Request)

#### - 点击远端,进入项目所在网页

![image-20200915114051027](/images/imgs/gitee/image-20200915114051027.png)

#### - 点击新建PR

![image-20200915114144211](/images/imgs/gitee/image-20200915114144211.png)

#### - 创建PR

![image-20200915121855780](/images/imgs/gitee/image-20200915121855780.png)

#### - 完成提交, 等待管理员审核通过合并

![image-20200915122011108](/images/imgs/gitee/image-20200915122011108.png)

]]></content>
      <categories>
        <category>开发资料</category>
      </categories>
      <tags>
        <tag>Git</tag>
        <tag>版本控制</tag>
      </tags>
  </entry>
  <entry>
    <title>码云 PR提交关联任务+Hook提醒</title>
    <url>/2020/10/23/Gitee%20PR%E6%8F%90%E4%BA%A4%E5%85%B3%E8%81%94%E4%BB%BB%E5%8A%A1+Hook%E6%8F%90%E9%86%92/</url>
    <content><![CDATA[
## WebHook实现

### 企业微信端设置:

#### 1.创建企业微信群聊

#### 2.创建自定义机器人

> 需要配置企业后台开启机器人功能

![image-20200917134658399](/images/imgs/gitee/image-20200917134658399.png)

3.获取机器人 `WebHook 地址`

![image-20200917134711636](/images/imgs/gitee/image-20200917134711636.png)

### Gitee仓库设置:

#### 1.打开项目网址, 进入管理选项卡

#### 2.选择WebHooks, 点击添加

![image-20200917134819489](/images/imgs/gitee/image-20200917134819489.png)

#### 3.填写配置信息

- 将机器人WebHook地址填入**URL** 

-  **WebHook 密码/签名密钥** 选择密码, 置空

  > 企业微信未提供秘钥, 钉钉需要勾选签名秘钥并填写

- 勾选需要触发通知的条件

  ![image-20200917134934255](/images/imgs/gitee/image-20200917134934255.png)

#### 4.点击添加

添加完成后, 将自动发送一条企业微信机器人通知, 如下

![image-20200917135104778](/images/imgs/gitee/image-20200917135104778.png)

## PR提交关联任务

具体操作为在提交时, 书写`link #ID`, 即可将任务关联到PR提交

![image-20200917135557587](/images/imgs/gitee/image-20200917135557587.png)

注意: 完成提交, 将PR合并后将自动关闭`Issue` 

## PR提交配置模板

在项目文件中新建文件

`.gitee/PULL_REQUEST_TEMPLATE.zh-CN.md`

内容实例为:

> markdown 书写方式, 可自定义

```
### 相关的Issue


### 原因（目的、解决的问题等）


### 描述（做了什么，变更了什么）


### 测试用例（新增、改动、可能影响的功能）
```

提交后(最好在master分支), 后面的PR提交会显示模板内容

![image-20200917145343046](/images/imgs/gitee/image-20200917145343046.png)

]]></content>
      <categories>
        <category>开发资料</category>
      </categories>
      <tags>
        <tag>Git</tag>
        <tag>版本控制</tag>
      </tags>
  </entry>
  <entry>
    <title>码云 fork+pr操作教程</title>
    <url>/2020/10/25/Gitee%20%E7%A0%81%E4%BA%91fork+pr%E6%93%8D%E4%BD%9C%E6%95%99%E7%A8%8B/</url>
    <content><![CDATA[
#  pull request 操作

## 一.单账号Fork_PR操作

### 1.准备账号:

主账号:   Mr.NI9NE_`ni9ne@outook.com`   

副账号1: Mr.zlb1_ `940223345@qq.com`      副账号2:   Mr.ZLB2_ `488747128@qq.com`    

### 2.主账号建立私有仓库:

![1600050343620](/images/imgs/gitee/1600050343620.png) 



### 3.副账号1Fork该仓库

#### - 添加该账号到项目

![1600051268581](/images/imgs/gitee/1600051268581.png)

#### - Fork仓库到自己的项目中

![1600051387661](/images/imgs/gitee/1600051387661.png)

![1600051479417](/images/imgs/gitee/1600051479417.png)

### 4.副账号1克隆自己的项目到本地开发

![1600051676792](/images/imgs/gitee/1600051676792.png)

### 5.开发功能完成, 推送到本账号项目分支

![1600053781089](/images/imgs/gitee/1600053781089.png)

### 6.进入项目Gitee页面, 创建Pull Request

#### - 点击新建Pull Request

![1600053940805](/images/imgs/gitee/1600053940805.png)

#### - 选择本地项目分支 和 目标项目分支

![1600054310266](/images/imgs/gitee/1600054310266.png)

#### - 填写Pull Request 详情, 选择审核/测试负责人

![1600054321207](/images/imgs/gitee/1600054321207.png)

> 当前显示可自动合并即可, 否则需要自行处理冲突



### 7.管理员查看, 测试, 合并到主项目分支

#### - 查看Pull Request

![1600054512665](/images/imgs/gitee/1600054512665.png)

#### - 审查代码,测试代码

![1600062213525](/images/imgs/gitee/1600062213525.png)

#### - 确认合并

![1600062395922](/images/imgs/gitee/1600062395922.png)

### 8.查看合并结果

![1600062711861](/images/imgs/gitee/1600062711861.png)

## 二.多账号Fork_PR操作

### 1.副账号2Fork仓库

### 2.副账号2Clone仓库

![1600063510303](/images/imgs/gitee/1600063510303.png)

### 3.基于master分支创建新特性分支Feature2

![1600064116925](/images/imgs/gitee/1600064116925.png)

### 4.开发功能, 提交分支

> 功能代码与其他无冲突

![1600064152851](/images/imgs/gitee/1600064152851.png)

![1600064173030](/images/imgs/gitee/1600064173030.png)

### 5.创建Pull Request

#### - 新建Pull Request

![1600064276903](/images/imgs/gitee/1600064276903.png)

#### - 选择提交分支, 提交目标分支

![1600064495182](/images/imgs/gitee/1600064495182.png)

#### - 查看提交, 并自测

> 有显示是否可以自动合并, 说明提交代码没有冲突

![1600064530725](/images/imgs/gitee/1600064530725.png)

### 6.切换主账号查看Pull Request

![1600064811716](/images/imgs/gitee/1600064811716.png)

### 7.确认代码符合条件, 合并至分支

![1600064886860](/images/imgs/gitee/1600064886860.png)

![1600064981103](/images/imgs/gitee/1600064981103.png)

### 8.查看主项目合并状况

![1600065480982](/images/imgs/gitee/1600065480982.png)

## 三.副账号查看源仓库变动(最新)代码

### 1.添加 remote 关联

 `git remote add resource https://gitee.com/NI9NE/laravel_permission_test.git` 

![1600065554478](/images/imgs/gitee/1600065554478.png)

### 2.查看关联情况

`git remote -v` 

### 3.拉取源仓库更新

`git fetch --all   /  git fetch resource ` 

### 4.合并到本地分支

`git merge resource/dev` 

### 5.推送变更到本地对应远程origin仓库

 `git push origin dev` 

![1600066019005](/images/imgs/gitee/1600066019005.png)

### 6.查看项目合并拉取状况

![1600067187887](/images/imgs/gitee/1600067187887.png)

## 四.多账号冲突Fork_PR操作

### 1.同步账号1和账号2所在源项目分支代码

### 2.副账号2先修改提交

#### - 删除+新增 代码

![1600067406076](/images/imgs/gitee/1600067406076.png)

#### - 审核/合并代码,拉取最新代码

![1600068317627](/images/imgs/gitee/1600068317627.png)

### 3.副账号1同时修改该文件

![1600068550112](/images/imgs/gitee/1600068550112.png)

####  - 提交Pull Request

![1600068867942](/images/imgs/gitee/1600068867942.png)

#### -  暂缓提交, 拉取最新代码, 查看冲突

![1600069183412](/images/imgs/gitee/1600069183412.png)

![1600069033120](/images/imgs/gitee/1600069033120.png)

#### - 处理冲突

![1600069530351](/images/imgs/gitee/1600069530351.png)

#### -  冲突处理完毕, 重新发起PR

![1600069597014](/images/imgs/gitee/1600069597014.png)

### 4.主账号审核/合并分支

![1600069801114](/images/imgs/gitee/1600069801114.png)

#### - 查看合并状态

![1600069780593](/images/imgs/gitee/1600069780593.png)

```
git:https://gitee.com
488747128@qq.com
940223345@qq.com
ni9ne@outlook.com
```


]]></content>
      <categories>
        <category>开发资料</category>
      </categories>
      <tags>
        <tag>Git</tag>
        <tag>版本控制</tag>
      </tags>
  </entry>
  <entry>
    <title>IoT物联网接入</title>
    <url>/2020/11/27/IoT%E7%89%A9%E8%81%94%E7%BD%91%E6%8E%A5%E5%85%A5/</url>
    <content><![CDATA[
## 阿里云平台功能页面

### 1.设备生命周期

设备注册、功能定义、数据解析、在线调试、远程配置、固件升级、远程维护、实时监控、分组管理、设备删除

### 2.[阿里云平台API列表](https://help.aliyun.com/document_detail/69893.html?spm=a2c4g.11186623.6.737.7fb77d9eYGo3Jd) 

![1589334935827](/images/imgs/Iot/1589334935827.png)

#### 2.1 [API调用详情页](https://help.aliyun.com/document_detail/69123.html?spm=a2c4g.11186623.2.16.496931123iaPXc#reference-mjn-n5l-vdb) ![1589335056739](assets/1589335056739.png)

#### 2.2 [ OpenAPI Explorer(开放平台接口)](https://api.aliyun.com/#/?product=Iot&api=CreateProduct&params={}&tab=DEMO&lang=PHP) 

![1589335226192](/images/imgs/Iot/1589335226192.png)



## 测试产品生命周期调用接口测试

### 1.注册产品

```
CreateProduct-调用该接口新建产品。
$result = AlibabaCloud::rpc()
                          ->product('Iot')
                          // ->scheme('https') // https | http
                          ->version('2018-01-20')
                          ->action('CreateProduct')
                          ->method('POST')
                          ->host('iot.cn-shanghai.aliyuncs.com')
                          ->options([
                                        'query' => [
                                          'RegionId' => "cn-shanghai",
                                          'NodeType' => "0",
                                          'ProductName' => "测试设备",
                                          'Description' => "测试设备描述信息",
                                        ],
                                    ])
                          ->request();
    print_r($result->toArray());
```

```
返回数据
{
	"RequestId": "EF546A4E-BC53-43C6-AA00-41FBC945B2C8",
	"Data": {
		"Description": "测试设备描述信息",
		"ProductName": "测试设备",
		"AliyunCommodityCode": "iothub",
		"NodeType": 0,
		"ProductKey": "a1WWzwKZcvd"
	},
	"Code": "",
	"Success": true,
	"ProductKey": "a1WWzwKZcvd"
}
```

### 2.注册设备

```
RegisterDevice-调用该接口在指定产品下注册设备。

$result = AlibabaCloud::rpc()
                          ->product('Iot')
                          // ->scheme('https') // https | http
                          ->version('2018-01-20')
                          ->action('RegisterDevice')
                          ->method('POST')
                          ->host('iot.cn-shanghai.aliyuncs.com')
                          ->options([
                                        'query' => [
                                          'RegionId' => "cn-shanghai",
                                          'ProductKey' => "a1WWzwKZcvd",
                                          'Nickname' => "这是备注名",
                                        ],
                                    ])
                          ->request();
    print_r($result->toArray());
```

```
返回数据-自动生成
{
	"RequestId": "8B4CC93D-A515-4469-B054-323DCA1BF913",
	"Data": {
		"IotId": "8B8MvTIuD8qgAz8Q6jhW000000",   #设备的唯一标识符
		"DeviceSecret": "npjzVfRuA6WSG9PrGNPaKEIXTMa8Dv0v",  #设备密钥
		"ProductKey": "a1WWzwKZcvd",  #所属产品
		"JoinEui": "",
		"DeviceName": "8B8MvTIuD8qgAz8Q6jhW",  #设备名称
		"Nickname": "这是备注名"
	},
	"Code": "",
	"Success": true
}
```

### 3.启用设备

```
EnableThing-调用该接口解除指定设备的禁用状态，即启用被禁用的设备。

    $result = AlibabaCloud::rpc()
                          ->product('Iot')
                          // ->scheme('https') // https | http
                          ->version('2018-01-20')
                          ->action('EnableThing')
                          ->method('POST')
                          ->host('iot.cn-shanghai.aliyuncs.com')
                          ->options([
                                        'query' => [
                                          'RegionId' => "cn-shanghai",
                                          'ProductKey' => "a1WWzwKZcvd",
                                          'DeviceName' => "8B8MvTIuD8qgAz8Q6jhW",
                                        ],
                                    ])
                          ->request();
    print_r($result->toArray());
```

```
返回数据-成功/失败
{
	"RequestId": "95094861-499A-48BC-A000-601CDA4E7116",
	"Code": "",
	"Success": true
}
```

>  显示设备未激活(需要绑定真实的设备)

![1589337285038](/images/imgs/Iot/1589337285038.png)

### 4.查询设备状态

```
GetDeviceStatus-查看指定设备的运行状态。
	$result = AlibabaCloud::rpc()
                          ->product('Iot')
                          // ->scheme('https') // https | http
                          ->version('2018-01-20')
                          ->action('GetDeviceStatus')
                          ->method('POST')
                          ->host('iot.cn-shanghai.aliyuncs.com')
                          ->options([
                                        'query' => [
                                          'RegionId' => "cn-shanghai",
                                          'ProductKey' => "a1WWzwKZcvd",
                                          'DeviceName' => "8B8MvTIuD8qgAz8Q6jhW",
                                        ],
                                    ])
                          ->request();
    print_r($result->toArray());
```

```
返回数据
{
	"RequestId": "D1510E6D-D871-4E5C-9C99-22B8F501E104",
	"Data": {
		"Status": "UNACTIVE"  #未激活
	},
	"Code": "",
	"Success": true
}
```

### 5.创建本地模拟设备(nodejs)

>  每5秒发送温度+湿度随机参数

![1589435890759](/images/imgs/Iot/1589435890759.png)

![1589435938715](/images/imgs/Iot/1589435938715.png) 

### 6.创建物模型

```
CreateThingModel-为指定产品的物模型新增功能
    "productKey": "a1WWzwKZcvd",
    "properties": [
        {
            "productKey": "a1WWzwKZcvd",
            "identifier": "temperature",
            "dataType": {
		        "type": "double",
		        "specs": {
		          "min": "0",
		          "max": "100",
		          "unit": "%",
		          "unitName": "百分比",
		          "step": "0.01"
		        }
      		}
            "name": "温度",
            "rwFlag": "READ_WRITE"
        }
    ],
    "services": [],
    "events": []
}
```

```
返回数据
{
  "RequestId": "9E76053E-26ED-4AB4-AE58-8AFC3F1E7E8E",
  "Success": true
}
```

### 7.显示设备即时数据

![1589443197759](/images/imgs/Iot/1589443197759.png)

![1589443989620](/images/imgs/Iot/1589443989620.png)



## 调用API请求结构

### 1.请求结构

#### 1.接口

```
http://Endpoint/?Action=xx&Parameters
```

> 可发送HTTP/HTTPS请求

#### 2.参数

| 参数       | 说明                                                         |
| ---------- | ------------------------------------------------------------ |
| Endpoint   | 调用云服务的接入地址。物联网平台的接入地址格式：`iot.${RegionId}.aliyuncs.com`。其中，变量${RegionId}需替换为您的物联网平台服务的地域代码。<br />例如: 华东2（上海）：`iot.cn-shanghai.aliyuncs.com` |
| Action     | 要执行的操作，即云端API接口的名称。例如，调用Pub接口向指定Topic发布消息，**Action**对应的值就是Pub，即`Action=Pub`。 |
| Parameters | 请求参数。每个参数之间用（&）符号分隔。<br />请求参数由[公共请求参数](https://help.aliyun.com/document_detail/30561.html#reference-tjr-twc-xdb)和API自定义参数组成。公共参数中包含API版本号、身份验证等信息。 |

公共请求参数如下:

> 公共请求参数是调用每个API时都需要使用的请求参数。

| 名称             | 类型   | 是否必需 | 描述                                                         |
| :--------------- | :----- | :------- | :----------------------------------------------------------- |
| Format           | String | 否       | 返回值的类型，支持JSON和XML类型。默认为XML。                 |
| Version          | String | 是       | API版本号，为日期形式：`YYYY-MM-DD`，最新版本为`2018-01-20` 。每个接口可以存在多个版本。 |
| AccessKeyId      | String | 是       | 阿里云颁发给用户的访问服务所用的密钥ID。登录阿里云控制台，将光标移至账号头像上，然后单击**accesskeys**，跳转至**用户信息管理**页，即可创建和查看AccessKey。 |
| Signature        | String | 是       | 签名结果串。                                                 |
| SignatureMethod  | String | 是       | 签名方式，目前支持HMAC-SHA1。                                |
| Timestamp        | String | 是       | 请求的时间戳。日期格式按照ISO8601标准表示，并需要使用UTC时间。格式为`YYYY-MM-DDThh:mm:ssZ`。例如，`2016-01-04T12:00:00Z`表示北京时间2016年01月04日20点0分0秒。 |
| SignatureVersion | String | 是       | 签名算法版本。目前版本是1.0。                                |
| SignatureNonce   | String | 是       | 唯一随机数。用于防止网络重放攻击。用户在不同请求中要使用不同的随机数值。 |
| RegionId         | String | 是       | 设备所在地域（与控制台上的地域对应），如cn-shanghai。        |

#### 3.案例

> 调用Pub接口向指定Topic发布消息

```
https://iot.cn-shanghai.aliyuncs.com/?Action=Pub
&Format=XML
&Version=2017-04-20
&Signature=Pc5WB8gokVn0xfeu%2FZV%2BiNM1dgI%3D
&SignatureMethod=HMAC-SHA1
&SignatureNonce=15215528852396
&SignatureVersion=1.0
&AccessKeyId=...
&Timestamp=2017-07-19T12:00:00Z
&RegionId=cn-shanghai
...
```

#### 4.返回参数

- 成功:

  - XML格式

    ```
    <?xml version="1.0" encoding="UTF-8"?> 
    <!—结果的根结点-->
    <接口名称+Response>
        <!—返回请求标签-->
        <RequestId>4C467B38-3910-447D-87BC-AC049166F216</RequestId>
        <!—返回结果数据-->
    </接口名称+Response>
    ```

  - JSON格式

    ```
    {
        "RequestId": "4C467B38-3910-447D-87BC-AC049166F216"
        /* 返回结果数据 */
    }
    ```

- 失败

  - XML格式

    ```
    <?xml version="1.0" encoding="UTF-8"?>
    <Error>
       <RequestId>8906582E-6722-409A-A6C4-0E7863B733A5</RequestId>
       <Code>UnsupportedOperation</Code>
       <Message>The specified action is not supported.</Message>
    </Error>
    ```

  - JSON格式

    ```
    {
        "RequestId": "8906582E-6722-409A-A6C4-0E7863B733A5",
        "Code": "UnsupportedOperation",
        "Message": "The specified action is not supported."
    }
    ```

>  注意:  需要**授权调用**的接口的**Action参数**由原来的 `操作名`变为`iot:操作名`

### 2.签名机制

物联网平台会对每个接口访问请求的发送者进行身份验证，所以无论使用HTTP还是HTTPS协议提交请求，都需要在请求中包含签名（Signature）信息。

#### 签名方法

签名时，您需在控制台 [AccessKey 管理](https://usercenter.console.aliyun.com/#/manage/ak)页面查看您的账号的AccessKeyId和AccessKeySecret，然后进行对称加密。其中，AccessKeyId用于标识访问者身份；AccessKeySecret是用于加密签名字符串和服务器端验证签名字符串的密钥，必须严格保密。

#### 签名示例

以调用Pub接口为例。假设您的`AccessKeyId=testid`，`AccessKeySecret=testsecret`。

1. 组成签名前的请求URL。

   ```
   http://iot.cn-shanghai.aliyuncs.com/?MessageContent=aGVsbG93b3JsZA%3D&Action=Pub&Timestamp=2017-10-02T09%3A39%3A41Z&SignatureVersion=1.0&ServiceCode=iot&Format=XML&Qos=0&SignatureNonce=0715a395-aedf-4a41-bab7-746b43d38d88&Version=2017-04-20&AccessKeyId=testid&SignatureMethod=HMAC-SHA1&RegionId=cn-shanghai&ProductKey=12345abcdeZ&TopicFullName=%2FproductKey%2Ftestdevice%2Fget
   ```

2. 计算得到待签名字符串

   StringToSign

   ```
   GET&%2F&AccessKeyId%3Dtestid%26Action%3DPub%26Format%3DXML%26MessageContent%3DaGVsbG93b3JsZA%253D%26ProductKey%3D12345abcdeZ%26Qos%3D0%26RegionId%3Dcn-shanghai%26ServiceCode%3Diot%26SignatureMethod%3DHMAC-SHA1%26SignatureNonce%3D0715a395-aedf-4a41-bab7-746b43d38d88%26SignatureVersion%3D1.0%26Timestamp%3D2017-10-02T09%253A39%253A41Z%26TopicFullName%3D%252FproductKey%252Ftestdevice%252Fget%26Version%3D2017-04-20
   ```

3. 计算签名值。

   因为`AccessKeySecret=testsecret`，用于计算的Key为testsecret&，计算得到的签名值为：

   ```
   Y9eWn4nF8QPh3c4zAFkM/k/u7eA=
   ```

4. 将签名作为

   `Signature`参数加入到URL请求中，最后得到的URL为：

   ```
   http://iot.cn-shanghai.aliyuncs.com/?MessageContent=aGVsbG93b3JsZA%3D
   &Action=Pub
   &Timestamp=2017-10-02T09%3A39%3A41Z
   &SignatureVersion=1.0
   &ServiceCode=iot
   &Format=XML
   &Qos=0
   &SignatureNonce=0715a395-aedf-4a41-bab7-746b43d38d88
   &Version=2017-04-20
   &AccessKeyId=testid
   &Signature=Y9eWn4nF8QPh3c4zAFkM%2Fk%2Fu7eA%3D
   &SignatureMethod=HMAC-SHA1
   &RegionId=cn-shanghai
   &ProductKey=12345abcdeZ
   &TopicFullName=%2FproductKey%2Ftestdevice%2Fget
   ```



## 企业基于物联网平台的业务链路

![企业基于物联网平台的业务链路](https://static-aliyun-doc.oss-cn-hangzhou.aliyuncs.com/assets/img/zh-CN/3621418851/p101379.png)

## 产品名词解释

| 名词          | 描述                                                         |
| :------------ | :----------------------------------------------------------- |
| 产品          | 设备的集合，通常指一组具有相同功能的设备。物联网平台为每个产品颁发全局唯一的ProductKey。每个产品下最多可以包含50万个设备。 |
| 设备          | 归属于某个产品下的具体设备。物联网平台为设备颁发产品内唯一的证书DeviceName。设备可以直接连接物联网平台，也可以作为子设备通过网关连接物联网平台。 |
| 分组          | 物联网平台支持建立设备分组，分组中可包含不同产品下的设备。通过设备组来进行跨产品管理设备。 |
| 网关          | 能够直接连接物联网平台的设备，且具有子设备管理功能，能够代理子设备连接云端。 |
| 子设备        | 本质上也是设备。子设备不能直接连接物联网平台，只能通过网关连接。 |
| 设备证书      | 设备证书指**ProductKey**、**DeviceName**、**DeviceSecret**。**ProductKey**：是物联网平台为产品颁发的全局唯一标识。该参数很重要，在设备认证以及通信中都会用到，因此需要您保管好。**DeviceName**：在注册设备时，自定义的或系统生成的设备名称，具备产品维度内的唯一性。该参数很重要，在设备认证以及通信中都会用到，因此需要您保管好。**DeviceSecret**：物联网平台为设备颁发的设备密钥，和DeviceName成对出现。该参数很重要，在设备认证时会用到，因此需要您保管好并且不能泄露。 |
| ProductSecret | 由物联网平台颁发的产品密钥，通常与ProductKey成对出现，可用于一型一密的认证方案。该参数很重要，需要您保管好，不能泄露。 |
| 设备X.509证书 | 物联网平台支持设备使用X.509数字证书进行身份验证。您创建认证方式为X.509证书的设备后，物联网平台为设备颁发对应的X.509证书，证书信息包括：X.509数字证书（**Certificate**）、X.509证书ID（**CertSN**）和X.509证书密钥（**PrivateKey**）。 |
| Topic         | Topic是UTF-8字符串，是发布（Pub）/订阅（Sub）消息的传输中介。可以向Topic发布或者订阅消息。 |
| Topic类       | 同一产品下不同设备的Topic集合，用`${productkey}`和`${deviceName}`通配一个唯一的设备，一个Topic类对一个ProductKey下所有设备通用。 |
| 发布          | 操作Topic的权限类型，对应的英文名称为Pub。可以往此类Topic中发布消息。 |
| 订阅          | 操作Topic的权限类型，对应的英文名称为Sub。可以从此类Topic中订阅消息。 |
| RRPC          | 全称：Revert-RPC。RPC（Remote Procedure Call）采用客户机/服务器模式，用户不需要了解底层技术协议，即可远程请求服务。RRPC则可以实现由服务端请求设备端，并能够使设备端响应的功能。 |
| 标签          | 标签分为产品标签、设备标签和分组标签。产品标签：描述同一个产品下，所有设备所具有的共性信息。设备标签：通常根据设备的特性为设备添加的特有标记，您可以自定义标签内容。分组标签：描述同一个分组下，所有设备所具有的共性信息。 |
| Alink协议     | 阿里云定义的设备与云端之间的通信协议。                       |
| 物模型        | 是对设备在云端的功能描述，包括设备的属性、服务和事件。物联网平台通过定义一种物的描述语言来描述物模型，称之为 TSL（即 Thing Specification Language），采用JSON格式，您可以根据TSL组装上报设备的数据。 |
| 属性          | 设备的功能模型之一，一般用于描述设备运行时的状态，如环境监测设备所读取的当前环境温度等。属性支持 GET 和 SET 请求方式。应用系统可发起对属性的读取和设置请求。 |
| 服务          | 设备的功能模型之一，设备可被外部调用的能力或方法，可设置输入参数和输出参数。相比于属性，服务可通过一条指令实现更复杂的业务逻辑，如执行某项特定的任务。 |
| 事件          | 设备的功能模型之一，设备运行时的事件。事件一般包含需要被外部感知和处理的通知信息，可包含多个输出参数。例如，某项任务完成的信息，或者设备发生故障或告警时的温度等，事件可以被订阅和推送。 |
| 数据解析脚本  | 针对采用透传格式/自定义数据格式的设备，需要在云端编写数据解析脚本，将设备上报的二进制数据或自定义的JSON数据，转换为物联网平台支持的Alink JSON数据格式；将平台下发的Alink JSON格式数据，转换为设备支持的格式。 |
| 设备影子      | 是一个JSON文档，用于存储设备或者应用的当前状态信息。每个设备都会在云端有唯一的设备影子。无论该设备是否连接到Internet，您都可以使用设备影子通过MQTT协议或HTTP协议获取和设置设备的状态。 |
| 规则引擎      | 通过创建、配置规则，以实现数据流转和场景联动。               |
| 数据流转      | 物联网平台规则引擎的数据流转功能，可将Topic中的数据转发至其他Topic或其他阿里云服务进行存储或处理。 |
| 场景联动      | 场景联动是一种开发自动化业务逻辑的可视化编程方式。您可以通过可视化的方式定义设备之间联动规则，并将规则部署至云端或者边缘端。 |
| 服务端订阅    | 服务端订阅产品下所有类型的消息：设备上报消息、设备状态变化通知、网关发现子设备上报消息、设备生命周期变更消息和设备拓扑关系变更消息。目前支持两种方式实现服务端订阅：AMQP：Advanced Message Queuing Protocol即高级消息队列协议。服务端通过AMQP协议接入云端，接收云端推送的消息。MNS：将消息流转到指定MNS队列中，您的服务端从MNS队列中接收消息。 |
| 一型一密      | 同一产品下所有设备可以烧录相同产品证书（即ProductKey和ProductSecret）。设备发送激活请求时，物联网平台进行产品身份确认，认证通过，下发该设备对应的DeviceSecret。 |
| 一机一密      | 每个设备烧录其唯一的设备证书（ProductKey、DeviceName和DeviceSecret）。当设备与物联网平台建立连接时，物联网平台对其携带的设备证书信息进行认证。 |
| 期望属性值    | 通过期望属性值功能，设置您希望的设备属性值。若设备在线，将实时更新属性值；若设备离线，期望属性值将缓存在云端。设备上线后，获取期望属性值，并更新属性值。 |
| 公共实例      | 在阿里云官网线上开通的物联网平台服务为公共实例。公共实例部署于阿里云经典网络。多账号共用一个公共实例，账号之间逻辑隔离。产品、设备、规则等资源可在[阿里云物联网平台控制台](https://iot.console.aliyun.com/product/region/cn-shanghai)上进行操作管理。 |
| 独享实例      | 部署于阿里云VPC网络的物联网平台独享实例。一个账号独享一个实例资源。独享实例适用于设备数量达10万及以上的客户、资源隔离性要求高的行业客户或物联网平台转售商等。购买独享实例，请联系阿里云商务人员（电话：95187转1）或[提交工单](https://selfservice.console.aliyun.com/ticket/createIndex)。 |

## API列表

`https://help.aliyun.com/document_detail/69893.html` 

]]></content>
      <categories>
        <category>学习笔记</category>
      </categories>
      <tags>
        <tag>PHP</tag>
        <tag>后端</tag>
        <tag>Iot</tag>
      </tags>
  </entry>
  <entry>
    <title>Supervisor线上进程监护工具配置</title>
    <url>/2020/01/19/Supervisor%E7%BA%BF%E4%B8%8A%E8%BF%9B%E7%A8%8B%E7%9B%91%E6%8A%A4%E5%B7%A5%E5%85%B7%E9%85%8D%E7%BD%AE/</url>
    <content><![CDATA[
# Supervisor 使用总结

**Supervisor 是一个进程监护工具，在 Laravel 中，我们用来监护消息队列、Horizon 进程，以便在其意外退出时自动重启。**

Ubuntu 环境下，运行：`apt-get install -y supervisor`。

安装完毕后，配置文件位于：`/etc/supervior`，在该文件夹下，有

```
conf.d  # 自定义配置文件存放目录
supervisord.conf # 主配置文件，自定义文件会在这里include进来
```

为了监护 Horizon 进程，我们在 conf.d 文件夹下创建一份配置，文件名随意，各项作用见注释：

```
[program:laravel_horizon]    ;监护程序名称，随意起，但不能跟其他的重复
process_name=%(program_name)s_%(process_num)02d    ;进程名称
directory=/var/www/html/larabbs    ;命令运行的目录
command=php artisan horizon    ;要执行的命令
autostart=true    ;当supervisor启动时,程序自动启动
autorestart=true    ;自动重启
numprocs=1    ; 进程数
user=root     ;执行命令的账号
stopasgroup=true    ;这个和下面一个配置可以防止监护的进程意外重启后子进程残留
killasgroup=true
redirect_stderr=true    ;这里设为true，就可以配置下面的目录
stdout_logfile=/var/www/html/larabbs/storage/laravel_horizon.log    ;日志目录
```

## 使用

运行 `supervisord -c /etc/supervisor/supervisord.conf` 启动，启动后就可以使用 `supervisorctl` 命令来进行一些进程管理操作，比如：

```
supervisorctl status # 查看状态

 # 以下针对laravel_horizon:laravel_horizon_00进程操作：
 supervisorctl stop laravel_horizon:laravel_horizon_00 
 supervisorctl start laravel_horizon:laravel_horizon_00
 supervisorctl restart laravel_horizon:laravel_horizon_00
 

supervisorctl shutdown  # 关闭supervisor

supervisorctl reread
supervisorctl update   配置文件修改后可以使用该命令加载新的配置
supervisorctl start mch-register:*
supervisorctl start mch-project:*
supervisorctl start mch-settled:*
supervisorctl help：帮助命令
supervisorctl reload： 重新启动配置中的所有程序

sudo supervisorctl stop all 停止所有进程
```

> 如果 supervisor 成功启动，在日志文件中可以看到：`Horizon started successfully.`，当有队列被执行了，日志中可以看到信息，比如：

```
[2019-11-19 14:27:30][8] Processing: App\Jobs\TranslateSlug
[2019-11-19 14:27:30][8] Processed:  App\Jobs\TranslateSlug
```

## 遇到的问题

- 启动时报错，找不到 unix:///var/run/supervisor.sock

  解决：Linux 命令中断依次运行以下命令：

  ```php
  touch /var/run/supervisor.sock
  chmod 777 /var/run/supervisor.sock
  ```

- 启动时报错：Unlinking stale socket /var/run/supervisor.sock

  解决：运行：`unlink /var/run/supervisor.sock`

- supervisor: couldn't chdir to /var/html/www/larabbs: ENOENT
  supervisor: child process was not spawned

  解决：directory 目录路径写错了，调整回正确路径

- `no such file or directory line224`

  ```undefined
  启动服务
  systemctl start supervisord
  再继续执行 supervisorctl reread
  ```

- 跨库插入失败, 实际上插入成功, 出现失败记录, 导致一直尝试重复插入

  尝试1: 将t_job/t_failed_job 均改为v_t_job/ v_t_failed_job 同库查询操作

- **如果遇到 Failed to cache access token 的问题，一般有两种可能**

  ------

  第一种情况，你可能使用的是 overtrue/wechat 4.1.16 版本，因为作者的大意引发的BUG，作者紧接着在4.1.17就修复了，更新新版就可以了。

  第二种情况就是

  问题的源起是我修改了php-fpm的运行用户，处理完一些常见的目录权限之后，报了Failed to cache access token 这个错误，于是我去 overtrue/wechat/src/Kernel/AccessToken.php:141 看了下源码，发现是因为token缓存文件没写成功。

  然后在文档( [缓存](https://www.easywechat.com/docs/master/customize/cache) )中找到了缓存方式。
  overtrue/wechat 默认使用的是 symfony/cache 来进行缓存操作，ubuntu中，symfony/cache会在`/tmp`目录下建立`symfony_cache`来储存临时缓存。
  ps:如果不是/tmp目录，可以使用 sys_get_temp_dir() 方法获取你的临时文件目录。

  因为之前使用www-data用户运行的项目，所以symfony_cache目录已被www-data创建，且其他用户不可写，直接删掉这个目录或者修改权限就可以了！

  ```
  chmod -R 777 /tmp/symfony_cache
  ```

- **Throw问题**

  项目部署到Linux 服务器上后有时会出现 每日日志无法写入的问题。由此汇总一下常出现的问题及解决方式。

  **权限问题**

  导致无法写入日志的问题，是由于代码更新时添加了文件是 root 用户，所以创建日志文件也是root 权限，导致其它用户的 www 权限无法写入日志文件中。

  所以修改 storage/logs/ 的用户权限为 www

  **chown www:www storage/logs -R**

  注意：如果用户使用supervisord服务运行队列的话，如果队列里有日志记录，那么运行的用户也需要改成 www 用户。
]]></content>
      <categories>
        <category>学习笔记</category>
      </categories>
      <tags>
        <tag>PHP</tag>
        <tag>后端</tag>
        <tag>Supervisor</tag>
      </tags>
  </entry>
  <entry>
    <title>电子合同平台操作文档</title>
    <url>/2021/10/22/%E7%94%A8%E6%88%B7%E6%89%8B%E5%86%8C/%E7%94%B5%E5%AD%90%E5%90%88%E5%90%8C%E5%B9%B3%E5%8F%B0%E6%93%8D%E4%BD%9C%E6%96%87%E6%A1%A3/</url>
    <content><![CDATA[
## 电子合同平台操作

### 配置-报表配置:

#### 配置入口: 

`站点级: 智能云顶部->操作->系统配置->报表配置` / `系统级: qb软件->xml`

![image-20211020152208296](/images/imgs/电子合同平台/image-20211020152208296.png)

![image-20211020152318370](/images/imgs/电子合同平台/image-20211020152318370.png)

#### 新版配置案例:

> 配置具体作用请查询开发手册

```json
{
    "beforeCreateContract": {
        "column": "sign_target_id,sign_target_phone,sign_target_email",
        "sql": "SELECT k.ID as sign_target_id,k.kehushouji as sign_target_phone,if(ifnull(k.dzyx,'')='',x.jfdzyx,k.dzyx) sign_target_email FROM t_xsdd x left join t_kehu k on k.ID = x.khbh WHERE x.ID = '[OID]'"
    },
    "beforeSignPDF": [
        {
            "action": "camera",
            "camera": [
                {
                    "column": "id_card_front",
                    "chname": "身份证正面",
                    "remind": "请拍摄身份证正面",
                    "required": true
                },
                {
                    "column": "head_picture",
                    "chname": "头像",
                    "remind": "请拍摄本人头像"
                }
            ],
            "actionHook": {
                "sql": [
                    "update t_xsdd set htspg='[id_card_front],[head_picture]' where ID = '[OID]'"
                ],
                "api": []
            }
        }
    ],
    "afterSignPDF": {
        "needApproval": {
            "sql": [
                "UPDATE `t_xsdd` SET `htfj` = if(ifnull(htfj,'')='','[FILE_NAME]',concat(htfj,',','[FILE_NAME]')) ,updated_at=NOW() WHERE `ID` = '[OID]' AND _site = '[SITE]'"
            ],
            "api": [
                {
                    "target": "https://eqbsdemo.quanzhuyun.com/api/v1.Api.Approve",
                    "post": {
                        "Func": "Core",
                        "Token": "88888888",
                        "Pack": {
                            "Builder": "[module]",
                            "Record_ID": "[OID]",
                            "User_ID": "[createuser]",
                            "Use_Site": "[SITE]",
                            "Action": "SUBMIT"
                        }
                    }
                }
            ]
        },
        "approveSuccess": {
            "sql": [],
            "api": [
                {
                    "target": "https://testapi.quanzhuejia.com/api/push",
                    "post": {
                        "Package": {
                            "Version": "V1",
                            "Func": "SendEmail",
                            "Body": {
                                "config": {
                                    "MAIL_DRIVER": "smtp",
                                    "MAIL_HOST": "smtphz.qiye.163.com",
                                    "MAIL_PORT": "994",
                                    "MAIL_ENCRYPTION": "ssl",
                                    "MAIL_FROM_ADDRESS": "e-home@trendzone.com.cn",
                                    "MAIL_FROM_NAME": "全筑e家",
                                    "MAIL_USERNAME": "e-home@trendzone.com.cn",
                                    "MAIL_PASSWORD": "Trendzone2019"
                                },
                                "from": "全筑e家",
                                "to": "[EMAIL]",
                                "message": "您好，感谢您对我公司的支持与信任！附件为您的合同文件，请查收。您线上签署的电子合同已经生效，此合同与纸质合同具有同等法律效力。谢谢~",
                                "title": "请查收您的合同文件",
                                "file": "[FILE_URL]"
                            }
                        }
                    }
                }
            ]
        }
    }
}
```

#### 配置分析:

-  该配置比普通电子签约多出一项 `beforeSignPDF`, 用于用户签约前验证信息的填写, 用户签约提交后会执行该项下`actionHook` 配置, 将验证信息通过SQL或接口存入指定字段

- 该配置`afterSignPDF`使用了第二种模式: 审批模式. 
  - 通过配置 下属 `needApproval` 项, 实现了将签约后文件存入对应单据字段, 且自动提交对应单据审批的动作. 
  - 通过配置 下属 `approveSuccess` 项, 提供了归档触发回调接口, 实现归档后自动修改推送状态为`审批完成`, 并发送配置邮件通知

### 配置-审批流程

#### 配置入口:

`智能云顶部->操作->系统配置->审批流程`

![image-20211020153526829](/images/imgs/电子合同平台/image-20211020153526829.png)

#### 配置案例:

- 无前置配置接口, 直接配置如下:

  ```
  [HTTP_DIR]/core/sign_report.php?opr=approveCallBack&type=[MODULE]&ID=[ID]
  ```

- 存在前置配置 , 修改对应文件, 加入如下代码: 

  ```php
  <?php
  	$showFileProtocol = ( (isset($_SERVER['HTTPS']) && $_SERVER['HTTPS'] == 'on') || ( isset($_SERVER['HTTP_X_FORWARDED_PROTO'] ) && $_SERVER['HTTP_X_FORWARDED_PROTO'] == 'https') ) ? 'https' : 'http';
  	# 请自行替换参数: type为当前模块, 替换ID为当前单据ID
  	$url = $showFileProtocol."://".$_SERVER['HTTP_HOST']."/core/sign_report.php?opr=approveCallBack&type={$_GET['type']}&ID={$_GET['ID']}";
  	file_get_contents($url);
  ```

### 操作流程

#### 业务人员发起签约

发起电子合同签约

![image-20211020155751967](/images/imgs/电子合同平台/image-20211020155751967.png)

确认信息后发送给用户

![image-20211020155828123](/images/imgs/电子合同平台/image-20211020155828123.png)

确认发送结果

![image-20211020155900876](/images/imgs/电子合同平台/image-20211020155900876.png)

#### 用户签约

用户打开链接查看合同

![image-20211021145427335](/images/imgs/电子合同平台/image-20211021145427335.png)

用户签约

![无标题](/images/imgs/电子合同平台/无标题.png)

#### 后台执行配置动作

##### 平台级别动作

- 修改签约清单对应模板记录为已签约, 并存储签约后合同及签名数据

  ![image-20211021151358186](/images/imgs/电子合同平台/image-20211021151358186.png)

- 修改推送记录中审批状态为 `审批中` 

  ![image-20211021151439787](/images/imgs/电子合同平台/image-20211021151439787.png)

##### 配置级别动作

- 存储验证图片到订单单据字段 `beforeSignPDF -> afterHook` 

  ![image-20211021150955258](/images/imgs/电子合同平台/image-20211021150955258.png)

- 存储签约后合同到订单单据字段就 `afterSignPDF -> needApprovel -> sql` 

  ![image-20211021151136475](/images/imgs/电子合同平台/image-20211021151136475.png)

- 提交对应订单单据审批 `afterSignPDF -> needApprovel -> api` 

  ![image-20211021151213782](/images/imgs/电子合同平台/image-20211021151213782.png)

#### 流程审批归档

完成归档后触发归档脚本接口

![image-20211021151607989](/images/imgs/电子合同平台/image-20211021151607989.png)

![image-20211021151624472](/images/imgs/电子合同平台/image-20211021151624472.png)

![image-20211021151712158](/images/imgs/电子合同平台/image-20211021151712158.png)

#### 后台执行动作

##### 平台级别动作

- 修改推送记录审批状态为 `审批通过` 

  ![image-20211021151840421](/images/imgs/电子合同平台/image-20211021151840421.png)

##### 配置级别动作

- 审批完成, 发送通知给用户 `afterSignPDF -> approveSuccess -> api`

  ![image-20211021152029270](/images/imgs/电子合同平台/image-20211021152029270.png)



### 扩展能力

#### 审批状态单据无法发起电子合同

![image-20211021152204118](/images/imgs/电子合同平台/image-20211021152204118.png)

#### 废弃当前合同重新签约

>  修改存储状态为废弃, 即可保证用户无法查看之前推送, 且可以在对应单据重新发起签约

![image-20211021152249944](/images/imgs/电子合同平台/image-20211021152249944.png)

![image-20211021152344740](/images/imgs/电子合同平台/image-20211021152344740.png)

![image-20211021152430706](/images/imgs/电子合同平台/image-20211021152430706.png)

]]></content>
      <categories>
        <category>开发手册</category>
      </categories>
      <tags>
        <tag>PHP</tag>
        <tag>后端</tag>
        <tag>项目</tag>
      </tags>
  </entry>
  <entry>
    <title>雪花算法实现</title>
    <url>/2020/12/12/%E7%AE%97%E6%B3%95/%E9%9B%AA%E8%8A%B1%E7%AE%97%E6%B3%95%E5%AE%9E%E7%8E%B0/</url>
    <content><![CDATA[
# 雪花算法实现

在laravel中实现雪花算法

----------------------------------------------

![1599733143891](/images/imgs/1599733143891.png)

```php
class SnowFake
{
	CONST START_TIME = '2020-01-01 00:00:00';       # 起始时间
    CONST MAX40_BIN_DEC = 1099511627775;
    CONST MAX12_BIN_DEC = 4095;
    CONST MAX10_BIN_DEC = 1023;

    STATIC LAST_MID = 0;       # 最新机器码
    STATIC SEQUENCE_NUM = 0;   # 最新序列码

	
    /**
     * @desc 雪花算法生成唯一ID,
     *       支持从开始时间约69年时间内,
     *       1024台机器,每秒4096000个唯一ID
     * @return float|int|string
     */
    public static function Union_Id(){
        $first_bin = '0';                       # 1/64 符号位
        $now_time = floor(microtime(true) * 1000);
        $start_time = strtotime(self::START_TIME) * 1000;
        $diff_time = $now_time - $start_time;
        $diff_time_bin = base_convert($diff_time, 10, 2);
        $diff_time_bin = str_pad($diff_time_bin,41,'0', STR_PAD_LEFT);
        $second_bin = $diff_time_bin;           # 2-42/64 时间戳位
        self::setSequence();
        self::getMid();
        $mid_bin = decbin(self::$LAST_MID);
        $third_bin = str_pad($mid_bin, 10, '0', STR_PAD_LEFT);          # 42-52/64 数据中心+机器码位
        $sequence_bin = decbin(self::$SEQUENCE_NUM);
        $forth_bin = str_pad($sequence_bin, 12, '0', STR_PAD_LEFT);     # 52-64/64 序列编号位
        $union_bin = $first_bin . $second_bin . $third_bin . $forth_bin;
        $bin_dec = base_convert($union_bin,2,10);
        return $bin_dec;
    }
    
    
    private static function getMid()
    {
//        $machine_code = config('original.Machine_Code');
//        if ($machine_code < 1 || $machine_code > 1023) {
//            self::Error(5018,['env Config: MACHINE_CODE error, must be int between 1 and 1023']);
//        }
//        self::$LAST_MID = $machine_code;
        if (self::$SEQUENCE_NUM >= self::MAX12_BIN_DEC){
            self::$LAST_MID ++;
            if (self::$LAST_MID > self::MAX10_BIN_DEC){
                self::$LAST_MID = 0;
            }
        }
    }

    private static function setSequence()
    {
        self::$SEQUENCE_NUM ++;
        if (self::$SEQUENCE_NUM > self::MAX12_BIN_DEC){
            self::$SEQUENCE_NUM = 0;
        }
    }
}

```

]]></content>
      <categories>
        <category>实际演练</category>
      </categories>
      <tags>
        <tag>PHP</tag>
        <tag>后端</tag>
      </tags>
  </entry>
  <entry>
    <title>Composer包从零搭建</title>
    <url>/2021/08/13/Composer%E5%8C%85%E4%BB%8E%E9%9B%B6%E6%90%AD%E5%BB%BA/</url>
    <content><![CDATA[
# Composer搭建

搭建一个自己的PHP Composer包并发布

## Git操作

### 1.Git创建仓库

进入Git页面, 创建仓库

![image-20211113192619005](/images/imgs/Composer包搭建/image-20211113192619005.png)

### 2.克隆该仓库到本地

```
git clone git@github.com:NI9NE/excelexport.git
```

![image-20211113192914990](/images/imgs/Composer包搭建/image-20211113192914990.png)

### 3.初始化composer包

```
composer init
```

![image-20211113193005218](/images/imgs/Composer包搭建/image-20211113193005218.png)

![image-20211113193248507](/images/imgs/Composer包搭建/image-20211113193248507.png)

> 暂不定义包依赖, 后续编写逻辑时再添加

### 4.编写包类逻辑

依照psr-4规范创建对应目录, 加入逻辑

![image-20211113200840420](/images/imgs/Composer包搭建/image-20211113200840420.png)

在 composer.json 文件中加入包依赖并注册类命名空间

![image-20211113194837850](/images/imgs/Composer包搭建/image-20211113194837850.png)

编写测试使用demo

```
需要先安装依赖包  composer install
```

![image-20211113200942087](/images/imgs/Composer包搭建/image-20211113200942087.png)

运行测试是否成功

![image-20211113201001589](/images/imgs/Composer包搭建/image-20211113201001589.png)

### 5.上传Git

```
git add .
git commit -m 'init'
git push 
```

![image-20211113201104246](/images/imgs/Composer包搭建/image-20211113201104246.png)

### 6.添加tag并发布release

打标签(版本号规则请查看文档)

```
git tag v1.0.0
git push origin v1.0.0
```

![image-20211113201339556](/images/imgs/Composer包搭建/image-20211113201339556.png)

发布Realease

![image-20211113201457927](/images/imgs/Composer包搭建/image-20211113201457927.png)

![image-20211113201536914](/images/imgs/Composer包搭建/image-20211113201536914.png)

## composer发布操作

### 1.登录packagist.org

![image-20211113201730169](/images/imgs/Composer包搭建/image-20211113201730169.png)

### 2.发布包

![image-20211113201820239](/images/imgs/Composer包搭建/image-20211113201820239.png)

### 3.发布完成

![image-20211113201916645](/images/imgs/Composer包搭建/image-20211113201916645.png)

## 测试使用该composer包

### 1.安装发布的composer包

> 推荐使用国内composer镜像源, 否则可能拉取失败

```
composer require ni9ne/excelexport
```

![image-20211113202052070](/images/imgs/Composer包搭建/image-20211113202052070.png)

### 2.编写使用代码,运行测试

![image-20211113202314900](/images/imgs/Composer包搭建/image-20211113202314900.png)

## 后续发布版本

后续变更只需要变更后提交修改, 打好tag, 发布release, composer会通过githook自动实现版本发布

![image-20211113202443901](/images/imgs/Composer包搭建/image-20211113202443901.png)]]></content>
      <categories>
        <category>实际演练</category>
      </categories>
      <tags>
        <tag>PHP</tag>
        <tag>后端</tag>
        <tag>Composer</tag>
      </tags>
  </entry>
  <entry>
    <title></title>
    <url>/2021/11/19/Nginx/Nginx%E9%9D%99%E6%80%81%E8%B5%84%E6%BA%90%E9%85%8D%E7%BD%AE/</url>
    <content><![CDATA[## Nginx静态资源部署

### 1.nginx静态资源配置指令

#### listen 用于配置监听端口

##### 指令语法

`listen address[:port] [default_server] ...` / `listen port [default_server]...`

##### 指令文档

```
http://nginx.org/en/docs/http/ngx_http_core_module.html#listen
```

##### 用例

```
listen 127.0.0.1:8080;
listen 127.0.0.1;
listen 8080;
listen *:8080;
```

##### default_server

> 默认主机标识符, 即没有匹配到对应的address:port时, 默认执行的server块
>
> 若不指定, 默认使用第一个server

```
listen 8080 default_server; # 当前监听所在server块为默认服务
```

#### server_name 用于设置虚拟主机服务名称

##### 指令语法

`server_name  name1 [name2...]`  中间用空格分隔

##### 指令文档

```
http://nginx.org/en/docs/http/ngx_http_core_module.html#server_name
```

##### 匹配方式

- 精确匹配

  ```
  server{
  	listen 80;
  	server_name www.host1.com www.host2.com;
  }
  ```

- 匹配通配符

  > `*` 可以放在域名首段或者尾段, 但不能出现在域名中间

  ```
  server{
  	listen 80;
  	server_name *.host1.com www.host2.*;
  }
  ```

- 正则匹配

  > `~` 为正则表达式开启标记

  ```
  server{
  	listen 80;
  	server_name ~^www\.(\w+)\.com$;
  	return 200 $1;
  }
  ```

##### 匹配执行顺序

精确匹配 > 前通配符 > 后通配符 > 正则匹配 > 默认server

#### location 用于设置请求URI

##### 指令语法

`location [ = | ~ | ~* | ^~ | @ ] uri{...}`

> 以匹配度最高的路由作为实际转发路由

##### 指令文档

```
http://nginx.org/en/docs/http/ngx_http_core_module.html#location
```

##### 匹配方式

- 以指定模式访问

  ```
  server{
  	listen 80;
  	server_name 127.0.0.1;
  	location /abc{
  		default_type text/plain;
  		return 200 'access success';
  	}
  }
  ```

  ```
  则如下方式均可访问
  http://127.0.0.1/abc
  http://127.0.0.1/abc?p1=test
  http://127.0.0.1/abcde
  ```

- 以精确匹配模式访问(不含正则)

  ```
  server{
  	listen 80;
  	server_name 127.0.0.1;
  	location =/abc{
  		default_type text/plain;
  		return 200 'access success';
  	}
  }
  ```

  ```
  则以下方式可访问:
  http://127.0.0.1/abc
  http://127.0.0.1/abc?p1=test
  以下无法访问:
  http://127.0.0.1/abc/
  http://127.0.0.1/abcde
  ```

- 以正则匹配模式访问

  `~ `  : 用于表示当前URI中包含正则, 且区分大小写

  `~*` : 用于表示当前URI包含正则, 且不区分大小写

  ```
  server{
  	listen 80;
  	server_name 127.0.0.1;
  	# location ~*^/abc\w${	# 不区分大小写
  	location ~^/abc\w${
  		default_type text/plain;
  		return 200 'access success';
  	}
  }
  ```

  ```
  则以下方式可访问:
  http://127.0.0.1/abcd
  以下无法访问:
  http://127.0.0.1/abc
  http://127.0.0.1/abc/
  http://127.0.0.1/abcde
  ```

- 匹配后停止

  `^~` : 用于不包含正则的URI前, 功能和不加符号的一致, 表示如果模式匹配, 就停止搜索其他模式

  ```
  server{
  	listen 80;
  	server_name 127.0.0.1;
  	location ^~/abcd{
  		default_type text/plain;
  		return 200 'abcd access success';
  	}
  	location ~^/abc\w${
  		default_type text/plain;
  		return 200 'access success';
  	}
  }
  ```

  ```
  http://127.0.0.1/abcd
  访问到第一个location块后匹配, 就不再向后搜索, 直接使用该URI
  ```

- nginx内部跳转

  `@` 表示在nginx中跳转到对应的location

  ```
  location /404 {
  	error_page 404 @404_error;
  }
  location @404_error {
  	...
  }
  ```

#### root/alias 设置请求资源的目录

##### 指令语法

`root path`  设置请求的根目录

```
root html;
```

`path` 为Nginx服务器收到请求后查找资源的根目录路径

`alias path`  用于更改location的URI

`path` 为修改后的根目录

##### root/alias 区别

```
root  处理结果为: root路径+location路径
alias 处理结果为: 使用alias路径替换location路径
```

```
以下三个配置功效相同
location /images {
	root /var/www/test;	# 结果为: /var/www/test/images
}

location /images {
	alias /var/www/test/images;	# 替换原有images为 /var/www/test/images
}
location /images/ {
	alias /var/www/test/images/;# 替换原有images/为 /var/www/test/images/
}
```

#### index 用于设置网站的默认首页

##### 指令语法

`index file;`

```
index index index.html;
```

> index 后可以跟多个设置, 如果访问URI没有指定具体访问的资源, 则会依次查找, 直到找到第一个

##### 指令位置

```
http / server / location
```

如:

```
location / {
	root /var/www/test;
	index index index.html index.htm;
}
访问时, 可以直接使用 http://test.project.com 访问, 后面不加任何参数
```

#### error_page 设置网站的错误页面

##### 指令语法

`error_page code ...[=[reponse]] rui;`

##### 指令位置

```
http / server / location
```

##### 实例

```
1. 具体跳转页面地址
server {
	error_page 404 http://test.project.com/404.html;
}
2. 指定重定向地址
server {
	error_page 404 /50x.html;
	error_page 500 502 503 504 /50x.html;
	location =/50x.html{
		root html;
	}
}
3. 使用location的@符号完成错误信息展示
server {
	error_page 404 @to_error_page;
	location @to_error_page{
		default_type text/plain;
		return 404 'Not Found Page!';
	}
}
```

##### response

可选项 `=[response]` 用于将匹配状态码改为另一个状态码返回浏览器

```
server{
	error_page 404 =200 /50x.html;
	location =/50x.html{
		...
	}
}
```

### 2.nginx静态资源优化配置语法

#### sendfile

`sendfile on|off` 用于开启高效文件传输模式

![image-20211118235723693](https://ni9ne.oss-cn-shanghai.aliyuncs.com/mdimg/image-20211118235723693.png)

![image-20211118235844001](https://ni9ne.oss-cn-shanghai.aliyuncs.com/mdimg/image-20211118235844001.png)

```
使用sendfil()之后, 减少了两次copy(), 以及用户态与内核态切换的耗费
```

#### tcp_nopush

`tcp_nopush on|off`

用于提升网络包的传输效率, 必须在sendfile打开的状态下才会生效

#### tcp_nodelay

`tcp_nodelay on|off`

用于提高网络包传输的实时性, 必须在keep-alive 连接开启时才生效

![image-20211119001043741](https://ni9ne.oss-cn-shanghai.aliyuncs.com/mdimg/image-20211119001043741.png)

```
tcp_nopush和tcp_nodelay在linux 2.5.9之后可以兼容, 两者都开启可以大大加快数据传输效率
```

### 3.nginx静态资源压缩实战

在Nginx的配置文件中可以通过gzip来对静态资源进行压缩

```
ngx_http_gzip_module模块		# nginx自带
ngx_http_gzip_static_module模块	# 需要安装
ngx_http_gunzip_module模块		# 需要安装
```

#### Gzip各模块支持配置指令

以下指令都来自于ngx_http_gzip_module模块支持, 该模块nginx内置, 可以直接使用

```
模块文档: http://nginx.org/en/docs/http/ngx_http_gzip_module.html
```

##### gzip 

`gzip on|off`  用于开启或关闭gzip功能

```
http{
	gzip on;
}
```

> 可以用于http/server/loaction

##### gzip_types

`gzip_types mime-type ...` 设置需要压缩的文件mime类型

默认压缩text/html 

```
http{
	gzip_types application/javascript;
}
```

> 所选值可以从mime.types文件中查找, 也可以使用* 代表所有类型, 但不推荐

##### gzip_comp_level 

`gzip_comp_level level` 设置Gzip压缩程度

级别从1到9, 压缩程度上升, 压缩效率降低, 9 代表压缩程度最高, 但效率最低

```
http{
	gzip_comp_level 6;
}
```

##### gzip_vary 

`gzip_vary on|off ` 设置是否携带gzip响应头

`gzip_vary` 用于设置进行压缩发送是否携带 `Vary:Accept-Encoding` 响应头, 告诉接收方该资源经过了Gzip压缩处理

```
http{
	gzip_vary on;
}
```

> 可用于http/server/location

##### gzip_buffers

`gzip_buffers number size` 用于设置压缩的缓冲区数量及大小

该值设定一般和服务器操作系统有关, 一般使用默认值即可

```
http{
	gzip_buffers 4 16k;
}
```

##### gzip_disable

`gzip_disable regex ..` 用于使用正则针对不同的浏览器禁用Gzip功能

regex匹配`Request Headers`中`User-Agent` 数据

```
http{
	gzip_disable "MSIE [1-6]\."; # 排除IE6以下版本
}
```

##### gzip_http_version

`gzip_http_version 1.0|1.1`  针对不同的HTTP协议版本, 选择性开启或关闭gzip

该指令用于指定最低HTTP协议版本, 一般用默认值即可

```
http{
	gzip_http_version 1.1;
}
```

##### gzip_min_length

`gzip_min_length` 指定需要压缩的最小文件长度

默认20, 从头信息中的`Content-Length`中获取

```
nginx 计量但对: bytes[字节] / kb[千字节] / M[兆]
如: 1024 / 10k / 10m
```

```
http{
	gzip_min_length 20;
}
```

##### gzip_proxied

`gzip_proxied off|expired|no-cache|no-store|private|no_last_modified|no-etag|auth|any` 设置是否对服务端返回结果进行Gzip压缩

> 反向代理相关

- off  关闭nginx服务器对后台服务器返回结果的压缩, 忽略其他参数
- expired  启用压缩, 如果响应头headers头中包含`Expires` 头信息
- no-cache  启用压缩, 如果响应头headers头中包含`Cache-Control:no-cache`头信息
- no-store  启用压缩, 如果响应头headers头中包含`Cache-Control:no-store`头信息
- private  启用压缩, 如果响应头headers头中包含`Cache-Control:private`头信息
- no-last-modified  启用压缩, 如果响应头headers头中不包含`Last-Modified` 头信息
- no-etag  启用压缩, 如果响应头headers头中不包含 `ETag` 头信息
- auth  启用压缩, 如果响应头headers头中包含`Authorization` 头信息
- any  为所有代理请求无条件启用压缩

#### Gzip压缩功能配置

编辑新建nginx_zip.conf文件

```
gzip on;			# 开启gzip功能
gzip_types *;		# 压缩文件类型,mime-type
gzip_comp_level 6;	# gzip 压缩等级
gzip_min_length 1024;# 需要进行压缩响应页面的最小长度 content-length
gzip_buffers 4 16k;	# 缓存空间数量及大小
gzip_http_version 1.1;# 指定压缩响应需要的最低HTTP协议版本
gzip_vary on;		# 向响应头中添加压缩表示
gzip_disable "MSIE [1-6]\.";	# 过滤浏览器禁用压缩
gzip_proxied off;	# nginx作为反向代理压缩服务端返回数据的条件
```

将配置文件引入nginx.conf

```
include nginx_zip.conf;
```

#### Gzip和sendfile的冲突解决

Gzip需要应用程序用户态进行操作文件并压缩发送, 但sendfile是直接从内核缓冲区发送到Socket缓冲区的, 会导致功能冲突

可以使用`ngx_http_gzip_static_module` 模块的 `gzip_static` 指令解决问题

![image-20211119012700914](https://ni9ne.oss-cn-shanghai.aliyuncs.com/mdimg/image-20211119012700914.png)

解决方案是在请求资源之前, 就将资源压缩, `jquery.js` 压缩为 `jquery.js.gz`, 在用户请求资源时, 发送压缩后的文件给用户, 由浏览器进行解压缩显示

##### gzip_static

`gzip_static on|off|always;` 

访问与资源同名的`.gz` 文件时, response中以gzip相关的header返回`.gz`文件内容

> 添加上述命令后, 若报错 unknown directiove 'gzip_static', 原因是Nginx默认没有添加对应模块, 需要手动安装 ./configure --with-http_gzip_static_module

```
http{
	gzip_static on;
}
```

```shell
gzip /var/www/test/images/jquery.js
```

]]></content>
  </entry>
</search>
