<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width">
<meta name="theme-color" content="#222" media="(prefers-color-scheme: light)">
<meta name="theme-color" content="#222" media="(prefers-color-scheme: dark)">
<meta name="generator" content="Hexo 5.4.0">

<link rel="preconnect" href="https://unpkg.com" crossorigin>
  <link rel="apple-touch-icon" sizes="180x180" href="/images/favicon/apple-touch-icon.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon/favicon-32x32.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon/favicon-16x16.png">
  <link rel="mask-icon" href="/images/favicon/safari-pinned-tab.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">



<link rel="stylesheet" href="https://unpkg.com/@fortawesome/fontawesome-free@5.15.4/css/all.min.css" integrity="sha256-mUZM63G8m73Mcidfrv5E+Y61y7a12O5mW4ezU3bxqW4=" crossorigin="anonymous">
  <link rel="stylesheet" href="https://unpkg.com/animate.css@3.1.1/animate.min.css" integrity="sha256-PR7ttpcvz8qrF57fur/yAx1qXMFJeJFiA6pSzWi0OIE=" crossorigin="anonymous">
  <link rel="stylesheet" href="https://unpkg.com/@fancyapps/fancybox@3.5.7/dist/jquery.fancybox.min.css" integrity="sha256-Vzbj7sDDS/woiFS3uNKo8eIuni59rjyNGtXfstRzStA=" crossorigin="anonymous">

<script class="next-config" data-name="main" type="application/json">{"hostname":"ni9ne.github.io","root":"/","images":"/images","scheme":"Gemini","darkmode":true,"version":"8.8.1","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12},"copycode":true,"bookmark":{"enable":false,"color":"#222","save":"auto"},"mediumzoom":true,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"stickytabs":false,"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"fadeInDown","post_body":"fadeInDown","coll_header":"fadeInLeft","sidebar":"fadeInUp"}},"prism":false,"i18n":{"placeholder":"搜索...","empty":"没有找到任何搜索结果：${query}","hits_time":"找到 ${hits} 个搜索结果（用时 ${time} 毫秒）","hits":"找到 ${hits} 个搜索结果"},"path":"/search.xml","localsearch":{"enable":true,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false}}</script><script src="/js/config.js"></script>
<meta name="description" content="Redis原理解析数据结构动态字符串SDS">
<meta property="og:type" content="article">
<meta property="og:title" content="Redis原理解析">
<meta property="og:url" content="https://ni9ne.github.io/2022/05/22/Redis/Redis%E5%8E%9F%E7%90%86%E8%A7%A3%E6%9E%90/index.html">
<meta property="og:site_name" content="NI9NE&#39;s Zone">
<meta property="og:description" content="Redis原理解析数据结构动态字符串SDS">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://ni9ne.oss-cn-shanghai.aliyuncs.com/mdimg/69f6edd95cacd1c4a0ca4815a321dbac-aaf255e.png">
<meta property="og:image" content="https://ni9ne.oss-cn-shanghai.aliyuncs.com/mdimg/fbd991e9cd61aaa86030ca473e35b4d0-348f2d4.png">
<meta property="og:image" content="https://ni9ne.oss-cn-shanghai.aliyuncs.com/mdimg/3ddf52c51c24369f788f860030e7da81-305679b.png">
<meta property="og:image" content="https://ni9ne.oss-cn-shanghai.aliyuncs.com/mdimg/b212adf4e1c29d33a2fc6092e6fc54be-18118b8.png">
<meta property="og:image" content="https://ni9ne.oss-cn-shanghai.aliyuncs.com/mdimg/37f675c0d3ffa076a5592443367f0450-eafde3f.png">
<meta property="og:image" content="https://ni9ne.oss-cn-shanghai.aliyuncs.com/mdimg/de01adf9e0bef045278bf465d021d481-a974fc5.gif">
<meta property="og:image" content="https://ni9ne.oss-cn-shanghai.aliyuncs.com/mdimg/60b78fc4e014fb8d63d19f89e9f8a09e-cc93f1a.png">
<meta property="og:image" content="https://ni9ne.oss-cn-shanghai.aliyuncs.com/mdimg/bbf9d4f45a0226651e126b0d4cf83921-43caee5.png">
<meta property="og:image" content="https://ni9ne.oss-cn-shanghai.aliyuncs.com/mdimg/5c2fff360bcd5a3cdaa52e7b51e17f04-ff9633d.png">
<meta property="og:image" content="https://ni9ne.oss-cn-shanghai.aliyuncs.com/mdimg/8813407661098e92eac6fd735d18b102-93e5d0f.png">
<meta property="og:image" content="https://ni9ne.oss-cn-shanghai.aliyuncs.com/mdimg/57b99fe9ac796be76edc9a91eafd9675-217bb7d.png">
<meta property="og:image" content="https://ni9ne.oss-cn-shanghai.aliyuncs.com/mdimg/82e31ed742e0d119352b7b1eb4351d48-e7c70a8.png">
<meta property="og:image" content="https://ni9ne.oss-cn-shanghai.aliyuncs.com/mdimg/ff206082930d2da5d1c75169c03f20f3-c00248c.png">
<meta property="og:image" content="https://ni9ne.oss-cn-shanghai.aliyuncs.com/mdimg/55d2163867f7886cdbfa6f63fc661b3f-f41062d.png">
<meta property="og:image" content="https://ni9ne.oss-cn-shanghai.aliyuncs.com/mdimg/681ff7fae8ff96472ffaee38e07fd651-89db125.png">
<meta property="og:image" content="https://ni9ne.oss-cn-shanghai.aliyuncs.com/mdimg/ccbb30addfb6030347b1d512be252560-08e1949.png">
<meta property="og:image" content="https://ni9ne.oss-cn-shanghai.aliyuncs.com/mdimg/dae1baaa7e854df6a9369f6c9b091ceb-4864207.png">
<meta property="og:image" content="https://ni9ne.oss-cn-shanghai.aliyuncs.com/mdimg/22c0604f905c9a9320ed22fe6ca20ad4-7e2fbee.png">
<meta property="og:image" content="https://ni9ne.oss-cn-shanghai.aliyuncs.com/mdimg/b5676912c64e4eddaed222a5d97d79ba-4cec64e.png">
<meta property="og:image" content="https://ni9ne.oss-cn-shanghai.aliyuncs.com/mdimg/a012be5aa820a61ebafb64e05846231c-a7e09fe.png">
<meta property="og:image" content="https://ni9ne.oss-cn-shanghai.aliyuncs.com/mdimg/a6443c22addef2e2cd0a6001a877bc94-9a3e055.gif">
<meta property="og:image" content="https://ni9ne.oss-cn-shanghai.aliyuncs.com/mdimg/5ee52eb9d9b91437973c0a5588d0e991-9a2f4a5.png">
<meta property="og:image" content="https://ni9ne.oss-cn-shanghai.aliyuncs.com/mdimg/02301de3782a5593f91715f65e798123-e33658f.png">
<meta property="og:image" content="https://ni9ne.oss-cn-shanghai.aliyuncs.com/mdimg/de01b2eced959d2faf0e56b0e7b7e3db-857cbe0.png">
<meta property="og:image" content="https://ni9ne.oss-cn-shanghai.aliyuncs.com/mdimg/f385696f7af49d7d18de157325da5f70-1007903.png">
<meta property="og:image" content="https://ni9ne.oss-cn-shanghai.aliyuncs.com/mdimg/7cd6aa7894635b14a84422f70c39c04b-de40245.gif">
<meta property="og:image" content="https://ni9ne.oss-cn-shanghai.aliyuncs.com/mdimg/cb71923492cc0e2879e8b79e9e76a946-1e56300.png">
<meta property="og:image" content="https://ni9ne.oss-cn-shanghai.aliyuncs.com/mdimg/f7e80ed1a3702650e04a690fb08450a1-6257078.png">
<meta property="og:image" content="https://ni9ne.oss-cn-shanghai.aliyuncs.com/mdimg/8b648382d193b59dc1f1b3638d755f2e-4c5ddb2.png">
<meta property="og:image" content="https://ni9ne.oss-cn-shanghai.aliyuncs.com/mdimg/476e4b74386df29d93868ab0263195e1-fdc5df2.png">
<meta property="og:image" content="https://ni9ne.oss-cn-shanghai.aliyuncs.com/mdimg/bc7b1e49e6cfe5d0c512f47277aeb435-faa07df.png">
<meta property="og:image" content="https://ni9ne.oss-cn-shanghai.aliyuncs.com/mdimg/2d0b96b94f091cc0e1f580d2f4a053d5-307ef23.png">
<meta property="og:image" content="https://ni9ne.oss-cn-shanghai.aliyuncs.com/mdimg/69ae08821256e681ffd04819f7d7fd4d-ed02b0c.png">
<meta property="og:image" content="https://ni9ne.oss-cn-shanghai.aliyuncs.com/mdimg/f4a0b6ea384f2e5660d6c3400947d8d0-9bf376b.png">
<meta property="og:image" content="https://ni9ne.oss-cn-shanghai.aliyuncs.com/mdimg/8def98475926e2de06c6df26e3ed7ddb-636bdc7.png">
<meta property="og:image" content="https://ni9ne.oss-cn-shanghai.aliyuncs.com/mdimg/af40a3d93a91631f4708f847334c937c-18f8955.png">
<meta property="og:image" content="https://ni9ne.oss-cn-shanghai.aliyuncs.com/mdimg/e704f0768e2dac979cfae3e5410b8703-1deb05d.png">
<meta property="og:image" content="https://ni9ne.oss-cn-shanghai.aliyuncs.com/mdimg/4931ae3a6ffba9db55d886a7495dd155-bffe22d.png">
<meta property="og:image" content="https://ni9ne.oss-cn-shanghai.aliyuncs.com/mdimg/c28a446d5bd4fbc14ae867c44e8babaa-bde6d3a.png">
<meta property="og:image" content="https://ni9ne.oss-cn-shanghai.aliyuncs.com/mdimg/4b88d039e0e4f66060bff62f09285fdf-de513b4.png">
<meta property="og:image" content="https://ni9ne.oss-cn-shanghai.aliyuncs.com/mdimg/9378b10899e23356eff2fac34c79deb1-2b85d7f.png">
<meta property="og:image" content="https://ni9ne.oss-cn-shanghai.aliyuncs.com/mdimg/d8b248a19ca10063ba9be12dce9b6a90-6948607.png">
<meta property="og:image" content="https://ni9ne.oss-cn-shanghai.aliyuncs.com/mdimg/46bcf52e1c0fb159c954be2faec70f7f-876abcf.png">
<meta property="og:image" content="https://ni9ne.oss-cn-shanghai.aliyuncs.com/mdimg/067741ed45b3559bfc1aae0c55a4ea71-e2ba790.png">
<meta property="og:image" content="https://ni9ne.oss-cn-shanghai.aliyuncs.com/mdimg/2718ee01e1cd5d9b7801592dfbc91bb6-7e99597.png">
<meta property="og:image" content="https://ni9ne.oss-cn-shanghai.aliyuncs.com/mdimg/fff5e4813c4de4b4adea56d9d1c8e060-314286f.png">
<meta property="og:image" content="https://ni9ne.oss-cn-shanghai.aliyuncs.com/mdimg/2190502fe238d4d21ca30bce958b24b1-b9ec829.png">
<meta property="og:image" content="https://ni9ne.oss-cn-shanghai.aliyuncs.com/mdimg/c146938cec76c6f3e4d47a892d34fb02-41c3ff7.gif">
<meta property="og:image" content="https://ni9ne.oss-cn-shanghai.aliyuncs.com/mdimg/a5d0d2b84b53dc6b6ab6cb4fad2403ff-81a309d.png">
<meta property="og:image" content="https://ni9ne.oss-cn-shanghai.aliyuncs.com/mdimg/649abd10205ff31bc3be4bb6c4e2175b-73d922e.png">
<meta property="og:image" content="https://ni9ne.oss-cn-shanghai.aliyuncs.com/mdimg/65825a12764b966245c57528acd27dbe-2eaefc9.png">
<meta property="og:image" content="https://ni9ne.oss-cn-shanghai.aliyuncs.com/mdimg/ad91ac65b51c40c3e29b843f530ee250-d4db508.png">
<meta property="og:image" content="https://ni9ne.oss-cn-shanghai.aliyuncs.com/mdimg/b1f7a62d64998a685ab4025e720db318-38bce94.png">
<meta property="og:image" content="https://ni9ne.oss-cn-shanghai.aliyuncs.com/mdimg/4bec58fe8aa3945105fd103c148a510e-15389ea.png">
<meta property="og:image" content="https://ni9ne.oss-cn-shanghai.aliyuncs.com/mdimg/65f59d50376d351ecb8141d4fdeb2755-914caf5.png">
<meta property="og:image" content="https://ni9ne.oss-cn-shanghai.aliyuncs.com/mdimg/ac8294568531ac2d8e28bf47d4939464-00e144d.png">
<meta property="og:image" content="https://ni9ne.oss-cn-shanghai.aliyuncs.com/mdimg/5c079def535c550a9f57981483f4252f-bf99d8f.png">
<meta property="og:image" content="https://ni9ne.oss-cn-shanghai.aliyuncs.com/mdimg/cceff6a61c012e38294d678b3c331ca3-3086a5b.png">
<meta property="og:image" content="https://ni9ne.oss-cn-shanghai.aliyuncs.com/mdimg/712b6cbfe9c96f69c82db5fd24cab043-c51c92c.png">
<meta property="og:image" content="https://ni9ne.oss-cn-shanghai.aliyuncs.com/mdimg/46600170012e52066d83d982a07d946f-49e5bbc.png">
<meta property="og:image" content="https://ni9ne.oss-cn-shanghai.aliyuncs.com/mdimg/7d6d2153a1d9776379b8c1db245fdf1c-6721eff.png">
<meta property="og:image" content="https://ni9ne.oss-cn-shanghai.aliyuncs.com/mdimg/0d0f72f07780ecb47b052d72f5a69353-b1fea25.png">
<meta property="og:image" content="https://ni9ne.oss-cn-shanghai.aliyuncs.com/mdimg/ab0e67f006519d322587e0c6dd0b6fd9-c31e492.gif">
<meta property="og:image" content="https://ni9ne.oss-cn-shanghai.aliyuncs.com/mdimg/3f20355ccc9adb18249ad45aa9679911-89fec95.png">
<meta property="og:image" content="https://ni9ne.oss-cn-shanghai.aliyuncs.com/mdimg/a636c9f70d884c8888f893d261bc0a14-a9acef8.png">
<meta property="og:image" content="https://ni9ne.oss-cn-shanghai.aliyuncs.com/mdimg/4d9a51361d722d8920d8e6e40880b3e2-6609e5b.gif">
<meta property="og:image" content="https://ni9ne.oss-cn-shanghai.aliyuncs.com/mdimg/233fd3a83713fc6d2c9097c95bb39082-16e1354.png">
<meta property="og:image" content="https://ni9ne.oss-cn-shanghai.aliyuncs.com/mdimg/1aac4dfd1b8280c09d7b62b4df4b0fa4-0b5eab5.png">
<meta property="og:image" content="https://ni9ne.oss-cn-shanghai.aliyuncs.com/mdimg/23158e23e7db717eb48231268ce784f9-f813eb0.png">
<meta property="og:image" content="https://ni9ne.oss-cn-shanghai.aliyuncs.com/mdimg/6704416d0646e1cd9e768c5f4de15292-78bdf56.png">
<meta property="og:image" content="https://ni9ne.oss-cn-shanghai.aliyuncs.com/mdimg/def9441aaa256e2878f18c703ab55d4b-55d43fe.png">
<meta property="og:image" content="https://ni9ne.oss-cn-shanghai.aliyuncs.com/mdimg/cc9cea3a079f897d41d30ef134c74d72-21b10b5.png">
<meta property="og:image" content="https://ni9ne.oss-cn-shanghai.aliyuncs.com/mdimg/dd6caa8813cfb591002117390451d4ac-0b82264.png">
<meta property="og:image" content="https://ni9ne.oss-cn-shanghai.aliyuncs.com/mdimg/f166984c504ca0572d90443ee6a5c827-b460529.png">
<meta property="og:image" content="https://ni9ne.oss-cn-shanghai.aliyuncs.com/mdimg/f6a6f17690652f8db1e153dfdc1b1dfe-7773614.png">
<meta property="og:image" content="https://ni9ne.oss-cn-shanghai.aliyuncs.com/mdimg/6fefd0eacd8763bd8f4879e3d06eaf84-77d5a84.png">
<meta property="og:image" content="https://ni9ne.oss-cn-shanghai.aliyuncs.com/mdimg/406f421be12129c0c641452af565ff93-8ee99f5.png">
<meta property="og:image" content="https://ni9ne.oss-cn-shanghai.aliyuncs.com/mdimg/1abf7163730594c9ed1cbc279db9cd0a-c96cc7d.png">
<meta property="og:image" content="https://ni9ne.oss-cn-shanghai.aliyuncs.com/mdimg/624f3c606f0b85f72b702f4f1ce229cb-4a4dd96.png">
<meta property="og:image" content="https://ni9ne.oss-cn-shanghai.aliyuncs.com/mdimg/98af221b859a20a3d4d9b5f32367f03a-c9e7fa3.png">
<meta property="og:image" content="https://ni9ne.oss-cn-shanghai.aliyuncs.com/mdimg/f58bce0e122463aa227d2b62230e27c5-490fb09.png">
<meta property="og:image" content="https://ni9ne.oss-cn-shanghai.aliyuncs.com/mdimg/11e43364a194fe41a5ef628d05ac861a-cf060ae.png">
<meta property="og:image" content="https://ni9ne.oss-cn-shanghai.aliyuncs.com/mdimg/3ed8f7407adec7fce41f6bf24aad69b0-3b8ea91.png">
<meta property="og:image" content="https://ni9ne.oss-cn-shanghai.aliyuncs.com/mdimg/78786408b62d1b7cbccfb70feeda506b-8b1d24a.png">
<meta property="og:image" content="https://ni9ne.oss-cn-shanghai.aliyuncs.com/mdimg/7ebc5a108459037109c7e1c66c4bc517-e433dae.png">
<meta property="og:image" content="https://ni9ne.oss-cn-shanghai.aliyuncs.com/mdimg/661f27ee502a096a363a9e920a95eb85-33207de.png">
<meta property="og:image" content="https://ni9ne.oss-cn-shanghai.aliyuncs.com/mdimg/3a1a4d839f15b91febf4062aed8d9569-bd0f0f8.png">
<meta property="og:image" content="https://ni9ne.oss-cn-shanghai.aliyuncs.com/mdimg/460a024a7fa900faaf2ba2929ee4c2fc-6e1fa9f.png">
<meta property="article:published_time" content="2022-05-22T12:37:22.000Z">
<meta property="article:modified_time" content="2022-07-12T11:36:44.574Z">
<meta property="article:author" content="NI9NE">
<meta property="article:tag" content="Redis">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://ni9ne.oss-cn-shanghai.aliyuncs.com/mdimg/69f6edd95cacd1c4a0ca4815a321dbac-aaf255e.png">


<link rel="canonical" href="https://ni9ne.github.io/2022/05/22/Redis/Redis%E5%8E%9F%E7%90%86%E8%A7%A3%E6%9E%90/">



<script class="next-config" data-name="page" type="application/json">{"sidebar":"","isHome":false,"isPost":true,"lang":"zh-CN","comments":true,"permalink":"https://ni9ne.github.io/2022/05/22/Redis/Redis%E5%8E%9F%E7%90%86%E8%A7%A3%E6%9E%90/","path":"2022/05/22/Redis/Redis原理解析/","title":"Redis原理解析"}</script>

<script class="next-config" data-name="calendar" type="application/json">""</script>
<title>Redis原理解析 | NI9NE's Zone</title>
  




  <noscript>
    <link rel="stylesheet" href="/css/noscript.css">
  </noscript>
</head>

<body itemscope itemtype="http://schema.org/WebPage" class="use-motion">
  <div class="headband"></div>

  <main class="main">
    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏" role="button">
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <i class="logo-line"></i>
      <h1 class="site-title">NI9NE's Zone</h1>
      <i class="logo-line"></i>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
        <i class="fa fa-search fa-fw fa-lg"></i>
    </div>
  </div>
</div>



<nav class="site-nav">
  <ul class="main-menu menu">
        <li class="menu-item menu-item-home"><a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a></li>
        <li class="menu-item menu-item-tags"><a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>标签<span class="badge">53</span></a></li>
        <li class="menu-item menu-item-categories"><a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>分类<span class="badge">6</span></a></li>
        <li class="menu-item menu-item-archives"><a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档<span class="badge">99</span></a></li>
      <li class="menu-item menu-item-search">
        <a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>搜索
        </a>
      </li>
  </ul>
</nav>



  <div class="search-pop-overlay">
    <div class="popup search-popup"><div class="search-header">
  <span class="search-icon">
    <i class="fa fa-search"></i>
  </span>
  <div class="search-input-container">
    <input autocomplete="off" autocapitalize="off" maxlength="80"
           placeholder="搜索..." spellcheck="false"
           type="search" class="search-input">
  </div>
  <span class="popup-btn-close" role="button">
    <i class="fa fa-times-circle"></i>
  </span>
</div>
<div class="search-result-container no-result">
  <div class="search-result-icon">
    <i class="fa fa-spinner fa-pulse fa-5x"></i>
  </div>
</div>

    </div>
  </div>

</div>
        
  
  <div class="toggle sidebar-toggle" role="button">
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
  </div>

  <aside class="sidebar">

    <div class="sidebar-inner sidebar-nav-active sidebar-toc-active">
      <ul class="sidebar-nav">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <div class="sidebar-panel-container">
        <!--noindex-->
        <div class="post-toc-wrap sidebar-panel">
            <div class="post-toc animated"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#Redis%E5%8E%9F%E7%90%86%E8%A7%A3%E6%9E%90"><span class="nav-number">1.</span> <span class="nav-text">Redis原理解析</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84"><span class="nav-number">1.1.</span> <span class="nav-text">数据结构</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%8A%A8%E6%80%81%E5%AD%97%E7%AC%A6%E4%B8%B2SDS"><span class="nav-number">1.1.1.</span> <span class="nav-text">动态字符串SDS</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#SDS%E7%AE%80%E4%BB%8B"><span class="nav-number">1.1.1.1.</span> <span class="nav-text">SDS简介</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%BA%95%E5%B1%82%E5%AE%9E%E7%8E%B0"><span class="nav-number">1.1.1.2.</span> <span class="nav-text">底层实现</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#SDS%E6%89%A9%E5%AE%B9"><span class="nav-number">1.1.1.3.</span> <span class="nav-text">SDS扩容</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#IntSet"><span class="nav-number">1.1.2.</span> <span class="nav-text">IntSet</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#IntSet%E7%AE%80%E4%BB%8B"><span class="nav-number">1.1.2.1.</span> <span class="nav-text">IntSet简介</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#IntSet%E5%8D%87%E7%BA%A7"><span class="nav-number">1.1.2.2.</span> <span class="nav-text">IntSet升级</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#IntSet%E6%96%B0%E5%A2%9E%E6%B5%81%E7%A8%8B"><span class="nav-number">1.1.2.3.</span> <span class="nav-text">IntSet新增流程</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#%E6%96%B0%E5%A2%9E%E5%8A%A8%E4%BD%9C"><span class="nav-number">1.1.2.3.1.</span> <span class="nav-text">新增动作:</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E5%8D%87%E7%BA%A7%E5%8A%A8%E4%BD%9C"><span class="nav-number">1.1.2.3.2.</span> <span class="nav-text">升级动作:</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E6%9F%A5%E6%89%BE%E5%BD%93%E5%89%8D%E5%80%BC%E8%A7%92%E6%A0%87"><span class="nav-number">1.1.2.3.3.</span> <span class="nav-text">查找当前值角标:</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#IntSet%E7%89%B9%E7%82%B9"><span class="nav-number">1.1.2.4.</span> <span class="nav-text">IntSet特点</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Dict"><span class="nav-number">1.1.3.</span> <span class="nav-text">Dict</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#Dict%E7%AE%80%E4%BB%8B"><span class="nav-number">1.1.3.1.</span> <span class="nav-text">Dict简介</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Dict%E6%B7%BB%E5%8A%A0%E9%94%AE%E5%80%BC%E5%AF%B9"><span class="nav-number">1.1.3.2.</span> <span class="nav-text">Dict添加键值对</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Dict%E5%AE%8C%E6%95%B4%E7%BB%93%E6%9E%84"><span class="nav-number">1.1.3.3.</span> <span class="nav-text">Dict完整结构</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Dict%E7%9A%84%E6%89%A9%E5%AE%B9"><span class="nav-number">1.1.3.4.</span> <span class="nav-text">Dict的扩容</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Dict%E7%9A%84%E6%94%B6%E7%BC%A9"><span class="nav-number">1.1.3.5.</span> <span class="nav-text">Dict的收缩</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Dict%E7%9A%84rehash"><span class="nav-number">1.1.3.6.</span> <span class="nav-text">Dict的rehash</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%80%BB%E7%BB%93"><span class="nav-number">1.1.3.7.</span> <span class="nav-text">总结</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#ZipList"><span class="nav-number">1.1.4.</span> <span class="nav-text">ZipList</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#ZipList%E7%AE%80%E4%BB%8B"><span class="nav-number">1.1.4.1.</span> <span class="nav-text">ZipList简介</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#ZipListEntry"><span class="nav-number">1.1.4.2.</span> <span class="nav-text">ZipListEntry</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#Encoding%E7%BC%96%E7%A0%81"><span class="nav-number">1.1.4.2.1.</span> <span class="nav-text">Encoding编码</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#ZipList%E7%9A%84%E8%BF%9E%E9%94%81%E6%9B%B4%E6%96%B0%E9%97%AE%E9%A2%98"><span class="nav-number">1.1.4.3.</span> <span class="nav-text">ZipList的连锁更新问题</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%80%BB%E7%BB%93-1"><span class="nav-number">1.1.4.4.</span> <span class="nav-text">总结</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#QuickList"><span class="nav-number">1.1.5.</span> <span class="nav-text">QuickList</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#QuickList%E5%BC%95%E5%85%A5"><span class="nav-number">1.1.5.1.</span> <span class="nav-text">QuickList引入</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#ZipList%E8%8A%82%E7%82%B9%E6%8E%A7%E5%88%B6"><span class="nav-number">1.1.5.2.</span> <span class="nav-text">ZipList节点控制</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%BA%95%E5%B1%82%E5%AE%9E%E7%8E%B0-1"><span class="nav-number">1.1.5.3.</span> <span class="nav-text">底层实现</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#QuickList%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84"><span class="nav-number">1.1.5.4.</span> <span class="nav-text">QuickList数据结构</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#SkipList"><span class="nav-number">1.1.6.</span> <span class="nav-text">SkipList</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#SkipList%E7%AE%80%E4%BB%8B"><span class="nav-number">1.1.6.1.</span> <span class="nav-text">SkipList简介</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-1"><span class="nav-number">1.1.6.2.</span> <span class="nav-text">数据结构</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%80%BB%E7%BB%93-2"><span class="nav-number">1.1.6.3.</span> <span class="nav-text">总结</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#RedisObject"><span class="nav-number">1.1.7.</span> <span class="nav-text">RedisObject</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BA%94%E7%A7%8D%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84"><span class="nav-number">1.1.8.</span> <span class="nav-text">五种数据结构</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#String"><span class="nav-number">1.1.8.1.</span> <span class="nav-text">String</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#List"><span class="nav-number">1.1.8.2.</span> <span class="nav-text">List</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Set"><span class="nav-number">1.1.8.3.</span> <span class="nav-text">Set</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Zset"><span class="nav-number">1.1.8.4.</span> <span class="nav-text">Zset</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Hash"><span class="nav-number">1.1.8.5.</span> <span class="nav-text">Hash</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%BD%91%E7%BB%9C%E6%A8%A1%E5%9E%8B"><span class="nav-number">1.2.</span> <span class="nav-text">网络模型</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%94%A8%E6%88%B7%E7%A9%BA%E9%97%B4%E5%92%8C%E5%86%85%E6%A0%B8%E7%A9%BA%E9%97%B4"><span class="nav-number">1.2.1.</span> <span class="nav-text">用户空间和内核空间</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BA%94%E7%A7%8DIO%E6%A8%A1%E5%9E%8B"><span class="nav-number">1.2.2.</span> <span class="nav-text">五种IO模型</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E9%98%BB%E5%A1%9EIO"><span class="nav-number">1.2.2.1.</span> <span class="nav-text">阻塞IO</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E9%9D%9E%E9%98%BB%E5%A1%9EIO"><span class="nav-number">1.2.2.2.</span> <span class="nav-text">非阻塞IO</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#IO%E5%A4%9A%E8%B7%AF%E5%A4%8D%E7%94%A8"><span class="nav-number">1.2.2.3.</span> <span class="nav-text">IO多路复用</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#IO%E5%A4%9A%E8%B7%AF%E5%A4%8D%E7%94%A8-select"><span class="nav-number">1.2.2.3.1.</span> <span class="nav-text">IO多路复用-select</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#IO%E5%A4%9A%E8%B7%AF%E5%A4%8D%E7%94%A8-poll"><span class="nav-number">1.2.2.3.2.</span> <span class="nav-text">IO多路复用-poll</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#IO%E5%A4%9A%E8%B7%AF%E5%A4%8D%E7%94%A8-epoll"><span class="nav-number">1.2.2.3.3.</span> <span class="nav-text">IO多路复用-epoll</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#IO%E5%A4%9A%E8%B7%AF%E5%A4%8D%E7%94%A8-%E4%BA%8B%E4%BB%B6%E9%80%9A%E7%9F%A5%E6%9C%BA%E5%88%B6"><span class="nav-number">1.2.2.3.4.</span> <span class="nav-text">IO多路复用-事件通知机制</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#IO%E5%A4%9A%E8%B7%AF%E5%A4%8D%E7%94%A8-web%E6%9C%8D%E5%8A%A1%E6%B5%81%E7%A8%8B"><span class="nav-number">1.2.2.3.5.</span> <span class="nav-text">IO多路复用-web服务流程</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%BF%A1%E5%8F%B7%E9%A9%B1%E5%8A%A8IO"><span class="nav-number">1.2.2.4.</span> <span class="nav-text">信号驱动IO</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%BC%82%E6%AD%A5IO"><span class="nav-number">1.2.2.5.</span> <span class="nav-text">异步IO</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%90%8C%E6%AD%A5%E5%92%8C%E5%BC%82%E6%AD%A5%E5%88%A4%E6%96%AD"><span class="nav-number">1.2.2.6.</span> <span class="nav-text">同步和异步判断</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Redis%E7%BD%91%E7%BB%9C%E6%A8%A1%E5%9E%8B"><span class="nav-number">1.2.3.</span> <span class="nav-text">Redis网络模型</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#Redis%E5%88%B0%E5%BA%95%E6%98%AF%E5%8D%95%E7%BA%BF%E7%A8%8B%E8%BF%98%E6%98%AF%E5%A4%9A%E7%BA%BF%E7%A8%8B"><span class="nav-number">1.2.3.1.</span> <span class="nav-text">Redis到底是单线程还是多线程</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%B8%BA%E4%BB%80%E4%B9%88Redis%E8%A6%81%E9%80%89%E6%8B%A9%E5%8D%95%E7%BA%BF%E7%A8%8B"><span class="nav-number">1.2.3.2.</span> <span class="nav-text">为什么Redis要选择单线程</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%BA%8B%E4%BB%B6API%E5%BA%93-AE"><span class="nav-number">1.2.3.3.</span> <span class="nav-text">事件API库 AE</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Redis%E5%8D%95%E7%BA%BF%E7%A8%8B%E7%BD%91%E7%BB%9C%E6%A8%A1%E5%9E%8B%E7%9A%84%E6%B5%81%E7%A8%8B"><span class="nav-number">1.2.3.4.</span> <span class="nav-text">Redis单线程网络模型的流程</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Redis%E5%A4%9A%E7%BA%BF%E7%A8%8B%E5%BA%94%E7%94%A8"><span class="nav-number">1.2.3.5.</span> <span class="nav-text">Redis多线程应用</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E9%80%9A%E4%BF%A1%E5%8D%8F%E8%AE%AE"><span class="nav-number">1.3.</span> <span class="nav-text">通信协议</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#RESP%E5%8D%8F%E8%AE%AE"><span class="nav-number">1.3.1.</span> <span class="nav-text">RESP协议</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#RESP%E5%8D%8F%E8%AE%AE-%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B"><span class="nav-number">1.3.1.1.</span> <span class="nav-text">RESP协议-数据类型</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%BD%BF%E7%94%A8socket%E6%A8%A1%E6%8B%9FRedis-cli"><span class="nav-number">1.3.1.2.</span> <span class="nav-text">使用socket模拟Redis-cli</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%86%85%E5%AD%98%E7%AD%96%E7%95%A5"><span class="nav-number">1.4.</span> <span class="nav-text">内存策略</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%BF%87%E6%9C%9F%E7%AD%96%E7%95%A5"><span class="nav-number">1.4.1.</span> <span class="nav-text">过期策略</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E8%BF%87%E6%9C%9F%E7%AD%96%E7%95%A5-DB%E7%BB%93%E6%9E%84"><span class="nav-number">1.4.1.1.</span> <span class="nav-text">过期策略-DB结构</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E8%BF%87%E6%9C%9F%E7%AD%96%E7%95%A5-%E8%BF%87%E6%9C%9F%E5%88%A0%E9%99%A4"><span class="nav-number">1.4.1.2.</span> <span class="nav-text">过期策略-过期删除</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%B7%98%E6%B1%B0%E7%AD%96%E7%95%A5"><span class="nav-number">1.4.2.</span> <span class="nav-text">淘汰策略</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%86%85%E5%AD%98%E6%B7%98%E6%B1%B0"><span class="nav-number">1.4.2.1.</span> <span class="nav-text">内存淘汰</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%85%AB%E7%A7%8D%E6%B7%98%E6%B1%B0%E7%AD%96%E7%95%A5"><span class="nav-number">1.4.2.2.</span> <span class="nav-text">八种淘汰策略</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#LRU-LFU%E6%B7%98%E6%B1%B0%E5%8E%9F%E7%90%86"><span class="nav-number">1.4.2.3.</span> <span class="nav-text">LRU&#x2F;LFU淘汰原理</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%B7%98%E6%B1%B0%E7%AD%96%E7%95%A5%E6%B5%81%E7%A8%8B"><span class="nav-number">1.4.2.4.</span> <span class="nav-text">淘汰策略流程</span></a></li></ol></li></ol></li></ol></li></ol></div>
        </div>
        <!--/noindex-->

        <div class="site-overview-wrap sidebar-panel">
          <div class="site-author site-overview-item animated" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="NI9NE"
      src="/images/favicon/mstile-150x150.png">
  <p class="site-author-name" itemprop="name">NI9NE</p>
  <div class="site-description" itemprop="description">TECH OTAKU SAVE THE WORLD</div>
</div>
<div class="site-state-wrap site-overview-item animated">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
        <a href="/archives/">
          <span class="site-state-item-count">99</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
          <a href="/categories/">
        <span class="site-state-item-count">6</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
          <a href="/tags/">
        <span class="site-state-item-count">53</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>
  <div class="links-of-author site-overview-item animated">
      <span class="links-of-author-item">
        <a href="https://github.com/ni9ne" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;ni9ne" rel="noopener" target="_blank"><i class="fab fa-github fa-fw"></i>GitHub</a>
      </span>
      <span class="links-of-author-item">
        <a href="https://gitee.com/ni9ne" title="Gitee → https:&#x2F;&#x2F;gitee.com&#x2F;ni9ne" rel="noopener" target="_blank"><i class="fab fa-git fa-fw"></i>Gitee</a>
      </span>
  </div>
  <div class="cc-license site-overview-item animated" itemprop="license">
    <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" class="cc-opacity" rel="noopener" target="_blank"><img src="https://unpkg.com/@creativecommons/vocabulary@2020.11.3/assets/license_badges/small/by_nc_sa.svg" alt="Creative Commons"></a>
  </div>



        </div>
      </div>
    </div>
  </aside>
  <div class="sidebar-dimmer"></div>


    </header>

    
  <div class="back-to-top" role="button" aria-label="返回顶部">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>
  <div class="reading-progress-bar"></div>

  <a href="https://gitee.com/ni9ne" class="github-corner" title="Follow me on GitHub" aria-label="Follow me on GitHub" rel="noopener" target="_blank"><svg width="80" height="80" viewBox="0 0 250 250" aria-hidden="true"><path d="M0,0 L115,115 L130,115 L142,142 L250,250 L250,0 Z"></path><path d="M128.3,109.0 C113.8,99.7 119.0,89.6 119.0,89.6 C122.0,82.7 120.5,78.6 120.5,78.6 C119.2,72.0 123.4,76.3 123.4,76.3 C127.3,80.9 125.5,87.3 125.5,87.3 C122.9,97.6 130.6,101.9 134.4,103.2" fill="currentColor" style="transform-origin: 130px 106px;" class="octo-arm"></path><path d="M115.0,115.0 C114.9,115.1 118.7,116.5 119.8,115.4 L133.7,101.6 C136.9,99.2 139.9,98.4 142.2,98.6 C133.8,88.0 127.5,74.4 143.8,58.0 C148.5,53.4 154.0,51.2 159.7,51.0 C160.3,49.4 163.2,43.6 171.4,40.1 C171.4,40.1 176.1,42.5 178.8,56.2 C183.1,58.6 187.2,61.8 190.9,65.4 C194.5,69.0 197.7,73.2 200.1,77.6 C213.8,80.2 216.3,84.9 216.3,84.9 C212.7,93.1 206.9,96.0 205.4,96.6 C205.1,102.4 203.0,107.8 198.3,112.5 C181.9,128.9 168.3,122.5 157.7,114.1 C157.9,116.9 156.7,120.9 152.7,124.9 L141.0,136.5 C139.8,137.7 141.6,141.9 141.8,141.8 Z" fill="currentColor" class="octo-body"></path></svg></a>

<noscript>
  <div class="noscript-warning">Theme NexT works best with JavaScript enabled</div>
</noscript>


    <div class="main-inner post posts-expand">


  


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://ni9ne.github.io/2022/05/22/Redis/Redis%E5%8E%9F%E7%90%86%E8%A7%A3%E6%9E%90/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/favicon/mstile-150x150.png">
      <meta itemprop="name" content="NI9NE">
      <meta itemprop="description" content="TECH OTAKU SAVE THE WORLD">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="NI9NE's Zone">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          Redis原理解析
        </h1>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2022-05-22 20:37:22" itemprop="dateCreated datePublished" datetime="2022-05-22T20:37:22+08:00">2022-05-22</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E5%BC%80%E5%8F%91%E8%B5%84%E6%96%99/" itemprop="url" rel="index"><span itemprop="name">开发资料</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
        <h1 id="Redis原理解析"><a href="#Redis原理解析" class="headerlink" title="Redis原理解析"></a>Redis原理解析</h1><h2 id="数据结构"><a href="#数据结构" class="headerlink" title="数据结构"></a>数据结构</h2><h3 id="动态字符串SDS"><a href="#动态字符串SDS" class="headerlink" title="动态字符串SDS"></a>动态字符串SDS</h3><h4 id="SDS简介"><a href="#SDS简介" class="headerlink" title="SDS简介"></a>SDS简介</h4><p>Redis中保存的Key是字符串, value往往是字符串或者字符串的集合. 可见字符串是Redis中最常用的一种数据结构</p>
<p>不过Redis没有直接使用C语言中的字符串，因为C语言字符串存在很多问题：</p>
<ul>
<li><p>获取字符串长度的需要通过运算, 循环加计数器直到找到结尾标识符</p>
</li>
<li><p>非二进制安全, 不可以存在结尾特殊字符 <code>\0</code> </p>
</li>
<li><p>不可修改, 保存在常量中</p>
<p><img src="https://ni9ne.oss-cn-shanghai.aliyuncs.com/mdimg/69f6edd95cacd1c4a0ca4815a321dbac-aaf255e.png" alt="image-20220702023422666"></p>
</li>
</ul>
<p>Redis构建了一种新的字符串结构，称为<strong>简单动态字符串</strong>（<strong>S</strong>imple <strong>D</strong>ynamic <strong>S</strong>tring），简称<strong>SDS</strong>。</p>
<p>例如，我们执行命令：</p>
<figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">127.0.0.1</span>:<span class="string">6379&gt; set name ni9ne</span></span><br><span class="line"><span class="attr">OK</span></span><br></pre></td></tr></table></figure>

<p>那么Redis将在底层创建两个SDS，其中一个是包含<code>name</code>的SDS，另一个是包含<code>ni9ne</code>的SDS。</p>
<h4 id="底层实现"><a href="#底层实现" class="headerlink" title="底层实现"></a>底层实现</h4><p>Redis是C语言实现的，其中SDS是一个结构体，源码如下</p>
<p><img src="https://ni9ne.oss-cn-shanghai.aliyuncs.com/mdimg/fbd991e9cd61aaa86030ca473e35b4d0-348f2d4.png" alt="image-20220702024023424"></p>
<blockquote>
<p>Redis提供了不同位的数据结构实现, 可存储 2^5 / 2^8 / 2^16 / 2^32 / 2^64 大小的字符串</p>
</blockquote>
<p>例如，一个包含字符串<code>name</code>的sds结构如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"> ------------------------------------------------</span><br><span class="line">| len:4 | alloc:4 | flags:1 | n | a | m | e | \0 |</span><br><span class="line"> ------------------------------------------------</span><br><span class="line">\         header            /\      数据         /</span><br><span class="line"> - - - - - - - - - - - - - -  - - - - - - - - - </span><br></pre></td></tr></table></figure>

<h4 id="SDS扩容"><a href="#SDS扩容" class="headerlink" title="SDS扩容"></a>SDS扩容</h4><p>SDS之所以叫做<strong>动态字符串</strong>，是因为它具备<strong>动态扩容</strong>的能力，例如给上面的SDS数据添加字符串 : <code>ofyou</code> </p>
<p>首先会申请新内存空间：</p>
<ul>
<li><p>如果新字符串小于1M，则新空间为 <code>扩展后字符串长度的两倍+1</code>；</p>
</li>
<li><p>如果新字符串大于1M，则新空间为 <code>扩展后字符串长度+1M+1</code>。称为<strong>内存预分配</strong>。</p>
<blockquote>
<p>避免用户态与内核态频繁切换, 预先分配内存空间</p>
</blockquote>
</li>
</ul>
<p><strong>扩容后结构如下:</strong> </p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"> ------------------------------------------------------------------------------------</span><br><span class="line">| len:9 | alloc:18| flags:1 | n | a | m | e | o | f | y | o | u | \0 | | | | | | | | |</span><br><span class="line"> ------------------------------------------------------------------------------------</span><br><span class="line">\         header            /\                     数据                              /</span><br><span class="line"> - - - - - - - - - - - - - -  - - - - - - - - - - - - - - - - - - - - - - - - - - - </span><br></pre></td></tr></table></figure>

<p><strong>优点:</strong> </p>
<ul>
<li><p>获取字符串长度的时间复杂度为O(1)</p>
</li>
<li><p>支持动态扩容</p>
</li>
<li><p>减少内存分配次数</p>
</li>
<li><p>二进制安全</p>
</li>
</ul>
<h3 id="IntSet"><a href="#IntSet" class="headerlink" title="IntSet"></a>IntSet</h3><h4 id="IntSet简介"><a href="#IntSet简介" class="headerlink" title="IntSet简介"></a>IntSet简介</h4><p>IntSet是Redis中set集合的一种实现方式，基于整数数组来实现，并且具备长度可变、有序等特征。</p>
<p>结构如下：</p>
<p><img src="https://ni9ne.oss-cn-shanghai.aliyuncs.com/mdimg/3ddf52c51c24369f788f860030e7da81-305679b.png" alt="image-20220702033837718"></p>
<p>其中的encoding包含三种模式，表示存储的整数大小不同：</p>
<p><img src="https://ni9ne.oss-cn-shanghai.aliyuncs.com/mdimg/b212adf4e1c29d33a2fc6092e6fc54be-18118b8.png" alt="image-20220702033940663"></p>
<p>为了方便查找，Redis会将intset中所有的整数按照升序依次保存在contents数组中，结构如图：</p>
<p><img src="https://ni9ne.oss-cn-shanghai.aliyuncs.com/mdimg/37f675c0d3ffa076a5592443367f0450-eafde3f.png" alt="image-20220702034513176"></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">现在，数组中每个数字都在int16_t的范围内，因此采用的编码方式是INTSET_ENC_INT16，每部分占用的字节大小为:</span><br><span class="line">- encoding：4字节</span><br><span class="line">- length：4字节</span><br><span class="line">- contents：2字节 * 3  = 6字节</span><br></pre></td></tr></table></figure>

<h4 id="IntSet升级"><a href="#IntSet升级" class="headerlink" title="IntSet升级"></a>IntSet升级</h4><p>有一个<code>intset</code>，元素为<code>&#123;5,10，20&#125;</code>，采用的编码是<code>INTSET_ENC_INT16</code>，则每个整数占2字节. </p>
<p>向该其中添加一个数字：<code>50000</code>，这个数字超出了<code>int16_t</code>的范围，intset会自动<strong>升级</strong>编码方式到合适的大小。</p>
<p>流程如下：</p>
<p><img src="https://ni9ne.oss-cn-shanghai.aliyuncs.com/mdimg/de01adf9e0bef045278bf465d021d481-a974fc5.gif" alt="image-193507020329160000030"></p>
<p>①升级编码为<code>INTSET_ENC_INT32</code>, 每个整数占4字节，并按照新的编码方式及元素个数扩容数组</p>
<p>②<strong>倒序</strong>依次将数组中的元素拷贝到扩容后的正确位置 (避免顺序覆盖原有数据)</p>
<p>③将待添加的元素放入数组末尾</p>
<p>④最后，将<code>intset</code>的<code>encoding</code>属性改为<code>INTSET_ENC_INT32</code>，将<code>length</code>属性改为4</p>
<p><img src="https://ni9ne.oss-cn-shanghai.aliyuncs.com/mdimg/60b78fc4e014fb8d63d19f89e9f8a09e-cc93f1a.png" alt="image-20220702035044685"></p>
<h4 id="IntSet新增流程"><a href="#IntSet新增流程" class="headerlink" title="IntSet新增流程"></a>IntSet新增流程</h4><h5 id="新增动作"><a href="#新增动作" class="headerlink" title="新增动作:"></a>新增动作:</h5><p><img src="https://ni9ne.oss-cn-shanghai.aliyuncs.com/mdimg/bbf9d4f45a0226651e126b0d4cf83921-43caee5.png" alt="image-20220702142044022"></p>
<h5 id="升级动作"><a href="#升级动作" class="headerlink" title="升级动作:"></a>升级动作:</h5><p><img src="https://ni9ne.oss-cn-shanghai.aliyuncs.com/mdimg/5c2fff360bcd5a3cdaa52e7b51e17f04-ff9633d.png" alt="image-20220702142248229"></p>
<h5 id="查找当前值角标"><a href="#查找当前值角标" class="headerlink" title="查找当前值角标:"></a>查找当前值角标:</h5><p><img src="https://ni9ne.oss-cn-shanghai.aliyuncs.com/mdimg/8813407661098e92eac6fd735d18b102-93e5d0f.png" alt="image-20220702142513749"></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* Search for the position of &quot;value&quot;. Return 1 when the value was found and</span></span><br><span class="line"><span class="comment"> * sets &quot;pos&quot; to the position of the value within the intset. Return 0 when</span></span><br><span class="line"><span class="comment"> * the value is not present in the intset and sets &quot;pos&quot; to the position</span></span><br><span class="line"><span class="comment"> * where &quot;value&quot; can be inserted. */</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">uint8_t</span> <span class="title">intsetSearch</span><span class="params">(intset *is, <span class="keyword">int64_t</span> value, <span class="keyword">uint32_t</span> *pos)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 初始化二分查找的 min , max , mid</span></span><br><span class="line">    <span class="keyword">int</span> min = <span class="number">0</span>, max = intrev32ifbe(is-&gt;length)<span class="number">-1</span>, mid = <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">int64_t</span> cur = <span class="number">-1</span>;	<span class="comment">// mid对应的值</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 若数组为空则不需要找了, 返回0 */</span></span><br><span class="line">    <span class="keyword">if</span> (intrev32ifbe(is-&gt;length) == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (pos) *pos = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">/* 数组不为空, 判断value是否大于最大值, 小于最小值 */</span></span><br><span class="line">        <span class="keyword">if</span> (value &gt; _intsetGet(is,max)) &#123;	<span class="comment">// 大于最大值, 插入队尾</span></span><br><span class="line">            <span class="keyword">if</span> (pos) *pos = intrev32ifbe(is-&gt;length);</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (value &lt; _intsetGet(is,<span class="number">0</span>)) &#123;	<span class="comment">// 小于最小值, 插入队首</span></span><br><span class="line">            <span class="keyword">if</span> (pos) *pos = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">	<span class="comment">// 二分查找</span></span><br><span class="line">    <span class="keyword">while</span>(max &gt;= min) &#123;</span><br><span class="line">        mid = ((<span class="keyword">unsigned</span> <span class="keyword">int</span>)min + (<span class="keyword">unsigned</span> <span class="keyword">int</span>)max) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">        cur = _intsetGet(is,mid);</span><br><span class="line">        <span class="keyword">if</span> (value &gt; cur) &#123;</span><br><span class="line">            min = mid+<span class="number">1</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (value &lt; cur) &#123;</span><br><span class="line">            max = mid<span class="number">-1</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (value == cur) &#123;</span><br><span class="line">        <span class="keyword">if</span> (pos) *pos = mid;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (pos) *pos = min;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="IntSet特点"><a href="#IntSet特点" class="headerlink" title="IntSet特点"></a>IntSet特点</h4><p>Intset可以看做是特殊的整数数组，具备以下特点：</p>
<ul>
<li><p>Redis会确保Intset中的元素唯一、有序</p>
</li>
<li><p>具备类型升级机制，可以节省内存空间</p>
</li>
<li><p>底层采用二分查找方式来查询</p>
</li>
</ul>
<blockquote>
<p>存储少量数据, 在数据量不多的情况下使用</p>
</blockquote>
<h3 id="Dict"><a href="#Dict" class="headerlink" title="Dict"></a>Dict</h3><h4 id="Dict简介"><a href="#Dict简介" class="headerlink" title="Dict简介"></a>Dict简介</h4><p>Redis是一个键值型（Key-Value Pair）的数据库，我们可以根据键实现快速的增删改查。而<strong>键与值的映射关系</strong>正是通过Dict来实现的。</p>
<p>Dict由三部分组成，分别是：哈希表（DictHashTable）、哈希节点（DictEntry）、字典（Dict）</p>
<ul>
<li><p>哈希表（DictHashTable）</p>
<p><img src="https://ni9ne.oss-cn-shanghai.aliyuncs.com/mdimg/57b99fe9ac796be76edc9a91eafd9675-217bb7d.png" alt="image-20220702104442031"></p>
</li>
<li><p>哈希节点（DictEntry）</p>
<p><img src="https://ni9ne.oss-cn-shanghai.aliyuncs.com/mdimg/82e31ed742e0d119352b7b1eb4351d48-e7c70a8.png" alt="image-20220702104607302"></p>
</li>
<li><p>字典（Dict）</p>
<p><img src="https://ni9ne.oss-cn-shanghai.aliyuncs.com/mdimg/ff206082930d2da5d1c75169c03f20f3-c00248c.png" alt="image-20220702104743512"></p>
</li>
</ul>
<h4 id="Dict添加键值对"><a href="#Dict添加键值对" class="headerlink" title="Dict添加键值对"></a>Dict添加键值对</h4><p>当我们向Dict添加键值对时, Redis首先根据key计算出hash值(h), 然后利用 <code>h &amp; sizemask</code>(相当于<code>h mod size</code>)来计算元素应该存储到数组中的哪个索引位置。</p>
<p>存储<code>k1=v1</code>，假设k1的哈希值h =1，则<code>1&amp;3 =1</code>，因此<code>k1=v1</code>要存储到数组角标<code>1</code>位置。</p>
<p><img src="https://ni9ne.oss-cn-shanghai.aliyuncs.com/mdimg/55d2163867f7886cdbfa6f63fc661b3f-f41062d.png" alt="image-20220702104943218"></p>
<p>再次添加<code>k2=v2</code> , 使用头插法插入数据</p>
<p><img src="https://ni9ne.oss-cn-shanghai.aliyuncs.com/mdimg/681ff7fae8ff96472ffaee38e07fd651-89db125.png" alt="image-20220702105133894"></p>
<h4 id="Dict完整结构"><a href="#Dict完整结构" class="headerlink" title="Dict完整结构"></a>Dict完整结构</h4><p><img src="https://ni9ne.oss-cn-shanghai.aliyuncs.com/mdimg/ccbb30addfb6030347b1d512be252560-08e1949.png" alt="image-20220702105304986"></p>
<p><code>type</code> 和 <code>privdata</code>为私有数据, <code>rehashidx</code> 和 <code>pauserehash</code> 供Rehash使用, 实际数据存储于<code>ht[2]</code></p>
<p><code>ht[1]</code> 用于存储数据, <code>ht[2]</code> 用于<code>rehash</code> </p>
<h4 id="Dict的扩容"><a href="#Dict的扩容" class="headerlink" title="Dict的扩容"></a>Dict的扩容</h4><p>Dict中的HashTable就是数组结合单向链表的实现，当集合中元素较多时，必然导致哈希冲突增多，链表过长，则查询效率会大大降低。</p>
<p>Dict在每次新增键值对时都会检查<strong>负载因子</strong>(<code>LoadFactor = used/size</code>), 满足以下两种情况时会触发<strong>哈希表扩容</strong>：</p>
<ul>
<li><p>哈希表的 LoadFactor &gt;= 1，并且服务器没有执行 <code>BGSAVE</code> 或者 <code>BGREWRITEAOF </code>等后台进程；</p>
</li>
<li><p>哈希表的 LoadFactor &gt; 5 ；</p>
</li>
</ul>
<p><img src="https://ni9ne.oss-cn-shanghai.aliyuncs.com/mdimg/dae1baaa7e854df6a9369f6c9b091ceb-4864207.png" alt="image-20220702142914108"></p>
<h4 id="Dict的收缩"><a href="#Dict的收缩" class="headerlink" title="Dict的收缩"></a>Dict的收缩</h4><p>Dict除了扩容以外，每次删除元素时，也会对负载因子做检查，当LoadFactor &lt; 0.1 时，会做哈希表收缩：</p>
<p><img src="https://ni9ne.oss-cn-shanghai.aliyuncs.com/mdimg/22c0604f905c9a9320ed22fe6ca20ad4-7e2fbee.png" alt="image-20220702143228068"></p>
<p><img src="https://ni9ne.oss-cn-shanghai.aliyuncs.com/mdimg/b5676912c64e4eddaed222a5d97d79ba-4cec64e.png" alt="image-20220702143331778"></p>
<p><img src="https://ni9ne.oss-cn-shanghai.aliyuncs.com/mdimg/a012be5aa820a61ebafb64e05846231c-a7e09fe.png" alt="image-20220702143501558"></p>
<h4 id="Dict的rehash"><a href="#Dict的rehash" class="headerlink" title="Dict的rehash"></a>Dict的rehash</h4><p>不管是扩容还是收缩，必定会创建新的哈希表，导致哈希表的size和sizemask变化，而key的查询与sizemask有关。因此必须对哈希表中的每一个key重新计算索引，插入新的哈希表，这个过程称为<strong>rehash</strong>。</p>
<p><img src="https://ni9ne.oss-cn-shanghai.aliyuncs.com/mdimg/a6443c22addef2e2cd0a6001a877bc94-9a3e055.gif" alt="158955482123522445622131"></p>
<p>①计算新hash表的size，值取决于当前要做的是扩容还是收缩：</p>
<ul>
<li><p>如果是扩容，则新size为第一个大于等于<code>dict.ht[0].used + 1</code>的2^n</p>
</li>
<li><p>如果是收缩，则新size为第一个大于等于<code>dict.ht[0].used</code>的2^n （不得小于4）</p>
</li>
</ul>
<p>②按照新的size申请内存空间，创建<code>dictht</code>，并赋值给<code>dict.ht[1]</code> </p>
<p>③设置<code>dict.rehashidx = 0</code>，标示开始rehash</p>
<p><del>④将<code>dict.ht[0]</code>中的每一个dictEntry都rehash到<code>dict.ht[1]</code></del> </p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Dict的rehash并不是一次性完成的。</span><br><span class="line">如果Dict中包含数百万的entry，要在一次rehash完成，极有可能导致主线程阻塞。</span><br><span class="line">因此Dict的rehash是分多次、渐进式的完成，因此称为渐进式rehash。</span><br></pre></td></tr></table></figure>

<p>④每次执行新增、查询、修改、删除操作时，都检查一下<code>dict.rehashidx</code>是否大于-1，如果是则将<code>dict.ht[0].table[rehashidx]</code>的entry链表rehash到<code>dict.ht[1]</code>，并且将<code>rehashidx++</code>。直至<code>dict.ht[0]</code>的所有数据都rehash到<code>dict.ht[1]</code></p>
<p>⑤将<code>dict.ht[1]</code>赋值给<code>dict.ht[0]</code>，给<code>dict.ht[1]</code>初始化为空哈希表，释放原来的<code>dict.ht[0]</code>的内存</p>
<p>⑥将<code>rehashidx</code>赋值为<code>-1</code>，代表rehash结束</p>
<p>⑦在rehash过程中，新增操作，则直接写入<code>ht[1]</code>，查询、修改和删除则会在<code>dict.ht[0]</code>和<code>dict.ht[1]</code>依次查找并执行。这样可以确保<code>ht[0]</code>的数据只减不增，随着rehash最终为空</p>
<h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><p>Dict的结构：</p>
<ul>
<li><p>类似HashTable，底层是数组加链表来解决哈希冲突</p>
</li>
<li><p>Dict包含两个哈希表，<code>ht[0]</code>平常用，<code>ht[1]</code>用来rehash</p>
</li>
</ul>
<p>Dict的伸缩：</p>
<ul>
<li><p>当LoadFactor大于5或者LoadFactor大于1并且没有子进程任务时，Dict扩容</p>
</li>
<li><p>当LoadFactor小于0.1时，Dict收缩</p>
</li>
<li><p>扩容大小为第一个大于等于used + 1的2^n</p>
</li>
<li><p>收缩大小为第一个大于等于used 的2^n</p>
</li>
<li><p>Dict采用渐进式rehash，每次访问Dict时执行一次rehash</p>
</li>
<li><p>rehash时ht[0]只减不增，新增操作只在ht[1]执行，其它操作在两个哈希表</p>
</li>
</ul>
<blockquote>
<p>内存不连续, 内存浪费</p>
</blockquote>
<h3 id="ZipList"><a href="#ZipList" class="headerlink" title="ZipList"></a>ZipList</h3><h4 id="ZipList简介"><a href="#ZipList简介" class="headerlink" title="ZipList简介"></a>ZipList简介</h4><p><strong>ZipList</strong> 是一种特殊的“双端链表” ，由一系列特殊编码的连续内存块组成。可以在任意一端进行压入/弹出操作, 并且该操作的时间复杂度为 O(1)。具体的数据结构如下所示:</p>
<p><img src="https://ni9ne.oss-cn-shanghai.aliyuncs.com/mdimg/5ee52eb9d9b91437973c0a5588d0e991-9a2f4a5.png" alt="image-20220703085252637"></p>
<table>
<thead>
<tr>
<th>属性</th>
<th>类型</th>
<th>长度</th>
<th>用途</th>
</tr>
</thead>
<tbody><tr>
<td>zlbytes</td>
<td>uint32_t</td>
<td>4 字节</td>
<td>记录整个压缩列表占用的内存字节数</td>
</tr>
<tr>
<td>zltail</td>
<td>uint32_t</td>
<td>4 字节</td>
<td>记录压缩列表表尾节点距离压缩列表的起始地址有多少字节，<br />通过这个偏移量，可以确定表尾节点的地址。</td>
</tr>
<tr>
<td>zllen</td>
<td>uint16_t</td>
<td>2 字节</td>
<td>记录了压缩列表包含的节点数量。 最大值为UINT16_MAX （65534），<br />如果超过这个值，此处会记录为65535，<br />但节点的真实数量需要遍历整个压缩列表才能计算得出。</td>
</tr>
<tr>
<td>entry</td>
<td>列表节点</td>
<td>不定</td>
<td>压缩列表包含的各个节点，节点的长度由节点保存的内容决定。</td>
</tr>
<tr>
<td>zlend</td>
<td>uint8_t</td>
<td>1 字节</td>
<td>特殊值 <code>0xFF </code>（十进制 255 ），用于标记压缩列表的末端。</td>
</tr>
</tbody></table>
<h4 id="ZipListEntry"><a href="#ZipListEntry" class="headerlink" title="ZipListEntry"></a>ZipListEntry</h4><p><strong>ZipList</strong> 中的Entry并不像普通链表那样记录前后节点的指针，因为记录两个指针要占用16个字节，浪费内存。而是采用了下面的结构：</p>
<p><img src="https://ni9ne.oss-cn-shanghai.aliyuncs.com/mdimg/02301de3782a5593f91715f65e798123-e33658f.png" alt="image-20220703085748538"></p>
<ul>
<li><p>previous_entry_length：前一节点的长度，占1个或5个字节。</p>
<ul>
<li>如果前一节点的长度小于254字节，则采用1个字节来保存这个长度值</li>
<li>如果前一节点的长度大于254字节，则采用5个字节来保存这个长度值，第一个字节为<code>0xfe</code>，后四个字节才是真实长度数据</li>
</ul>
</li>
<li><p>encoding：编码属性，记录content的数据类型（字符串还是整数）以及长度，占用1个、2个或5个字节</p>
</li>
<li><p>contents：负责保存节点的数据，可以是字符串或整数</p>
</li>
</ul>
<blockquote>
<p>ZipList中所有存储长度的数值均采用小端字节序，即低位字节在前，高位字节在后。例如：数值<code>0x1234</code>，采用小端字节序后实际存储值为：<code>0x3412</code></p>
<p>[<a target="_blank" rel="noopener" href="https://www.cnblogs.com/gremount/p/8830707.html">理解字节序 大端字节序和小端字节序</a>]</p>
</blockquote>
<h5 id="Encoding编码"><a href="#Encoding编码" class="headerlink" title="Encoding编码"></a>Encoding编码</h5><p>ZipListEntry中的encoding编码分为字符串和整数两种：</p>
<ul>
<li><p>字符串：如果encoding是以“00”、“01”或者“10”开头，则证明content是字符串</p>
<table>
<thead>
<tr>
<th align="center">编码</th>
<th align="center">编码长度</th>
<th>字符串大小</th>
</tr>
</thead>
<tbody><tr>
<td align="center">|00pppppp|</td>
<td align="center">1  bytes</td>
<td>&lt;=  63 bytes</td>
</tr>
<tr>
<td align="center">|01pppppp|qqqqqqqq|</td>
<td align="center">2  bytes</td>
<td>&lt;=  16383 bytes</td>
</tr>
<tr>
<td align="center">|10000000|qqqqqqqq|rrrrrrrr|ssssssss|tttttttt|</td>
<td align="center">5  bytes</td>
<td>&lt;=  4294967295 bytes</td>
</tr>
</tbody></table>
<p>例如，我们要保存字符串：“ab”和 “bc”, 储存结构为: </p>
<p><img src="https://ni9ne.oss-cn-shanghai.aliyuncs.com/mdimg/de01b2eced959d2faf0e56b0e7b7e3db-857cbe0.png" alt="image-20220703090501059"></p>
</li>
<li><p>整数：如果encoding是以“11”开始，则证明content是整数，且encoding固定只占用1个字节</p>
<table>
<thead>
<tr>
<th align="center">编码</th>
<th align="center">编码长度</th>
<th>整数类型</th>
</tr>
</thead>
<tbody><tr>
<td align="center">11000000</td>
<td align="center">1</td>
<td>int16_t（2  bytes）</td>
</tr>
<tr>
<td align="center">11010000</td>
<td align="center">1</td>
<td>int32_t（4  bytes）</td>
</tr>
<tr>
<td align="center">11100000</td>
<td align="center">1</td>
<td>int64_t（8  bytes）</td>
</tr>
<tr>
<td align="center">11110000</td>
<td align="center">1</td>
<td>24位有符整数(3 bytes)</td>
</tr>
<tr>
<td align="center">11111110</td>
<td align="center">1</td>
<td>8位有符整数(1 bytes)</td>
</tr>
<tr>
<td align="center">1111xxxx</td>
<td align="center">1</td>
<td>直接在xxxx位置保存数值, 范围从0001<del>1101, 减1后结果为实际值, 即0</del>12</td>
</tr>
</tbody></table>
<p>例如，一个ZipList中包含两个整数值：“2”和“5”</p>
<p><img src="https://ni9ne.oss-cn-shanghai.aliyuncs.com/mdimg/f385696f7af49d7d18de157325da5f70-1007903.png" alt="image-20220703090900521"></p>
</li>
</ul>
<h4 id="ZipList的连锁更新问题"><a href="#ZipList的连锁更新问题" class="headerlink" title="ZipList的连锁更新问题"></a>ZipList的连锁更新问题</h4><p>ZipList的每个Entry都包含<code>previous_entry_length</code>来记录上一个节点的大小，长度是1个或5个字节：</p>
<ul>
<li><p>如果前一节点的长度小于254字节，则采用1个字节来保存这个长度值</p>
</li>
<li><p>如果前一节点的长度大于等于254字节，则采用5个字节来保存这个长度值，第一个字节为0xfe，后四个字节才是真实长度数据</p>
</li>
</ul>
<p>假设存在有N个连续的、长度为250~253字节之间的entry，因此entry的<code>previous_entry_length</code>属性用1个字节即可表示，如果在队首添加一个大于等于254字节的元素, 如图所示：</p>
<p><img src="https://ni9ne.oss-cn-shanghai.aliyuncs.com/mdimg/7cd6aa7894635b14a84422f70c39c04b-de40245.gif" alt="12332455703091933089823211"></p>
<p>ZipList这种特殊情况下产生的连续多次空间扩展操作称之为<strong>连锁更新（Cascade Update）</strong>。新增、删除都可能导致连锁更新的发生。</p>
<h4 id="总结-1"><a href="#总结-1" class="headerlink" title="总结"></a>总结</h4><p>ZipList特性：</p>
<p>①压缩列表的可以看做一种连续内存空间的”双向链表”</p>
<p>②列表的节点之间不是通过指针连接，而是记录上一节点和本节点长度来寻址，内存占用较低</p>
<p>③如果列表数据过多，导致链表过长，可能影响查询性能, 所以长度有限制</p>
<p>④增或删较大数据时有可能发生连续更新问题</p>
<h3 id="QuickList"><a href="#QuickList" class="headerlink" title="QuickList"></a>QuickList</h3><h4 id="QuickList引入"><a href="#QuickList引入" class="headerlink" title="QuickList引入"></a>QuickList引入</h4><p>ZipList虽然节省内存，但申请内存必须是连续空间，如果内存占用较多，申请内存效率很低。为了缓解这个问题，我们必须限制ZipList的长度和entry大小。</p>
<p>但是要存储大量数据，超出了ZipList最佳的上限, 可以创建多个ZipList来分片存储数据。</p>
<p>数据拆分后比较分散，不方便管理和查找，这多个ZipList如何建立联系？Redis在3.2版本引入了新的数据结构<strong>QuickList</strong>，它是一个双端链表，只不过链表中的每个节点都是一个ZipList。</p>
<p><img src="https://ni9ne.oss-cn-shanghai.aliyuncs.com/mdimg/cb71923492cc0e2879e8b79e9e76a946-1e56300.png" alt="image-20220703093654762"></p>
<h4 id="ZipList节点控制"><a href="#ZipList节点控制" class="headerlink" title="ZipList节点控制"></a>ZipList节点控制</h4><p>为了避免QuickList中的每个ZipList中entry过多，Redis提供了一个配置项：<code>list-max-ziplist-size</code>来限制。</p>
<ul>
<li><p>如果值为正，则代表ZipList的允许的<strong>entry个数</strong>的最大值</p>
</li>
<li><p>如果值为负，则代表ZipList的<strong>最大内存</strong>大小，分5种情况：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">-1：每个ZipList的内存占用不能超过4kb</span><br><span class="line">-2：每个ZipList的内存占用不能超过8kb</span><br><span class="line">-3：每个ZipList的内存占用不能超过16kb</span><br><span class="line">-4：每个ZipList的内存占用不能超过32kb</span><br><span class="line">-5：每个ZipList的内存占用不能超过64kb</span><br><span class="line">其默认值为 -2：</span><br></pre></td></tr></table></figure>

<p><img src="https://ni9ne.oss-cn-shanghai.aliyuncs.com/mdimg/f7e80ed1a3702650e04a690fb08450a1-6257078.png" alt="image-20220703093837954"></p>
</li>
</ul>
<p>除了控制ZipList的大小，QuickList还可以对节点的ZipList做压缩。通过配置项<code>list-compress-depth</code>来控制。因为链表一般都是从首尾访问较多，所以首尾是不压缩的。这个参数是控制首尾不压缩的节点个数：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">0：特殊值，代表不压缩</span><br><span class="line">1：标示QuickList的首尾各有1个节点不压缩，中间节点压缩</span><br><span class="line">2：标示QuickList的首尾各有2个节点不压缩，中间节点压缩</span><br><span class="line">其默认值为 0</span><br><span class="line">以此类推</span><br></pre></td></tr></table></figure>

<p><img src="https://ni9ne.oss-cn-shanghai.aliyuncs.com/mdimg/8b648382d193b59dc1f1b3638d755f2e-4c5ddb2.png" alt="image-20220703093958090"></p>
<h4 id="底层实现-1"><a href="#底层实现-1" class="headerlink" title="底层实现"></a>底层实现</h4><p><img src="https://ni9ne.oss-cn-shanghai.aliyuncs.com/mdimg/476e4b74386df29d93868ab0263195e1-fdc5df2.png" alt="image-20220703094248775"></p>
<p><img src="https://ni9ne.oss-cn-shanghai.aliyuncs.com/mdimg/bc7b1e49e6cfe5d0c512f47277aeb435-faa07df.png" alt="image-20220703094428304"></p>
<h4 id="QuickList数据结构"><a href="#QuickList数据结构" class="headerlink" title="QuickList数据结构"></a>QuickList数据结构</h4><p><img src="https://ni9ne.oss-cn-shanghai.aliyuncs.com/mdimg/2d0b96b94f091cc0e1f580d2f4a053d5-307ef23.png" alt="image-20220703094456586"></p>
<h3 id="SkipList"><a href="#SkipList" class="headerlink" title="SkipList"></a>SkipList</h3><h4 id="SkipList简介"><a href="#SkipList简介" class="headerlink" title="SkipList简介"></a>SkipList简介</h4><p><strong>SkipList（跳表）</strong>首先是链表，但与传统链表相比有几点差异：</p>
<ul>
<li><p>元素按照升序排列存储</p>
</li>
<li><p>节点可能包含多个指针，指针跨度不同。</p>
</li>
</ul>
<p>对比ZipList和QuickList, 查询中间节点数据性能较好, 不用逐个遍历元素</p>
<p><img src="https://ni9ne.oss-cn-shanghai.aliyuncs.com/mdimg/69ae08821256e681ffd04819f7d7fd4d-ed02b0c.png" alt="image-20220703100231514"></p>
<h4 id="数据结构-1"><a href="#数据结构-1" class="headerlink" title="数据结构"></a>数据结构</h4><p><img src="https://ni9ne.oss-cn-shanghai.aliyuncs.com/mdimg/f4a0b6ea384f2e5660d6c3400947d8d0-9bf376b.png" alt="image-20220703100618827"></p>
<p><img src="https://ni9ne.oss-cn-shanghai.aliyuncs.com/mdimg/8def98475926e2de06c6df26e3ed7ddb-636bdc7.png" alt="image-20220703100729681"></p>
<h4 id="总结-2"><a href="#总结-2" class="headerlink" title="总结"></a>总结</h4><p>SkipList的特点：</p>
<ul>
<li><p>跳跃表是一个双向链表，每个节点都包含score和ele值</p>
</li>
<li><p>节点按照score值排序，score值一样则按照ele字典排序</p>
</li>
<li><p>每个节点都可以包含多层指针，层数是<strong>1到32</strong>之间的随机数</p>
</li>
<li><p>不同层指针到下一个节点的跨度不同，层级越高，跨度越大</p>
</li>
<li><p>增删改查效率与红黑树基本一致，实现却更简单</p>
</li>
</ul>
<h3 id="RedisObject"><a href="#RedisObject" class="headerlink" title="RedisObject"></a>RedisObject</h3><p>Redis中的任意数据类型的键和值都会被封装为一个RedisObject，也叫做Redis对象，源码如下：</p>
<p><img src="https://ni9ne.oss-cn-shanghai.aliyuncs.com/mdimg/af40a3d93a91631f4708f847334c937c-18f8955.png" alt="image-20220703102753661"></p>
<p>Redis中会根据存储的数据类型不同，选择不同的编码方式，共包含11种不同类型：</p>
<table>
<thead>
<tr>
<th align="center">编号</th>
<th>编码方式</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td align="center">0</td>
<td>OBJ_ENCODING_RAW</td>
<td>raw编码动态字符串</td>
</tr>
<tr>
<td align="center">1</td>
<td>OBJ_ENCODING_INT</td>
<td>long类型的整数的字符串</td>
</tr>
<tr>
<td align="center">2</td>
<td>OBJ_ENCODING_HT</td>
<td>hash表（字典dict）</td>
</tr>
<tr>
<td align="center">3</td>
<td>OBJ_ENCODING_ZIPMAP</td>
<td>已废弃</td>
</tr>
<tr>
<td align="center">4</td>
<td>OBJ_ENCODING_LINKEDLIST</td>
<td>双端链表</td>
</tr>
<tr>
<td align="center">5</td>
<td>OBJ_ENCODING_ZIPLIST</td>
<td>压缩列表</td>
</tr>
<tr>
<td align="center">6</td>
<td>OBJ_ENCODING_INTSET</td>
<td>整数集合</td>
</tr>
<tr>
<td align="center">7</td>
<td>OBJ_ENCODING_SKIPLIST</td>
<td>跳表</td>
</tr>
<tr>
<td align="center">8</td>
<td>OBJ_ENCODING_EMBSTR</td>
<td>embstr的动态字符串</td>
</tr>
<tr>
<td align="center">9</td>
<td>OBJ_ENCODING_QUICKLIST</td>
<td>快速列表</td>
</tr>
<tr>
<td align="center">10</td>
<td>OBJ_ENCODING_STREAM</td>
<td>Stream流</td>
</tr>
</tbody></table>
<p>Redis中会根据存储的数据类型不同，选择不同的编码方式。每种数据类型的使用的编码方式如下：</p>
<table>
<thead>
<tr>
<th align="center">数据类型</th>
<th>编码方式</th>
</tr>
</thead>
<tbody><tr>
<td align="center">OBJ_STRING</td>
<td>int、embstr、raw</td>
</tr>
<tr>
<td align="center">OBJ_LIST</td>
<td>LinkedList和ZipList(3.2以前)、QuickList（3.2以后）</td>
</tr>
<tr>
<td align="center">OBJ_SET</td>
<td>intset、HT</td>
</tr>
<tr>
<td align="center">OBJ_ZSET</td>
<td>ZipList、HT、SkipList</td>
</tr>
<tr>
<td align="center">OBJ_HASH</td>
<td>ZipList、HT</td>
</tr>
</tbody></table>
<h3 id="五种数据结构"><a href="#五种数据结构" class="headerlink" title="五种数据结构"></a>五种数据结构</h3><h4 id="String"><a href="#String" class="headerlink" title="String"></a>String</h4><p>String是Redis中最常见的数据存储类型：</p>
<ul>
<li><p>其基本编码方式是<strong>RAW</strong>，基于<strong>简单动态字符串（SDS）</strong>实现，存储上限为512mb。</p>
<p><img src="https://ni9ne.oss-cn-shanghai.aliyuncs.com/mdimg/e704f0768e2dac979cfae3e5410b8703-1deb05d.png" alt="image-20220703110216960"></p>
</li>
<li><p>如果存储的SDS长度小于44字节，则会采用<strong>EMBSTR</strong>编码，此时object head与SDS是一段连续空间。申请内存时只需要调用一次内存分配函数，效率更高。</p>
<p><img src="https://ni9ne.oss-cn-shanghai.aliyuncs.com/mdimg/4931ae3a6ffba9db55d886a7495dd155-bffe22d.png" alt="image-20220703110236364"></p>
</li>
<li><p>如果存储的字符串是整数值，并且大小在<code>LONG_MAX</code>范围内，则会采用<strong>INT</strong>编码：直接将数据保存在RedisObject的ptr指针位置（刚好8字节），不再需要SDS了。</p>
<p><img src="https://ni9ne.oss-cn-shanghai.aliyuncs.com/mdimg/c28a446d5bd4fbc14ae867c44e8babaa-bde6d3a.png" alt="image-20220703110258535"></p>
</li>
</ul>
<p><img src="https://ni9ne.oss-cn-shanghai.aliyuncs.com/mdimg/4b88d039e0e4f66060bff62f09285fdf-de513b4.png" alt="image-20220703110548121"></p>
<blockquote>
<p>使用字符串格式数据时, 按照节省内存的逻辑, 尽量使用优先数字(int编码格式), 其次优先使用小于45个字符的字符串(embstr编码格式), 不推荐使用大字符串保存数据, 可能造成BigKey</p>
</blockquote>
<h4 id="List"><a href="#List" class="headerlink" title="List"></a>List</h4><p>Redis的List类型可以从首、尾操作列表中的元素, 满足该特征的数据结构有三种:</p>
<ul>
<li><p><strong>LinkedList</strong> ：普通链表，可以从双端访问，内存占用较高，内存碎片较多</p>
</li>
<li><p><strong>ZipList</strong> ：压缩列表，可以从双端访问，连续内存空间, 内存占用低，存储上限低</p>
</li>
<li><p><strong>QuickList</strong>：LinkedList + ZipList，可以从双端访问，内存占用较低，包含多个ZipList，存储上限高</p>
</li>
</ul>
<p>在3.2版本之前，Redis采用<strong>ZipList</strong>和<strong>LinkedList</strong>来实现List，当元素数量小于512并且元素大小小于64字节时采用ZipList编码，超过则采用LinkedList编码。</p>
<p>在3.2版本之后，Redis统一采用<strong>QuickList</strong>来实现List：</p>
<p><img src="https://ni9ne.oss-cn-shanghai.aliyuncs.com/mdimg/9378b10899e23356eff2fac34c79deb1-2b85d7f.png" alt="image-20220703112919765"></p>
<p><img src="https://ni9ne.oss-cn-shanghai.aliyuncs.com/mdimg/d8b248a19ca10063ba9be12dce9b6a90-6948607.png" alt="image-20220703112936331"></p>
<p>内存图:</p>
<p><img src="https://ni9ne.oss-cn-shanghai.aliyuncs.com/mdimg/46bcf52e1c0fb159c954be2faec70f7f-876abcf.png" alt="image-20220703113020320"></p>
<h4 id="Set"><a href="#Set" class="headerlink" title="Set"></a>Set</h4><p>Set是Redis中的单列集合，满足下列特点：</p>
<ul>
<li><p>不保证有序性</p>
</li>
<li><p>保证元素唯一 (可以判断元素是否存在)</p>
</li>
<li><p>求交集、并集、差集</p>
</li>
</ul>
<p>可以看出，Set对查询元素的效率要求非常高, 使用HashTable可以满足以上需求, 也就是Redis中的Dict，不过Dict是双列集合（可以存键、值对）</p>
<p>Set是Redis中的集合，不一定确保元素有序，可以满足元素唯一、查询效率要求极高。</p>
<ul>
<li><p>为了查询效率和唯一性，set采用HT编码（<strong>Dict</strong>）。Dict中的key用来存储元素，value统一为null。</p>
</li>
<li><p>当存储的所有数据都是整数，并且元素数量不超过<code>set-max-intset-entries</code>(默认值是512)时，Set会采用<strong>IntSet</strong>编码，以节省内存。</p>
</li>
</ul>
<p><strong>代码实现</strong> </p>
<p>创建:</p>
<p><img src="https://ni9ne.oss-cn-shanghai.aliyuncs.com/mdimg/067741ed45b3559bfc1aae0c55a4ea71-e2ba790.png" alt="image-20220703133521825"></p>
<p>添加元素</p>
<p><img src="https://ni9ne.oss-cn-shanghai.aliyuncs.com/mdimg/2718ee01e1cd5d9b7801592dfbc91bb6-7e99597.png" alt="image-20220703133825524"></p>
<p><img src="https://ni9ne.oss-cn-shanghai.aliyuncs.com/mdimg/fff5e4813c4de4b4adea56d9d1c8e060-314286f.png" alt="image-20220703134722184"></p>
<p><strong>内存图</strong></p>
<p><img src="https://ni9ne.oss-cn-shanghai.aliyuncs.com/mdimg/2190502fe238d4d21ca30bce958b24b1-b9ec829.png" alt="image-20220703140602215"></p>
<p>添加新数据变动:</p>
<p><img src="https://ni9ne.oss-cn-shanghai.aliyuncs.com/mdimg/c146938cec76c6f3e4d47a892d34fb02-41c3ff7.gif" alt="1232344220703134230324430"></p>
<h4 id="Zset"><a href="#Zset" class="headerlink" title="Zset"></a>Zset</h4><p>ZSet也就是SortedSet，其中每一个元素都需要指定一个score值和member值, 需要实现：</p>
<ul>
<li><p>可以根据score值排序后</p>
</li>
<li><p>member必须唯一</p>
</li>
<li><p>可以根据member查询分数</p>
</li>
</ul>
<p>因此，zset底层数据结构必须满足<strong>键值存储、键必须唯一、可排序</strong>这几个需求。其中编码结构可以满足需求的有:</p>
<ul>
<li><p><strong>SkipList</strong>：可以排序，并且可以同时存储score和ele值（member）</p>
</li>
<li><p><strong>HT（Dict）</strong>：可以键值存储，并且可以根据key找value</p>
</li>
</ul>
<p><strong>代码实现</strong> </p>
<p><strong>创建:</strong></p>
<p><img src="https://ni9ne.oss-cn-shanghai.aliyuncs.com/mdimg/a5d0d2b84b53dc6b6ab6cb4fad2403ff-81a309d.png" alt="image-20220703141350789"></p>
<p><strong>少量元素优化:</strong> </p>
<p>当元素数量不多时，<strong>HT</strong>和<strong>SkipList</strong>的优势不明显，而且更耗内存。因此zset还会采用仅<strong>ZipList</strong>结构来节省内存，不过需要同时满足两个条件：</p>
<p>①元素数量小于<code>zset_max_ziplist_entries</code>，默认值128</p>
<p>②每个元素都小于<code>zset_max_ziplist_value</code>字节，默认值64</p>
<p><img src="https://ni9ne.oss-cn-shanghai.aliyuncs.com/mdimg/649abd10205ff31bc3be4bb6c4e2175b-73d922e.png" alt="image-20220703142327034"></p>
<p><strong>添加元素</strong>:</p>
<p><img src="https://ni9ne.oss-cn-shanghai.aliyuncs.com/mdimg/65825a12764b966245c57528acd27dbe-2eaefc9.png" alt="image-20220703143032001"></p>
<p><strong>排序实现</strong></p>
<p>ziplist本身没有排序功能，而且没有键值对的概念，因此需要有zset通过编码实现：</p>
<ul>
<li><p>ZipList是连续内存，因此score和element是紧挨在一起的两个entry， element在前，score在后</p>
</li>
<li><p>score越小越接近队首，score越大越接近队尾，按照score值升序排列</p>
</li>
</ul>
<p><img src="https://ni9ne.oss-cn-shanghai.aliyuncs.com/mdimg/ad91ac65b51c40c3e29b843f530ee250-d4db508.png" alt="image-20220703143222838"></p>
<h4 id="Hash"><a href="#Hash" class="headerlink" title="Hash"></a>Hash</h4><p>Hash结构与Redis中的Zset非常类似：</p>
<ul>
<li><p>都是键值存储</p>
</li>
<li><p>都需求根据键获取值</p>
</li>
<li><p>键必须唯一</p>
</li>
</ul>
<p>区别如下：</p>
<ul>
<li><p>zset的键是member，值是score；hash的键和值都是任意值</p>
</li>
<li><p>zset要根据score排序；hash则无需排序</p>
</li>
</ul>
<p>因此，Hash底层采用的编码与Zset也基本一致，只需要把排序有关的SkipList去掉即可：</p>
<ul>
<li><p>Hash结构默认采用<strong>ZipList</strong>编码，用以节省内存。 ZipList中相邻的两个entry 分别保存field和value</p>
</li>
<li><p>当数据量较大时，Hash结构会转为HT编码，也就是<strong>Dict</strong>，触发条件有两个：</p>
<p>① ZipList中的元素数量超过了<code>hash-max-ziplist-entries</code>（默认512）</p>
<p>② ZipList中的任意entry大小超过了<code>hash-max-ziplist-value</code>（默认64字节）</p>
</li>
</ul>
<p><img src="https://ni9ne.oss-cn-shanghai.aliyuncs.com/mdimg/b1f7a62d64998a685ab4025e720db318-38bce94.png" alt="image-20220703150630161"></p>
<p><strong>代码实现:</strong> </p>
<p><img src="https://ni9ne.oss-cn-shanghai.aliyuncs.com/mdimg/4bec58fe8aa3945105fd103c148a510e-15389ea.png" alt="image-20220703152600746"></p>
<h2 id="网络模型"><a href="#网络模型" class="headerlink" title="网络模型"></a>网络模型</h2><h3 id="用户空间和内核空间"><a href="#用户空间和内核空间" class="headerlink" title="用户空间和内核空间"></a>用户空间和内核空间</h3><p>任何Linux发行版，其系统内核都是Linux。我们的应用都需要通过Linux内核与硬件交互。</p>
<p><img src="https://ni9ne.oss-cn-shanghai.aliyuncs.com/mdimg/65f59d50376d351ecb8141d4fdeb2755-914caf5.png" alt="image-20220704124243506"></p>
<p>为了避免用户应用导致冲突甚至内核崩溃，用户应用与内核是分离的：</p>
<ul>
<li><p>进程的寻址空间会划分为两部分：<strong>内核空间、用户空间</strong></p>
</li>
<li><p><strong>用户空间</strong>只能执行受限的命令（Ring3），而且不能直接调用系统资源，必须通过内核提供的接口来访问</p>
</li>
<li><p><strong>内核空间</strong>可以执行特权命令（Ring0），调用一切系统资源</p>
</li>
</ul>
<p><img src="https://ni9ne.oss-cn-shanghai.aliyuncs.com/mdimg/ac8294568531ac2d8e28bf47d4939464-00e144d.png" alt="image-20220704124448883"></p>
<p>Linux系统为了提高IO效率，会在用户空间和内核空间都加入缓冲区：</p>
<ul>
<li><p>写数据时，要把用户缓冲数据拷贝到内核缓冲区，然后写入设备</p>
</li>
<li><p>读数据时，要从设备读取数据到内核缓冲区，然后拷贝到用户缓冲区</p>
</li>
</ul>
<p><img src="https://ni9ne.oss-cn-shanghai.aliyuncs.com/mdimg/5c079def535c550a9f57981483f4252f-bf99d8f.png" alt="image-20220704124828298"></p>
<h3 id="五种IO模型"><a href="#五种IO模型" class="headerlink" title="五种IO模型"></a>五种IO模型</h3><p>在《UNIX网络编程》一书中，总结归纳了5种IO模型：</p>
<ul>
<li><p>阻塞IO（Blocking IO）</p>
</li>
<li><p>非阻塞IO（Nonblocking IO）</p>
</li>
<li><p>IO多路复用（IO Multiplexing）</p>
</li>
<li><p>信号驱动IO（Signal Driven IO）</p>
</li>
<li><p>异步IO（Asynchronous IO）</p>
</li>
</ul>
<p><img src="https://ni9ne.oss-cn-shanghai.aliyuncs.com/mdimg/cceff6a61c012e38294d678b3c331ca3-3086a5b.png" alt="image-20220704124731196"></p>
<h4 id="阻塞IO"><a href="#阻塞IO" class="headerlink" title="阻塞IO"></a>阻塞IO</h4><p>顾名思义，阻塞IO就是两个阶段都必须阻塞等待：</p>
<p><img src="https://ni9ne.oss-cn-shanghai.aliyuncs.com/mdimg/712b6cbfe9c96f69c82db5fd24cab043-c51c92c.png" alt="image-20220704125002627"></p>
<p><strong>阶段一：</strong></p>
<ul>
<li><p>①用户进程尝试读取数据（比如网卡数据）</p>
</li>
<li><p>②此时数据尚未到达，内核需要等待数据</p>
</li>
<li><p>③此时用户进程也处于阻塞状态</p>
</li>
</ul>
<p><strong>阶段二：</strong></p>
<ul>
<li><p>①数据到达并拷贝到内核缓冲区，代表已就绪</p>
</li>
<li><p>②将内核数据拷贝到用户缓冲区</p>
</li>
<li><p>③拷贝过程中，用户进程依然阻塞等待</p>
</li>
<li><p>④拷贝完成，用户进程解除阻塞，处理数据</p>
</li>
</ul>
<p>可以看到，阻塞IO模型中，用户进程在两个阶段都是阻塞状态。</p>
<h4 id="非阻塞IO"><a href="#非阻塞IO" class="headerlink" title="非阻塞IO"></a>非阻塞IO</h4><p>顾名思义，非阻塞IO的<code>recvfrom</code>操作会立即返回结果而不是阻塞用户进程。</p>
<p><img src="https://ni9ne.oss-cn-shanghai.aliyuncs.com/mdimg/46600170012e52066d83d982a07d946f-49e5bbc.png" alt="image-20220704125144758"></p>
<p><strong>阶段一：</strong></p>
<ul>
<li><p>①用户进程尝试读取数据（比如网卡数据）</p>
</li>
<li><p>②此时数据尚未到达，内核需要等待数据</p>
</li>
<li><p>③返回异常给用户进程</p>
</li>
<li><p>④用户进程拿到error后，再次尝试读取</p>
</li>
<li><p>⑤循环往复，直到数据就绪</p>
</li>
</ul>
<p><strong>阶段二：</strong></p>
<ul>
<li><p>①将内核数据拷贝到用户缓冲区</p>
</li>
<li><p>②拷贝过程中，用户进程依然阻塞等待</p>
</li>
<li><p>③拷贝完成，用户进程解除阻塞，处理数据</p>
</li>
</ul>
<p>可以看到，非阻塞IO模型中，用户进程在第一个阶段是非阻塞，第二个阶段是阻塞状态。虽然是非阻塞，但性能并没有得到提高。而且忙等机制会导致CPU空转，CPU使用率暴增。</p>
<h4 id="IO多路复用"><a href="#IO多路复用" class="headerlink" title="IO多路复用"></a>IO多路复用</h4><p>无论是阻塞IO还是非阻塞IO，用户应用在一阶段都需要调用<code>recvfrom</code>来获取数据，差别在于无数据时的处理方案：</p>
<ul>
<li><p>如果调用<code>recvfrom</code>时，恰好<strong>没有</strong>数据，阻塞IO会使CPU阻塞，非阻塞IO使CPU空转，都不能充分发挥CPU的作用。</p>
</li>
<li><p>如果调用<code>recvfrom</code>时，恰好<strong>有</strong>数据，则用户进程可以直接进入第二阶段，读取并处理数据</p>
</li>
</ul>
<p>而在单线程情况下，只能依次处理IO事件，如果正在处理的IO事件恰好未就绪（数据不可读或不可写），线程就会被阻塞，所有IO事件都必须等待，性能自然会很差。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">就比如服务员给顾客点餐，分两步：</span><br><span class="line"> ①顾客思考要吃什么（等待数据就绪）</span><br><span class="line"> ②顾客想好了，开始点餐（读取数据）</span><br><span class="line"></span><br><span class="line">要提高效率有几种办法？</span><br><span class="line">- 方案一：增加更多服务员（多线程）</span><br><span class="line">- 方案二：不排队，谁想好了吃什么（数据就绪了），服务员就给谁点餐（用户应用就去读取数据）</span><br><span class="line"></span><br><span class="line">那么问题来了：用户进程如何知道内核中数据是否就绪呢？</span><br></pre></td></tr></table></figure>

<p><strong>文件描述符</strong>（File Descriptor）：简称FD，是一个从0 开始的无符号整数，用来关联Linux中的一个文件。在Linux中，一切皆文件，例如常规文件、视频、硬件设备等，当然也包括网络套接字（Socket）。</p>
<p><strong>IO多路复用</strong>：是利用单个线程来同时监听多个FD，并在某个FD可读、可写时得到通知，从而避免无效的等待，充分利用CPU资源。</p>
<p><img src="https://ni9ne.oss-cn-shanghai.aliyuncs.com/mdimg/7d6d2153a1d9776379b8c1db245fdf1c-6721eff.png" alt="image-20220704125458059"></p>
<p><strong>阶段一：</strong></p>
<ul>
<li><p>①用户进程调用select，指定要监听的FD集合</p>
</li>
<li><p>②内核监听FD对应的多个socket</p>
</li>
<li><p>③任意一个或多个socket数据就绪则返回readable</p>
</li>
<li><p>④此过程中用户进程阻塞</p>
</li>
</ul>
<p><strong>阶段二：</strong></p>
<ul>
<li><p>①用户进程找到就绪的socket</p>
</li>
<li><p>②依次调用<code>recvfrom</code>读取数据</p>
</li>
<li><p>③内核将数据拷贝到用户空间</p>
</li>
<li><p>④用户进程处理数据</p>
</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">IO多路复用是利用单个线程来同时监听多个FD，不过监听FD的方式、通知的方式又有多种实现，常见的有：</span><br><span class="line">- select</span><br><span class="line">- poll</span><br><span class="line">- epoll</span><br><span class="line"></span><br><span class="line">差异：</span><br><span class="line">select和poll只会通知用户进程有FD就绪，但不确定具体是哪个FD，需要用户进程逐个遍历FD来确认</span><br><span class="line">epoll则会在通知用户进程FD就绪的同时，把已就绪的FD写入用户空间</span><br></pre></td></tr></table></figure>

<h5 id="IO多路复用-select"><a href="#IO多路复用-select" class="headerlink" title="IO多路复用-select"></a>IO多路复用-select</h5><p><strong>select</strong>是Linux最早的I/O多路复用技术：</p>
<p><img src="https://ni9ne.oss-cn-shanghai.aliyuncs.com/mdimg/0d0f72f07780ecb47b052d72f5a69353-b1fea25.png" alt="image-20220704131319638"></p>
<p><img src="https://ni9ne.oss-cn-shanghai.aliyuncs.com/mdimg/ab0e67f006519d322587e0c6dd0b6fd9-c31e492.gif" alt="53432341123210704130219 00_"></p>
<p><strong>select模式存在的问题</strong>：</p>
<ul>
<li><p>需要将整个<code>fd_set</code>从用户空间拷贝到内核空间，<code>select</code>结束还要再次拷贝回用户空间</p>
</li>
<li><p><code>select</code>无法得知具体是哪个<code>fd</code>就绪，需要遍历整个<code>fd_set</code></p>
</li>
<li><p><code>fd_set</code>监听的<code>fd</code>数量不能超过1024</p>
</li>
</ul>
<h5 id="IO多路复用-poll"><a href="#IO多路复用-poll" class="headerlink" title="IO多路复用-poll"></a>IO多路复用-poll</h5><p><strong>poll</strong>模式对select模式做了简单改进，但性能提升不明显，部分关键代码如下：</p>
<p><img src="https://ni9ne.oss-cn-shanghai.aliyuncs.com/mdimg/3f20355ccc9adb18249ad45aa9679911-89fec95.png" alt="image-20220704131935087"></p>
<p><strong>IO流程</strong>：</p>
<ul>
<li><p>①创建<code>pollfd</code>数组，向其中添加关注的<code>fd</code>信息，数组大小自定义</p>
</li>
<li><p>②调用<code>poll</code>函数，将<code>pollfd</code>数组拷贝到内核空间，转链表存储，无上限</p>
</li>
<li><p>③内核遍历<code>fd</code>，判断是否就绪</p>
</li>
<li><p>④数据就绪或超时后，拷贝<code>pollfd</code>数组到用户空间，返回就绪<code>fd</code>数量<code>n</code></p>
</li>
<li><p>⑤用户进程判断<code>n</code>是否大于0</p>
</li>
<li><p>⑥大于0则遍历<code>pollfd</code>数组，找到就绪的<code>fd</code></p>
</li>
</ul>
<p><strong>与select对比</strong>：</p>
<ul>
<li><p>select模式中的<code>fd_set</code>大小固定为1024，而<code>pollfd在</code>内核中采用<strong>链表</strong>，理论上无上限</p>
</li>
<li><p>监听FD越多，每次遍历消耗时间也越久，性能反而会下降</p>
</li>
</ul>
<h5 id="IO多路复用-epoll"><a href="#IO多路复用-epoll" class="headerlink" title="IO多路复用-epoll"></a>IO多路复用-epoll</h5><p>epoll模式是对select和poll的改进，它提供了三个函数：</p>
<p><img src="https://ni9ne.oss-cn-shanghai.aliyuncs.com/mdimg/a636c9f70d884c8888f893d261bc0a14-a9acef8.png" alt="image-20220704132641292"></p>
<p><img src="https://ni9ne.oss-cn-shanghai.aliyuncs.com/mdimg/4d9a51361d722d8920d8e6e40880b3e2-6609e5b.gif" alt="867645456704132748 00_0"></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">select模式存在的三个问题：</span><br><span class="line"> - 能监听的FD最大不超过1024</span><br><span class="line"> - 每次select都需要把所有要监听的FD都拷贝到内核空间</span><br><span class="line"> - 每次都要遍历所有FD来判断就绪状态</span><br><span class="line">poll模式的问题：</span><br><span class="line"> - poll利用链表解决了select中监听FD上限的问题，但依然要遍历所有FD，如果监听较多，性能会下降</span><br><span class="line">epoll模式中如何解决这些问题的？</span><br><span class="line"> - 基于epoll实例中的红黑树保存要监听的FD，理论上无上限，而且增删改查效率都非常高</span><br><span class="line"> - 每个FD只需要执行一次epoll_ctl添加到红黑树，以后每次epol_wait无需传递任何参数，无需重复拷贝FD到内核空间</span><br><span class="line"> - 利用ep_poll_callback机制来监听FD状态，无需遍历所有FD，因此性能不会随监听的FD数量增多而下降</span><br></pre></td></tr></table></figure>

<h5 id="IO多路复用-事件通知机制"><a href="#IO多路复用-事件通知机制" class="headerlink" title="IO多路复用-事件通知机制"></a>IO多路复用-事件通知机制</h5><p>当FD有数据可读时，我们调用<code>epoll_wait</code>（或者<code>select</code>、<code>poll</code>）可以得到通知。但是事件通知的模式有两种：</p>
<ul>
<li><p><strong>LevelTriggered</strong>：简称<strong>LT</strong>，也叫做<strong>水平触发</strong>。只要某个<code>FD</code>中有数据可读，每次调用<code>epoll_wait</code>都会得到通知。</p>
</li>
<li><p><strong>EdgeTriggered</strong>：简称<strong>ET</strong>，也叫做<strong>边沿触发</strong>。只有在某个<code>FD</code>有状态变化时，调用<code>epoll_wait</code>才会被通知。</p>
</li>
</ul>
<p>举个例子：</p>
<p>①假设一个客户端<code>socket</code>对应的<code>FD</code>已经注册到了<code>epoll</code>实例中</p>
<p>②客户端<code>socket</code>发送了2kb的数据</p>
<p>③服务端调用<code>epoll_wait</code>，得到通知说<code>FD</code>就绪</p>
<p>④服务端从<code>FD</code>读取了1kb数据</p>
<p>⑤回到步骤3（再次调用<code>epoll_wait</code>，形成循环）</p>
<p>结果：</p>
<ul>
<li><p>如果采用LT模式，因为<code>FD</code>中仍有1kb数据，则第⑤步依然会返回结果，并且得到通知</p>
</li>
<li><p>如果采用ET模式，因为第③步已经消费了<code>FD</code>可读事件，第⑤步<code>FD</code>状态没有变化，因此<code>epoll_wait</code>不会返回，数据无法读取，客户端响应超时。</p>
</li>
</ul>
<p>结论:</p>
<ul>
<li><p>LT：事件通知频率较高，会有重复通知，影响性能</p>
</li>
<li><p>ET：仅通知一次，效率高。可以基于非阻塞IO循环读取解决数据读取不完整问题</p>
</li>
</ul>
<blockquote>
<p> select和poll仅支持LT模式，epoll可以自由选择LT和ET两种模式</p>
</blockquote>
<h5 id="IO多路复用-web服务流程"><a href="#IO多路复用-web服务流程" class="headerlink" title="IO多路复用-web服务流程"></a>IO多路复用-web服务流程</h5><p>基于epoll模式的web服务的基本流程如图：</p>
<p><img src="https://ni9ne.oss-cn-shanghai.aliyuncs.com/mdimg/233fd3a83713fc6d2c9097c95bb39082-16e1354.png" alt="image-20220704133537920"></p>
<h4 id="信号驱动IO"><a href="#信号驱动IO" class="headerlink" title="信号驱动IO"></a>信号驱动IO</h4><p><strong>信号驱动IO</strong>是与内核建立<code>SIGIO</code>的信号关联并设置回调，当内核有<code>FD</code>就绪时，会发出<code>SIGIO</code>信号通知用户，期间用户应用可以执行其它业务，无需阻塞等待。</p>
<p><img src="https://ni9ne.oss-cn-shanghai.aliyuncs.com/mdimg/1aac4dfd1b8280c09d7b62b4df4b0fa4-0b5eab5.png" alt="image-20220704133804934"></p>
<p>阶段一：</p>
<ul>
<li><p>①用户进程调用<code>sigaction</code>，注册信号处理函数</p>
</li>
<li><p>②内核返回成功，开始监听<code>FD</code></p>
</li>
<li><p>③用户进程不阻塞等待，可以执行其它业务</p>
</li>
<li><p>④当内核数据就绪后，回调用户进程的<code>SIGIO</code>处理函数</p>
</li>
</ul>
<p>阶段二：</p>
<ul>
<li><p>①收到<code>SIGIO</code>回调信号</p>
</li>
<li><p>②调用<code>recvfrom</code>，读取</p>
</li>
<li><p>③内核将数据拷贝到用户空间</p>
</li>
<li><p>④用户进程处理数据</p>
</li>
</ul>
<blockquote>
<p>当有大量IO操作时，信号较多，SIGIO处理函数不能及时处理可能导致信号队列溢出，而且内核空间与用户空间的频繁信号交互性能也较低。</p>
</blockquote>
<h4 id="异步IO"><a href="#异步IO" class="headerlink" title="异步IO"></a>异步IO</h4><p><strong>异步IO</strong>的整个过程都是非阻塞的，用户进程调用完异步API后就可以去做其它事情，内核等待数据<strong>就绪并拷贝到用户空间后</strong>才会递交信号，通知用户进程。</p>
<p><img src="https://ni9ne.oss-cn-shanghai.aliyuncs.com/mdimg/23158e23e7db717eb48231268ce784f9-f813eb0.png" alt="image-20220704134003847"></p>
<p>阶段一：</p>
<ul>
<li><p>①用户进程调用<code>aio_read</code>，创建信号回调函数</p>
</li>
<li><p>②内核等待数据就绪</p>
</li>
<li><p>③用户进程无需阻塞，可以做任何事情</p>
</li>
</ul>
<p>阶段二：</p>
<ul>
<li><p>①内核数据就绪</p>
</li>
<li><p>②内核数据拷贝到用户缓冲区</p>
</li>
<li><p>③拷贝完成，内核递交信号触发<code>aio_read</code>中的回调函数</p>
</li>
<li><p>④用户进程处理数据</p>
</li>
</ul>
<blockquote>
<p>可以看到，异步IO模型中，用户进程在两个阶段都是非阻塞状态。<br>但在大并发情况下, 内核积存的IO处理可能崩溃, 所以需要应用并发限流, 造成代码复杂度升高</p>
</blockquote>
<h4 id="同步和异步判断"><a href="#同步和异步判断" class="headerlink" title="同步和异步判断"></a>同步和异步判断</h4><p>IO操作是同步还是异步，关键看数据在内核空间与用户空间的拷贝过程（数据读写的IO操作），也就是阶段二是同步还是异步：</p>
<p><img src="https://ni9ne.oss-cn-shanghai.aliyuncs.com/mdimg/6704416d0646e1cd9e768c5f4de15292-78bdf56.png" alt="image-20220704134151079"></p>
<h3 id="Redis网络模型"><a href="#Redis网络模型" class="headerlink" title="Redis网络模型"></a>Redis网络模型</h3><h4 id="Redis到底是单线程还是多线程"><a href="#Redis到底是单线程还是多线程" class="headerlink" title="Redis到底是单线程还是多线程"></a>Redis到底是单线程还是多线程</h4><ul>
<li><p>如果仅仅是Redis的核心业务部分（命令处理），是单线程</p>
</li>
<li><p>如果是整个Redis，那么就是多线程</p>
</li>
</ul>
<p>在Redis版本迭代过程中，在两个重要的时间节点上引入了多线程的支持：</p>
<ul>
<li><p>Redis v4.0：引入多线程异步处理一些耗时较旧的任务，例如异步删除命令<code>unlink</code></p>
</li>
<li><p>Redis v6.0：在核心网络模型中引入 多线程，进一步提高对于多核CPU的利用率</p>
</li>
</ul>
<p>因此，对于Redis的核心网络模型，在Redis 6.0之前确实都是单线程。是利用<code>epoll</code>（Linux系统）这样的IO多路复用技术在事件循环中不断处理客户端情况。</p>
<h4 id="为什么Redis要选择单线程"><a href="#为什么Redis要选择单线程" class="headerlink" title="为什么Redis要选择单线程"></a>为什么Redis要选择单线程</h4><ul>
<li><p>抛开持久化不谈，Redis是<strong>纯内存操作</strong>，执行速度非常快，它的性能瓶颈是网络延迟而不是执行速度，因此多线程并不会带来巨大的性能提升。</p>
</li>
<li><p>多线程会导致过多的<strong>上下文切换</strong>，带来不必要的开销</p>
</li>
<li><p>引入多线程会面临<strong>线程安全</strong>问题，必然要引入线程锁这样的安全手段，实现复杂度增高，而且性能也会大打折扣</p>
</li>
</ul>
<h4 id="事件API库-AE"><a href="#事件API库-AE" class="headerlink" title="事件API库 AE"></a>事件API库 AE</h4><p>Redis通过IO多路复用来提高网络性能，并且支持各种不同的多路复用实现，并且将这些实现进行封装， 提供了统一的高性能事件库API库 AE：</p>
<p><img src="https://ni9ne.oss-cn-shanghai.aliyuncs.com/mdimg/def9441aaa256e2878f18c703ab55d4b-55d43fe.png" alt="image-20220704134802204"></p>
<h4 id="Redis单线程网络模型的流程"><a href="#Redis单线程网络模型的流程" class="headerlink" title="Redis单线程网络模型的流程"></a>Redis单线程网络模型的流程</h4><p><img src="https://ni9ne.oss-cn-shanghai.aliyuncs.com/mdimg/cc9cea3a079f897d41d30ef134c74d72-21b10b5.png" alt="image-20220704140419658"></p>
<p><img src="https://ni9ne.oss-cn-shanghai.aliyuncs.com/mdimg/dd6caa8813cfb591002117390451d4ac-0b82264.png" alt="image-20220704140551856"></p>
<p><strong>beforSleep代码</strong> </p>
<p><img src="https://ni9ne.oss-cn-shanghai.aliyuncs.com/mdimg/f166984c504ca0572d90443ee6a5c827-b460529.png" alt="image-20220704140907427"></p>
<p><strong>readQueryFromClient代码</strong> </p>
<p><img src="https://ni9ne.oss-cn-shanghai.aliyuncs.com/mdimg/f6a6f17690652f8db1e153dfdc1b1dfe-7773614.png" alt="image-20220704141124651"></p>
<h4 id="Redis多线程应用"><a href="#Redis多线程应用" class="headerlink" title="Redis多线程应用"></a>Redis多线程应用</h4><p>Redis 6.0版本中引入了多线程，目的是为了提高IO读写效率。因此在<strong>解析客户端命令</strong>、<strong>写响应结果</strong>时采用了多线程。核心的命令执行、IO多路复用模块依然是由主线程执行。</p>
<p><img src="https://ni9ne.oss-cn-shanghai.aliyuncs.com/mdimg/6fefd0eacd8763bd8f4879e3d06eaf84-77d5a84.png" alt="image-20220704140655294"></p>
<h2 id="通信协议"><a href="#通信协议" class="headerlink" title="通信协议"></a>通信协议</h2><h3 id="RESP协议"><a href="#RESP协议" class="headerlink" title="RESP协议"></a>RESP协议</h3><p>Redis是一个CS架构的软件，通信一般分两步（不包括pipeline和PubSub）：</p>
<ul>
<li><p>①客户端（client）向服务端（server）发送一条命令</p>
</li>
<li><p>②服务端解析并执行命令，返回响应结果给客户端</p>
</li>
</ul>
<p>因此客户端发送命令的格式、服务端响应结果的格式必须有一个规范，这个规范就是通信协议。</p>
<p>而在Redis中采用的是<strong>RESP</strong>（Redis Serialization Protocol）协议：</p>
<ul>
<li><p>Redis 1.2版本引入了RESP协议</p>
</li>
<li><p>Redis 2.0版本中成为与Redis服务端通信的标准，称为RESP2</p>
</li>
<li><p>Redis 6.0版本中，从RESP2升级到了RESP3协议，增加了更多数据类型并且支持6.0的新特性–客户端缓存</p>
</li>
</ul>
<blockquote>
<p>但目前，默认使用的依然是RESP2协议（简称RESP）。</p>
</blockquote>
<h4 id="RESP协议-数据类型"><a href="#RESP协议-数据类型" class="headerlink" title="RESP协议-数据类型"></a>RESP协议-数据类型</h4><p>在RESP中，通过首字节的字符来区分不同数据类型，常用的数据类型包括5种：</p>
<ul>
<li><p>单行字符串：首字节是 ‘<code>+</code>’ ，后面跟上单行字符串，以CRLF（ “<code>\r\n</code>“ ）结尾。</p>
<p>例如返回”<code>OK</code>“： “<code>+OK\r\n</code>“</p>
</li>
<li><p>错误（Errors）：首字节是 ‘<code>-</code>’ ，与单行字符串格式一样，只是字符串是异常信息</p>
<p>例如：”<code>-Error message\r\n</code>“</p>
</li>
<li><p>数值：首字节是 ‘<code>:</code>’ ，后面跟上数字格式的字符串，以CRLF结尾。</p>
<p>例如：”<code>:10\r\n</code>“</p>
</li>
<li><p>多行字符串：首字节是 ‘<code>$</code>’ ，表示二进制安全的字符串，最大支持512MB：</p>
<ul>
<li>如果大小为0，则代表空字符串：”<code>$0\r\n\r\n</code>“</li>
<li>如果大小为-1，则代表不存在：”<code>$-1\r\n</code>“</li>
</ul>
<p><img src="https://ni9ne.oss-cn-shanghai.aliyuncs.com/mdimg/406f421be12129c0c641452af565ff93-8ee99f5.png" alt="image-20220704154034088"></p>
</li>
<li><p>数组：首字节是 ‘<code>*</code>’，后面跟上数组元素个数，再跟上元素，元素数据类型不限:</p>
<p><img src="https://ni9ne.oss-cn-shanghai.aliyuncs.com/mdimg/1abf7163730594c9ed1cbc279db9cd0a-c96cc7d.png" alt="image-20220704154114414"></p>
</li>
</ul>
<h4 id="使用socket模拟Redis-cli"><a href="#使用socket模拟Redis-cli" class="headerlink" title="使用socket模拟Redis-cli"></a>使用socket模拟Redis-cli</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="内存策略"><a href="#内存策略" class="headerlink" title="内存策略"></a>内存策略</h2><p>Redis之所以性能强，最主要的原因就是基于内存存储。然而单节点的Redis其内存大小不宜过大，会影响<strong>持久化</strong>或<strong>主从同步</strong>性能。</p>
<p>我们可以通过修改配置文件来设置Redis的最大内存：</p>
<figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 格式：</span></span><br><span class="line"><span class="comment"># maxmemory &lt;bytes&gt;</span></span><br><span class="line"><span class="comment"># 例如：</span></span><br><span class="line"><span class="attr">maxmemory</span> <span class="string">1gb</span></span><br></pre></td></tr></table></figure>

<p>当内存使用达到上限时，就无法存储更多数据了。为了解决这个问题，Redis提供了一些策略实现内存回收：</p>
<ul>
<li><p>内存过期策略</p>
</li>
<li><p>内存淘汰策略</p>
</li>
</ul>
<h3 id="过期策略"><a href="#过期策略" class="headerlink" title="过期策略"></a>过期策略</h3><p>可以通过<code>expire</code>命令给Redis的key设置TTL（存活时间）：</p>
<p><img src="https://ni9ne.oss-cn-shanghai.aliyuncs.com/mdimg/624f3c606f0b85f72b702f4f1ce229cb-4a4dd96.png" alt="image-20220704154451906"></p>
<p>当key的TTL到期以后，再次访问<code>name</code>返回的是<code>nil</code>，说明这个key已经不存在了，对应的内存也得到释放。从而起到内存回收的目的。</p>
<h4 id="过期策略-DB结构"><a href="#过期策略-DB结构" class="headerlink" title="过期策略-DB结构"></a>过期策略-DB结构</h4><p>Redis本身是一个典型的key-value内存存储数据库，因此所有的key、value都保存在<strong>Dict</strong>结构中。不过在其database结构体中，有两个Dict：一个用来记录key-value(<code>dict</code>)；另一个用来记录key-TTL(<code>expires</code>)。</p>
<p><img src="https://ni9ne.oss-cn-shanghai.aliyuncs.com/mdimg/98af221b859a20a3d4d9b5f32367f03a-c9e7fa3.png" alt="image-20220704154725181"></p>
<p>redisDb内存图如下:</p>
<p><img src="https://ni9ne.oss-cn-shanghai.aliyuncs.com/mdimg/f58bce0e122463aa227d2b62230e27c5-490fb09.png" alt="image-20220704154902329"></p>
<p>即Redis是通过key所在<code>redisDb</code>中<code>expires</code>包含<code>TTL</code>数据确定过期与否</p>
<h4 id="过期策略-过期删除"><a href="#过期策略-过期删除" class="headerlink" title="过期策略-过期删除"></a>过期策略-过期删除</h4><p>Redis的过期删除是通过结合使用惰性删除和周期删除完成的</p>
<ul>
<li><p>惰性删除</p>
<p><strong>惰性删除：</strong>顾名思义并不是在TTL到期后就立刻删除，而是在访问一个key的时候，检查该key的存活时间，如果已经过期才执行删除。</p>
<p><img src="https://ni9ne.oss-cn-shanghai.aliyuncs.com/mdimg/11e43364a194fe41a5ef628d05ac861a-cf060ae.png" alt="image-20220704155509355"></p>
</li>
<li><p>周期删除.</p>
<p><strong>周期删除：</strong>顾名思义是通过一个定时任务，周期性的<strong>抽样部分过期的key</strong>，然后执行删除。执行周期有两种：</p>
<ul>
<li><p>Redis服务初始化函数<code>initServer()</code>中设置定时任务<code>serverCron</code>，按照<code>server.hz</code>的频率来执行过期key清理，模式为<strong>SLOW</strong> </p>
<p><strong>SLOW</strong>模式规则：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">①执行频率受server.hz影响，默认为10，即每秒执行10次，每个执行周期100ms。</span><br><span class="line">②执行清理耗时不超过一次执行周期的25%.默认slow模式耗时不超过25ms</span><br><span class="line">③逐个遍历db，逐个遍历db中的bucket，抽取20个key判断是否过期</span><br><span class="line">④如果没达到时间上限（25ms）并且全局过期key比例大于10%，再进行一次抽样，否则结束</span><br></pre></td></tr></table></figure></li>
<li><p>Redis的每个事件循环前会调用<code>beforeSleep()</code>函数，执行过期key清理，模式为<strong>FAST</strong> </p>
<p><strong>FAST</strong>模式规则（全局过期key比例小于10%不执行 ）：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">①执行频率受beforeSleep()调用频率影响，但两次FAST模式间隔不低于2ms</span><br><span class="line">②执行清理耗时不超过1ms</span><br><span class="line">③逐个遍历db，逐个遍历db中的bucket，抽取20个key判断是否过期</span><br><span class="line">④如果没达到时间上限（1ms）并且过期key比例大于10%，再进行一次抽样，否则结束</span><br></pre></td></tr></table></figure></li>
</ul>
<p><img src="https://ni9ne.oss-cn-shanghai.aliyuncs.com/mdimg/3ed8f7407adec7fce41f6bf24aad69b0-3b8ea91.png" alt="image-20220704155829670"></p>
</li>
</ul>
<h3 id="淘汰策略"><a href="#淘汰策略" class="headerlink" title="淘汰策略"></a>淘汰策略</h3><h4 id="内存淘汰"><a href="#内存淘汰" class="headerlink" title="内存淘汰"></a>内存淘汰</h4><p><strong>内存淘汰</strong>：就是当Redis内存使用达到设置的上限时，主动挑选<strong>部分key</strong>删除以释放更多内存的流程。Redis会在每次处理客户端命令的方法<code>processCommand()</code>中尝试做内存淘汰：</p>
<p><img src="https://ni9ne.oss-cn-shanghai.aliyuncs.com/mdimg/78786408b62d1b7cbccfb70feeda506b-8b1d24a.png" alt="image-20220704160141189"></p>
<h4 id="八种淘汰策略"><a href="#八种淘汰策略" class="headerlink" title="八种淘汰策略"></a>八种淘汰策略</h4><p><img src="https://ni9ne.oss-cn-shanghai.aliyuncs.com/mdimg/7ebc5a108459037109c7e1c66c4bc517-e433dae.png" alt="image-20220704160346602"></p>
<p>Redis支持8种不同策略来选择要删除的key：</p>
<ul>
<li><p><strong>noeviction</strong>： 不淘汰任何key，但是内存满时不允许写入新数据，默认就是这种策略。</p>
</li>
<li><p><strong>volatile-ttl</strong>： 对设置了TTL的key，比较key的剩余TTL值，TTL越小越先被淘汰</p>
</li>
<li><p><strong>allkeys-random</strong>：对全体key ，随机进行淘汰。也就是直接从db-&gt;dict中随机挑选</p>
</li>
<li><p><strong>volatile-random</strong>：对设置了TTL的key ，随机进行淘汰。也就是从db-&gt;expires中随机挑选。</p>
</li>
<li><p><strong>allkeys-lru</strong>： 对全体key，基于LRU算法进行淘汰</p>
</li>
<li><p>volatile-lru： 对设置了TTL的key，基于LRU算法进行淘汰</p>
</li>
<li><p><strong>allkeys-lfu</strong>： 对全体key，基于LFU算法进行淘汰</p>
</li>
<li><p><strong>volatile-lfu</strong>： 对设置了TTL的key，基于LFI算法进行淘汰</p>
</li>
</ul>
<p>比较容易混淆的有两个：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">- LRU（Least Recently Used），最少最近使用。用当前时间减去最后一次访问时间，这个值越大则淘汰优先级越高。</span><br><span class="line">- LFU（Least Frequently Used），最少频率使用。会统计每个key的访问频率，值越小淘汰优先级越高。</span><br></pre></td></tr></table></figure>

<h4 id="LRU-LFU淘汰原理"><a href="#LRU-LFU淘汰原理" class="headerlink" title="LRU/LFU淘汰原理"></a>LRU/LFU淘汰原理</h4><p>Redis的数据都会被封装为<code>RedisObject</code>结构：</p>
<p><img src="https://ni9ne.oss-cn-shanghai.aliyuncs.com/mdimg/661f27ee502a096a363a9e920a95eb85-33207de.png" alt="image-20220704160630664"></p>
<p><strong>LFU</strong>的访问次数之所以叫做<strong>逻辑访问次数</strong>，是因为并不是每次key被访问都计数，而是通过运算：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">①生成0~1之间的随机数R</span><br><span class="line">②计算 (旧次数 * lfu_log_factor + 1)，记录为P</span><br><span class="line">③如果 R &lt; P ，则计数器 + 1，且最大不超过255</span><br><span class="line">④访问次数会随时间衰减，距离上一次访问时间每隔 lfu_decay_time 分钟，计数器 -1</span><br></pre></td></tr></table></figure>

<p><img src="https://ni9ne.oss-cn-shanghai.aliyuncs.com/mdimg/3a1a4d839f15b91febf4062aed8d9569-bd0f0f8.png" alt="image-20220704160955402"></p>
<h4 id="淘汰策略流程"><a href="#淘汰策略流程" class="headerlink" title="淘汰策略流程"></a>淘汰策略流程</h4><p><img src="https://ni9ne.oss-cn-shanghai.aliyuncs.com/mdimg/460a024a7fa900faaf2ba2929ee4c2fc-6e1fa9f.png" alt="image-20220704161044411"></p>

    </div>

    
    
    

    <footer class="post-footer">
          

<div class="post-copyright">
<ul>
  <li class="post-copyright-author">
      <strong>本文作者： </strong>NI9NE
  </li>
  <li class="post-copyright-link">
      <strong>本文链接：</strong>
      <a href="https://ni9ne.github.io/2022/05/22/Redis/Redis%E5%8E%9F%E7%90%86%E8%A7%A3%E6%9E%90/" title="Redis原理解析">https://ni9ne.github.io/2022/05/22/Redis/Redis原理解析/</a>
  </li>
  <li class="post-copyright-license">
    <strong>版权声明： </strong>本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" rel="noopener" target="_blank"><i class="fab fa-fw fa-creative-commons"></i>BY-NC-SA</a> 许可协议。转载请注明出处！
  </li>
</ul>
</div>

          <div class="post-tags">
              <a href="/tags/Redis/" rel="tag"># Redis</a>
          </div>

        

          <div class="post-nav">
            <div class="post-nav-item">
                <a href="/2022/05/22/Redis/Redis%E5%9F%BA%E4%BA%8E%E9%A1%B9%E7%9B%AE%E6%96%B9%E6%A1%88%E7%9A%84%E7%BB%93%E6%9E%84%E5%8A%9F%E8%83%BD%E8%A7%A3%E6%9E%90/" rel="prev" title="Redis基于项目方案的结构功能解析">
                  <i class="fa fa-chevron-left"></i> Redis基于项目方案的结构功能解析
                </a>
            </div>
            <div class="post-nav-item">
                <a href="/2022/05/22/Redis/Redis%E4%BD%BF%E7%94%A8%E6%8A%80%E5%B7%A7%E5%8F%8A%E6%9C%80%E4%BD%B3%E5%AE%9E%E8%B7%B5/" rel="next" title="Redis使用技巧及最佳实践">
                  Redis使用技巧及最佳实践 <i class="fa fa-chevron-right"></i>
                </a>
            </div>
          </div>
    </footer>
  </article>
</div>






</div>
  </main>

  <footer class="footer">
    <div class="footer-inner">


<div class="copyright">
  &copy; 2017 – 
  <span itemprop="copyrightYear">2022</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">NI9NE</span>
</div>

    </div>
  </footer>

  
  <script src="https://unpkg.com/animejs@3.2.1/lib/anime.min.js" integrity="sha256-XL2inqUJaslATFnHdJOi9GfQ60on8Wx1C2H8DYiN1xY=" crossorigin="anonymous"></script>
  <script src="https://unpkg.com/@next-theme/pjax@0.5.0/pjax.min.js" integrity="sha256-3NkoLDrmHLTYj7csHIZSr0MHAFTXth7Ua/DDt4MRUAg=" crossorigin="anonymous"></script>
  <script src="https://unpkg.com/jquery@3.6.0/dist/jquery.min.js" integrity="sha256-/xUj+3OJU5yExlq6GSYGSHk7tPXikynS7ogEvDej/m4=" crossorigin="anonymous"></script>
  <script src="https://unpkg.com/@fancyapps/fancybox@3.5.7/dist/jquery.fancybox.min.js" integrity="sha256-yt2kYMy0w8AbtF89WXb2P1rfjcP/HTHLT7097U8Y5b8=" crossorigin="anonymous"></script>
  <script src="https://unpkg.com/medium-zoom@1.0.6/dist/medium-zoom.min.js" integrity="sha256-EdPgYcPk/IIrw7FYeuJQexva49pVRZNmt3LculEr7zM=" crossorigin="anonymous"></script>
<script src="/js/comments.js"></script><script src="/js/utils.js"></script><script src="/js/motion.js"></script><script src="/js/next-boot.js"></script><script src="/js/pjax.js"></script>

  
<script src="https://unpkg.com/hexo-generator-searchdb@1.4.0/dist/search.js" integrity="sha256-vXZMYLEqsROAXkEw93GGIvaB2ab+QW6w3+1ahD9nXXA=" crossorigin="anonymous"></script>
<script src="/js/third-party/search/local-search.js"></script>



  <script src="/js/third-party/fancybox.js"></script>


  





</body>
</html>
